=== ./erm.txt ===
=== ./nostr_auth.py ===
#!/usr/bin/env python3
import sys
import os

# Add Odoo to Python path
odoo_path = '/opt/odoo/odoo'
sys.path.append(odoo_path)

import odoo
from odoo.tools import config
# from nostr_auth import authenticate_user

def authenticate_user(public_key, private_key):
    # Generate a random challenge
    challenge = os.urandom(32).hex()
    
    # Sign the challenge with the private key
    private_key_int = int(private_key, 16)
    private_key_obj = ec.derive_private_key(private_key_int, ec.SECP256K1())
    signature = private_key_obj.sign(challenge.encode('utf-8'), ec.ECDSA(hashes.SHA256()))
    
    # Verify the signature
    if verify_nostr_signature(public_key, challenge, signature.hex()):
        # Check if user exists in Odoo database
        conn = psycopg2.connect(
            dbname="odoodb",
            user="odoo",
            password="your_secure_password",
            host="localhost",
            port="5432"
        )
        cur = conn.cursor()
        cur.execute("SELECT id FROM res_users WHERE login = %s", (public_key,))
        user = cur.fetchone()
        
        if user:
            return user[0]  # Return user ID if exists
        else:
            # Create new user
            cur.execute("INSERT INTO res_users (login, password) VALUES (%s, %s) RETURNING id", (public_key, hashlib.sha256(private_key.encode()).hexdigest()))
            new_user_id = cur.fetchone()[0]
            conn.commit()
            return new_user_id
    else:
        return None

if __name__ == "__main__":
    config.parse_config(sys.argv[1:])
    
    if config.get('auth_method') == 'nostr':
        def check_security(method, *args, **kwargs):
            # Get Nostr public and private keys from request
            public_key = odoo.http.request.params.get('public_key')
            private_key = odoo.http.request.params.get('private_key')
            
            if not public_key or not private_key:
                raise odoo.exceptions.AccessDenied()
            
            user_id = authenticate_user(public_key, private_key)
            if user_id:
                odoo.http.request.uid = user_id
            else:
                raise odoo.exceptions.AccessDenied()
        
        odoo.http.root.check_security = check_security
    
    odoo.cli.main()
=== ./docker-compose.yml ===
version: '3'
services:
  postgres:
    image: postgres:14
    environment:
      - POSTGRES_DB=odoodb
      - POSTGRES_PASSWORD=your_secure_password
      - POSTGRES_USER=odoo
    networks:
      - odoo_network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U odoo"]
      interval: 10s
      timeout: 5s
      retries: 5

  odoo:
    build: .
    command: ["/opt/odoo/odoo/odoo-bin", "-c", "/etc/odoo/odoo.conf", "-d", "odoodb", "-i", "base,nostr_bridge,ivcs_git"]
    depends_on:
      postgres:
        condition: service_healthy
    ports:
      - "8069:8069"
      - "8072:8072"
    volumes:
      - ./odoo.conf:/etc/odoo/odoo.conf
      - ./odoo_custom_addons:/opt/odoo/custom_addons
      - ivcs_repos:/opt/ivcs_repos
    environment:
      - HOST=postgres
      - USER=odoo
      - PASSWORD=your_secure_password
    networks:
      - odoo_network

networks:
  odoo_network:
    driver: bridge

volumes:
  ivcs_repos:
=== ./odoo.conf ===
[options]
addons_path = /opt/odoo/odoo/addons,/opt/odoo/odoo/odoo/addons,/opt/odoo/custom_addons
admin_passwd = your_secure_admin_password
db_host = postgres
db_port = 5432
db_user = odoo
db_password = your_secure_password
db_name = odoodb
http_port = 8069
xmlrpc_port = 8069
gevent_port = 8072
longpolling_port = 8072
proxy_mode = True
workers = 2
max_cron_threads = 1
limit_time_cpu = 600
limit_time_real = 1200
log_level = debug
log_handler = [':DEBUG']
logfile = /var/log/odoo/odoo-server.log
=== ./podman-compose.yml ===
version: '3'
services:
  postgres:
    image: postgres:14
    environment:
      - POSTGRES_DB=odoodb
      - POSTGRES_PASSWORD=your_secure_password
      - POSTGRES_USER=odoo
    networks:
      - odoo_network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U odoo"]
      interval: 10s
      timeout: 5s
      retries: 5

  odoo:
    build: .
    command: ["/opt/odoo/odoo/odoo-bin", "-c", "/etc/odoo/odoo.conf", "-d", "odoodb", "-i", "base,nostr_bridge,ivcs_git"]
    depends_on:
      postgres:
        condition: service_healthy
    ports:
      - "8069:8069"
      - "8072:8072"
    volumes:
      - ./odoo.conf:/etc/odoo/odoo.conf:Z
      - ./odoo_custom_addons:/opt/odoo/custom_addons:Z
      - ivcs_repos:/opt/ivcs_repos:Z
    environment:
      - HOST=postgres
      - USER=odoo
      - PASSWORD=your_secure_password
    networks:
      - odoo_network

networks:
  odoo_network:
    driver: bridge

volumes:
  ivcs_repos:
=== ./patch_openssl.py ===

=== ./git_repository_anchor.txt ===
Certainly! I'll refine and merge the code into a single Odoo module as requested. Here's the structure and content for the `git_repository_anchor` Odoo module:



First, let's create the module structure:

```bash
git_repository_anchor/
├── __init__.py
├── __manifest__.py
├── models/
│   ├── __init__.py
│   ├── repository_anchor.py
│   ├── branch_manager.py
│   └── odoo_models.py
├── controllers/
│   ├── __init__.py
│   └── main.py
└── tests/
    ├── __init__.py
    └── test_repository_anchor.py

```

Now, let's implement each component:

1. Module Manifest (__manifest__.py):

```python
{
    'name': 'Git Repository Anchor',
    'version': '1.0',
    'category': 'Development',
    'summary': 'Manage Git repositories using Nostr events',
    'author': 'Your Name',
    'website': 'https://www.example.com',
    'depends': ['base'],
    'data': [
        'security/ir.model.access.csv',
        'views/repository_views.xml',
    ],
    'installable': True,
    'application': True,
    'auto_install': False,
}

```

2. Models (models/repository_anchor.py):

```python
import logging
import time
from functools import wraps
from odoo import models, fields, api
from nostr.key import PrivateKey

def log_execution_time(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        logging.debug(f"{func.__name__} executed in {end_time - start_time:.2f} seconds")
        return result
    return wrapper

class RepositoryAnchor(models.AbstractModel):
    _name = 'git.repository.anchor'
    _description = 'Git Repository Anchor'

    @api.model
    def _get_private_key(self):
        # In practice, you'd retrieve this securely
        return PrivateKey()

    @log_execution_time
    def create_repository(self, name, description, maintainers):
        private_key = self._get_private_key()
        # Implement repository creation logic here
        logging.info(f"Creating repository: {name}")
        # Return the created repository as an Odoo recordset

    @log_execution_time
    def update_repository(self, repo, description=None, maintainers=None):
        # Implement repository update logic here
        logging.info(f"Updating repository: {repo.name}")
        # Return the updated repository

    # Implement other methods (fork_repository, list_maintainers, etc.)

```

3. Models (models/odoo_models.py):

```python
from odoo import models, fields, api

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Repository Name', required=True)
    description = fields.Text(string='Description')
    maintainer_ids = fields.Many2many('res.users', string='Maintainers')
    created_at = fields.Datetime(string='Created At', default=fields.Datetime.now)
    last_updated = fields.Datetime(string='Last Updated', default=fields.Datetime.now)

class GitBranch(models.Model):
    _name = 'git.branch'
    _description = 'Git Branch'

    name = fields.Char(string='Branch Name', required=True)
    repository_id = fields.Many2one('git.repository', string='Repository', required=True)
    head = fields.Char(string='Head Commit', required=True)

class GitEvent(models.Model):
    _name = 'git.event'
    _description = 'Git Event'

    event_type = fields.Selection([
        ('create_repository', 'Create Repository'),
        ('update_repository', 'Update Repository'),
        ('fork_repository', 'Fork Repository'),
        ('create_branch', 'Create Branch'),
        ('update_branch', 'Update Branch'),
        ('delete_branch', 'Delete Branch')
    ], string='Event Type')
    content = fields.Text(string='Event Content')
    created_at = fields.Datetime(string='Created At', default=fields.Datetime.now)

class GitRepositoryManager(models.Model):
    _name = 'git.repository.manager'
    _description = 'Git Repository Manager'

    @api.model
    def create_repository(self, name, description, maintainer_ids):
        anchor = self.env['git.repository.anchor']
        repo = anchor.create_repository(name, description, maintainer_ids)
        return repo.id

    # Implement other management methods

```

4. Controllers (controllers/main.py):

```python
from odoo import http
from odoo.http import request

class GitRepositoryController(http.Controller):
    @http.route('/git/repository/create', type='json', auth='user')
    def create_repository(self, name, description, maintainer_ids):
        repo_manager = request.env['git.repository.manager'].sudo()
        repo_id = repo_manager.create_repository(name, description, maintainer_ids)
        return {'success': True, 'repository_id': repo_id}

    # Implement other routes (update_repository, fork_repository, etc.)

```

5. Tests (tests/test_repository_anchor.py):

```python
from odoo.tests.common import TransactionCase

class TestRepositoryAnchor(TransactionCase):

    def setUp(self):
        super(TestRepositoryAnchor, self).setUp()
        self.repo_manager = self.env['git.repository.manager'].sudo()

    def test_create_repository(self):
        repo_id = self.repo_manager.create_repository(
            "test-repo", "Test repository", [self.env.user.id]
        )
        repo = self.env['git.repository'].browse(repo_id)
        self.assertEqual(repo.name, "test-repo")
        self.assertEqual(repo.description, "Test repository")
        self.assertIn(self.env.user, repo.maintainer_ids)

    # Implement other test methods

    def test_fork_repository(self):
        original_repo_id = self.repo_manager.create_repository(
            "original-repo", "Original repository", [self.env.user.id]
        )
        forked_repo_id = self.repo_manager.fork_repository(
            original_repo_id, "forked-repo", self.env.user.id
        )
        forked_repo = self.env['git.repository'].browse(forked_repo_id)
        self.assertEqual(forked_repo.name, "forked-repo")
        self.assertIn(self.env.user, forked_repo.maintainer_ids)

```

6. CLI Script (outside the module):

```python
import argparse
import logging
from odoo import api, registry, SUPERUSER_ID

def setup_logging():
    logging.basicConfig(level=logging.INFO,
                        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

def main(args):
    with api.Environment.manage():
        with registry('your_database_name').cursor() as cr:
            env = api.Environment(cr, SUPERUSER_ID, {})
            repo_manager = env['git.repository.manager'].sudo()

            if args.action == 'create':
                repo_id = repo_manager.create_repository(args.name, args.description, args.maintainers)
                print(f"Repository created with ID: {repo_id}")
            elif args.action == 'update':
                repo_manager.update_repository(args.repo_id, args.description, args.maintainers)
                print(f"Repository updated: {args.repo_id}")
            # Implement other actions

if __name__ == '__main__':
    setup_logging()
    parser = argparse.ArgumentParser(description="Git Repository Anchor CLI")
    parser.add_argument("action", choices=['create', 'update', 'fork', 'list'])
    parser.add_argument("--name", help="Repository name")
    parser.add_argument("--description", help="Repository description")
    parser.add_argument("--maintainers", nargs='+', type=int, help="Maintainer user IDs")
    parser.add_argument("--repo-id", type=int, help="Repository ID for updates")
    args = parser.parse_args()
    main(args)

```

This refined and merged code creates a complete Odoo module for managing Git repositories using Nostr events. It includes:

1. A proper Odoo module structure
2. Odoo models for repositories, branches, and events
3. A repository manager that uses the RepositoryAnchor functionality
4. Odoo controllers for web interactions
5. Unit tests integrated with Odoo's testing framework
6. Enhanced logging throughout the module
7. A CLI script for standalone usage

To use this module:
1. Place the `git_repository_anchor` directory in your Odoo addons path.
2. Update your Odoo apps list and install the "Git Repository Anchor" module.
3. Use the Odoo interface or the provided CLI script to manage repositories.

Remember to add necessary security rules and views (not shown here for brevity) to make the module fully functional within Odoo.
=== ./ivcs_version.py ===
from odoo import models, fields, api

class IVCSVersion(models.Model):
    _name = 'ivcs.version'
    _description = 'IVCS Version'

    name = fields.Char(string='Version Name', required=True)
    description = fields.Text(string='Description')
    state = fields.Selection([
        ('draft', 'Draft'),
        ('confirmed', 'Confirmed'),
        ('done', 'Done')
    ], string='State', default='draft')
    item_id = fields.Many2one('ivcs.item', string='IVCS Item', required=True)
    create_date = fields.Datetime(string='Created On', readonly=True, default=fields.Datetime.now)

    @api.model
    def create(self, vals):
        version = super(IVCSVersion, self).create(vals)
        if version.item_id and not version.item_id.current_version_id:
            version.item_id.current_version_id = version.id
        return version

    def name_get(self):
        result = []
        for version in self:
            name = f"{version.item_id.name} - {version.name}"
            result.append((version.id, name))
        return result
=== ./podman_commands.txt ===
/home/impromise/.local/bin/podman-compose

sudo /home/impromise/.local/bin/podman-compose down
sudo /home/impromise/.local/bin/podman-compose build
sudo /home/impromise/.local/bin/podman-compose up -d
ping google.com -c 10 # wait 10 seconds
sudo podman ps
sudo podman logs odoo-nostr-project-odoo-1
ping google.com -c 10 # wait 10 seconds
sudo podman exec -it odoo-nostr-project-odoo-1 /opt/odoo/odoo/odoo-bin -c /etc/odoo/odoo.conf -d odoodb -u nostr_bridge
sudo podman exec -it odoo-nostr-project-odoo-1 /opt/odoo/odoo/odoo-bin -c /etc/odoo/odoo.conf -d odoodb -u nostr_auth
sudo podman exec -it odoo-nostr-project-odoo-1 /opt/odoo/odoo/odoo-bin -c /etc/odoo/odoo.conf -d odoodb -u ivcs_git
sudo podman exec -it odoo-nostr-project-odoo-1 /opt/odoo/odoo/odoo-bin -c /etc/odoo/odoo.conf -d odoodb -u nostr_identity
sudo podman exec -it odoo-nostr-project-odoo-1 /opt/odoo/odoo/odoo-bin -c /etc/odoo/odoo.conf -d odoodb -u decentralized_sync
sudo podman exec -it odoo-nostr-project-odoo-1 /opt/odoo/odoo/odoo-bin -c /etc/odoo/odoo.conf -d odoodb -u git_nostr_bridge
ping google.com -c 10 # wait 10 seconds
sudo podman logs odoo-nostr-project-odoo-1


podman-compose down
podman-compose build
podman-compose up -d
ping google.com -c 10 # wait 10 seconds
podman ps
podman logs odoo-nostr-project-odoo-1
ping google.com -c 10 # wait 10 seconds
podman exec -it odoo-nostr-project-odoo-1 /opt/odoo/odoo/odoo-bin -c /etc/odoo/odoo.conf -d odoodb -u nostr_bridge
podman exec -it odoo-nostr-project-odoo-1 /opt/odoo/odoo/odoo-bin -c /etc/odoo/odoo.conf -d odoodb -u nostr_auth
podman exec -it odoo-nostr-project-odoo-1 /opt/odoo/odoo/odoo-bin -c /etc/odoo/odoo.conf -d odoodb -u ivcs_git
podman exec -it odoo-nostr-project-odoo-1 /opt/odoo/odoo/odoo-bin -c /etc/odoo/odoo.conf -d odoodb -u nostr_identity
podman exec -it odoo-nostr-project-odoo-1 /opt/odoo/odoo/odoo-bin -c /etc/odoo/odoo.conf -d odoodb -u decentralized_sync
podman exec -it odoo-nostr-project-odoo-1 /opt/odoo/odoo/odoo-bin -c /etc/odoo/odoo.conf -d odoodb -u git_nostr_bridge
ping google.com -c 10 # wait 10 seconds
podman logs odoo-nostr-project-odoo-1





podman run -d --name postgres -e POSTGRES_DB=odoodb -e POSTGRES_PASSWORD=your_secure_password -e POSTGRES_USER=odoo postgres:14

podman build -t odoo-custom .

podman run -d --name odoo -p 8069:8069 -p 8072:8072 --pod-id-file /tmp/postgres-pod-id -e HOST=postgres -e USER=odoo -e PASSWORD=your_secure_password -v ./odoo.conf:/etc/odoo/odoo.conf:Z -v ./odoo_custom_addons:/opt/odoo/custom_addons:Z odoo-custom



# Remove any existing containers and pods
podman pod rm -f odoo-pod
podman rm -f postgres odoo

# Create the pod
podman pod create --name odoo-pod -p 8069:8069 -p 8072:8072

# Run PostgreSQL in the pod
podman run -d --pod odoo-pod --name postgres -e POSTGRES_DB=odoodb -e POSTGRES_PASSWORD=your_secure_password -e POSTGRES_USER=odoo postgres:14

# Run Odoo in the pod
podman run -d --pod odoo-pod --name odoo -e HOST=postgres -e USER=odoo -e PASSWORD=your_secure_password -v ./odoo.conf:/etc/odoo/odoo.conf:Z -v ./odoo_custom_addons:/opt/odoo/custom_addons:Z localhost/odoo-custom:latest /bin/bash -c "while ! pg_isready -h postgres -p 5432 -U odoo; do sleep 1; done; /opt/odoo/check_nostr_bridge.sh && python3 /opt/odoo/odoo/odoo-bin -c /etc/odoo/odoo.conf -d odoodb -i base && python3 /opt/odoo/custom_odoo_server.py -c /etc/odoo/odoo.conf"



podman stop $(sudo podman ps -aq)
podman rm $(sudo podman ps -aq)
podman system prune -a --volumes -f
podman-compose down
podman-compose build
podman-compose up -d
ping google.com -c 10 # wait 10 seconds
podman ps
podman logs odoo-nostr-project-odoo-1
ping google.com -c 10 # wait 10 seconds
podman exec -it odoo-nostr-project-odoo-1 /opt/odoo/odoo/odoo-bin -c /etc/odoo/odoo.conf -d odoodb -u nostr_bridge
podman exec -it odoo-nostr-project-odoo-1 /opt/odoo/odoo/odoo-bin -c /etc/odoo/odoo.conf -d odoodb -u nostr_auth
podman exec -it odoo-nostr-project-odoo-1 /opt/odoo/odoo/odoo-bin -c /etc/odoo/odoo.conf -d odoodb -u ivcs_git
podman exec -it odoo-nostr-project-odoo-1 /opt/odoo/odoo/odoo-bin -c /etc/odoo/odoo.conf -d odoodb -u nostr_identity
podman exec -it odoo-nostr-project-odoo-1 /opt/odoo/odoo/odoo-bin -c /etc/odoo/odoo.conf -d odoodb -u decentralized_sync
podman exec -it odoo-nostr-project-odoo-1 /opt/odoo/odoo/odoo-bin -c /etc/odoo/odoo.conf -d odoodb -u git_nostr_bridge
=== ./test.txt ===

=== ./start.sh ===
#!/bin/bash

docker-compose up -d
echo "Odoo is starting up. You can access it at http://localhost:8080"
echo "It may take a few moments for the service to be fully available."
=== ./odoo_custom_addons (copy)/git_repository_anchor/models/git_repository.py ===
from odoo import models, fields, api, _
from odoo.exceptions import UserError
import git
import os
import logging

_logger = logging.getLogger(__name__)

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'
    _inherit = ['mail.thread', 'mail.activity.mixin']

    name = fields.Char(string='Repository Name', required=True)
    path = fields.Char(string='Repository Path', required=True)
    description = fields.Text(string='Description', tracking=True)
    maintainer_ids = fields.Many2many('res.users', string='Maintainers')
    anchor_event_id = fields.Many2one('nostr.event', string='Anchor Event')
    #company_id = fields.Many2one('res.company', string='Company', required=True, default=lambda self: self.env.company)

    @api.model
    def create(self, vals):
        repo = super(GitRepository, self).create(vals)
        repo._initialize_repository()
        return repo

    def _initialize_repository(self):
        if not os.path.exists(self.path):
            os.makedirs(self.path)
            git.Repo.init(self.path)
            readme_path = os.path.join(self.path, 'README.md')
            with open(readme_path, 'w') as f:
                f.write(f"# {self.name}\n\n{self.description or ''}")
            repo = git.Repo(self.path)
            repo.index.add(['README.md'])
            repo.index.commit("Initial commit")

    def _create_anchor_event(self):
        anchor = self.env['git.repository.anchor']
        event = anchor.create_anchor_event(self.path, self.maintainer_ids.mapped('nostr_public_key'))
        self.env['nostr.event'].create_and_publish(event)
        self.anchor_event_id = self.env['nostr.event'].search([('event_id', '=', event.id)], limit=1).id

    def update_maintainers(self):
        anchor = self.env['git.repository.anchor']
        event = anchor.update_anchor(self.path, self.maintainer_ids.mapped('nostr_public_key'))
        self.env['nostr.event'].create_and_publish(event)
        self.anchor_event_id = self.env['nostr.event'].search([('event_id', '=', event.id)], limit=1).id

    def fork_repository(self, new_name, new_path, new_maintainer_ids):
        anchor = self.env['git.repository.anchor']
        new_maintainers = self.env['res.users'].browse(new_maintainer_ids).mapped('nostr_public_key')
        event = anchor.fork_repository(self.path, new_path, new_maintainers)
        self.env['nostr.event'].create_and_publish(event)
        
        new_repo = self.create({
            'name': new_name,
            'path': new_path,
            'maintainer_ids': [(6, 0, new_maintainer_ids)],
        })
        new_repo.anchor_event_id = self.env['nostr.event'].search([('event_id', '=', event.id)], limit=1).id
        
        # Clone the repository
        git.Repo.clone_from(self.path, new_path)
        
        return new_repo

    def check_permission(self, user_id):
        user = self.env['res.users'].browse(user_id)
        anchor = self.env['git.repository.anchor']
        return anchor.check_permission(self.anchor_event_id, user.nostr_public_key)
=== ./odoo_custom_addons (copy)/git_repository_anchor/models/__init__.py ===
from . import repository_anchor
from . import branch_manager
from . import odoo_models
from . import git_repository
from . import nostr_event
=== ./odoo_custom_addons (copy)/git_repository_anchor/models/repository_anchor.py ===
from odoo import models, fields, api, _
from odoo.exceptions import UserError
from nostr.event import Event
from nostr.key import PrivateKey
import json
import os
import logging
import time
from functools import wraps  # Add this import

_logger = logging.getLogger(__name__)

def log_execution_time(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        _logger.info(f"{func.__name__} executed in {end_time - start_time:.2f} seconds")
        return result
    return wrapper

class RepositoryAnchor(models.AbstractModel):
    _name = 'git.repository.anchor'
    _description = 'Git Repository Anchor'

    @api.model
    def _get_private_key(self):
        # In practice, you'd retrieve this securely
        return PrivateKey()

    @log_execution_time
    def create_anchor_event(self, repo_path, maintainers):
        _logger.info(f"Creating anchor event for repository: {repo_path}")
        start_time = time.time()

        private_key = self._get_private_key()
        content = json.dumps({
            "action": "create_repository",
            "repo_name": os.path.basename(repo_path),
            "maintainers": maintainers
        })
        event = Event(
            kind=31228,
            content=content,
            tags=[['r', repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)

        end_time = time.time()
        _logger.info(f"Anchor event created in {end_time - start_time:.2f} seconds")
        return event

    def update_anchor(self, repo_path, maintainers):
        _logger.info(f"Updating anchor for repository: {repo_path}")
        start_time = time.time()

        private_key = self._get_private_key()
        content = json.dumps({
            "action": "update_repository",
            "repo_name": os.path.basename(repo_path),
            "maintainers": maintainers
        })
        event = Event(
            kind=31228,
            content=content,
            tags=[['r', repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)

        end_time = time.time()
        _logger.info(f"Anchor updated in {end_time - start_time:.2f} seconds")
        return event

    def resolve_repository_state(self, anchor_event):
        _logger.info("Resolving repository state from anchor event")
        start_time = time.time()

        try:
            content = json.loads(anchor_event.content)
            state = {
                "repo_name": content["repo_name"],
                "maintainers": content["maintainers"]
            }
        except json.JSONDecodeError as e:
            _logger.error(f"Error decoding anchor event content: {str(e)}")
            raise UserError(_("Invalid anchor event content"))
        except KeyError as e:
            _logger.error(f"Missing key in anchor event content: {str(e)}")
            raise UserError(_("Incomplete anchor event content"))

        end_time = time.time()
        _logger.info(f"Repository state resolved in {end_time - start_time:.2f} seconds")
        return state

    def list_maintainers(self, anchor_event):
        _logger.info("Listing maintainers from anchor event")
        start_time = time.time()

        try:
            content = json.loads(anchor_event.content)
            maintainers = content["maintainers"]
        except json.JSONDecodeError as e:
            _logger.error(f"Error decoding anchor event content: {str(e)}")
            raise UserError(_("Invalid anchor event content"))
        except KeyError:
            _logger.error("Maintainers key not found in anchor event content")
            raise UserError(_("Incomplete anchor event content"))

        end_time = time.time()
        _logger.info(f"Maintainers listed in {end_time - start_time:.2f} seconds")
        return maintainers

    def check_permission(self, anchor_event, public_key):
        _logger.info(f"Checking permission for public key: {public_key}")
        start_time = time.time()

        maintainers = self.list_maintainers(anchor_event)
        has_permission = public_key in maintainers

        end_time = time.time()
        _logger.info(f"Permission check completed in {end_time - start_time:.2f} seconds")
        return has_permission

    def fork_repository(self, original_repo_path, new_repo_path, new_maintainers):
        _logger.info(f"Forking repository from {original_repo_path} to {new_repo_path}")
        start_time = time.time()

        private_key = self._get_private_key()
        content = json.dumps({
            "action": "fork_repository",
            "original_repo": original_repo_path,
            "new_repo": new_repo_path,
            "maintainers": new_maintainers
        })
        event = Event(
            kind=31228,
            content=content,
            tags=[['r', new_repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)

        end_time = time.time()
        _logger.info(f"Repository forked in {end_time - start_time:.2f} seconds")
        return event
=== ./odoo_custom_addons (copy)/git_repository_anchor/models/nostr_event.py ===
# File: /opt/odoo/custom_addons/git_repository_anchor/models/nostr_event.py

from odoo import models, fields, api, _
from odoo.exceptions import UserError
from nostr.event import Event as NostrLibEvent
from nostr.key import PrivateKey
import json
import time
import logging

_logger = logging.getLogger(__name__)

class NostrEvent(models.Model):
    _name = 'nostr.event'
    _description = 'Nostr Event'

    name = fields.Char(string='Name', required=True)
    event_id = fields.Char(string='Event ID', readonly=True)
    kind = fields.Integer(string='Event Kind', required=True)
    content = fields.Text(string='Content')
    tags = fields.Text(string='Tags')
    public_key = fields.Char(string='Public Key', readonly=True)
    created_at = fields.Integer(string='Created At', readonly=True)
    signature = fields.Char(string='Signature', readonly=True)
    published = fields.Boolean(string='Published', default=False)
    event_type = fields.Selection([
        ('commit', 'Commit'),
        ('branch', 'Branch'),
        ('tree', 'Tree'),
        ('blob', 'Blob'),
    ], string='Event Type')
    repository_id = fields.Many2one('git.repository', string='Related Repository')

    @api.model
    def create(self, vals):
        try:
            # Generate a new private key for this event
            private_key = PrivateKey()
            public_key = private_key.public_key.hex()
            
            created_at = int(time.time())
            tags = json.loads(vals.get('tags', '[]'))
            
            event = NostrLibEvent(
                kind=vals['kind'],
                content=vals.get('content', ''),
                tags=tags,
                pub_key=public_key,
                created_at=created_at
            )
            
            # Sign the event
            private_key.sign_event(event)
            
            # Update vals with generated data
            vals.update({
                'event_id': event.id,
                'public_key': public_key,
                'created_at': created_at,
                'signature': event.sig
            })
            
            _logger.info(f"Created Nostr event: {event.id}")
        except Exception as e:
            _logger.error(f"Error creating Nostr event: {str(e)}")
            raise UserError(_("Failed to create Nostr event: %s") % str(e))
        
        return super(NostrEvent, self).create(vals)

    @api.model
    def create_and_publish(self, event):
        vals = {
            'name': f"Event {event.id[:8]}",  # Use first 8 characters of event ID as name
            'event_id': event.id,
            'kind': event.kind,
            'content': event.content,
            'tags': json.dumps(event.tags),
            'public_key': event.public_key,
            'created_at': event.created_at,
            'signature': event.sig,
        }
        nostr_event = self.create(vals)
        # Here you would typically publish the event to Nostr relays
        # For demonstration purposes, we'll just log it
        _logger.info(f"Published Nostr event: {event.to_message()}")
        return nostr_event
=== ./odoo_custom_addons (copy)/git_repository_anchor/models/odoo_models.py ===
from odoo import models, fields, api
import logging

_logger = logging.getLogger(__name__)

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Repository Name', required=True)
    path = fields.Char(string='Repository Path', required=True)
    description = fields.Text(string='Description')
    maintainer_ids = fields.Many2many('res.users', string='Maintainers')
    created_at = fields.Datetime(string='Created At', default=fields.Datetime.now)
    last_updated = fields.Datetime(string='Last Updated', default=fields.Datetime.now)
    branch_ids = fields.One2many('git.branch', 'repository_id', string='Branches')

    @api.model
    def fields_get(self, allfields=None, attributes=None):
        res = super(GitRepository, self).fields_get(allfields, attributes)
        _logger.info(f"Fields in GitRepository model: {res.keys()}")
        return res

    @api.model
    def search_read(self, domain=None, fields=None, offset=0, limit=None, order=None):
        _logger.info(f"Search_read called with fields: {fields}")
        return super(GitRepository, self).search_read(domain=domain, fields=fields, offset=offset, limit=limit, order=order)

    def read(self, fields=None, load='_classic_read'):
        _logger.info(f"Read called with fields: {fields}")
        return super(GitRepository, self).read(fields=fields, load=load)

    @api.model
    def create(self, vals):
        repo = super(GitRepository, self).create(vals)
        repo._create_default_branch()
        return repo

    def _create_default_branch(self):
        self.env['git.branch'].create({
            'name': 'main',
            'repository_id': self.id,
            'head': 'initial commit',
        })

class GitBranch(models.Model):
    _name = 'git.branch'
    _description = 'Git Branch'

    name = fields.Char(string='Branch Name', required=True)
    repository_id = fields.Many2one('git.repository', string='Repository', required=True)
    head = fields.Char(string='Head Commit', required=True)

class GitEvent(models.Model):
    _name = 'git.event'
    _description = 'Git Event'

    event_type = fields.Selection([
        ('create_repository', 'Create Repository'),
        ('update_repository', 'Update Repository'),
        ('fork_repository', 'Fork Repository'),
        ('create_branch', 'Create Branch'),
        ('update_branch', 'Update Branch'),
        ('delete_branch', 'Delete Branch')
    ], string='Event Type')
    content = fields.Text(string='Event Content')
    created_at = fields.Datetime(string='Created At', default=fields.Datetime.now)

class GitRepositoryManager(models.Model):
    _name = 'git.repository.manager'
    _description = 'Git Repository Manager'

    @api.model
    def create_repository(self, name, path, description, maintainer_ids):
        anchor = self.env['git.repository.anchor']
        repo = anchor.create_repository(name, path, description, maintainer_ids)
        return repo.id

    @api.model
    def update_repository(self, repo_id, description=None, maintainer_ids=None):
        anchor = self.env['git.repository.anchor']
        repo = self.env['git.repository'].browse(repo_id)
        updated_repo = anchor.update_repository(repo, description, maintainer_ids)
        return updated_repo.id

    @api.model
    def fork_repository(self, original_repo_id, new_name, new_maintainer_id):
        anchor = self.env['git.repository.anchor']
        original_repo = self.env['git.repository'].browse(original_repo_id)
        forked_repo = anchor.fork_repository(original_repo, new_name, new_maintainer_id)
        return forked_repo.id

    @api.model
    def list_maintainers(self, repo_id):
        anchor = self.env['git.repository.anchor']
        repo = self.env['git.repository'].browse(repo_id)
        maintainers = anchor.list_maintainers(repo)
        return maintainers.ids
=== ./odoo_custom_addons (copy)/git_repository_anchor/models/branch_manager.py ===
from odoo import models, fields, api
from .repository_anchor import log_execution_time
from git import Repo, GitCommandError
import json
from nostr.event import Event
from nostr.key import PrivateKey
import logging

_logger = logging.getLogger(__name__)

class BranchManager(models.AbstractModel):
    _name = 'ivcs.branch.manager'
    _description = 'IVCS Branch Manager'

    name = fields.Char(string='Name', required=True)
    item_id = fields.Many2one('ivcs.item', string='IVCS Item', required=True)

    @api.model
    @log_execution_time
    def create_branch(self, repository_id, name, head):
        repo = self.env['git.repository'].browse(repository_id)
        branch = self.env['git.branch'].create({
            'name': name,
            'repository_id': repository_id,
            'head': head,
        })
        self._create_event('create_branch', branch)
        return branch.id

    @api.model
    @log_execution_time
    def update_branch(self, branch_id, new_head):
        branch = self.env['git.branch'].browse(branch_id)
        branch.write({'head': new_head})
        self._create_event('update_branch', branch)
        return branch.id

    @api.model
    @log_execution_time
    def delete_branch(self, branch_id):
        branch = self.env['git.branch'].browse(branch_id)
        self._create_event('delete_branch', branch)
        branch.unlink()
        return True

    @api.model
    def _create_event(self, event_type, branch):
        self.env['git.event'].create({
            'event_type': event_type,
            'content': f"{event_type}: {branch.name} in {branch.repository_id.name}",
        })
=== ./odoo_custom_addons (copy)/git_repository_anchor/__init__.py ===
from . import models
from . import controllers
=== ./odoo_custom_addons (copy)/git_repository_anchor/__manifest__.py ===
{
    'name': 'Git Repository Anchor',
    'version': '1.0',
    'category': 'Development',
    'summary': 'Manage Git repositories using Nostr events',
    'author': 'Your Name',
    'website': 'https://www.example.com',
    'depends': ['base', 'mail'],
    'data': [
        'security/git_repository_security.xml',
        'security/ir.model.access.csv',
        'views/git_repository_views.xml',
        'views/nostr_event_views.xml',
    ],
    'installable': True,
    'application': True,
    'auto_install': False,
    'external_dependencies': {
        'python': ['git', 'nostr'],
    },
}
=== ./odoo_custom_addons (copy)/git_repository_anchor/security/git_repository_security.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="module_category_git_repository" model="ir.module.category">
        <field name="name">Git Repository</field>
        <field name="description">Manage Git repositories</field>
        <field name="sequence">20</field>
    </record>

    <record id="group_git_repository_user" model="res.groups">
        <field name="name">User</field>
        <field name="category_id" ref="module_category_git_repository"/>
    </record>

    <record id="group_git_repository_manager" model="res.groups">
        <field name="name">Manager</field>
        <field name="category_id" ref="module_category_git_repository"/>
        <field name="implied_ids" eval="[(4, ref('group_git_repository_user'))]"/>
        <field name="users" eval="[(4, ref('base.user_root')), (4, ref('base.user_admin'))]"/>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/git_repository_anchor/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_git_repository_user,git.repository user,model_git_repository,group_git_repository_user,1,0,0,0
access_git_repository_manager,git.repository manager,model_git_repository,group_git_repository_manager,1,1,1,1
access_git_branch_user,git.branch user,model_git_branch,group_git_repository_user,1,1,1,0
access_git_branch_manager,git.branch manager,model_git_branch,group_git_repository_manager,1,1,1,1
access_git_event_user,git.event user,model_git_event,group_git_repository_user,1,0,0,0
access_git_event_manager,git.event manager,model_git_event,group_git_repository_manager,1,1,1,1
access_git_repository_manager_user,git.repository.manager user,model_git_repository_manager,group_git_repository_user,1,1,1,0
access_git_repository_manager_manager,git.repository.manager manager,model_git_repository_manager,group_git_repository_manager,1,1,1,1
access_nostr_event_user,nostr.event user,model_nostr_event,group_git_repository_user,1,0,0,0
access_nostr_event_manager,nostr.event manager,model_nostr_event,group_git_repository_manager,1,1,1,1
access_git_repository_user,git.repository user,model_git_repository,base.group_user,1,1,1,0
access_git_repository_manager,git.repository manager,model_git_repository,base.group_system,1,1,1,1
access_nostr_event_user,nostr.event user,model_nostr_event,base.group_user,1,0,0,0
access_nostr_event_manager,nostr.event manager,model_nostr_event,base.group_system,1,1,1,1
=== ./odoo_custom_addons (copy)/git_repository_anchor/security/oldgit_repository_security.xml.txt ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="module_category_git_repository" model="ir.module.category">
        <field name="name">Git Repository</field>
        <field name="description">Manage Git repositories</field>
        <field name="sequence">20</field>
    </record>

    <record id="group_git_repository_user" model="res.groups">
        <field name="name">User</field>
        <field name="category_id" ref="module_category_git_repository"/>
    </record>

    <record id="group_git_repository_manager" model="res.groups">
        <field name="name">Manager</field>
        <field name="category_id" ref="module_category_git_repository"/>
        <field name="implied_ids" eval="[(4, ref('group_git_repository_user'))]"/>
        <field name="users" eval="[(4, ref('base.user_root')), (4, ref('base.user_admin'))]"/>
    </record>

    <record id="git_repository_comp_rule" model="ir.rule">
        <field name="name">Git Repository multi-company</field>
        <field name="model_id" ref="model_git_repository"/>
        <field name="global" eval="True"/>
        <field name="domain_force">['|', ('company_id', '=', False), ('company_id', 'in', company_ids)]</field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/git_repository_anchor/tests/test_repository_anchor.py ===
from odoo.tests.common import TransactionCase
from odoo.exceptions import AccessError

class TestRepositoryAnchor(TransactionCase):

    def setUp(self):
        super(TestRepositoryAnchor, self).setUp()
        self.repo_manager = self.env['git.repository.manager'].sudo()
        self.user_admin = self.env.ref('base.user_admin')
        self.user_demo = self.env.ref('base.user_demo')

    def test_create_repository(self):
        repo_id = self.repo_manager.create_repository(
            "test-repo", "/path/to/test-repo", "Test repository", [self.user_admin.id]
        )
        repo = self.env['git.repository'].browse(repo_id)
        self.assertEqual(repo.name, "test-repo")
        self.assertEqual(repo.path, "/path/to/test-repo")
        self.assertEqual(repo.description, "Test repository")
        self.assertIn(self.user_admin, repo.maintainer_ids)
        self.assertEqual(len(repo.branch_ids), 1)
        self.assertEqual(repo.branch_ids[0].name, 'main')

    def test_update_repository(self):
        repo_id = self.repo_manager.create_repository(
            "test-repo", "Test repository", [self.user_admin.id]
        )
        updated_repo_id = self.repo_manager.update_repository(
            repo_id, "Updated description", [self.user_admin.id, self.user_demo.id]
        )
        repo = self.env['git.repository'].browse(updated_repo_id)
        self.assertEqual(repo.description, "Updated description")
        self.assertIn(self.user_demo, repo.maintainer_ids)

    def test_fork_repository(self):
        original_repo_id = self.repo_manager.create_repository(
            "original-repo", "Original repository", [self.user_admin.id]
        )
        forked_repo_id = self.repo_manager.fork_repository(
            original_repo_id, "forked-repo", self.user_demo.id
        )
        forked_repo = self.env['git.repository'].browse(forked_repo_id)
        self.assertEqual(forked_repo.name, "forked-repo")
        self.assertIn(self.user_demo, forked_repo.maintainer_ids)
        self.assertEqual(len(forked_repo.branch_ids), 1)
        self.assertEqual(forked_repo.branch_ids[0].name, 'main')

    def test_list_maintainers(self):
        repo_id = self.repo_manager.create_repository(
            "test-repo", "Test repository", [self.user_admin.id, self.user_demo.id]
        )
        maintainer_ids = self.repo_manager.list_maintainers(repo_id)
        self.assertIn(self.user_admin.id, maintainer_ids)
        self.assertIn(self.user_demo.id, maintainer_ids)

    def test_access_rights(self):
        repo_id = self.repo_manager.create_repository(
            "test-repo", "Test repository", [self.user_admin.id]
        )
        
        # Test that non-maintainer can't update the repository
        with self.assertRaises(AccessError):
            self.repo_manager.with_user(self.user_demo).update_repository(
                repo_id, "Unauthorized update"
            )

        # Test that maintainer can update the repository
        self.repo_manager.with_user(self.user_admin).update_repository(
            repo_id, "Authorized update"
        )
        repo = self.env['git.repository'].browse(repo_id)
        self.assertEqual(repo.description, "Authorized update")
=== ./odoo_custom_addons (copy)/git_repository_anchor/tests/__init__.py ===
from . import test_repository_anchor
=== ./odoo_custom_addons (copy)/git_repository_anchor/data/README.md ===
# Git Repository Anchor

This Odoo module provides a system for managing Git repositories using Nostr events. It allows users to create, update, and fork repositories, as well as manage branches and maintainers.

## Features

- Create, update, and fork Git repositories
- Manage repository maintainers
- Create and manage branches
- Log all actions as Nostr events
- Odoo views for easy management through the UI
- CLI for standalone usage

## Installation

1. Place the `git_repository_anchor` directory in your Odoo addons path.
2. Update your Odoo apps list.
3. Install the "Git Repository Anchor" module from the Odoo Apps menu.

## Usage

### Through Odoo Interface

1. Navigate to the "Git Repositories" menu item.
2. Use the provided views to manage repositories, branches, and maintainers.

### Using CLI

A CLI script is provided for standalone usage. Example usage:

```bash
python cli_script.py create --name "New Repo" --description "A new repository" --maintainers 1 2
python cli_script.py update --repo-id 1 --description "Updated description"
python cli_script.py fork --original-repo-id 1 --new-name "Forked Repo"
=== ./odoo_custom_addons (copy)/git_repository_anchor/data/git_repository_data.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <!-- Example repository data -->
        <record id="git_repository_example" model="git.repository">
            <field name="name">Example Repository</field>
            <field name="path">/path/to/example-repo</field>
            <field name="description">This is an example repository created during module installation.</field>
            <field name="maintainer_ids" eval="[(4, ref('base.user_admin'))]"/>
        </record>
    </data>
</odoo>
=== ./odoo_custom_addons (copy)/git_repository_anchor/views/nostr_event_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_nostr_event_form" model="ir.ui.view">
        <field name="name">nostr.event.form</field>
        <field name="model">nostr.event</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="event_id" readonly="1"/>
                        <field name="kind"/>
                        <field name="content"/>
                        <field name="tags"/>
                        <field name="public_key" readonly="1"/>
                        <field name="created_at" readonly="1"/>
                        <field name="signature" readonly="1"/>
                        <field name="published"/>
                        <field name="event_type"/>
                        <field name="repository_id"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_nostr_event_tree" model="ir.ui.view">
        <field name="name">nostr.event.tree</field>
        <field name="model">nostr.event</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="event_id"/>
                <field name="kind"/>
                <field name="event_type"/>
                <field name="repository_id"/>
                <field name="public_key"/>
                <field name="created_at"/>
                <field name="published"/>
            </tree>
        </field>
    </record>

    <record id="action_nostr_event" model="ir.actions.act_window">
        <field name="name">Nostr Events</field>
        <field name="res_model">nostr.event</field>
        <field name="view_mode">tree,form</field>
    </record>

    <!-- Menu item for Nostr Events -->
    <menuitem id="menu_nostr_event"
              name="Nostr Events"
              parent="menu_git_nostr_bridge_root"
              action="action_nostr_event"
              sequence="20"/>
</odoo>
=== ./odoo_custom_addons (copy)/git_repository_anchor/views/git_repository_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_repository_form" model="ir.ui.view">
        <field name="name">git.repository.form</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="path"/>
                        <field name="description"/>
                    </group>
                </sheet>
                <div class="oe_chatter">
                    <field name="message_follower_ids" widget="mail_followers"/>
                    <field name="message_ids" widget="mail_thread"/>
                </div>
            </form>
        </field>
    </record>

    <record id="view_git_repository_tree" model="ir.ui.view">
        <field name="name">git.repository.tree</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="path"/>
            </tree>
        </field>
    </record>

    <record id="action_git_repository" model="ir.actions.act_window">
        <field name="name">Git Repositories</field>
        <field name="res_model">git.repository</field>
        <field name="view_mode">tree,form</field>
    </record>

    <!-- Root menu for the module -->
    <menuitem id="menu_git_nostr_bridge_root"
              name="Git Repository Anchor"
              sequence="10"/>

    <!-- Submenu for Git Repositories -->
    <menuitem id="menu_git_repository"
              name="Git Repositories"
              parent="menu_git_nostr_bridge_root"
              action="action_git_repository"
              sequence="10"/>
</odoo>
=== ./odoo_custom_addons (copy)/git_repository_anchor/views/repository_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data>
        <!-- Repository Form View -->
        <record id="view_git_repository_form" model="ir.ui.view">
            <field name="name">git.repository.form</field>
            <field name="model">git.repository</field>
            <field name="arch" type="xml">
                <form string="Git Repository">
                    <sheet>
                        <group>
                            <field name="name"/>
                            <field name="path"/>
                            <field name="description"/>
                            <field name="maintainer_ids" widget="many2many_tags"/>
                            <field name="created_at"/>
                            <field name="last_updated"/>
                        </group>
                        <notebook>
                            <page string="Branches">
                                <field name="branch_ids">
                                    <tree editable="bottom">
                                        <field name="name"/>
                                        <field name="head"/>
                                    </tree>
                                </field>
                            </page>
                        </notebook>
                    </sheet>
                </form>
            </field>
        </record>

        <!-- Repository Tree View -->
        <record id="view_git_repository_tree" model="ir.ui.view">
            <field name="name">git.repository.tree</field>
            <field name="model">git.repository</field>
            <field name="arch" type="xml">
                <tree string="Git Repositories">
                    <field name="name"/>
                    <field name="path"/>
                    <field name="description"/>
                    <field name="created_at"/>
                    <field name="last_updated"/>
                </tree>
            </field>
        </record>

        <!-- Repository Search View -->
        <record id="view_git_repository_search" model="ir.ui.view">
            <field name="name">git.repository.search</field>
            <field name="model">git.repository</field>
            <field name="arch" type="xml">
                <search string="Search Repositories">
                    <field name="name"/>
                    <field name="path"/>
                    <field name="description"/>
                    <field name="maintainer_ids"/>
                    <filter string="My Repositories" name="my_repositories" domain="[('maintainer_ids', 'in', uid)]"/>
                    <group expand="0" string="Group By">
                        <filter string="Created Date" name="group_by_created_at" context="{'group_by': 'created_at:month'}"/>
                    </group>
                </search>
            </field>
        </record>

        <!-- Repository Action -->
        <record id="action_git_repository" model="ir.actions.act_window">
            <field name="name">Git Repositories</field>
            <field name="res_model">git.repository</field>
            <field name="view_mode">tree,form</field>
            <field name="search_view_id" ref="view_git_repository_search"/>
        </record>

        <!-- Menu Items -->
        <menuitem id="menu_git_repository_root" name="Git Repositories" sequence="10"/>
        <menuitem id="menu_git_repository" parent="menu_git_repository_root" action="action_git_repository" sequence="10"/>
    </data>
</odoo>
=== ./odoo_custom_addons (copy)/git_repository_anchor/controllers/__init__.py ===
from . import main
=== ./odoo_custom_addons (copy)/git_repository_anchor/controllers/main.py ===
from odoo import http
from odoo.http import request

class GitRepositoryController(http.Controller):
    @http.route('/git/repository/create', type='json', auth='user')
    def create_repository(self, name, path, description, maintainer_ids):
        repo_manager = request.env['git.repository.manager'].sudo()
        repo_id = repo_manager.create_repository(name, path, description, maintainer_ids)
        return {'success': True, 'repository_id': repo_id}

    @http.route('/git/repository/update', type='json', auth='user')
    def update_repository(self, repo_id, description=None, maintainer_ids=None):
        repo_manager = request.env['git.repository.manager'].sudo()
        updated_repo_id = repo_manager.update_repository(repo_id, description, maintainer_ids)
        return {'success': True, 'repository_id': updated_repo_id}

    @http.route('/git/repository/fork', type='json', auth='user')
    def fork_repository(self, original_repo_id, new_name):
        repo_manager = request.env['git.repository.manager'].sudo()
        forked_repo_id = repo_manager.fork_repository(original_repo_id, new_name, request.env.user.id)
        return {'success': True, 'repository_id': forked_repo_id}

    @http.route('/git/repository/list_maintainers', type='json', auth='user')
    def list_maintainers(self, repo_id):
        repo_manager = request.env['git.repository.manager'].sudo()
        maintainer_ids = repo_manager.list_maintainers(repo_id)
        return {'success': True, 'maintainer_ids': maintainer_ids}
=== ./odoo_custom_addons (copy)/git_branch_manager/git-branch-manager-module.py ===
# Directory structure:
# git_branch_manager/
# ├── __init__.py
# ├── __manifest__.py
# ├── models/
# │   ├── __init__.py
# │   ├── branch.py
# │   ├── event.py
# │   └── branch_manager.py
# ├── controllers/
# │   ├── __init__.py
# │   └── main.py
# ├── security/
# │   └── ir.model.access.csv
# └── views/
#     ├── branch_views.xml
#     └── event_views.xml

# __init__.py
from . import models
from . import controllers

# __manifest__.py
{
    'name': 'Git Branch Manager',
    'version': '1.0',
    'summary': 'Manage Git branches using Nostr events',
    'description': """
    This module allows you to manage Git branches using Nostr events.
    It integrates with the Nostr-Odoo application to handle branch operations.
    """,
    'author': 'Your Name',
    'depends': ['base'],
    'data': [
        'security/ir.model.access.csv',
        'views/branch_views.xml',
        'views/event_views.xml',
    ],
    'installable': True,
    'application': True,
}

# models/__init__.py
from . import branch
from . import event
from . import branch_manager

# models/branch.py
from odoo import models, fields

class GitBranch(models.Model):
    _name = 'git.branch'
    _description = 'Git Branch'

    name = fields.Char(string='Branch Name', required=True)
    head = fields.Char(string='Head Commit', required=True)
    created_at = fields.Datetime(string='Created At')
    last_updated = fields.Datetime(string='Last Updated')

# models/event.py
from odoo import models, fields

class GitEvent(models.Model):
    _name = 'git.event'
    _description = 'Git Event'

    event_type = fields.Selection([('create', 'Create'), ('update', 'Update'), ('delete', 'Delete')], string='Event Type')
    content = fields.Text(string='Event Content')
    created_at = fields.Datetime(string='Created At', default=fields.Datetime.now)

# models/branch_manager.py
from odoo import models, api
from nostr.event import Event
from nostr.key import PrivateKey
import json
import logging
import time

_logger = logging.getLogger(__name__)

class GitBranchManager(models.AbstractModel):
    _name = 'git.branch.manager'
    _description = 'Git Branch Manager'

    @api.model
    def create_branch(self, name, head):
        _logger.info(f"Creating branch: {name} with head: {head}")
        start_time = time.time()

        try:
            if self.env['git.branch'].search([('name', '=', name)]):
                raise ValueError(f"Branch {name} already exists")

            branch = self.env['git.branch'].create({
                'name': name,
                'head': head,
                'created_at': fields.Datetime.now(),
                'last_updated': fields.Datetime.now(),
            })

            event = self._create_branch_event(branch, 'create')
            self._publish_event(event)

            end_time = time.time()
            _logger.info(f"Branch {name} created in {end_time - start_time:.2f} seconds")
            return True
        except Exception as e:
            _logger.exception(f"Error creating branch: {str(e)}")
            raise

    @api.model
    def update_branch(self, name, new_head):
        _logger.info(f"Updating branch: {name} to new head: {new_head}")
        start_time = time.time()

        try:
            branch = self.env['git.branch'].search([('name', '=', name)])
            if not branch:
                raise ValueError(f"Branch {name} does not exist")

            branch.write({
                'head': new_head,
                'last_updated': fields.Datetime.now(),
            })

            event = self._create_branch_event(branch, 'update')
            self._publish_event(event)

            end_time = time.time()
            _logger.info(f"Branch {name} updated in {end_time - start_time:.2f} seconds")
            return True
        except Exception as e:
            _logger.exception(f"Error updating branch: {str(e)}")
            raise

    @api.model
    def delete_branch(self, name):
        _logger.info(f"Deleting branch: {name}")
        start_time = time.time()

        try:
            branch = self.env['git.branch'].search([('name', '=', name)])
            if not branch:
                raise ValueError(f"Branch {name} does not exist")

            event = self._create_branch_event(branch, 'delete')
            branch.unlink()
            self._publish_event(event)

            end_time = time.time()
            _logger.info(f"Branch {name} deleted in {end_time - start_time:.2f} seconds")
            return True
        except Exception as e:
            _logger.exception(f"Error deleting branch: {str(e)}")
            raise

    def _create_branch_event(self, branch, operation):
        event = Event()
        event.kind = 31227  # Custom event kind for git branch operations
        event.content = json.dumps({
            'operation': operation,
            'name': branch.name,
            'head': branch.head,
            'timestamp': fields.Datetime.now().isoformat(),
        })
        event.tags = [['e', 'git_branch']]

        private_key = PrivateKey()  # In practice, securely store and retrieve this
        event.sign(private_key.hex())

        return event

    def _publish_event(self, event):
        self.env['git.event'].create({
            'event_type': json.loads(event.content)['operation'],
            'content': event.to_message(),
        })
        # Here you would also publish the event to the Nostr network
        # This part depends on how you've implemented your Nostr client in Odoo

# controllers/__init__.py
from . import main

# controllers/main.py
from odoo import http
from odoo.http import request

class GitBranchController(http.Controller):

    @http.route('/git/branch/create', type='json', auth='user')
    def create_branch(self, name, head):
        branch_manager = request.env['git.branch.manager'].sudo()
        result = branch_manager.create_branch(name, head)
        return {'success': result}

    @http.route('/git/branch/update', type='json', auth='user')
    def update_branch(self, name, new_head):
        branch_manager = request.env['git.branch.manager'].sudo()
        result = branch_manager.update_branch(name, new_head)
        return {'success': result}

    @http.route('/git/branch/delete', type='json', auth='user')
    def delete_branch(self, name):
        branch_manager = request.env['git.branch.manager'].sudo()
        result = branch_manager.delete_branch(name)
        return {'success': result}

# security/ir.model.access.csv
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_git_branch_user,access_git_branch_user,model_git_branch,,1,1,1,1
access_git_event_user,access_git_event_user,model_git_event,,1,1,1,1

# views/branch_views.xml
<?xml version="1.0" encoding="UTF-8"?>
<odoo>
    <record id="view_git_branch_form" model="ir.ui.view">
        <field name="name">git.branch.form</field>
        <field name="model">git.branch</field>
        <field name="arch" type="xml">
            <form string="Git Branch">
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="head"/>
                        <field name="created_at"/>
                        <field name="last_updated"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_git_branch_tree" model="ir.ui.view">
        <field name="name">git.branch.tree</field>
        <field name="model">git.branch</field>
        <field name="arch" type="xml">
            <tree string="Git Branches">
                <field name="name"/>
                <field name="head"/>
                <field name="created_at"/>
                <field name="last_updated"/>
            </tree>
        </field>
    </record>

    <record id="action_git_branch" model="ir.actions.act_window">
        <field name="name">Branches</field>
        <field name="res_model">git.branch</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_git_branch_root" name="Git Branches" sequence="10"/>
    <menuitem id="menu_git_branch" parent="menu_git_branch_root"
              action="action_git_branch" sequence="10"/>
</odoo>

# views/event_views.xml
<?xml version="1.0" encoding="UTF-8"?>
<odoo>
    <record id="view_git_event_form" model="ir.ui.view">
        <field name="name">git.event.form</field>
        <field name="model">git.event</field>
        <field name="arch" type="xml">
            <form string="Git Event">
                <sheet>
                    <group>
                        <field name="event_type"/>
                        <field name="content"/>
                        <field name="created_at"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_git_event_tree" model="ir.ui.view">
        <field name="name">git.event.tree</field>
        <field name="model">git.event</field>
        <field name="arch" type="xml">
            <tree string="Git Events">
                <field name="event_type"/>
                <field name="content"/>
                <field name="created_at"/>
            </tree>
        </field>
    </record>

    <record id="action_git_event" model="ir.actions.act_window">
        <field name="name">Events</field>
        <field name="res_model">git.event</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_git_events" parent="menu_git_branch_root"
              action="action_git_event" sequence="20"/>
</odoo>
=== ./odoo_custom_addons (copy)/nostr_auth/models/__init__.py ===
# File: odoo_custom_addons/nostr_auth/models/__init__.py
from . import res_users
from . import nostr_auth_module
=== ./odoo_custom_addons (copy)/nostr_auth/models/res_users.py ===
# File: odoo_custom_addons/nostr_auth/models/res_users.py

from odoo import models, fields, api
from odoo.exceptions import ValidationError
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import hashes
import base64

class ResUsers(models.Model):
    _inherit = 'res.users'

    nostr_public_key = fields.Char(string='Nostr Public Key')
    nostr_private_key = fields.Char(string='Nostr Private Key')
    nostr_relay_url = fields.Char(string='Nostr Relay URL')

    @api.model_create_multi
    def create(self, vals_list):
        nostr_auth = self.env['nostr.auth.module']
        for vals in vals_list:
            if not vals.get('nostr_private_key'):
                keys = nostr_auth.generate_keypair()
                vals['nostr_private_key'] = keys['private_key']
                vals['nostr_public_key'] = keys['public_key']
        return super(ResUsers, self).create(vals_list)

    @api.constrains('nostr_public_key')
    def _check_nostr_public_key(self):
        for user in self:
            if user.nostr_public_key:
                if not user.nostr_public_key.startswith('npub1'):
                    raise ValidationError("Invalid Nostr public key format. It should start with 'npub1'.")

    @api.model
    def authenticate_nostr(self, public_key, signature, message):
        user = self.search([('nostr_public_key', '=', public_key)], limit=1)
        if user:
            nostr_auth = self.env['nostr.auth.module']
            if nostr_auth.verify_signature(public_key, message, signature):
                return user.id
        return False
=== ./odoo_custom_addons (copy)/nostr_auth/models/nostr_auth_module.py ===
# File: odoo_custom_addons/nostr_auth/models/nostr_auth_module.py

from odoo import models, api
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.serialization import Encoding, PublicFormat, PrivateFormat, NoEncryption
import base64
from bech32 import bech32_encode, bech32_decode, convertbits

class NostrAuthModule(models.AbstractModel):
    _name = 'nostr.auth.module'
    _description = 'Nostr Authentication Module'

    @api.model
    def generate_keypair(self):
        private_key = ec.generate_private_key(ec.SECP256K1())
        public_key = private_key.public_key()
        
        private_bytes = private_key.private_numbers().private_value.to_bytes(32, 'big')
        public_bytes = public_key.public_bytes(
            encoding=Encoding.X962,
            format=PublicFormat.UncompressedPoint
        )[1:]
        
        return {
            'private_key': self.bytes_to_nsec(private_bytes),
            'public_key': self.bytes_to_npub(public_bytes)
        }

    @api.model
    def verify_signature(self, public_key, message, signature):
        try:
            public_key_bytes = self.npub_to_bytes(public_key)
            public_key_obj = ec.EllipticCurvePublicKey.from_encoded_point(ec.SECP256K1(), b'\x04' + public_key_bytes)
            signature_bytes = base64.b64decode(signature)
            public_key_obj.verify(
                signature_bytes,
                message.encode('utf-8'),
                ec.ECDSA(hashes.SHA256())
            )
            return True
        except:
            return False

    @api.model
    def bytes_to_npub(self, key_bytes):
        data = convertbits(key_bytes[:32], 8, 5)
        return bech32_encode('npub', data)

    @api.model
    def bytes_to_nsec(self, key_bytes):
        data = convertbits(key_bytes[:32], 8, 5)
        return bech32_encode('nsec', data)
        
    @api.model
    def npub_to_bytes(self, npub):
        hrp, data = bech32_decode(npub)
        return bytes(convertbits(data, 5, 8, False))

    @api.model
    def nsec_to_bytes(self, nsec):
        hrp, data = bech32_decode(nsec)
        return bytes(convertbits(data, 5, 8, False))
=== ./odoo_custom_addons (copy)/nostr_auth/__init__.py ===
from . import models
=== ./odoo_custom_addons (copy)/nostr_auth/__manifest__.py ===
# File: odoo_custom_addons/nostr_auth/__manifest__.py
{
    'name': 'Nostr Authentication',
    'version': '1.0',
    'category': 'Authentication',
    'summary': 'Extends user model with Nostr fields and authentication',
    'depends': ['base', 'auth_signup'],
    'data': [
        'views/res_users_views.xml',
    ],
    'installable': True,
    'application': False,
    'auto_install': False,
    'external_dependencies': {
        'python': ['cryptography', 'bech32'],
    },
}
=== ./odoo_custom_addons (copy)/nostr_auth/views/res_users_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_users_form_nostr" model="ir.ui.view">
        <field name="name">res.users.form.nostr</field>
        <field name="model">res.users</field>
        <field name="inherit_id" ref="base.view_users_form"/>
        <field name="arch" type="xml">
            <xpath expr="//page[@name='access_rights']" position="after">
                <page string="Nostr Authentication" name="nostr_auth">
                    <group>
                        <field name="nostr_public_key"/>
                        <field name="nostr_relay_url"/>
                    </group>
                </page>
            </xpath>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/nostr_auth/controllers/__init__.py ===
from . import main
=== ./odoo_custom_addons (copy)/nostr_auth/controllers/main.py ===
# controllers/main.py
from odoo import http
from odoo.http import request
import json

class NostrAuthController(http.Controller):
    @http.route('/web/nostr/authenticate', type='json', auth='none')
    def authenticate(self, public_key, signature, message):
        uid = request.env['res.users'].sudo().authenticate_nostr(public_key, signature, message)
        if uid:
            request.session.authenticate(request.session.db, uid, public_key)
            return {'success': True, 'uid': uid}
        return {'success': False, 'error': 'Authentication failed'}
=== ./odoo_custom_addons (copy)/nostr_identity/models/__init__.py ===
# models/__init__.py
from . import nostr_identity
from . import nostr_identity_verifier
from . import nostr_message
=== ./odoo_custom_addons (copy)/nostr_identity/models/nostr_identity_verifier.py ===
from odoo import models, fields, api, _
from odoo.exceptions import UserError
import logging
import json
import websocket
import threading
import ssl
import time
from odoo.tools import config

_logger = logging.getLogger(__name__)

class NostrIdentityVerifier(models.Model):
    _name = 'nostr.identity.verifier'
    _description = 'Nostr Identity Verifier'

    name = fields.Char(string='Name', required=True)
    active = fields.Boolean(default=True)
    relay_url = fields.Char(string='Relay URL', required=True)
    websocket_state = fields.Selection([
        ('disconnected', 'Disconnected'),
        ('connecting', 'Connecting'),
        ('connected', 'Connected')
    ], default='disconnected', string='WebSocket State', readonly=True)
    last_error = fields.Text(string='Last Error', readonly=True)

    def _get_ws_connection(self):
        return self.env.context.get('ws_connection')

    def _set_ws_connection(self, ws):
        self = self.with_context(ws_connection=ws)

    def connect_to_relay(self):
        self.ensure_one()
        if self.websocket_state == 'connected':
            return True

        self.websocket_state = 'connecting'
        self.last_error = False

        try:
            ws = self._create_websocket(self.relay_url)
            self._set_ws_connection(ws)
            
            # Wait for connection to establish or fail
            for _ in range(20):  # Wait up to 10 seconds
                if self.websocket_state == 'connected':
                    return True
                elif self.websocket_state == 'disconnected':
                    raise UserError(self.last_error or _("Connection failed"))
                time.sleep(0.5)

            raise UserError(_("Connection timeout"))
        except Exception as e:
            self.websocket_state = 'disconnected'
            self.last_error = str(e)
            _logger.error(f"Failed to connect to {self.relay_url}: {str(e)}")
            return False

    def _create_websocket(self, relay_url):
        def on_message(ws, message):
            with self.pool.cursor() as new_cr:
                self.with_env(self.env(cr=new_cr))._handle_message(message)

        def on_error(ws, error):
            with self.pool.cursor() as new_cr:
                self.with_env(self.env(cr=new_cr))._handle_error(error)

        def on_close(ws, close_status_code, close_msg):
            with self.pool.cursor() as new_cr:
                self.with_env(self.env(cr=new_cr))._handle_close()

        def on_open(ws):
            with self.pool.cursor() as new_cr:
                self.with_env(self.env(cr=new_cr))._handle_open()

        ws = websocket.WebSocketApp(relay_url,
                                    on_message=on_message,
                                    on_error=on_error,
                                    on_close=on_close,
                                    on_open=on_open)

        wst = threading.Thread(target=lambda: ws.run_forever(sslopt={"cert_reqs": ssl.CERT_NONE}))
        wst.daemon = True
        wst.start()

        return ws

    def _handle_message(self, message):
        _logger.info(f"Received message from {self.relay_url}: {message}")
        self.env['nostr.message'].create({
            'verifier_id': self.id,
            'content': message
        })

    def _handle_error(self, error):
        _logger.error(f"WebSocket error for {self.relay_url}: {error}")
        self.write({'last_error': str(error), 'websocket_state': 'disconnected'})

    def _handle_close(self):
        _logger.info(f"WebSocket connection closed for {self.relay_url}")
        self.write({'websocket_state': 'disconnected'})

    def _handle_open(self):
        _logger.info(f"WebSocket connection opened for {self.relay_url}")
        self.write({'websocket_state': 'connected'})

    def publish_event(self, event):
        self.ensure_one()
        if self.websocket_state != 'connected':
            if not self.connect_to_relay():
                raise UserError(_("Failed to connect to relay"))

        try:
            message = json.dumps(["EVENT", event])
            ws = self._get_ws_connection()
            if ws:
                ws.send(message)
                _logger.info(f"Published event to {self.relay_url}")
                return True
            else:
                raise UserError(_("WebSocket connection is not available"))
        except Exception as e:
            _logger.error(f"Failed to publish event to {self.relay_url}: {str(e)}")
            raise UserError(_("Failed to publish event: %s") % str(e))

    @api.model
    def process_messages(self):
        messages = self.env['nostr.message'].search([('processed', '=', False)])
        for message in messages:
            try:
                # Process the message here
                _logger.info(f"Processing message: {message.content}")
                # Add your message processing logic here
                message.write({'processed': True})
            except Exception as e:
                _logger.error(f"Error processing message {message.id}: {str(e)}")

    def close_connection(self):
        self.ensure_one()
        ws = self._get_ws_connection()
        if ws:
            try:
                ws.close()
            except Exception as e:
                _logger.error(f"Error closing WebSocket for {self.relay_url}: {str(e)}")
        self._set_ws_connection(None)
        self.write({'websocket_state': 'disconnected'})
=== ./odoo_custom_addons (copy)/nostr_identity/models/nostr_identity.py ===
from odoo import models, fields, api, _
from odoo.exceptions import UserError, ValidationError
import base64
from cryptography.fernet import Fernet
import logging
import secrets
from nostr.key import PrivateKey
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import serialization
import bech32

_logger = logging.getLogger(__name__)

def hex_to_nostr_key(hex_key, prefix):
    # Convert hex to bytes
    data = bytes.fromhex(hex_key)
    
    # Convert to 5-bit words
    words = bech32.convertbits(data, 8, 5)
    
    # Encode with bech32
    encoded = bech32.bech32_encode(prefix, words)
    
    return encoded

class NostrIdentity(models.Model):
    _name = 'nostr.identity'
    _description = 'Nostr Identity'

    name = fields.Char(string='Name', required=True)
    public_key = fields.Char(string='Public Key (hex)', readonly=True)
    private_key = fields.Char(string='Private Key (hex)', readonly=True)
    public_key_bech32 = fields.Char(string='Public Key (npub)', readonly=True, compute='_compute_bech32_keys')
    private_key_bech32 = fields.Char(string='Private Key (nsec)', readonly=True, compute='_compute_bech32_keys')
    relay_urls = fields.Text(string='Relay URLs')
    profile_data = fields.Text(string='Profile Data')

    @api.model
    def create(self, vals):
        if 'public_key' not in vals or 'private_key' not in vals:
            try:
                private_key = PrivateKey()
                public_key = private_key.public_key
                vals['private_key'] = private_key.hex()
                vals['public_key'] = public_key.hex()
            except Exception as e:
                _logger.error(f"Failed to generate Nostr keys: {str(e)}")
                raise UserError(_("Failed to generate Nostr keys: %s") % str(e))
        return super(NostrIdentity, self).create(vals)

    @api.depends('public_key', 'private_key')
    def _compute_bech32_keys(self):
        for record in self:
            if record.public_key:
                record.public_key_bech32 = hex_to_nostr_key(record.public_key, "npub")
            else:
                record.public_key_bech32 = False
            
            if record.private_key:
                record.private_key_bech32 = hex_to_nostr_key(record.private_key, "nsec")
            else:
                record.private_key_bech32 = False

    def get_private_key(self):
        self.ensure_one()
        try:
            encryption_key = self.env['ir.config_parameter'].sudo().get_param('nostr.encryption_key')
            if not encryption_key:
                raise UserError(_("Encryption key not found. Unable to decrypt private key."))
            
            fernet = Fernet(encryption_key.encode())
            decrypted_private_key = fernet.decrypt(base64.b64decode(self.encrypted_private_key))
            return PrivateKey(bytes.fromhex(decrypted_private_key.decode()))
        except Exception as e:
            _logger.error(f"Failed to decrypt private key: {str(e)}")
            raise UserError(_("Failed to decrypt private key: %s") % str(e))

    def get_public_key_bech32(self):
        return self.public_key_bech32
=== ./odoo_custom_addons (copy)/nostr_identity/models/nostr_message.py ===
# models/nostr_message.py

from odoo import models, fields

class NostrMessage(models.Model):
    _name = 'nostr.message'
    _description = 'Nostr Message'

    verifier_id = fields.Many2one('nostr.identity.verifier', string='Verifier', required=True, ondelete='cascade')
    content = fields.Text(string='Message Content', required=True)
    processed = fields.Boolean(string='Processed', default=False)
=== ./odoo_custom_addons (copy)/nostr_identity/__init__.py ===
# nostr_identity/__init__.py

from . import models
from . import nostr_cleanup

def post_init_hook(cr, registry):
    from odoo import api, SUPERUSER_ID
    env = api.Environment(cr, SUPERUSER_ID, {})
    
    # Generate encryption key if it doesn't exist
    if not env['ir.config_parameter'].get_param('nostr.encryption_key'):
        from cryptography.fernet import Fernet
        encryption_key = Fernet.generate_key()
        env['ir.config_parameter'].set_param('nostr.encryption_key', encryption_key.decode())

def uninstall_hook(cr, registry):
    from odoo import api, SUPERUSER_ID
    env = api.Environment(cr, SUPERUSER_ID, {})
    
    # Remove the encryption key
    env['ir.config_parameter'].set_param('nostr.encryption_key', False)
    
    # Close all active WebSocket connections
    verifiers = env['nostr.identity.verifier'].search([])
    for verifier in verifiers:
        verifier.close_connection()
=== ./odoo_custom_addons (copy)/nostr_identity/__manifest__.py ===
# __manifest__.py
{
    'name': 'Nostr Identity Verifier',
    'version': '1.0',
    'category': 'Tools',
    'summary': 'Integrate Nostr identity verification into Odoo',
    'author': 'Your Name',
    'website': 'https://www.example.com',
    'license': 'LGPL-3',
    'depends': ['base', 'mail'],
    'data': [
        'security/nostr_security.xml',
        'security/ir.model.access.csv',
        'views/nostr_identity_views.xml',
        'data/ir_cron_data.xml',
    ],
    'demo': [],
    'external_dependencies': {
        'python': ['websocket-client', 'nostr'],
    },
    'installable': True,
    'application': False,
    'auto_install': False,
    'post_init_hook': 'post_init_hook',
    'uninstall_hook': 'uninstall_hook',
}
=== ./odoo_custom_addons (copy)/nostr_identity/nostr_cleanup.py ===
# nostr_identity/nostr_cleanup.py

import atexit
from odoo import api, SUPERUSER_ID

def cleanup_connections():
    try:
        with api.Environment.manage():
            env = api.Environment(odoo.registry(odoo.tools.config['db_name']).cursor(), SUPERUSER_ID, {})
            verifiers = env['nostr.identity.verifier'].search([])
            for verifier in verifiers:
                verifier.close_connection()
            env.cr.commit()
    except Exception as e:
        # Log the error, but don't raise it to avoid interfering with Odoo's shutdown process
        _logger.error(f"Error during Nostr connection cleanup: {e}")
    finally:
        if env and env.cr:
            env.cr.close()

atexit.register(cleanup_connections)
=== ./odoo_custom_addons (copy)/nostr_identity/security/nostr_security.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <!-- Rule: Users can only see their own Nostr Identity records -->
        <record id="rule_nostr_identity_users" model="ir.rule">
            <field name="name">Users can only see their own Nostr Identity</field>
            <field name="model_id" ref="model_nostr_identity"/>
            <field name="domain_force">[('create_uid', '=', user.id)]</field>
            <field name="groups" eval="[(4, ref('base.group_user'))]"/>
            <field name="perm_read" eval="True"/>
            <field name="perm_write" eval="False"/>
            <field name="perm_create" eval="False"/>
            <field name="perm_unlink" eval="False"/>
        </record>

        <!-- Rule: Managers can see all Nostr Identity records -->
        <record id="rule_nostr_identity_managers" model="ir.rule">
            <field name="name">Managers can see all Nostr Identity records</field>
            <field name="model_id" ref="model_nostr_identity"/>
            <field name="domain_force">[(1, '=', 1)]</field>
            <field name="groups" eval="[(4, ref('base.group_system'))]"/>
            <field name="perm_read" eval="True"/>
            <field name="perm_write" eval="True"/>
            <field name="perm_create" eval="True"/>
            <field name="perm_unlink" eval="True"/>
        </record>
    </data>
</odoo>
=== ./odoo_custom_addons (copy)/nostr_identity/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_nostr_identity_user,nostr.identity user,model_nostr_identity,base.group_user,1,1,1,0
access_nostr_identity_manager,nostr.identity manager,model_nostr_identity,base.group_system,1,1,1,1
access_nostr_identity_verifier_user,nostr.identity.verifier user,model_nostr_identity_verifier,base.group_user,1,0,0,0
access_nostr_identity_verifier_manager,nostr.identity.verifier manager,model_nostr_identity_verifier,base.group_system,1,1,1,1
access_nostr_message_user,nostr.message user,model_nostr_message,base.group_user,1,0,0,0
access_nostr_message_manager,nostr.message manager,model_nostr_message,base.group_system,1,1,1,1
=== ./odoo_custom_addons (copy)/nostr_identity/data/ir_cron_data.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <record id="ir_cron_nostr_process_messages" model="ir.cron">
            <field name="name">Nostr: Process Messages</field>
            <field name="model_id" ref="model_nostr_identity_verifier"/>
            <field name="state">code</field>
            <field name="code">model.process_messages()</field>
            <field name="interval_number">5</field>
            <field name="interval_type">minutes</field>
            <field name="numbercall">-1</field>
            <field name="doall" eval="False"/>
            <field name="active" eval="True"/>
        </record>
    </data>
</odoo>
=== ./odoo_custom_addons (copy)/nostr_identity/views/nostr_identity_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <!-- Nostr Identity Views -->
    <record id="view_nostr_identity_tree" model="ir.ui.view">
        <field name="name">nostr.identity.tree</field>
        <field name="model">nostr.identity</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="public_key"/>
                <field name="public_key_bech32"/>
            </tree>
        </field>
    </record>

    <record id="view_nostr_identity_form" model="ir.ui.view">
        <field name="name">nostr.identity.form</field>
        <field name="model">nostr.identity</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="public_key"/>
                        <field name="public_key_bech32"/>
                        <field name="relay_urls"/>
                        <field name="profile_data"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <!-- The rest of the XML remains unchanged -->
    <!-- Nostr Identity Verifier Views -->
    <record id="view_nostr_identity_verifier_tree" model="ir.ui.view">
        <field name="name">nostr.identity.verifier.tree</field>
        <field name="model">nostr.identity.verifier</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="relay_url"/>
                <field name="websocket_state"/>
            </tree>
        </field>
    </record>

    <record id="view_nostr_identity_verifier_form" model="ir.ui.view">
        <field name="name">nostr.identity.verifier.form</field>
        <field name="model">nostr.identity.verifier</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="connect_to_relay" string="Connect" type="object" class="oe_highlight" attrs="{'invisible': [('websocket_state', '=', 'connected')]}"/>
                    <button name="close_connection" string="Disconnect" type="object" attrs="{'invisible': [('websocket_state', '!=', 'connected')]}"/>
                </header>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="relay_url"/>
                        <field name="active"/>
                        <field name="websocket_state"/>
                        <field name="last_error"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <!-- Action Windows -->
    <record id="action_nostr_identity" model="ir.actions.act_window">
        <field name="name">Nostr Identities</field>
        <field name="res_model">nostr.identity</field>
        <field name="view_mode">tree,form</field>
    </record>

    <record id="action_nostr_identity_verifier" model="ir.actions.act_window">
        <field name="name">Nostr Identity Verifiers</field>
        <field name="res_model">nostr.identity.verifier</field>
        <field name="view_mode">tree,form</field>
    </record>

    <!-- Menu Items -->
    <menuitem id="menu_nostr_root" name="Nostr" sequence="10"/>
    <menuitem id="menu_nostr_identity" name="Identities" parent="menu_nostr_root" action="action_nostr_identity" sequence="10"/>
    <menuitem id="menu_nostr_identity_verifier" name="Verifiers" parent="menu_nostr_root" action="action_nostr_identity_verifier" sequence="20"/>
</odoo>
=== ./odoo_custom_addons (copy)/nostr_bridge/models/git_repository.py ===
# File: odoo_custom_addons/nostr_bridge/models/git_repository.py

from odoo import models, fields, api
import git
import os

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Repository Name', required=True)
    path = fields.Char(string='Repository Path', required=True)
    
    @api.model
    def create(self, vals):
        repo = super(GitRepository, self).create(vals)
        if not os.path.exists(repo.path):
            os.makedirs(repo.path)
            git.Repo.init(repo.path)
        return repo

    def commit_changes(self, message):
        repo = git.Repo(self.path)
        repo.git.add(A=True)
        commit = repo.index.commit(message)
        
        event_manager = self.env['nostr.event.manager']
        event = event_manager.create_git_event(self.path, commit.hexsha)
        event_manager.publish_event(event)
        
        return commit.hexsha
=== ./odoo_custom_addons (copy)/nostr_bridge/models/__init__.py ===
# File: odoo_custom_addons/nostr_bridge/models/__init__.py

from . import res_users
from . import mail_message
from . import nostr_adapter
from . import res_config_settings
from . import res_partner
from . import nostr_event_manager
from . import git_repository
=== ./odoo_custom_addons (copy)/nostr_bridge/models/res_users.py ===
"""from odoo import models, fields, api
from nostr.key import PrivateKey

class ResUsers(models.Model):
    _inherit = 'res.users'

    #nostr_private_key = fields.Char(string="Nostr Private Key")
    #nostr_public_key = fields.Char(string="Nostr Public Key", compute='_compute_public_key')
    #nostr_relay_url = fields.Char(string="Nostr Relay URL")

    nostr_public_key = fields.Char(string="Nostr Public Key")
    nostr_private_key = fields.Char(string="Nostr Private Key")
    nostr_relay_url = fields.Char(string="Nostr Relay URL")

    @api.model
    def create(self, vals):
        if not vals.get('nostr_private_key'):
            private_key = PrivateKey()
            vals['nostr_private_key'] = private_key.bech32()
        return super(ResUsers, self).create(vals)

    def write(self, vals):
        # Here you might want to handle updates to Nostr fields
        return super(ResUsers, self).write(vals)

    @api.depends('nostr_private_key')
    def _compute_public_key(self):
        for user in self:
            if user.nostr_private_key:
                private_key = PrivateKey.from_nsec(user.nostr_private_key)
                user.nostr_public_key = private_key.public_key.bech32()
            else:
                user.nostr_public_key = False
"""

"""from odoo import models, fields, api

class ResUsers(models.Model):
    _inherit = 'res.users'

    nostr_public_key = fields.Char(string="Nostr Public Key")
    nostr_private_key = fields.Char(string="Nostr Private Key")
    nostr_relay_url = fields.Char(string="Nostr Relay URL")

    @api.model
    def create(self, vals):
        # Here you might want to generate Nostr keys if they're not provided
        return super(ResUsers, self).create(vals)

    def write(self, vals):
        # Here you might want to handle updates to Nostr fields
        return super(ResUsers, self).write(vals)"""
        
        
from odoo import models, fields

class ResUsers(models.Model):
    _inherit = 'res.users'

    nostr_public_key = fields.Char(string="Nostr Public Key")
    nostr_private_key = fields.Char(string="Nostr Private Key")
    nostr_relay_url = fields.Char(string="Nostr Relay URL")
=== ./odoo_custom_addons (copy)/nostr_bridge/models/nostr_adapter.py ===
import requests
import websocket
from odoo import models, api
from websocket._exceptions import WebSocketConnectionClosedException
from odoo.exceptions import UserError
from nostr.event import Event
from nostr.key import PrivateKey
from nostr.relay_manager import RelayManager
import logging
import time

_logger = logging.getLogger(__name__)

class NostrAdapter(models.AbstractModel):
    _name = 'nostr.adapter'
    _description = 'Nostr Adapter'

    @api.model
    def get_relay_manager(self):
        ICPSudo = self.env['ir.config_parameter'].sudo()
        relay_urls = ICPSudo.get_param('nostr_bridge.relay_urls', '').split(',')
        if not relay_urls:
            raise UserError("Nostr relay URL is not configured. Please set it in the settings.")
        _logger.info(f"Nostr relay URLs: {relay_urls}")

        relay_manager = RelayManager()
        for url in relay_urls:
            url = url.strip()
            if url:  # Only add non-empty URLs
                _logger.info(f"Adding relay: {url}")
                relay_manager.add_relay(url)
        return relay_manager

    @api.model
    def publish_event(self, event_data, max_retries=3, retry_delay=1):
        for attempt in range(max_retries):
            try:
                private_key = PrivateKey.from_nsec(self.env.user.nostr_private_key)
                public_key = private_key.public_key.hex()
                
                event = Event(
                    kind=event_data['kind'],
                    content=event_data['content'],
                    tags=event_data.get('tags', []),
                    public_key=public_key
                )
                private_key.sign_event(event)
                
                relay_manager = self.get_relay_manager()
                relay_manager.open_connections({"write": True})
                time.sleep(1)  # Give some time for connections to establish
                
                publish_result = relay_manager.publish_event(event)
                _logger.info(f"Relay publish response: {publish_result}")
    
                relay_manager.close_connections()
                return True
            except Exception as e:
                _logger.exception(f"Error publishing event to Nostr: {str(e)}")
                time.sleep(retry_delay)
        
        _logger.error("Failed to publish event after multiple attempts")
        return False
=== ./odoo_custom_addons (copy)/nostr_bridge/models/mail_message.py ===
from odoo import models, api
import logging

_logger = logging.getLogger(__name__)

class MailMessage(models.Model):
    _inherit = 'mail.message'

    @api.model_create_multi
    def create(self, vals_list):
        _logger.info("Creating new mail messages")
        messages = super(MailMessage, self).create(vals_list)
        for message in messages:
            self._publish_to_nostr(message)
        return messages

    def _publish_to_nostr(self, message):
        try:
            nostr_adapter = self.env['nostr.adapter'].sudo()
            event_data = {
                'kind': 1,  # Text note
                'content': message.body,
                'tags': [
                    ['e', str(message.parent_id.id)] if message.parent_id else [],
                    ['p', message.author_id.nostr_public_key] if message.author_id and message.author_id.nostr_public_key else [],
                    ['client', 'Odoo Nostr Bridge'],
                ],
            }
            result = nostr_adapter.publish_event(event_data)
            if result:
                _logger.info(f"Successfully published message {message.id} to Nostr")
            else:
                _logger.warning(f"Failed to publish message {message.id} to Nostr")
        except Exception as e:
            _logger.exception(f"Error publishing message {message.id} to Nostr: {str(e)}")
=== ./odoo_custom_addons (copy)/nostr_bridge/models/nostr_event_handler.py ===
import json
from odoo import api, models

class NostrEventHandler(models.AbstractModel):
    _name = 'nostr.event.handler'
    _description = 'Nostr Event Handler'

    @api.model
    def handle_event(self, event):
        content = json.loads(event.content)
        if event.kind == 1:  # Text note
            self._handle_message(content)
        elif event.kind == 7:  # Reaction
            self._handle_reaction(content)

    def _handle_message(self, content):
        self.env['mail.message'].create({
            'body': content['body'],
            'author_id': self._get_author_id(content['author']),
            'model': content['channel'],
            'res_id': content['res_id'],
        })

    def _handle_reaction(self, content):
        # Implement reaction handling (e.g., likes, emojis)
        pass

    def _get_author_id(self, author_name):
        partner = self.env['res.partner'].search([('name', '=', author_name)], limit=1)
        if not partner:
            partner = self.env['res.partner'].create({'name': author_name})
        return partner.id
=== ./odoo_custom_addons (copy)/nostr_bridge/models/res_config_settings.py ===
import requests
import json
from odoo import fields, models, api
import logging

_logger = logging.getLogger(__name__)

class ResConfigSettings(models.TransientModel):
    _inherit = 'res.config.settings'

    def _default_nostr_relays(self):
        return self._get_top_nostr_relays()

    @api.model
    def _get_top_nostr_relays(self, limit=108):
        url = "https://api.nostr.watch/v1/online"
        try:
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
            }
            response = requests.get(url, headers=headers, timeout=10)
            response.raise_for_status()
            _logger.info(f"Response status code: {response.status_code}")
            
            data = response.json()
            #_logger.info(f"API response (first 108 items): {json.dumps(data)[:1000]}")
            _logger.info(f"API response (first 108 items): {data[:108]}")
            
            relays = data[:108]
            _logger.info(f"Number of relay links found: {len(relays)}")
            _logger.info(f"Extracted relays (first 5): {relays[:5]}")
            
            relay_urls = ",".join(relays)
            return relay_urls
        except requests.RequestException as e:
            _logger.error(f"Error fetching Nostr relays: {e}")
            return "wss://nostr-relay.app,wss://nos.lol,wss://relay.snort.social,wss://relay.nostr.net"

    nostr_relay_urls = fields.Char(
        string="Nostr Relay URLs", 
        config_parameter='nostr_bridge.relay_urls',
        default=_default_nostr_relays
    )

    @api.model
    def get_values(self):
        res = super(ResConfigSettings, self).get_values()
        ICPSudo = self.env['ir.config_parameter'].sudo()
        
        relay_urls = ICPSudo.get_param('nostr_bridge.relay_urls')
        if not relay_urls:
            relay_urls = self._get_top_nostr_relays()
            ICPSudo.set_param('nostr_bridge.relay_urls', relay_urls)
            _logger.info(f"Set new relay URLs: {relay_urls[:100]}...")  # Log first 100 characters
        else:
            _logger.info(f"Using existing relay URLs: {relay_urls[:100]}...")  # Log first 100 characters
        
        res.update(nostr_relay_urls=relay_urls)
        return res

    def set_values(self):
        super(ResConfigSettings, self).set_values()
        ICPSudo = self.env['ir.config_parameter'].sudo()
        if self.nostr_relay_urls:
            ICPSudo.set_param('nostr_bridge.relay_urls', self.nostr_relay_urls)
            _logger.info(f"Updated relay URLs: {self.nostr_relay_urls[:100]}...")  # Log first 100 characters
        else:
            default_urls = self._get_top_nostr_relays()
            ICPSudo.set_param('nostr_bridge.relay_urls', default_urls)
            _logger.info(f"Set default relay URLs: {default_urls[:100]}...")  # Log first 100 characters
=== ./odoo_custom_addons (copy)/nostr_bridge/models/res_partner.py ===
from odoo import models, fields

class ResPartner(models.Model):
    _inherit = 'res.partner'

    nostr_public_key = fields.Char(string="Nostr Public Key")
=== ./odoo_custom_addons (copy)/nostr_bridge/models/nostr_event_manager.py ===
from odoo import models, fields, api
import json
import time
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.serialization import Encoding, PublicFormat
import logging

_logger = logging.getLogger(__name__)

class NostrEventManager(models.AbstractModel):
    _name = 'nostr.event.manager'
    _description = 'Nostr Event Manager'

    @api.model
    def create_event(self, content, tags, private_key):
        private_key_obj = PrivateKey.from_nsec(private_key)
        event = Event(kind=1, content=content, tags=tags)
        private_key_obj.sign_event(event)
        return event.to_json()

    @api.model
    def get_public_key(self, private_key):
        private_key_obj = ec.derive_private_key(int(private_key, 16), ec.SECP256K1())
        public_key = private_key_obj.public_key()
        return public_key.public_bytes(
            encoding=Encoding.X962,
            format=PublicFormat.UncompressedPoint
        )[1:].hex()

    @api.model
    def calculate_event_id(self, event_data):
        serialized = json.dumps([
            0,
            event_data['pubkey'],
            event_data['created_at'],
            event_data['kind'],
            event_data['tags'],
            event_data['content']
        ], separators=(',', ':'))
        return self.sha256(serialized)

    @api.model
    def sign_event(self, event_data, private_key):
        private_key_obj = ec.derive_private_key(int(private_key, 16), ec.SECP256K1())
        signature = private_key_obj.sign(
            bytes.fromhex(event_data['id']),
            ec.ECDSA(hashes.SHA256())
        )
        return signature.hex()

    @api.model
    def sha256(self, data):
        digest = hashes.Hash(hashes.SHA256())
        digest.update(data.encode())
        return digest.finalize().hex()

    @api.model
    def create_git_event(self, repo_path, commit_hash):
        repo = git.Repo(repo_path)
        commit = repo.commit(commit_hash)
        
        content = json.dumps({
            "action": "commit",
            "message": commit.message,
            "author": commit.author.name,
            "email": commit.author.email,
            "date": commit.authored_datetime.isoformat()
        })
        
        tags = [
            ["t", "commit"],
            ["h", commit_hash],
            ["n", repo.active_branch.name],
            ["m", commit.author.name],
            ["v", "1.0"],
            ["r", repo.remotes.origin.url if repo.remotes else ""],
            ["p", self.env.user.nostr_public_key],
            ["d", commit.message],
            ["s", "success"]
        ]
        
        event = self.create_event(content, tags, self.env.user.nostr_private_key)
        self.publish_event(event)
        return event

    def sync_with_decentralized_manager(self, event):
        sync_managers = self.env['decentralized.sync.manager'].search([])
        for manager in sync_managers:
            program = self.env['decentralized.sync.program'].search([
                ('manager_id', '=', manager.id),
                ('content', '=', event['content'])
            ], limit=1)

            if not program:
                program = self.env['decentralized.sync.program'].create({
                    'manager_id': manager.id,
                    'creator_id': self.env['decentralized.sync.creator'].search([], limit=1).id,
                    'content': event['content'],
                    'version': 1,
                    'size': 0.5  # Arbitrary size
                })

            manager.propagate_update(program)

    @api.model
    def publish_event(self, event):
        sync_managers = self.env['decentralized.sync.manager'].search([])
        for manager in sync_managers:
            manager.publish_event(event['content'], event['tags'])
        return True

    @api.model
    def get_events(self, filters=None):
        nostr_adapter = self.env['nostr.adapter']
        return nostr_adapter.get_events(filters)
=== ./odoo_custom_addons (copy)/nostr_bridge/models/ivcs_item.py ===
# File: odoo_custom_addons/nostr_bridge/models/ivcs_item.py

from odoo import models, fields, api, _
from odoo.exceptions import UserError
import git
import os
import logging
from nostr.key import PrivateKey

_logger = logging.getLogger(__name__)

class IVCSItem(models.Model):
    _inherit = 'ivcs.item'

    nostr_private_key = fields.Char(string="Nostr Private Key")

    def _create_nostr_event_and_publish(self, commit):
        if not self.nostr_private_key:
            self.nostr_private_key = PrivateKey().hex()
            self.sudo().write({'nostr_private_key': self.nostr_private_key})

        private_key = PrivateKey(bytes.fromhex(self.nostr_private_key))
        nostr_manager = self.env['nostr.event.manager']
        event = nostr_manager.create_git_event(commit, private_key)

        relay_urls = self.env['ir.config_parameter'].sudo().get_param('nostr_bridge.relay_urls', '').split(',')
        for relay_url in relay_urls:
            if relay_url.strip():
                success = nostr_manager.publish_event_sync(event, relay_url.strip())
                if success:
                    _logger.info(f"Successfully published event to {relay_url}")
                else:
                    _logger.warning(f"Failed to publish event to {relay_url}")

    def sync_repository(self):
        result = super(IVCSItem, self).sync_repository()
        if result.get('type') == 'ir.actions.client' and result['params']['type'] == 'success':
            repo = git.Repo(self.repo_path)
            latest_commit = repo.head.commit
            self._create_nostr_event_and_publish(latest_commit)
        return result

    def create_file(self, filename, content):
        result = super(IVCSItem, self).create_file(filename, content)
        if result.get('type') == 'ir.actions.client' and result['params']['type'] == 'success':
            repo = git.Repo(self.repo_path)
            latest_commit = repo.head.commit
            self._create_nostr_event_and_publish(latest_commit)
        return result

    @api.model
    def create(self, vals):
        item = super(IVCSItem, self).create(vals)
        repo = git.Repo(item.repo_path)
        initial_commit = repo.head.commit
        item._create_nostr_event_and_publish(initial_commit)
        return item
=== ./odoo_custom_addons (copy)/nostr_bridge/__init__.py ===
from . import models
from . import controllers
=== ./odoo_custom_addons (copy)/nostr_bridge/__manifest__.py ===
# File: odoo_custom_addons/nostr_bridge/__manifest__.py

{
    'name': 'Nostr Bridge',
    'version': '1.0',
    'category': 'Social',
    'summary': 'Bridge between Odoo messages, Git, and Nostr network',
    'depends': ['base', 'mail', 'web'],
    'data': [
        'views/res_config_settings_views.xml',
        'views/res_users_views.xml',
        'views/res_partner_views.xml',
        'views/git_repository_views.xml',
        'security/ir.model.access.csv',
    ],
    'installable': True,
    'application': False,
    'auto_install': False,
    'license': 'LGPL-3',
    'external_dependencies': {
        'python': ['cryptography', 'gitpython', 'nostr'],
    },
}
=== ./odoo_custom_addons (copy)/nostr_bridge/static/src/js/nostr_client.js ===
odoo.define('nostr_bridge.NostrClient', function (require) {
    "use strict";

    var Class = require('web.Class');

    var NostrClient = Class.extend({
        init: function (relayUrls) {
            this.relayUrls = relayUrls;
            this.relayPool = new NostrTools.RelayPool(this.relayUrls);
        },

        subscribe: function (filters, callback) {
            this.relayPool.subscribe(filters, callback);
        },

        publish: function (event) {
            this.relayPool.publish(event);
        }
    });

    return NostrClient;
});
=== ./odoo_custom_addons (copy)/nostr_bridge/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_git_repository_user,git.repository.user,model_git_repository,base.group_user,1,1,1,1
=== ./odoo_custom_addons (copy)/nostr_bridge/data/ir_cron_data.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <record id="ir_cron_migrate_messages_to_nostr" model="ir.cron">
            <field name="name">Migrate Messages to Nostr</field>
            <field name="model_id" ref="model_mail_message"/>
            <field name="state">code</field>
            <field name="code">model.migrate_messages_to_nostr()</field>
            <field name="interval_number">1</field>
            <field name="interval_type">days</field>
            <field name="numbercall">1</field>
            <field name="doall" eval="False"/>
        </record>
    </data>
</odoo>
=== ./odoo_custom_addons (copy)/nostr_bridge/views/res_users_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_users_form_nostr" model="ir.ui.view">
        <field name="name">res.users.form.nostr</field>
        <field name="model">res.users</field>
        <field name="inherit_id" ref="base.view_users_form"/>
        <field name="arch" type="xml">
            <xpath expr="//notebook" position="inside">
                <page string="Nostr Settings" name="nostr_settings">
                    <group>
                        <field name="nostr_public_key"/>
                        <field name="nostr_private_key" password="True"/>
                        <field name="nostr_relay_url"/>
                    </group>
                </page>
            </xpath>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/nostr_bridge/views/res_partner_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_partner_form_nostr" model="ir.ui.view">
        <field name="name">res.partner.form.nostr</field>
        <field name="model">res.partner</field>
        <field name="inherit_id" ref="base.view_partner_form"/>
        <field name="arch" type="xml">
            <xpath expr="//notebook" position="inside">
                <page string="Nostr Settings" name="nostr_settings">
                    <group>
                        <field name="nostr_public_key"/>
                    </group>
                </page>
            </xpath>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/nostr_bridge/views/res_config_settings_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="res_config_settings_view_form_nostr" model="ir.ui.view">
        <field name="name">res.config.settings.view.form.inherit.nostr</field>
        <field name="model">res.config.settings</field>
        <field name="inherit_id" ref="base.res_config_settings_view_form"/>
        <field name="arch" type="xml">
            <xpath expr="//div[hasclass('settings')]" position="inside">
                <div class="app_settings_block" data-string="Nostr Bridge" string="Nostr Bridge" data-key="nostr_bridge">
                    <h2>Nostr Settings</h2>
                    <div class="row mt16 o_settings_container">
                        <div class="col-12 col-lg-6 o_setting_box">
                            <div class="o_setting_left_pane"/>
                            <div class="o_setting_right_pane">
                                <span class="o_form_label">Nostr Relay URLs</span>
                                <div class="text-muted">
                                    Comma-separated list of Nostr relay URLs
                                </div>
                                <div class="content-group">
                                    <div class="mt16">
                                        <field name="nostr_relay_urls" class="o_light_label"/>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </xpath>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/nostr_bridge/views/templates.xml ===
<odoo>
    <template id="assets_backend" name="nostr_bridge assets" inherit_id="web.assets_backend">
        <xpath expr="." position="inside">
            <script type="text/javascript" src="/nostr_bridge/static/src/js/nostr_client.js"/>
        </xpath>
    </template>
</odoo>
=== ./odoo_custom_addons (copy)/nostr_bridge/views/git_repository_views.xml ===
<!-- File: odoo_custom_addons/nostr_bridge/views/git_repository_views.xml -->

<odoo>
    <record id="view_git_repository_form" model="ir.ui.view">
        <field name="name">git.repository.form</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="path"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="action_git_repository" model="ir.actions.act_window">
        <field name="name">Git Repositories</field>
        <field name="res_model">git.repository</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_git_repository" name="Git Repositories" action="action_git_repository" parent="base.menu_custom"/>
</odoo>
=== ./odoo_custom_addons (copy)/nostr_bridge/controllers/__init__.py ===
from . import main
=== ./odoo_custom_addons (copy)/nostr_bridge/controllers/main.py ===
from odoo import http
from odoo.http import request
import json
from nostr.event import Event
from nostr.key import PrivateKey

class NostrController(http.Controller):

    @http.route('/nostr/authenticate', type='json', auth='public')
    def authenticate(self, public_key, signature, message):
        User = request.env['res.users'].sudo()
        user_id = User.authenticate_nostr(public_key, signature, message)
        if user_id:
            request.session.authenticate(request.db, user_id, public_key)
            return {'success': True, 'uid': user_id}
        return {'success': False, 'error': 'Authentication failed'}

    @http.route('/nostr/publish', type='json', auth='user')
    def publish_event(self, event_data):
        nostr_adapter = request.env['nostr.adapter'].sudo().get_adapter()
        try:
            nostr_adapter.publish_event(event_data)
            return {'success': True}
        except Exception as e:
            return {'success': False, 'error': str(e)}

    @http.route('/nostr/subscribe', type='json', auth='user')
    def subscribe_to_events(self, filters):
        nostr_adapter = request.env['nostr.adapter'].sudo().get_adapter()
        try:
            def callback(event):
                # Process the event, e.g., create a message in Odoo
                request.env['nostr.event.handler'].sudo().handle_event(event)

            nostr_adapter.subscribe_to_events(filters, callback)
            return {'success': True}
        except Exception as e:
            return {'success': False, 'error': str(e)}

    @http.route('/nostr/get_public_key', type='json', auth='user')
    def get_public_key(self):
        user = request.env.user
        return {'public_key': user.nostr_public_key}

    @http.route('/nostr/create_event', type='json', auth='user')
    def create_event(self, kind, content, tags=None):
        user = request.env.user
        private_key = PrivateKey.from_nsec(user.nostr_private_key)
        event = Event(kind=kind, content=json.dumps(content), tags=tags or [])
        event.sign(private_key.hex())
        return {
            'id': event.id,
            'pubkey': event.public_key,
            'created_at': event.created_at,
            'kind': event.kind,
            'tags': event.tags,
            'content': event.content,
            'sig': event.signature,
        }
=== ./odoo_custom_addons (copy)/decentralized_sync/models/supporting_models.py ===
from odoo import models, fields, api

class DAO(models.Model):
    _name = 'decentralized.sync.dao'
    _description = 'DAO'

    manager_id = fields.Many2one('decentralized.sync.manager', string='Sync Manager')
    tier = fields.Selection([('primary', 'Primary'), ('secondary', 'Secondary'), ('tertiary', 'Tertiary')], string='Tier')
    location_lat = fields.Float(string='Latitude')
    location_lon = fields.Float(string='Longitude')
    storage_capacity = fields.Float(string='Storage Capacity')
    network_speed = fields.Float(string='Network Speed')
    local_state = fields.Text(string='Local State')

class Creator(models.Model):
    _name = 'decentralized.sync.creator'
    _description = 'Creator'

    manager_id = fields.Many2one('decentralized.sync.manager', string='Sync Manager')
    location_lat = fields.Float(string='Latitude')
    location_lon = fields.Float(string='Longitude')
    productivity = fields.Float(string='Productivity')
    dao_id = fields.Many2one('decentralized.sync.dao', string='Associated DAO')

class Program(models.Model):
    _name = 'decentralized.sync.program'
    _description = 'Program'

    manager_id = fields.Many2one('decentralized.sync.manager', string='Sync Manager')
    creator_id = fields.Many2one('decentralized.sync.creator', string='Creator')
    size = fields.Float(string='Size')
    version = fields.Integer(string='Version')
    content = fields.Text(string='Content')
    host_ids = fields.Many2many('decentralized.sync.dao', string='Hosts')

class Event(models.Model):
    _name = 'decentralized.sync.event'
    _description = 'Sync Event'

    manager_id = fields.Many2one('decentralized.sync.manager', string='Sync Manager')
    description = fields.Text(string='Event Description')
    timestamp = fields.Datetime(string='Timestamp', default=fields.Datetime.now)

class Connection(models.Model):
    _name = 'decentralized.sync.connection'
    _description = 'Connection between Creator and DAO'

    manager_id = fields.Many2one('decentralized.sync.manager', string='Sync Manager')
    creator_id = fields.Many2one('decentralized.sync.creator', string='Creator')
    dao_id = fields.Many2one('decentralized.sync.dao', string='DAO')
=== ./odoo_custom_addons (copy)/decentralized_sync/models/sync_manager.py ===
from odoo import models, fields, api
import logging
from nostr.key import PrivateKey
from nostr.event import Event
from nostr.relay_manager import RelayManager
import git
import os

_logger = logging.getLogger(__name__)

class DecentralizedNostrSyncManager(models.Model):
    _name = 'decentralized.sync.manager'
    _description = 'Decentralized Nostr Sync Manager'

    name = fields.Char(string='Name', required=True)
    relay_urls = fields.Text(string='Relay URLs', required=True)
    private_key = fields.Char(string='Private Key')
    public_key = fields.Char(string='Public Key', compute='_compute_public_key')

    @api.depends('private_key')
    def _compute_public_key(self):
        for record in self:
            if record.private_key:
                private_key = PrivateKey.from_nsec(record.private_key)
                record.public_key = private_key.public_key.bech32()
            else:
                record.public_key = False

    def initialize_nostr(self):
        if not self.private_key:
            private_key = PrivateKey()
            self.private_key = private_key.bech32()
        
        self.relay_manager = RelayManager()
        for url in self.relay_urls.split(','):
            self.relay_manager.add_relay(url.strip())
        self.relay_manager.open_connections()

    def publish_event(self, content, tags=None):
        if not hasattr(self, 'relay_manager'):
            self.initialize_nostr()

        private_key = PrivateKey.from_nsec(self.private_key)
        event = Event(content=content, tags=tags or [])
        private_key.sign_event(event)
        
        self.relay_manager.publish_event(event)
        return event

    def sync_git_repository(self, repo_path):
        repo = git.Repo(repo_path)
        if not repo.remotes:
            raise ValueError('No remote repository configured')

        origin = repo.remotes.origin
        origin.fetch()
        
        current_branch = repo.active_branch
        if f'origin/{current_branch.name}' not in repo.refs:
            origin.push(current_branch)
        else:
            origin.pull(current_branch)

        for commit in repo.iter_commits(f'{current_branch.name}@{{u}}..{current_branch.name}'):
            self.publish_event(
                content=f"New commit: {commit.hexsha}",
                tags=[['c', commit.hexsha], ['t', 'git_commit']]
            )

    @api.model
    def create(self, vals):
        manager = super(DecentralizedNostrSyncManager, self).create(vals)
        manager.initialize_nostr()
        return manager

    def write(self, vals):
        result = super(DecentralizedNostrSyncManager, self).write(vals)
        if 'relay_urls' in vals:
            self.initialize_nostr()
        return result
=== ./odoo_custom_addons (copy)/decentralized_sync/__init__.py ===
from . import models
from . import controllers
=== ./odoo_custom_addons (copy)/decentralized_sync/__manifest__.py ===
{
    'name': 'Decentralized Nostr Sync Manager',
    'version': '1.0',
    'category': 'Tools',
    'summary': 'Manage decentralized synchronization with Nostr and Git',
    'depends': ['base', 'ivcs_git', 'nostr_bridge'],
    'data': [
        'security/ir.model.access.csv',
        'views/sync_manager_views.xml',
        'views/dao_views.xml',
        'views/creator_views.xml',
        'views/program_views.xml',
        'views/event_views.xml',
        'views/menu_items.xml',
    ],
    'installable': True,
    'application': False,
    'auto_install': False,
}
=== ./odoo_custom_addons (copy)/decentralized_sync/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_decentralized_sync_manager_user,decentralized.sync.manager user,model_decentralized_sync_manager,base.group_user,1,1,1,1
access_decentralized_sync_dao_user,decentralized.sync.dao user,model_decentralized_sync_dao,base.group_user,1,1,1,1
access_decentralized_sync_creator_user,decentralized.sync.creator user,model_decentralized_sync_creator,base.group_user,1,1,1,1
access_decentralized_sync_program_user,decentralized.sync.program user,model_decentralized_sync_program,base.group_user,1,1,1,1
access_decentralized_sync_event_user,decentralized.sync.event user,model_decentralized_sync_event,base.group_user,1,1,1,1
access_decentralized_sync_connection_user,decentralized.sync.connection user,model_decentralized_sync_connection,base.group_user,1,1,1,1
=== ./odoo_custom_addons (copy)/decentralized_sync/controllers/main.py ===
from odoo import http
from odoo.http import request
from nostr.event import Event
import json

class DecentralizedSyncController(http.Controller):

    @http.route('/api/decentralized_sync/publish', type='json', auth='user')
    def publish_event(self, manager_id, content, tags=None):
        manager = request.env['decentralized.sync.manager'].browse(int(manager_id))
        event = manager.publish_event(content, tags)
        return {'status': 'success', 'event_id': event.id}

    @http.route('/api/decentralized_sync/sync_repo', type='json', auth='user')
    def sync_repository(self, manager_id, repo_path):
        manager = request.env['decentralized.sync.manager'].browse(int(manager_id))
        manager.sync_git_repository(repo_path)
        return {'status': 'success', 'message': 'Repository synced and events published'}

    @http.route('/api/decentralized_sync/events', type='json', auth='user')
    def get_events(self, manager_id):
        manager = request.env['decentralized.sync.manager'].browse(int(manager_id))
        # This would typically fetch events from Nostr relays
        # For now, we'll return an empty list
        return {'events': []}
=== ./odoo_custom_addons (copy)/nostr_auth_test/nostr_auth_module.py ===
import os
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import hashes
from odoo import models, fields, api
from odoo.exceptions import ValidationError
import base64

class NostrAuthModule(models.AbstractModel):
    _name = 'nostr.auth'
    _description = 'Nostr Authentication Module'

    @api.model
    def generate_keypair(self):
        """
        Generate a new Nostr keypair.
        This represents the 'Cause' in our 'Causal Relationship'.
        """
        private_key = ec.generate_private_key(ec.SECP256K1())
        public_key = private_key.public_key()
        
        private_bytes = private_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=serialization.NoEncryption()
        )
        public_bytes = public_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        )
        
        return {
            'private_key': base64.b64encode(private_bytes).decode('utf-8'),
            'public_key': base64.b64encode(public_bytes).decode('utf-8')
        }

    @api.model
    def store_keys(self, user_id, public_key, private_key):
        """
        Store the Nostr keys for a user.
        This action creates an 'Effect' in our 'Causal Relationship'.
        """
        user = self.env['res.users'].browse(user_id)
        if not user.exists():
            raise ValidationError("User does not exist")
        
        user.write({
            'nostr_public_key': public_key,
            'nostr_private_key': private_key  # In a real-world scenario, encrypt this before storage
        })

    @api.model
    def verify_signature(self, public_key, message, signature):
        """
        Verify a Nostr signature.
        This verification process is another 'Effect' in our 'Causal Relationship'.
        """
        try:
            public_key_obj = serialization.load_pem_public_key(base64.b64decode(public_key))
            signature_bytes = base64.b64decode(signature)
            public_key_obj.verify(
                signature_bytes,
                message.encode('utf-8'),
                ec.ECDSA(hashes.SHA256())
            )
            return True
        except:
            return False

    @api.model
    def authenticate_nostr(self, public_key, signature, message):
        """
        Authenticate a user using Nostr.
        This method embodies the complete 'Causal Relationship':
        The provided credentials (Cause) lead to authentication success or failure (Effect).
        """
        user = self.env['res.users'].search([('nostr_public_key', '=', public_key)], limit=1)
        if user and self.verify_signature(user.nostr_public_key, message, signature):
            return user.id
        return False

# For console testing
if __name__ == "__main__":
    # Simulate Odoo environment
    class MockEnv:
        def __init__(self):
            self.users = {}
        
        def __getitem__(self, key):
            return self
        
        def search(self, domain, limit=None):
            for user_id, user in self.users.items():
                if user['nostr_public_key'] == domain[0][2]:
                    return [MockUser(user_id, user)]
            return []
    
    class MockUser:
        def __init__(self, id, data):
            self.id = id
            self.__dict__.update(data)
        
        def exists(self):
            return True
        
        def write(self, vals):
            self.__dict__.update(vals)

    mock_env = MockEnv()
    
    # Create an instance of NostrAuthModule
    nostr_auth = NostrAuthModule()
    nostr_auth.env = mock_env

    # Test key generation
    print("Generating keypair...")
    keys = nostr_auth.generate_keypair()
    print(f"Public Key: {keys['public_key'][:32]}...")
    print(f"Private Key: {keys['private_key'][:32]}...")

    # Test key storage
    print("\nStoring keys...")
    mock_env.users[1] = {'name': 'Test User'}
    try:
        nostr_auth.store_keys(1, keys['public_key'], keys['private_key'])
        print("Keys stored successfully")
    except Exception as e:
        print(f"Error storing keys: {str(e)}")

    # Test signature verification
    print("\nTesting signature verification...")
    message = "Test message"
    private_key = serialization.load_pem_private_key(base64.b64decode(keys['private_key']), password=None)
    signature = base64.b64encode(private_key.sign(
        message.encode('utf-8'),
        ec.ECDSA(hashes.SHA256())
    )).decode('utf-8')
    
    is_valid = nostr_auth.verify_signature(keys['public_key'], message, signature)
    print(f"Signature valid: {is_valid}")

    # Test authentication
    print("\nTesting authentication...")
    user_id = nostr_auth.authenticate_nostr(keys['public_key'], signature, message)
    print(f"Authenticated user ID: {user_id}")

    print("\nAll tests completed.")
=== ./odoo_custom_addons (copy)/allfiles.txt ===
Home dir: ~/oldhome/home/impromise/Downloads/Telegram Desktop/nostr-w-relay-main (2)/nostr-w-relay-main (1)/src/views/components/login/odoo-nostr-project/odoo_custom_addons/

=== ./git_repository_anchor/models/git_repository.py ===
from odoo import models, fields, api, _
from odoo.exceptions import UserError
import git
import os
import logging

_logger = logging.getLogger(__name__)

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'
    _inherit = ['mail.thread', 'mail.activity.mixin']

    name = fields.Char(string='Repository Name', required=True)
    path = fields.Char(string='Repository Path', required=True)
    description = fields.Text(string='Description', tracking=True)
    maintainer_ids = fields.Many2many('res.users', string='Maintainers')
    anchor_event_id = fields.Many2one('nostr.event', string='Anchor Event')
    #company_id = fields.Many2one('res.company', string='Company', required=True, default=lambda self: self.env.company)

    @api.model
    def create(self, vals):
        repo = super(GitRepository, self).create(vals)
        repo._initialize_repository()
        return repo

    def _initialize_repository(self):
        if not os.path.exists(self.path):
            os.makedirs(self.path)
            git.Repo.init(self.path)
            readme_path = os.path.join(self.path, 'README.md')
            with open(readme_path, 'w') as f:
                f.write(f"# {self.name}\n\n{self.description or ''}")
            repo = git.Repo(self.path)
            repo.index.add(['README.md'])
            repo.index.commit("Initial commit")

    def _create_anchor_event(self):
        anchor = self.env['git.repository.anchor']
        event = anchor.create_anchor_event(self.path, self.maintainer_ids.mapped('nostr_public_key'))
        self.env['nostr.event'].create_and_publish(event)
        self.anchor_event_id = self.env['nostr.event'].search([('event_id', '=', event.id)], limit=1).id

    def update_maintainers(self):
        anchor = self.env['git.repository.anchor']
        event = anchor.update_anchor(self.path, self.maintainer_ids.mapped('nostr_public_key'))
        self.env['nostr.event'].create_and_publish(event)
        self.anchor_event_id = self.env['nostr.event'].search([('event_id', '=', event.id)], limit=1).id

    def fork_repository(self, new_name, new_path, new_maintainer_ids):
        anchor = self.env['git.repository.anchor']
        new_maintainers = self.env['res.users'].browse(new_maintainer_ids).mapped('nostr_public_key')
        event = anchor.fork_repository(self.path, new_path, new_maintainers)
        self.env['nostr.event'].create_and_publish(event)
        
        new_repo = self.create({
            'name': new_name,
            'path': new_path,
            'maintainer_ids': [(6, 0, new_maintainer_ids)],
        })
        new_repo.anchor_event_id = self.env['nostr.event'].search([('event_id', '=', event.id)], limit=1).id
        
        # Clone the repository
        git.Repo.clone_from(self.path, new_path)
        
        return new_repo

    def check_permission(self, user_id):
        user = self.env['res.users'].browse(user_id)
        anchor = self.env['git.repository.anchor']
        return anchor.check_permission(self.anchor_event_id, user.nostr_public_key)
=== ./git_repository_anchor/models/__init__.py ===
from . import repository_anchor
from . import branch_manager
from . import odoo_models
from . import git_repository
from . import nostr_event
=== ./git_repository_anchor/models/repository_anchor.py ===
from odoo import models, fields, api, _
from odoo.exceptions import UserError
from nostr.event import Event
from nostr.key import PrivateKey
import json
import os
import logging
import time
from functools import wraps  # Add this import

_logger = logging.getLogger(__name__)

def log_execution_time(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        _logger.info(f"{func.__name__} executed in {end_time - start_time:.2f} seconds")
        return result
    return wrapper

class RepositoryAnchor(models.AbstractModel):
    _name = 'git.repository.anchor'
    _description = 'Git Repository Anchor'

    @api.model
    def _get_private_key(self):
        # In practice, you'd retrieve this securely
        return PrivateKey()

    @log_execution_time
    def create_anchor_event(self, repo_path, maintainers):
        _logger.info(f"Creating anchor event for repository: {repo_path}")
        start_time = time.time()

        private_key = self._get_private_key()
        content = json.dumps({
            "action": "create_repository",
            "repo_name": os.path.basename(repo_path),
            "maintainers": maintainers
        })
        event = Event(
            kind=31228,
            content=content,
            tags=[['r', repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)

        end_time = time.time()
        _logger.info(f"Anchor event created in {end_time - start_time:.2f} seconds")
        return event

    def update_anchor(self, repo_path, maintainers):
        _logger.info(f"Updating anchor for repository: {repo_path}")
        start_time = time.time()

        private_key = self._get_private_key()
        content = json.dumps({
            "action": "update_repository",
            "repo_name": os.path.basename(repo_path),
            "maintainers": maintainers
        })
        event = Event(
            kind=31228,
            content=content,
            tags=[['r', repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)

        end_time = time.time()
        _logger.info(f"Anchor updated in {end_time - start_time:.2f} seconds")
        return event

    def resolve_repository_state(self, anchor_event):
        _logger.info("Resolving repository state from anchor event")
        start_time = time.time()

        try:
            content = json.loads(anchor_event.content)
            state = {
                "repo_name": content["repo_name"],
                "maintainers": content["maintainers"]
            }
        except json.JSONDecodeError as e:
            _logger.error(f"Error decoding anchor event content: {str(e)}")
            raise UserError(_("Invalid anchor event content"))
        except KeyError as e:
            _logger.error(f"Missing key in anchor event content: {str(e)}")
            raise UserError(_("Incomplete anchor event content"))

        end_time = time.time()
        _logger.info(f"Repository state resolved in {end_time - start_time:.2f} seconds")
        return state

    def list_maintainers(self, anchor_event):
        _logger.info("Listing maintainers from anchor event")
        start_time = time.time()

        try:
            content = json.loads(anchor_event.content)
            maintainers = content["maintainers"]
        except json.JSONDecodeError as e:
            _logger.error(f"Error decoding anchor event content: {str(e)}")
            raise UserError(_("Invalid anchor event content"))
        except KeyError:
            _logger.error("Maintainers key not found in anchor event content")
            raise UserError(_("Incomplete anchor event content"))

        end_time = time.time()
        _logger.info(f"Maintainers listed in {end_time - start_time:.2f} seconds")
        return maintainers

    def check_permission(self, anchor_event, public_key):
        _logger.info(f"Checking permission for public key: {public_key}")
        start_time = time.time()

        maintainers = self.list_maintainers(anchor_event)
        has_permission = public_key in maintainers

        end_time = time.time()
        _logger.info(f"Permission check completed in {end_time - start_time:.2f} seconds")
        return has_permission

    def fork_repository(self, original_repo_path, new_repo_path, new_maintainers):
        _logger.info(f"Forking repository from {original_repo_path} to {new_repo_path}")
        start_time = time.time()

        private_key = self._get_private_key()
        content = json.dumps({
            "action": "fork_repository",
            "original_repo": original_repo_path,
            "new_repo": new_repo_path,
            "maintainers": new_maintainers
        })
        event = Event(
            kind=31228,
            content=content,
            tags=[['r', new_repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)

        end_time = time.time()
        _logger.info(f"Repository forked in {end_time - start_time:.2f} seconds")
        return event
=== ./git_repository_anchor/models/nostr_event.py ===
# File: /opt/odoo/custom_addons/git_repository_anchor/models/nostr_event.py

from odoo import models, fields, api, _
from odoo.exceptions import UserError
from nostr.event import Event as NostrLibEvent
from nostr.key import PrivateKey
import json
import time
import logging

_logger = logging.getLogger(__name__)

class NostrEvent(models.Model):
    _name = 'nostr.event'
    _description = 'Nostr Event'

    name = fields.Char(string='Name', required=True)
    event_id = fields.Char(string='Event ID', readonly=True)
    kind = fields.Integer(string='Event Kind', required=True)
    content = fields.Text(string='Content')
    tags = fields.Text(string='Tags')
    public_key = fields.Char(string='Public Key', readonly=True)
    created_at = fields.Integer(string='Created At', readonly=True)
    signature = fields.Char(string='Signature', readonly=True)
    published = fields.Boolean(string='Published', default=False)
    event_type = fields.Selection([
        ('commit', 'Commit'),
        ('branch', 'Branch'),
        ('tree', 'Tree'),
        ('blob', 'Blob'),
    ], string='Event Type')
    repository_id = fields.Many2one('git.repository', string='Related Repository')

    @api.model
    def create(self, vals):
        try:
            # Generate a new private key for this event
            private_key = PrivateKey()
            public_key = private_key.public_key.hex()
            
            created_at = int(time.time())
            tags = json.loads(vals.get('tags', '[]'))
            
            event = NostrLibEvent(
                kind=vals['kind'],
                content=vals.get('content', ''),
                tags=tags,
                pub_key=public_key,
                created_at=created_at
            )
            
            # Sign the event
            private_key.sign_event(event)
            
            # Update vals with generated data
            vals.update({
                'event_id': event.id,
                'public_key': public_key,
                'created_at': created_at,
                'signature': event.sig
            })
            
            _logger.info(f"Created Nostr event: {event.id}")
        except Exception as e:
            _logger.error(f"Error creating Nostr event: {str(e)}")
            raise UserError(_("Failed to create Nostr event: %s") % str(e))
        
        return super(NostrEvent, self).create(vals)

    @api.model
    def create_and_publish(self, event):
        vals = {
            'name': f"Event {event.id[:8]}",  # Use first 8 characters of event ID as name
            'event_id': event.id,
            'kind': event.kind,
            'content': event.content,
            'tags': json.dumps(event.tags),
            'public_key': event.public_key,
            'created_at': event.created_at,
            'signature': event.sig,
        }
        nostr_event = self.create(vals)
        # Here you would typically publish the event to Nostr relays
        # For demonstration purposes, we'll just log it
        _logger.info(f"Published Nostr event: {event.to_message()}")
        return nostr_event
=== ./git_repository_anchor/models/odoo_models.py ===
from odoo import models, fields, api
import logging

_logger = logging.getLogger(__name__)

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Repository Name', required=True)
    path = fields.Char(string='Repository Path', required=True)
    description = fields.Text(string='Description')
    maintainer_ids = fields.Many2many('res.users', string='Maintainers')
    created_at = fields.Datetime(string='Created At', default=fields.Datetime.now)
    last_updated = fields.Datetime(string='Last Updated', default=fields.Datetime.now)
    branch_ids = fields.One2many('git.branch', 'repository_id', string='Branches')

    @api.model
    def fields_get(self, allfields=None, attributes=None):
        res = super(GitRepository, self).fields_get(allfields, attributes)
        _logger.info(f"Fields in GitRepository model: {res.keys()}")
        return res

    @api.model
    def search_read(self, domain=None, fields=None, offset=0, limit=None, order=None):
        _logger.info(f"Search_read called with fields: {fields}")
        return super(GitRepository, self).search_read(domain=domain, fields=fields, offset=offset, limit=limit, order=order)

    def read(self, fields=None, load='_classic_read'):
        _logger.info(f"Read called with fields: {fields}")
        return super(GitRepository, self).read(fields=fields, load=load)

    @api.model
    def create(self, vals):
        repo = super(GitRepository, self).create(vals)
        repo._create_default_branch()
        return repo

    def _create_default_branch(self):
        self.env['git.branch'].create({
            'name': 'main',
            'repository_id': self.id,
            'head': 'initial commit',
        })

class GitBranch(models.Model):
    _name = 'git.branch'
    _description = 'Git Branch'

    name = fields.Char(string='Branch Name', required=True)
    repository_id = fields.Many2one('git.repository', string='Repository', required=True)
    head = fields.Char(string='Head Commit', required=True)

class GitEvent(models.Model):
    _name = 'git.event'
    _description = 'Git Event'

    event_type = fields.Selection([
        ('create_repository', 'Create Repository'),
        ('update_repository', 'Update Repository'),
        ('fork_repository', 'Fork Repository'),
        ('create_branch', 'Create Branch'),
        ('update_branch', 'Update Branch'),
        ('delete_branch', 'Delete Branch')
    ], string='Event Type')
    content = fields.Text(string='Event Content')
    created_at = fields.Datetime(string='Created At', default=fields.Datetime.now)

class GitRepositoryManager(models.Model):
    _name = 'git.repository.manager'
    _description = 'Git Repository Manager'

    @api.model
    def create_repository(self, name, path, description, maintainer_ids):
        anchor = self.env['git.repository.anchor']
        repo = anchor.create_repository(name, path, description, maintainer_ids)
        return repo.id

    @api.model
    def update_repository(self, repo_id, description=None, maintainer_ids=None):
        anchor = self.env['git.repository.anchor']
        repo = self.env['git.repository'].browse(repo_id)
        updated_repo = anchor.update_repository(repo, description, maintainer_ids)
        return updated_repo.id

    @api.model
    def fork_repository(self, original_repo_id, new_name, new_maintainer_id):
        anchor = self.env['git.repository.anchor']
        original_repo = self.env['git.repository'].browse(original_repo_id)
        forked_repo = anchor.fork_repository(original_repo, new_name, new_maintainer_id)
        return forked_repo.id

    @api.model
    def list_maintainers(self, repo_id):
        anchor = self.env['git.repository.anchor']
        repo = self.env['git.repository'].browse(repo_id)
        maintainers = anchor.list_maintainers(repo)
        return maintainers.ids
=== ./git_repository_anchor/models/branch_manager.py ===
from odoo import models, fields, api
from .repository_anchor import log_execution_time
from git import Repo, GitCommandError
import json
from nostr.event import Event
from nostr.key import PrivateKey
import logging

_logger = logging.getLogger(__name__)

class BranchManager(models.AbstractModel):
    _name = 'ivcs.branch.manager'
    _description = 'IVCS Branch Manager'

    name = fields.Char(string='Name', required=True)
    item_id = fields.Many2one('ivcs.item', string='IVCS Item', required=True)

    @api.model
    @log_execution_time
    def create_branch(self, repository_id, name, head):
        repo = self.env['git.repository'].browse(repository_id)
        branch = self.env['git.branch'].create({
            'name': name,
            'repository_id': repository_id,
            'head': head,
        })
        self._create_event('create_branch', branch)
        return branch.id

    @api.model
    @log_execution_time
    def update_branch(self, branch_id, new_head):
        branch = self.env['git.branch'].browse(branch_id)
        branch.write({'head': new_head})
        self._create_event('update_branch', branch)
        return branch.id

    @api.model
    @log_execution_time
    def delete_branch(self, branch_id):
        branch = self.env['git.branch'].browse(branch_id)
        self._create_event('delete_branch', branch)
        branch.unlink()
        return True

    @api.model
    def _create_event(self, event_type, branch):
        self.env['git.event'].create({
            'event_type': event_type,
            'content': f"{event_type}: {branch.name} in {branch.repository_id.name}",
        })
=== ./git_repository_anchor/__init__.py ===
from . import models
from . import controllers
=== ./git_repository_anchor/__manifest__.py ===
{
    'name': 'Git Repository Anchor',
    'version': '1.0',
    'category': 'Development',
    'summary': 'Manage Git repositories using Nostr events',
    'author': 'Your Name',
    'website': 'https://www.example.com',
    'depends': ['base', 'mail'],
    'data': [
        'security/git_repository_security.xml',
        'security/ir.model.access.csv',
        'views/git_repository_views.xml',
        'views/nostr_event_views.xml',
    ],
    'installable': True,
    'application': True,
    'auto_install': False,
    'external_dependencies': {
        'python': ['git', 'nostr'],
    },
}
=== ./git_repository_anchor/security/git_repository_security.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="module_category_git_repository" model="ir.module.category">
        <field name="name">Git Repository</field>
        <field name="description">Manage Git repositories</field>
        <field name="sequence">20</field>
    </record>

    <record id="group_git_repository_user" model="res.groups">
        <field name="name">User</field>
        <field name="category_id" ref="module_category_git_repository"/>
    </record>

    <record id="group_git_repository_manager" model="res.groups">
        <field name="name">Manager</field>
        <field name="category_id" ref="module_category_git_repository"/>
        <field name="implied_ids" eval="[(4, ref('group_git_repository_user'))]"/>
        <field name="users" eval="[(4, ref('base.user_root')), (4, ref('base.user_admin'))]"/>
    </record>
</odoo>
=== ./git_repository_anchor/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_git_repository_user,git.repository user,model_git_repository,group_git_repository_user,1,0,0,0
access_git_repository_manager,git.repository manager,model_git_repository,group_git_repository_manager,1,1,1,1
access_git_branch_user,git.branch user,model_git_branch,group_git_repository_user,1,1,1,0
access_git_branch_manager,git.branch manager,model_git_branch,group_git_repository_manager,1,1,1,1
access_git_event_user,git.event user,model_git_event,group_git_repository_user,1,0,0,0
access_git_event_manager,git.event manager,model_git_event,group_git_repository_manager,1,1,1,1
access_git_repository_manager_user,git.repository.manager user,model_git_repository_manager,group_git_repository_user,1,1,1,0
access_git_repository_manager_manager,git.repository.manager manager,model_git_repository_manager,group_git_repository_manager,1,1,1,1
access_nostr_event_user,nostr.event user,model_nostr_event,group_git_repository_user,1,0,0,0
access_nostr_event_manager,nostr.event manager,model_nostr_event,group_git_repository_manager,1,1,1,1
access_git_repository_user,git.repository user,model_git_repository,base.group_user,1,1,1,0
access_git_repository_manager,git.repository manager,model_git_repository,base.group_system,1,1,1,1
access_nostr_event_user,nostr.event user,model_nostr_event,base.group_user,1,0,0,0
access_nostr_event_manager,nostr.event manager,model_nostr_event,base.group_system,1,1,1,1
=== ./git_repository_anchor/security/oldgit_repository_security.xml.txt ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="module_category_git_repository" model="ir.module.category">
        <field name="name">Git Repository</field>
        <field name="description">Manage Git repositories</field>
        <field name="sequence">20</field>
    </record>

    <record id="group_git_repository_user" model="res.groups">
        <field name="name">User</field>
        <field name="category_id" ref="module_category_git_repository"/>
    </record>

    <record id="group_git_repository_manager" model="res.groups">
        <field name="name">Manager</field>
        <field name="category_id" ref="module_category_git_repository"/>
        <field name="implied_ids" eval="[(4, ref('group_git_repository_user'))]"/>
        <field name="users" eval="[(4, ref('base.user_root')), (4, ref('base.user_admin'))]"/>
    </record>

    <record id="git_repository_comp_rule" model="ir.rule">
        <field name="name">Git Repository multi-company</field>
        <field name="model_id" ref="model_git_repository"/>
        <field name="global" eval="True"/>
        <field name="domain_force">['|', ('company_id', '=', False), ('company_id', 'in', company_ids)]</field>
    </record>
</odoo>
=== ./git_repository_anchor/tests/test_repository_anchor.py ===
from odoo.tests.common import TransactionCase
from odoo.exceptions import AccessError

class TestRepositoryAnchor(TransactionCase):

    def setUp(self):
        super(TestRepositoryAnchor, self).setUp()
        self.repo_manager = self.env['git.repository.manager'].sudo()
        self.user_admin = self.env.ref('base.user_admin')
        self.user_demo = self.env.ref('base.user_demo')

    def test_create_repository(self):
        repo_id = self.repo_manager.create_repository(
            "test-repo", "/path/to/test-repo", "Test repository", [self.user_admin.id]
        )
        repo = self.env['git.repository'].browse(repo_id)
        self.assertEqual(repo.name, "test-repo")
        self.assertEqual(repo.path, "/path/to/test-repo")
        self.assertEqual(repo.description, "Test repository")
        self.assertIn(self.user_admin, repo.maintainer_ids)
        self.assertEqual(len(repo.branch_ids), 1)
        self.assertEqual(repo.branch_ids[0].name, 'main')

    def test_update_repository(self):
        repo_id = self.repo_manager.create_repository(
            "test-repo", "Test repository", [self.user_admin.id]
        )
        updated_repo_id = self.repo_manager.update_repository(
            repo_id, "Updated description", [self.user_admin.id, self.user_demo.id]
        )
        repo = self.env['git.repository'].browse(updated_repo_id)
        self.assertEqual(repo.description, "Updated description")
        self.assertIn(self.user_demo, repo.maintainer_ids)

    def test_fork_repository(self):
        original_repo_id = self.repo_manager.create_repository(
            "original-repo", "Original repository", [self.user_admin.id]
        )
        forked_repo_id = self.repo_manager.fork_repository(
            original_repo_id, "forked-repo", self.user_demo.id
        )
        forked_repo = self.env['git.repository'].browse(forked_repo_id)
        self.assertEqual(forked_repo.name, "forked-repo")
        self.assertIn(self.user_demo, forked_repo.maintainer_ids)
        self.assertEqual(len(forked_repo.branch_ids), 1)
        self.assertEqual(forked_repo.branch_ids[0].name, 'main')

    def test_list_maintainers(self):
        repo_id = self.repo_manager.create_repository(
            "test-repo", "Test repository", [self.user_admin.id, self.user_demo.id]
        )
        maintainer_ids = self.repo_manager.list_maintainers(repo_id)
        self.assertIn(self.user_admin.id, maintainer_ids)
        self.assertIn(self.user_demo.id, maintainer_ids)

    def test_access_rights(self):
        repo_id = self.repo_manager.create_repository(
            "test-repo", "Test repository", [self.user_admin.id]
        )
        
        # Test that non-maintainer can't update the repository
        with self.assertRaises(AccessError):
            self.repo_manager.with_user(self.user_demo).update_repository(
                repo_id, "Unauthorized update"
            )

        # Test that maintainer can update the repository
        self.repo_manager.with_user(self.user_admin).update_repository(
            repo_id, "Authorized update"
        )
        repo = self.env['git.repository'].browse(repo_id)
        self.assertEqual(repo.description, "Authorized update")
=== ./git_repository_anchor/tests/__init__.py ===
from . import test_repository_anchor
=== ./git_repository_anchor/data/README.md ===
# Git Repository Anchor

This Odoo module provides a system for managing Git repositories using Nostr events. It allows users to create, update, and fork repositories, as well as manage branches and maintainers.

## Features

- Create, update, and fork Git repositories
- Manage repository maintainers
- Create and manage branches
- Log all actions as Nostr events
- Odoo views for easy management through the UI
- CLI for standalone usage

## Installation

1. Place the `git_repository_anchor` directory in your Odoo addons path.
2. Update your Odoo apps list.
3. Install the "Git Repository Anchor" module from the Odoo Apps menu.

## Usage

### Through Odoo Interface

1. Navigate to the "Git Repositories" menu item.
2. Use the provided views to manage repositories, branches, and maintainers.

### Using CLI

A CLI script is provided for standalone usage. Example usage:

```bash
python cli_script.py create --name "New Repo" --description "A new repository" --maintainers 1 2
python cli_script.py update --repo-id 1 --description "Updated description"
python cli_script.py fork --original-repo-id 1 --new-name "Forked Repo"
=== ./git_repository_anchor/data/git_repository_data.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <!-- Example repository data -->
        <record id="git_repository_example" model="git.repository">
            <field name="name">Example Repository</field>
            <field name="path">/path/to/example-repo</field>
            <field name="description">This is an example repository created during module installation.</field>
            <field name="maintainer_ids" eval="[(4, ref('base.user_admin'))]"/>
        </record>
    </data>
</odoo>
=== ./git_repository_anchor/views/nostr_event_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_nostr_event_form" model="ir.ui.view">
        <field name="name">nostr.event.form</field>
        <field name="model">nostr.event</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="event_id" readonly="1"/>
                        <field name="kind"/>
                        <field name="content"/>
                        <field name="tags"/>
                        <field name="public_key" readonly="1"/>
                        <field name="created_at" readonly="1"/>
                        <field name="signature" readonly="1"/>
                        <field name="published"/>
                        <field name="event_type"/>
                        <field name="repository_id"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_nostr_event_tree" model="ir.ui.view">
        <field name="name">nostr.event.tree</field>
        <field name="model">nostr.event</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="event_id"/>
                <field name="kind"/>
                <field name="event_type"/>
                <field name="repository_id"/>
                <field name="public_key"/>
                <field name="created_at"/>
                <field name="published"/>
            </tree>
        </field>
    </record>

    <record id="action_nostr_event" model="ir.actions.act_window">
        <field name="name">Nostr Events</field>
        <field name="res_model">nostr.event</field>
        <field name="view_mode">tree,form</field>
    </record>

    <!-- Menu item for Nostr Events -->
    <menuitem id="menu_nostr_event"
              name="Nostr Events"
              parent="menu_git_nostr_bridge_root"
              action="action_nostr_event"
              sequence="20"/>
</odoo>
=== ./git_repository_anchor/views/git_repository_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_repository_form" model="ir.ui.view">
        <field name="name">git.repository.form</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="path"/>
                        <field name="description"/>
                    </group>
                </sheet>
                <div class="oe_chatter">
                    <field name="message_follower_ids" widget="mail_followers"/>
                    <field name="message_ids" widget="mail_thread"/>
                </div>
            </form>
        </field>
    </record>

    <record id="view_git_repository_tree" model="ir.ui.view">
        <field name="name">git.repository.tree</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="path"/>
            </tree>
        </field>
    </record>

    <record id="action_git_repository" model="ir.actions.act_window">
        <field name="name">Git Repositories</field>
        <field name="res_model">git.repository</field>
        <field name="view_mode">tree,form</field>
    </record>

    <!-- Root menu for the module -->
    <menuitem id="menu_git_nostr_bridge_root"
              name="Git Repository Anchor"
              sequence="10"/>

    <!-- Submenu for Git Repositories -->
    <menuitem id="menu_git_repository"
              name="Git Repositories"
              parent="menu_git_nostr_bridge_root"
              action="action_git_repository"
              sequence="10"/>
</odoo>
=== ./git_repository_anchor/views/repository_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data>
        <!-- Repository Form View -->
        <record id="view_git_repository_form" model="ir.ui.view">
            <field name="name">git.repository.form</field>
            <field name="model">git.repository</field>
            <field name="arch" type="xml">
                <form string="Git Repository">
                    <sheet>
                        <group>
                            <field name="name"/>
                            <field name="path"/>
                            <field name="description"/>
                            <field name="maintainer_ids" widget="many2many_tags"/>
                            <field name="created_at"/>
                            <field name="last_updated"/>
                        </group>
                        <notebook>
                            <page string="Branches">
                                <field name="branch_ids">
                                    <tree editable="bottom">
                                        <field name="name"/>
                                        <field name="head"/>
                                    </tree>
                                </field>
                            </page>
                        </notebook>
                    </sheet>
                </form>
            </field>
        </record>

        <!-- Repository Tree View -->
        <record id="view_git_repository_tree" model="ir.ui.view">
            <field name="name">git.repository.tree</field>
            <field name="model">git.repository</field>
            <field name="arch" type="xml">
                <tree string="Git Repositories">
                    <field name="name"/>
                    <field name="path"/>
                    <field name="description"/>
                    <field name="created_at"/>
                    <field name="last_updated"/>
                </tree>
            </field>
        </record>

        <!-- Repository Search View -->
        <record id="view_git_repository_search" model="ir.ui.view">
            <field name="name">git.repository.search</field>
            <field name="model">git.repository</field>
            <field name="arch" type="xml">
                <search string="Search Repositories">
                    <field name="name"/>
                    <field name="path"/>
                    <field name="description"/>
                    <field name="maintainer_ids"/>
                    <filter string="My Repositories" name="my_repositories" domain="[('maintainer_ids', 'in', uid)]"/>
                    <group expand="0" string="Group By">
                        <filter string="Created Date" name="group_by_created_at" context="{'group_by': 'created_at:month'}"/>
                    </group>
                </search>
            </field>
        </record>

        <!-- Repository Action -->
        <record id="action_git_repository" model="ir.actions.act_window">
            <field name="name">Git Repositories</field>
            <field name="res_model">git.repository</field>
            <field name="view_mode">tree,form</field>
            <field name="search_view_id" ref="view_git_repository_search"/>
        </record>

        <!-- Menu Items -->
        <menuitem id="menu_git_repository_root" name="Git Repositories" sequence="10"/>
        <menuitem id="menu_git_repository" parent="menu_git_repository_root" action="action_git_repository" sequence="10"/>
    </data>
</odoo>
=== ./git_repository_anchor/controllers/__init__.py ===
from . import main
=== ./git_repository_anchor/controllers/main.py ===
from odoo import http
from odoo.http import request

class GitRepositoryController(http.Controller):
    @http.route('/git/repository/create', type='json', auth='user')
    def create_repository(self, name, path, description, maintainer_ids):
        repo_manager = request.env['git.repository.manager'].sudo()
        repo_id = repo_manager.create_repository(name, path, description, maintainer_ids)
        return {'success': True, 'repository_id': repo_id}

    @http.route('/git/repository/update', type='json', auth='user')
    def update_repository(self, repo_id, description=None, maintainer_ids=None):
        repo_manager = request.env['git.repository.manager'].sudo()
        updated_repo_id = repo_manager.update_repository(repo_id, description, maintainer_ids)
        return {'success': True, 'repository_id': updated_repo_id}

    @http.route('/git/repository/fork', type='json', auth='user')
    def fork_repository(self, original_repo_id, new_name):
        repo_manager = request.env['git.repository.manager'].sudo()
        forked_repo_id = repo_manager.fork_repository(original_repo_id, new_name, request.env.user.id)
        return {'success': True, 'repository_id': forked_repo_id}

    @http.route('/git/repository/list_maintainers', type='json', auth='user')
    def list_maintainers(self, repo_id):
        repo_manager = request.env['git.repository.manager'].sudo()
        maintainer_ids = repo_manager.list_maintainers(repo_id)
        return {'success': True, 'maintainer_ids': maintainer_ids}
=== ./git_branch_manager/git-branch-manager-module.py ===
# Directory structure:
# git_branch_manager/
# ├── __init__.py
# ├── __manifest__.py
# ├── models/
# │   ├── __init__.py
# │   ├── branch.py
# │   ├── event.py
# │   └── branch_manager.py
# ├── controllers/
# │   ├── __init__.py
# │   └── main.py
# ├── security/
# │   └── ir.model.access.csv
# └── views/
#     ├── branch_views.xml
#     └── event_views.xml

# __init__.py
from . import models
from . import controllers

# __manifest__.py
{
    'name': 'Git Branch Manager',
    'version': '1.0',
    'summary': 'Manage Git branches using Nostr events',
    'description': """
    This module allows you to manage Git branches using Nostr events.
    It integrates with the Nostr-Odoo application to handle branch operations.
    """,
    'author': 'Your Name',
    'depends': ['base'],
    'data': [
        'security/ir.model.access.csv',
        'views/branch_views.xml',
        'views/event_views.xml',
    ],
    'installable': True,
    'application': True,
}

# models/__init__.py
from . import branch
from . import event
from . import branch_manager

# models/branch.py
from odoo import models, fields

class GitBranch(models.Model):
    _name = 'git.branch'
    _description = 'Git Branch'

    name = fields.Char(string='Branch Name', required=True)
    head = fields.Char(string='Head Commit', required=True)
    created_at = fields.Datetime(string='Created At')
    last_updated = fields.Datetime(string='Last Updated')

# models/event.py
from odoo import models, fields

class GitEvent(models.Model):
    _name = 'git.event'
    _description = 'Git Event'

    event_type = fields.Selection([('create', 'Create'), ('update', 'Update'), ('delete', 'Delete')], string='Event Type')
    content = fields.Text(string='Event Content')
    created_at = fields.Datetime(string='Created At', default=fields.Datetime.now)

# models/branch_manager.py
from odoo import models, api
from nostr.event import Event
from nostr.key import PrivateKey
import json
import logging
import time

_logger = logging.getLogger(__name__)

class GitBranchManager(models.AbstractModel):
    _name = 'git.branch.manager'
    _description = 'Git Branch Manager'

    @api.model
    def create_branch(self, name, head):
        _logger.info(f"Creating branch: {name} with head: {head}")
        start_time = time.time()

        try:
            if self.env['git.branch'].search([('name', '=', name)]):
                raise ValueError(f"Branch {name} already exists")

            branch = self.env['git.branch'].create({
                'name': name,
                'head': head,
                'created_at': fields.Datetime.now(),
                'last_updated': fields.Datetime.now(),
            })

            event = self._create_branch_event(branch, 'create')
            self._publish_event(event)

            end_time = time.time()
            _logger.info(f"Branch {name} created in {end_time - start_time:.2f} seconds")
            return True
        except Exception as e:
            _logger.exception(f"Error creating branch: {str(e)}")
            raise

    @api.model
    def update_branch(self, name, new_head):
        _logger.info(f"Updating branch: {name} to new head: {new_head}")
        start_time = time.time()

        try:
            branch = self.env['git.branch'].search([('name', '=', name)])
            if not branch:
                raise ValueError(f"Branch {name} does not exist")

            branch.write({
                'head': new_head,
                'last_updated': fields.Datetime.now(),
            })

            event = self._create_branch_event(branch, 'update')
            self._publish_event(event)

            end_time = time.time()
            _logger.info(f"Branch {name} updated in {end_time - start_time:.2f} seconds")
            return True
        except Exception as e:
            _logger.exception(f"Error updating branch: {str(e)}")
            raise

    @api.model
    def delete_branch(self, name):
        _logger.info(f"Deleting branch: {name}")
        start_time = time.time()

        try:
            branch = self.env['git.branch'].search([('name', '=', name)])
            if not branch:
                raise ValueError(f"Branch {name} does not exist")

            event = self._create_branch_event(branch, 'delete')
            branch.unlink()
            self._publish_event(event)

            end_time = time.time()
            _logger.info(f"Branch {name} deleted in {end_time - start_time:.2f} seconds")
            return True
        except Exception as e:
            _logger.exception(f"Error deleting branch: {str(e)}")
            raise

    def _create_branch_event(self, branch, operation):
        event = Event()
        event.kind = 31227  # Custom event kind for git branch operations
        event.content = json.dumps({
            'operation': operation,
            'name': branch.name,
            'head': branch.head,
            'timestamp': fields.Datetime.now().isoformat(),
        })
        event.tags = [['e', 'git_branch']]

        private_key = PrivateKey()  # In practice, securely store and retrieve this
        event.sign(private_key.hex())

        return event

    def _publish_event(self, event):
        self.env['git.event'].create({
            'event_type': json.loads(event.content)['operation'],
            'content': event.to_message(),
        })
        # Here you would also publish the event to the Nostr network
        # This part depends on how you've implemented your Nostr client in Odoo

# controllers/__init__.py
from . import main

# controllers/main.py
from odoo import http
from odoo.http import request

class GitBranchController(http.Controller):

    @http.route('/git/branch/create', type='json', auth='user')
    def create_branch(self, name, head):
        branch_manager = request.env['git.branch.manager'].sudo()
        result = branch_manager.create_branch(name, head)
        return {'success': result}

    @http.route('/git/branch/update', type='json', auth='user')
    def update_branch(self, name, new_head):
        branch_manager = request.env['git.branch.manager'].sudo()
        result = branch_manager.update_branch(name, new_head)
        return {'success': result}

    @http.route('/git/branch/delete', type='json', auth='user')
    def delete_branch(self, name):
        branch_manager = request.env['git.branch.manager'].sudo()
        result = branch_manager.delete_branch(name)
        return {'success': result}

# security/ir.model.access.csv
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_git_branch_user,access_git_branch_user,model_git_branch,,1,1,1,1
access_git_event_user,access_git_event_user,model_git_event,,1,1,1,1

# views/branch_views.xml
<?xml version="1.0" encoding="UTF-8"?>
<odoo>
    <record id="view_git_branch_form" model="ir.ui.view">
        <field name="name">git.branch.form</field>
        <field name="model">git.branch</field>
        <field name="arch" type="xml">
            <form string="Git Branch">
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="head"/>
                        <field name="created_at"/>
                        <field name="last_updated"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_git_branch_tree" model="ir.ui.view">
        <field name="name">git.branch.tree</field>
        <field name="model">git.branch</field>
        <field name="arch" type="xml">
            <tree string="Git Branches">
                <field name="name"/>
                <field name="head"/>
                <field name="created_at"/>
                <field name="last_updated"/>
            </tree>
        </field>
    </record>

    <record id="action_git_branch" model="ir.actions.act_window">
        <field name="name">Branches</field>
        <field name="res_model">git.branch</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_git_branch_root" name="Git Branches" sequence="10"/>
    <menuitem id="menu_git_branch" parent="menu_git_branch_root"
              action="action_git_branch" sequence="10"/>
</odoo>

# views/event_views.xml
<?xml version="1.0" encoding="UTF-8"?>
<odoo>
    <record id="view_git_event_form" model="ir.ui.view">
        <field name="name">git.event.form</field>
        <field name="model">git.event</field>
        <field name="arch" type="xml">
            <form string="Git Event">
                <sheet>
                    <group>
                        <field name="event_type"/>
                        <field name="content"/>
                        <field name="created_at"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_git_event_tree" model="ir.ui.view">
        <field name="name">git.event.tree</field>
        <field name="model">git.event</field>
        <field name="arch" type="xml">
            <tree string="Git Events">
                <field name="event_type"/>
                <field name="content"/>
                <field name="created_at"/>
            </tree>
        </field>
    </record>

    <record id="action_git_event" model="ir.actions.act_window">
        <field name="name">Events</field>
        <field name="res_model">git.event</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_git_events" parent="menu_git_branch_root"
              action="action_git_event" sequence="20"/>
</odoo>
=== ./nostr_auth/models/__init__.py ===
# File: odoo_custom_addons/nostr_auth/models/__init__.py
from . import res_users
from . import nostr_auth_module
=== ./nostr_auth/models/res_users.py ===
# File: odoo_custom_addons/nostr_auth/models/res_users.py

from odoo import models, fields, api
from odoo.exceptions import ValidationError
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import hashes
import base64

class ResUsers(models.Model):
    _inherit = 'res.users'

    nostr_public_key = fields.Char(string='Nostr Public Key')
    nostr_private_key = fields.Char(string='Nostr Private Key')
    nostr_relay_url = fields.Char(string='Nostr Relay URL')

    @api.model_create_multi
    def create(self, vals_list):
        nostr_auth = self.env['nostr.auth.module']
        for vals in vals_list:
            if not vals.get('nostr_private_key'):
                keys = nostr_auth.generate_keypair()
                vals['nostr_private_key'] = keys['private_key']
                vals['nostr_public_key'] = keys['public_key']
        return super(ResUsers, self).create(vals_list)

    @api.constrains('nostr_public_key')
    def _check_nostr_public_key(self):
        for user in self:
            if user.nostr_public_key:
                if not user.nostr_public_key.startswith('npub1'):
                    raise ValidationError("Invalid Nostr public key format. It should start with 'npub1'.")

    @api.model
    def authenticate_nostr(self, public_key, signature, message):
        user = self.search([('nostr_public_key', '=', public_key)], limit=1)
        if user:
            nostr_auth = self.env['nostr.auth.module']
            if nostr_auth.verify_signature(public_key, message, signature):
                return user.id
        return False
=== ./nostr_auth/models/nostr_auth_module.py ===
# File: odoo_custom_addons/nostr_auth/models/nostr_auth_module.py

from odoo import models, api
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.serialization import Encoding, PublicFormat, PrivateFormat, NoEncryption
import base64
from bech32 import bech32_encode, bech32_decode, convertbits

class NostrAuthModule(models.AbstractModel):
    _name = 'nostr.auth.module'
    _description = 'Nostr Authentication Module'

    @api.model
    def generate_keypair(self):
        private_key = ec.generate_private_key(ec.SECP256K1())
        public_key = private_key.public_key()
        
        private_bytes = private_key.private_numbers().private_value.to_bytes(32, 'big')
        public_bytes = public_key.public_bytes(
            encoding=Encoding.X962,
            format=PublicFormat.UncompressedPoint
        )[1:]
        
        return {
            'private_key': self.bytes_to_nsec(private_bytes),
            'public_key': self.bytes_to_npub(public_bytes)
        }

    @api.model
    def verify_signature(self, public_key, message, signature):
        try:
            public_key_bytes = self.npub_to_bytes(public_key)
            public_key_obj = ec.EllipticCurvePublicKey.from_encoded_point(ec.SECP256K1(), b'\x04' + public_key_bytes)
            signature_bytes = base64.b64decode(signature)
            public_key_obj.verify(
                signature_bytes,
                message.encode('utf-8'),
                ec.ECDSA(hashes.SHA256())
            )
            return True
        except:
            return False

    @api.model
    def bytes_to_npub(self, key_bytes):
        data = convertbits(key_bytes[:32], 8, 5)
        return bech32_encode('npub', data)

    @api.model
    def bytes_to_nsec(self, key_bytes):
        data = convertbits(key_bytes[:32], 8, 5)
        return bech32_encode('nsec', data)
        
    @api.model
    def npub_to_bytes(self, npub):
        hrp, data = bech32_decode(npub)
        return bytes(convertbits(data, 5, 8, False))

    @api.model
    def nsec_to_bytes(self, nsec):
        hrp, data = bech32_decode(nsec)
        return bytes(convertbits(data, 5, 8, False))
=== ./nostr_auth/__init__.py ===
from . import models
=== ./nostr_auth/__manifest__.py ===
# File: odoo_custom_addons/nostr_auth/__manifest__.py
{
    'name': 'Nostr Authentication',
    'version': '1.0',
    'category': 'Authentication',
    'summary': 'Extends user model with Nostr fields and authentication',
    'depends': ['base', 'auth_signup'],
    'data': [
        'views/res_users_views.xml',
    ],
    'installable': True,
    'application': False,
    'auto_install': False,
    'external_dependencies': {
        'python': ['cryptography', 'bech32'],
    },
}
=== ./nostr_auth/views/res_users_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_users_form_nostr" model="ir.ui.view">
        <field name="name">res.users.form.nostr</field>
        <field name="model">res.users</field>
        <field name="inherit_id" ref="base.view_users_form"/>
        <field name="arch" type="xml">
            <xpath expr="//page[@name='access_rights']" position="after">
                <page string="Nostr Authentication" name="nostr_auth">
                    <group>
                        <field name="nostr_public_key"/>
                        <field name="nostr_relay_url"/>
                    </group>
                </page>
            </xpath>
        </field>
    </record>
</odoo>
=== ./nostr_auth/controllers/__init__.py ===
from . import main
=== ./nostr_auth/controllers/main.py ===
# controllers/main.py
from odoo import http
from odoo.http import request
import json

class NostrAuthController(http.Controller):
    @http.route('/web/nostr/authenticate', type='json', auth='none')
    def authenticate(self, public_key, signature, message):
        uid = request.env['res.users'].sudo().authenticate_nostr(public_key, signature, message)
        if uid:
            request.session.authenticate(request.session.db, uid, public_key)
            return {'success': True, 'uid': uid}
        return {'success': False, 'error': 'Authentication failed'}
=== ./nostr_identity/models/__init__.py ===
# models/__init__.py
from . import nostr_identity
from . import nostr_identity_verifier
from . import nostr_message
=== ./nostr_identity/models/nostr_identity_verifier.py ===
from odoo import models, fields, api, _
from odoo.exceptions import UserError
import logging
import json
import websocket
import threading
import ssl
import time
from odoo.tools import config

_logger = logging.getLogger(__name__)

class NostrIdentityVerifier(models.Model):
    _name = 'nostr.identity.verifier'
    _description = 'Nostr Identity Verifier'

    name = fields.Char(string='Name', required=True)
    active = fields.Boolean(default=True)
    relay_url = fields.Char(string='Relay URL', required=True)
    websocket_state = fields.Selection([
        ('disconnected', 'Disconnected'),
        ('connecting', 'Connecting'),
        ('connected', 'Connected')
    ], default='disconnected', string='WebSocket State', readonly=True)
    last_error = fields.Text(string='Last Error', readonly=True)

    def _get_ws_connection(self):
        return self.env.context.get('ws_connection')

    def _set_ws_connection(self, ws):
        self = self.with_context(ws_connection=ws)

    def connect_to_relay(self):
        self.ensure_one()
        if self.websocket_state == 'connected':
            return True

        self.websocket_state = 'connecting'
        self.last_error = False

        try:
            ws = self._create_websocket(self.relay_url)
            self._set_ws_connection(ws)
            
            # Wait for connection to establish or fail
            for _ in range(20):  # Wait up to 10 seconds
                if self.websocket_state == 'connected':
                    return True
                elif self.websocket_state == 'disconnected':
                    raise UserError(self.last_error or _("Connection failed"))
                time.sleep(0.5)

            raise UserError(_("Connection timeout"))
        except Exception as e:
            self.websocket_state = 'disconnected'
            self.last_error = str(e)
            _logger.error(f"Failed to connect to {self.relay_url}: {str(e)}")
            return False

    def _create_websocket(self, relay_url):
        def on_message(ws, message):
            with self.pool.cursor() as new_cr:
                self.with_env(self.env(cr=new_cr))._handle_message(message)

        def on_error(ws, error):
            with self.pool.cursor() as new_cr:
                self.with_env(self.env(cr=new_cr))._handle_error(error)

        def on_close(ws, close_status_code, close_msg):
            with self.pool.cursor() as new_cr:
                self.with_env(self.env(cr=new_cr))._handle_close()

        def on_open(ws):
            with self.pool.cursor() as new_cr:
                self.with_env(self.env(cr=new_cr))._handle_open()

        ws = websocket.WebSocketApp(relay_url,
                                    on_message=on_message,
                                    on_error=on_error,
                                    on_close=on_close,
                                    on_open=on_open)

        wst = threading.Thread(target=lambda: ws.run_forever(sslopt={"cert_reqs": ssl.CERT_NONE}))
        wst.daemon = True
        wst.start()

        return ws

    def _handle_message(self, message):
        _logger.info(f"Received message from {self.relay_url}: {message}")
        self.env['nostr.message'].create({
            'verifier_id': self.id,
            'content': message
        })

    def _handle_error(self, error):
        _logger.error(f"WebSocket error for {self.relay_url}: {error}")
        self.write({'last_error': str(error), 'websocket_state': 'disconnected'})

    def _handle_close(self):
        _logger.info(f"WebSocket connection closed for {self.relay_url}")
        self.write({'websocket_state': 'disconnected'})

    def _handle_open(self):
        _logger.info(f"WebSocket connection opened for {self.relay_url}")
        self.write({'websocket_state': 'connected'})

    def publish_event(self, event):
        self.ensure_one()
        if self.websocket_state != 'connected':
            if not self.connect_to_relay():
                raise UserError(_("Failed to connect to relay"))

        try:
            message = json.dumps(["EVENT", event])
            ws = self._get_ws_connection()
            if ws:
                ws.send(message)
                _logger.info(f"Published event to {self.relay_url}")
                return True
            else:
                raise UserError(_("WebSocket connection is not available"))
        except Exception as e:
            _logger.error(f"Failed to publish event to {self.relay_url}: {str(e)}")
            raise UserError(_("Failed to publish event: %s") % str(e))

    @api.model
    def process_messages(self):
        messages = self.env['nostr.message'].search([('processed', '=', False)])
        for message in messages:
            try:
                # Process the message here
                _logger.info(f"Processing message: {message.content}")
                # Add your message processing logic here
                message.write({'processed': True})
            except Exception as e:
                _logger.error(f"Error processing message {message.id}: {str(e)}")

    def close_connection(self):
        self.ensure_one()
        ws = self._get_ws_connection()
        if ws:
            try:
                ws.close()
            except Exception as e:
                _logger.error(f"Error closing WebSocket for {self.relay_url}: {str(e)}")
        self._set_ws_connection(None)
        self.write({'websocket_state': 'disconnected'})
=== ./nostr_identity/models/nostr_identity.py ===
from odoo import models, fields, api, _
from odoo.exceptions import UserError, ValidationError
import base64
from cryptography.fernet import Fernet
import logging
import secrets
from nostr.key import PrivateKey
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import serialization
import bech32

_logger = logging.getLogger(__name__)

def hex_to_nostr_key(hex_key, prefix):
    # Convert hex to bytes
    data = bytes.fromhex(hex_key)
    
    # Convert to 5-bit words
    words = bech32.convertbits(data, 8, 5)
    
    # Encode with bech32
    encoded = bech32.bech32_encode(prefix, words)
    
    return encoded

class NostrIdentity(models.Model):
    _name = 'nostr.identity'
    _description = 'Nostr Identity'

    name = fields.Char(string='Name', required=True)
    public_key = fields.Char(string='Public Key (hex)', readonly=True)
    private_key = fields.Char(string='Private Key (hex)', readonly=True)
    public_key_bech32 = fields.Char(string='Public Key (npub)', readonly=True, compute='_compute_bech32_keys')
    private_key_bech32 = fields.Char(string='Private Key (nsec)', readonly=True, compute='_compute_bech32_keys')
    relay_urls = fields.Text(string='Relay URLs')
    profile_data = fields.Text(string='Profile Data')

    @api.model
    def create(self, vals):
        if 'public_key' not in vals or 'private_key' not in vals:
            try:
                private_key = PrivateKey()
                public_key = private_key.public_key
                vals['private_key'] = private_key.hex()
                vals['public_key'] = public_key.hex()
            except Exception as e:
                _logger.error(f"Failed to generate Nostr keys: {str(e)}")
                raise UserError(_("Failed to generate Nostr keys: %s") % str(e))
        return super(NostrIdentity, self).create(vals)

    @api.depends('public_key', 'private_key')
    def _compute_bech32_keys(self):
        for record in self:
            if record.public_key:
                record.public_key_bech32 = hex_to_nostr_key(record.public_key, "npub")
            else:
                record.public_key_bech32 = False
            
            if record.private_key:
                record.private_key_bech32 = hex_to_nostr_key(record.private_key, "nsec")
            else:
                record.private_key_bech32 = False

    def get_private_key(self):
        self.ensure_one()
        try:
            encryption_key = self.env['ir.config_parameter'].sudo().get_param('nostr.encryption_key')
            if not encryption_key:
                raise UserError(_("Encryption key not found. Unable to decrypt private key."))
            
            fernet = Fernet(encryption_key.encode())
            decrypted_private_key = fernet.decrypt(base64.b64decode(self.encrypted_private_key))
            return PrivateKey(bytes.fromhex(decrypted_private_key.decode()))
        except Exception as e:
            _logger.error(f"Failed to decrypt private key: {str(e)}")
            raise UserError(_("Failed to decrypt private key: %s") % str(e))

    def get_public_key_bech32(self):
        return self.public_key_bech32
=== ./nostr_identity/models/nostr_message.py ===
# models/nostr_message.py

from odoo import models, fields

class NostrMessage(models.Model):
    _name = 'nostr.message'
    _description = 'Nostr Message'

    verifier_id = fields.Many2one('nostr.identity.verifier', string='Verifier', required=True, ondelete='cascade')
    content = fields.Text(string='Message Content', required=True)
    processed = fields.Boolean(string='Processed', default=False)
=== ./nostr_identity/__init__.py ===
# nostr_identity/__init__.py

from . import models
from . import nostr_cleanup

def post_init_hook(cr, registry):
    from odoo import api, SUPERUSER_ID
    env = api.Environment(cr, SUPERUSER_ID, {})
    
    # Generate encryption key if it doesn't exist
    if not env['ir.config_parameter'].get_param('nostr.encryption_key'):
        from cryptography.fernet import Fernet
        encryption_key = Fernet.generate_key()
        env['ir.config_parameter'].set_param('nostr.encryption_key', encryption_key.decode())

def uninstall_hook(cr, registry):
    from odoo import api, SUPERUSER_ID
    env = api.Environment(cr, SUPERUSER_ID, {})
    
    # Remove the encryption key
    env['ir.config_parameter'].set_param('nostr.encryption_key', False)
    
    # Close all active WebSocket connections
    verifiers = env['nostr.identity.verifier'].search([])
    for verifier in verifiers:
        verifier.close_connection()
=== ./nostr_identity/__manifest__.py ===
# __manifest__.py
{
    'name': 'Nostr Identity Verifier',
    'version': '1.0',
    'category': 'Tools',
    'summary': 'Integrate Nostr identity verification into Odoo',
    'author': 'Your Name',
    'website': 'https://www.example.com',
    'license': 'LGPL-3',
    'depends': ['base', 'mail'],
    'data': [
        'security/nostr_security.xml',
        'security/ir.model.access.csv',
        'views/nostr_identity_views.xml',
        'data/ir_cron_data.xml',
    ],
    'demo': [],
    'external_dependencies': {
        'python': ['websocket-client', 'nostr'],
    },
    'installable': True,
    'application': False,
    'auto_install': False,
    'post_init_hook': 'post_init_hook',
    'uninstall_hook': 'uninstall_hook',
}
=== ./nostr_identity/nostr_cleanup.py ===
# nostr_identity/nostr_cleanup.py

import atexit
from odoo import api, SUPERUSER_ID

def cleanup_connections():
    try:
        with api.Environment.manage():
            env = api.Environment(odoo.registry(odoo.tools.config['db_name']).cursor(), SUPERUSER_ID, {})
            verifiers = env['nostr.identity.verifier'].search([])
            for verifier in verifiers:
                verifier.close_connection()
            env.cr.commit()
    except Exception as e:
        # Log the error, but don't raise it to avoid interfering with Odoo's shutdown process
        _logger.error(f"Error during Nostr connection cleanup: {e}")
    finally:
        if env and env.cr:
            env.cr.close()

atexit.register(cleanup_connections)
=== ./nostr_identity/security/nostr_security.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <!-- Rule: Users can only see their own Nostr Identity records -->
        <record id="rule_nostr_identity_users" model="ir.rule">
            <field name="name">Users can only see their own Nostr Identity</field>
            <field name="model_id" ref="model_nostr_identity"/>
            <field name="domain_force">[('create_uid', '=', user.id)]</field>
            <field name="groups" eval="[(4, ref('base.group_user'))]"/>
            <field name="perm_read" eval="True"/>
            <field name="perm_write" eval="False"/>
            <field name="perm_create" eval="False"/>
            <field name="perm_unlink" eval="False"/>
        </record>

        <!-- Rule: Managers can see all Nostr Identity records -->
        <record id="rule_nostr_identity_managers" model="ir.rule">
            <field name="name">Managers can see all Nostr Identity records</field>
            <field name="model_id" ref="model_nostr_identity"/>
            <field name="domain_force">[(1, '=', 1)]</field>
            <field name="groups" eval="[(4, ref('base.group_system'))]"/>
            <field name="perm_read" eval="True"/>
            <field name="perm_write" eval="True"/>
            <field name="perm_create" eval="True"/>
            <field name="perm_unlink" eval="True"/>
        </record>
    </data>
</odoo>
=== ./nostr_identity/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_nostr_identity_user,nostr.identity user,model_nostr_identity,base.group_user,1,1,1,0
access_nostr_identity_manager,nostr.identity manager,model_nostr_identity,base.group_system,1,1,1,1
access_nostr_identity_verifier_user,nostr.identity.verifier user,model_nostr_identity_verifier,base.group_user,1,0,0,0
access_nostr_identity_verifier_manager,nostr.identity.verifier manager,model_nostr_identity_verifier,base.group_system,1,1,1,1
access_nostr_message_user,nostr.message user,model_nostr_message,base.group_user,1,0,0,0
access_nostr_message_manager,nostr.message manager,model_nostr_message,base.group_system,1,1,1,1
=== ./nostr_identity/data/ir_cron_data.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <record id="ir_cron_nostr_process_messages" model="ir.cron">
            <field name="name">Nostr: Process Messages</field>
            <field name="model_id" ref="model_nostr_identity_verifier"/>
            <field name="state">code</field>
            <field name="code">model.process_messages()</field>
            <field name="interval_number">5</field>
            <field name="interval_type">minutes</field>
            <field name="numbercall">-1</field>
            <field name="doall" eval="False"/>
            <field name="active" eval="True"/>
        </record>
    </data>
</odoo>
=== ./nostr_identity/views/nostr_identity_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <!-- Nostr Identity Views -->
    <record id="view_nostr_identity_tree" model="ir.ui.view">
        <field name="name">nostr.identity.tree</field>
        <field name="model">nostr.identity</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="public_key"/>
                <field name="public_key_bech32"/>
            </tree>
        </field>
    </record>

    <record id="view_nostr_identity_form" model="ir.ui.view">
        <field name="name">nostr.identity.form</field>
        <field name="model">nostr.identity</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="public_key"/>
                        <field name="public_key_bech32"/>
                        <field name="relay_urls"/>
                        <field name="profile_data"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <!-- The rest of the XML remains unchanged -->
    <!-- Nostr Identity Verifier Views -->
    <record id="view_nostr_identity_verifier_tree" model="ir.ui.view">
        <field name="name">nostr.identity.verifier.tree</field>
        <field name="model">nostr.identity.verifier</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="relay_url"/>
                <field name="websocket_state"/>
            </tree>
        </field>
    </record>

    <record id="view_nostr_identity_verifier_form" model="ir.ui.view">
        <field name="name">nostr.identity.verifier.form</field>
        <field name="model">nostr.identity.verifier</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="connect_to_relay" string="Connect" type="object" class="oe_highlight" attrs="{'invisible': [('websocket_state', '=', 'connected')]}"/>
                    <button name="close_connection" string="Disconnect" type="object" attrs="{'invisible': [('websocket_state', '!=', 'connected')]}"/>
                </header>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="relay_url"/>
                        <field name="active"/>
                        <field name="websocket_state"/>
                        <field name="last_error"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <!-- Action Windows -->
    <record id="action_nostr_identity" model="ir.actions.act_window">
        <field name="name">Nostr Identities</field>
        <field name="res_model">nostr.identity</field>
        <field name="view_mode">tree,form</field>
    </record>

    <record id="action_nostr_identity_verifier" model="ir.actions.act_window">
        <field name="name">Nostr Identity Verifiers</field>
        <field name="res_model">nostr.identity.verifier</field>
        <field name="view_mode">tree,form</field>
    </record>

    <!-- Menu Items -->
    <menuitem id="menu_nostr_root" name="Nostr" sequence="10"/>
    <menuitem id="menu_nostr_identity" name="Identities" parent="menu_nostr_root" action="action_nostr_identity" sequence="10"/>
    <menuitem id="menu_nostr_identity_verifier" name="Verifiers" parent="menu_nostr_root" action="action_nostr_identity_verifier" sequence="20"/>
</odoo>
=== ./nostr_bridge/models/git_repository.py ===
# File: odoo_custom_addons/nostr_bridge/models/git_repository.py

from odoo import models, fields, api
import git
import os

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Repository Name', required=True)
    path = fields.Char(string='Repository Path', required=True)
    
    @api.model
    def create(self, vals):
        repo = super(GitRepository, self).create(vals)
        if not os.path.exists(repo.path):
            os.makedirs(repo.path)
            git.Repo.init(repo.path)
        return repo

    def commit_changes(self, message):
        repo = git.Repo(self.path)
        repo.git.add(A=True)
        commit = repo.index.commit(message)
        
        event_manager = self.env['nostr.event.manager']
        event = event_manager.create_git_event(self.path, commit.hexsha)
        event_manager.publish_event(event)
        
        return commit.hexsha
=== ./nostr_bridge/models/__init__.py ===
# File: odoo_custom_addons/nostr_bridge/models/__init__.py

from . import res_users
from . import mail_message
from . import nostr_adapter
from . import res_config_settings
from . import res_partner
from . import nostr_event_manager
from . import git_repository
=== ./nostr_bridge/models/res_users.py ===
"""from odoo import models, fields, api
from nostr.key import PrivateKey

class ResUsers(models.Model):
    _inherit = 'res.users'

    #nostr_private_key = fields.Char(string="Nostr Private Key")
    #nostr_public_key = fields.Char(string="Nostr Public Key", compute='_compute_public_key')
    #nostr_relay_url = fields.Char(string="Nostr Relay URL")

    nostr_public_key = fields.Char(string="Nostr Public Key")
    nostr_private_key = fields.Char(string="Nostr Private Key")
    nostr_relay_url = fields.Char(string="Nostr Relay URL")

    @api.model
    def create(self, vals):
        if not vals.get('nostr_private_key'):
            private_key = PrivateKey()
            vals['nostr_private_key'] = private_key.bech32()
        return super(ResUsers, self).create(vals)

    def write(self, vals):
        # Here you might want to handle updates to Nostr fields
        return super(ResUsers, self).write(vals)

    @api.depends('nostr_private_key')
    def _compute_public_key(self):
        for user in self:
            if user.nostr_private_key:
                private_key = PrivateKey.from_nsec(user.nostr_private_key)
                user.nostr_public_key = private_key.public_key.bech32()
            else:
                user.nostr_public_key = False
"""

"""from odoo import models, fields, api

class ResUsers(models.Model):
    _inherit = 'res.users'

    nostr_public_key = fields.Char(string="Nostr Public Key")
    nostr_private_key = fields.Char(string="Nostr Private Key")
    nostr_relay_url = fields.Char(string="Nostr Relay URL")

    @api.model
    def create(self, vals):
        # Here you might want to generate Nostr keys if they're not provided
        return super(ResUsers, self).create(vals)

    def write(self, vals):
        # Here you might want to handle updates to Nostr fields
        return super(ResUsers, self).write(vals)"""
        
        
from odoo import models, fields

class ResUsers(models.Model):
    _inherit = 'res.users'

    nostr_public_key = fields.Char(string="Nostr Public Key")
    nostr_private_key = fields.Char(string="Nostr Private Key")
    nostr_relay_url = fields.Char(string="Nostr Relay URL")
=== ./nostr_bridge/models/nostr_adapter.py ===
import requests
import websocket
from odoo import models, api
from websocket._exceptions import WebSocketConnectionClosedException
from odoo.exceptions import UserError
from nostr.event import Event
from nostr.key import PrivateKey
from nostr.relay_manager import RelayManager
import logging
import time

_logger = logging.getLogger(__name__)

class NostrAdapter(models.AbstractModel):
    _name = 'nostr.adapter'
    _description = 'Nostr Adapter'

    @api.model
    def get_relay_manager(self):
        ICPSudo = self.env['ir.config_parameter'].sudo()
        relay_urls = ICPSudo.get_param('nostr_bridge.relay_urls', '').split(',')
        if not relay_urls:
            raise UserError("Nostr relay URL is not configured. Please set it in the settings.")
        _logger.info(f"Nostr relay URLs: {relay_urls}")

        relay_manager = RelayManager()
        for url in relay_urls:
            url = url.strip()
            if url:  # Only add non-empty URLs
                _logger.info(f"Adding relay: {url}")
                relay_manager.add_relay(url)
        return relay_manager

    @api.model
    def publish_event(self, event_data, max_retries=3, retry_delay=1):
        for attempt in range(max_retries):
            try:
                private_key = PrivateKey.from_nsec(self.env.user.nostr_private_key)
                public_key = private_key.public_key.hex()
                
                event = Event(
                    kind=event_data['kind'],
                    content=event_data['content'],
                    tags=event_data.get('tags', []),
                    public_key=public_key
                )
                private_key.sign_event(event)
                
                relay_manager = self.get_relay_manager()
                relay_manager.open_connections({"write": True})
                time.sleep(1)  # Give some time for connections to establish
                
                publish_result = relay_manager.publish_event(event)
                _logger.info(f"Relay publish response: {publish_result}")
    
                relay_manager.close_connections()
                return True
            except Exception as e:
                _logger.exception(f"Error publishing event to Nostr: {str(e)}")
                time.sleep(retry_delay)
        
        _logger.error("Failed to publish event after multiple attempts")
        return False
=== ./nostr_bridge/models/mail_message.py ===
from odoo import models, api
import logging

_logger = logging.getLogger(__name__)

class MailMessage(models.Model):
    _inherit = 'mail.message'

    @api.model_create_multi
    def create(self, vals_list):
        _logger.info("Creating new mail messages")
        messages = super(MailMessage, self).create(vals_list)
        for message in messages:
            self._publish_to_nostr(message)
        return messages

    def _publish_to_nostr(self, message):
        try:
            nostr_adapter = self.env['nostr.adapter'].sudo()
            event_data = {
                'kind': 1,  # Text note
                'content': message.body,
                'tags': [
                    ['e', str(message.parent_id.id)] if message.parent_id else [],
                    ['p', message.author_id.nostr_public_key] if message.author_id and message.author_id.nostr_public_key else [],
                    ['client', 'Odoo Nostr Bridge'],
                ],
            }
            result = nostr_adapter.publish_event(event_data)
            if result:
                _logger.info(f"Successfully published message {message.id} to Nostr")
            else:
                _logger.warning(f"Failed to publish message {message.id} to Nostr")
        except Exception as e:
            _logger.exception(f"Error publishing message {message.id} to Nostr: {str(e)}")
=== ./nostr_bridge/models/nostr_event_handler.py ===
import json
from odoo import api, models

class NostrEventHandler(models.AbstractModel):
    _name = 'nostr.event.handler'
    _description = 'Nostr Event Handler'

    @api.model
    def handle_event(self, event):
        content = json.loads(event.content)
        if event.kind == 1:  # Text note
            self._handle_message(content)
        elif event.kind == 7:  # Reaction
            self._handle_reaction(content)

    def _handle_message(self, content):
        self.env['mail.message'].create({
            'body': content['body'],
            'author_id': self._get_author_id(content['author']),
            'model': content['channel'],
            'res_id': content['res_id'],
        })

    def _handle_reaction(self, content):
        # Implement reaction handling (e.g., likes, emojis)
        pass

    def _get_author_id(self, author_name):
        partner = self.env['res.partner'].search([('name', '=', author_name)], limit=1)
        if not partner:
            partner = self.env['res.partner'].create({'name': author_name})
        return partner.id
=== ./nostr_bridge/models/res_config_settings.py ===
import requests
import json
from odoo import fields, models, api
import logging

_logger = logging.getLogger(__name__)

class ResConfigSettings(models.TransientModel):
    _inherit = 'res.config.settings'

    def _default_nostr_relays(self):
        return self._get_top_nostr_relays()

    @api.model
    def _get_top_nostr_relays(self, limit=108):
        url = "https://api.nostr.watch/v1/online"
        try:
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
            }
            response = requests.get(url, headers=headers, timeout=10)
            response.raise_for_status()
            _logger.info(f"Response status code: {response.status_code}")
            
            data = response.json()
            #_logger.info(f"API response (first 108 items): {json.dumps(data)[:1000]}")
            _logger.info(f"API response (first 108 items): {data[:108]}")
            
            relays = data[:108]
            _logger.info(f"Number of relay links found: {len(relays)}")
            _logger.info(f"Extracted relays (first 5): {relays[:5]}")
            
            relay_urls = ",".join(relays)
            return relay_urls
        except requests.RequestException as e:
            _logger.error(f"Error fetching Nostr relays: {e}")
            return "wss://nostr-relay.app,wss://nos.lol,wss://relay.snort.social,wss://relay.nostr.net"

    nostr_relay_urls = fields.Char(
        string="Nostr Relay URLs", 
        config_parameter='nostr_bridge.relay_urls',
        default=_default_nostr_relays
    )

    @api.model
    def get_values(self):
        res = super(ResConfigSettings, self).get_values()
        ICPSudo = self.env['ir.config_parameter'].sudo()
        
        relay_urls = ICPSudo.get_param('nostr_bridge.relay_urls')
        if not relay_urls:
            relay_urls = self._get_top_nostr_relays()
            ICPSudo.set_param('nostr_bridge.relay_urls', relay_urls)
            _logger.info(f"Set new relay URLs: {relay_urls[:100]}...")  # Log first 100 characters
        else:
            _logger.info(f"Using existing relay URLs: {relay_urls[:100]}...")  # Log first 100 characters
        
        res.update(nostr_relay_urls=relay_urls)
        return res

    def set_values(self):
        super(ResConfigSettings, self).set_values()
        ICPSudo = self.env['ir.config_parameter'].sudo()
        if self.nostr_relay_urls:
            ICPSudo.set_param('nostr_bridge.relay_urls', self.nostr_relay_urls)
            _logger.info(f"Updated relay URLs: {self.nostr_relay_urls[:100]}...")  # Log first 100 characters
        else:
            default_urls = self._get_top_nostr_relays()
            ICPSudo.set_param('nostr_bridge.relay_urls', default_urls)
            _logger.info(f"Set default relay URLs: {default_urls[:100]}...")  # Log first 100 characters
=== ./nostr_bridge/models/res_partner.py ===
from odoo import models, fields

class ResPartner(models.Model):
    _inherit = 'res.partner'

    nostr_public_key = fields.Char(string="Nostr Public Key")
=== ./nostr_bridge/models/nostr_event_manager.py ===
from odoo import models, fields, api
import json
import time
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.serialization import Encoding, PublicFormat
import logging

_logger = logging.getLogger(__name__)

class NostrEventManager(models.AbstractModel):
    _name = 'nostr.event.manager'
    _description = 'Nostr Event Manager'

    @api.model
    def create_event(self, content, tags, private_key):
        private_key_obj = PrivateKey.from_nsec(private_key)
        event = Event(kind=1, content=content, tags=tags)
        private_key_obj.sign_event(event)
        return event.to_json()

    @api.model
    def get_public_key(self, private_key):
        private_key_obj = ec.derive_private_key(int(private_key, 16), ec.SECP256K1())
        public_key = private_key_obj.public_key()
        return public_key.public_bytes(
            encoding=Encoding.X962,
            format=PublicFormat.UncompressedPoint
        )[1:].hex()

    @api.model
    def calculate_event_id(self, event_data):
        serialized = json.dumps([
            0,
            event_data['pubkey'],
            event_data['created_at'],
            event_data['kind'],
            event_data['tags'],
            event_data['content']
        ], separators=(',', ':'))
        return self.sha256(serialized)

    @api.model
    def sign_event(self, event_data, private_key):
        private_key_obj = ec.derive_private_key(int(private_key, 16), ec.SECP256K1())
        signature = private_key_obj.sign(
            bytes.fromhex(event_data['id']),
            ec.ECDSA(hashes.SHA256())
        )
        return signature.hex()

    @api.model
    def sha256(self, data):
        digest = hashes.Hash(hashes.SHA256())
        digest.update(data.encode())
        return digest.finalize().hex()

    @api.model
    def create_git_event(self, repo_path, commit_hash):
        repo = git.Repo(repo_path)
        commit = repo.commit(commit_hash)
        
        content = json.dumps({
            "action": "commit",
            "message": commit.message,
            "author": commit.author.name,
            "email": commit.author.email,
            "date": commit.authored_datetime.isoformat()
        })
        
        tags = [
            ["t", "commit"],
            ["h", commit_hash],
            ["n", repo.active_branch.name],
            ["m", commit.author.name],
            ["v", "1.0"],
            ["r", repo.remotes.origin.url if repo.remotes else ""],
            ["p", self.env.user.nostr_public_key],
            ["d", commit.message],
            ["s", "success"]
        ]
        
        event = self.create_event(content, tags, self.env.user.nostr_private_key)
        self.publish_event(event)
        return event

    def sync_with_decentralized_manager(self, event):
        sync_managers = self.env['decentralized.sync.manager'].search([])
        for manager in sync_managers:
            program = self.env['decentralized.sync.program'].search([
                ('manager_id', '=', manager.id),
                ('content', '=', event['content'])
            ], limit=1)

            if not program:
                program = self.env['decentralized.sync.program'].create({
                    'manager_id': manager.id,
                    'creator_id': self.env['decentralized.sync.creator'].search([], limit=1).id,
                    'content': event['content'],
                    'version': 1,
                    'size': 0.5  # Arbitrary size
                })

            manager.propagate_update(program)

    @api.model
    def publish_event(self, event):
        sync_managers = self.env['decentralized.sync.manager'].search([])
        for manager in sync_managers:
            manager.publish_event(event['content'], event['tags'])
        return True

    @api.model
    def get_events(self, filters=None):
        nostr_adapter = self.env['nostr.adapter']
        return nostr_adapter.get_events(filters)
=== ./nostr_bridge/models/ivcs_item.py ===
# File: odoo_custom_addons/nostr_bridge/models/ivcs_item.py

from odoo import models, fields, api, _
from odoo.exceptions import UserError
import git
import os
import logging
from nostr.key import PrivateKey

_logger = logging.getLogger(__name__)

class IVCSItem(models.Model):
    _inherit = 'ivcs.item'

    nostr_private_key = fields.Char(string="Nostr Private Key")

    def _create_nostr_event_and_publish(self, commit):
        if not self.nostr_private_key:
            self.nostr_private_key = PrivateKey().hex()
            self.sudo().write({'nostr_private_key': self.nostr_private_key})

        private_key = PrivateKey(bytes.fromhex(self.nostr_private_key))
        nostr_manager = self.env['nostr.event.manager']
        event = nostr_manager.create_git_event(commit, private_key)

        relay_urls = self.env['ir.config_parameter'].sudo().get_param('nostr_bridge.relay_urls', '').split(',')
        for relay_url in relay_urls:
            if relay_url.strip():
                success = nostr_manager.publish_event_sync(event, relay_url.strip())
                if success:
                    _logger.info(f"Successfully published event to {relay_url}")
                else:
                    _logger.warning(f"Failed to publish event to {relay_url}")

    def sync_repository(self):
        result = super(IVCSItem, self).sync_repository()
        if result.get('type') == 'ir.actions.client' and result['params']['type'] == 'success':
            repo = git.Repo(self.repo_path)
            latest_commit = repo.head.commit
            self._create_nostr_event_and_publish(latest_commit)
        return result

    def create_file(self, filename, content):
        result = super(IVCSItem, self).create_file(filename, content)
        if result.get('type') == 'ir.actions.client' and result['params']['type'] == 'success':
            repo = git.Repo(self.repo_path)
            latest_commit = repo.head.commit
            self._create_nostr_event_and_publish(latest_commit)
        return result

    @api.model
    def create(self, vals):
        item = super(IVCSItem, self).create(vals)
        repo = git.Repo(item.repo_path)
        initial_commit = repo.head.commit
        item._create_nostr_event_and_publish(initial_commit)
        return item
=== ./nostr_bridge/__init__.py ===
from . import models
from . import controllers
=== ./nostr_bridge/__manifest__.py ===
# File: odoo_custom_addons/nostr_bridge/__manifest__.py

{
    'name': 'Nostr Bridge',
    'version': '1.0',
    'category': 'Social',
    'summary': 'Bridge between Odoo messages, Git, and Nostr network',
    'depends': ['base', 'mail', 'web'],
    'data': [
        'views/res_config_settings_views.xml',
        'views/res_users_views.xml',
        'views/res_partner_views.xml',
        'views/git_repository_views.xml',
        'security/ir.model.access.csv',
    ],
    'installable': True,
    'application': False,
    'auto_install': False,
    'license': 'LGPL-3',
    'external_dependencies': {
        'python': ['cryptography', 'gitpython', 'nostr'],
    },
}
=== ./nostr_bridge/static/src/js/nostr_client.js ===
odoo.define('nostr_bridge.NostrClient', function (require) {
    "use strict";

    var Class = require('web.Class');

    var NostrClient = Class.extend({
        init: function (relayUrls) {
            this.relayUrls = relayUrls;
            this.relayPool = new NostrTools.RelayPool(this.relayUrls);
        },

        subscribe: function (filters, callback) {
            this.relayPool.subscribe(filters, callback);
        },

        publish: function (event) {
            this.relayPool.publish(event);
        }
    });

    return NostrClient;
});
=== ./nostr_bridge/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_git_repository_user,git.repository.user,model_git_repository,base.group_user,1,1,1,1
=== ./nostr_bridge/data/ir_cron_data.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <record id="ir_cron_migrate_messages_to_nostr" model="ir.cron">
            <field name="name">Migrate Messages to Nostr</field>
            <field name="model_id" ref="model_mail_message"/>
            <field name="state">code</field>
            <field name="code">model.migrate_messages_to_nostr()</field>
            <field name="interval_number">1</field>
            <field name="interval_type">days</field>
            <field name="numbercall">1</field>
            <field name="doall" eval="False"/>
        </record>
    </data>
</odoo>
=== ./nostr_bridge/views/res_users_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_users_form_nostr" model="ir.ui.view">
        <field name="name">res.users.form.nostr</field>
        <field name="model">res.users</field>
        <field name="inherit_id" ref="base.view_users_form"/>
        <field name="arch" type="xml">
            <xpath expr="//notebook" position="inside">
                <page string="Nostr Settings" name="nostr_settings">
                    <group>
                        <field name="nostr_public_key"/>
                        <field name="nostr_private_key" password="True"/>
                        <field name="nostr_relay_url"/>
                    </group>
                </page>
            </xpath>
        </field>
    </record>
</odoo>
=== ./nostr_bridge/views/res_partner_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_partner_form_nostr" model="ir.ui.view">
        <field name="name">res.partner.form.nostr</field>
        <field name="model">res.partner</field>
        <field name="inherit_id" ref="base.view_partner_form"/>
        <field name="arch" type="xml">
            <xpath expr="//notebook" position="inside">
                <page string="Nostr Settings" name="nostr_settings">
                    <group>
                        <field name="nostr_public_key"/>
                    </group>
                </page>
            </xpath>
        </field>
    </record>
</odoo>
=== ./nostr_bridge/views/res_config_settings_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="res_config_settings_view_form_nostr" model="ir.ui.view">
        <field name="name">res.config.settings.view.form.inherit.nostr</field>
        <field name="model">res.config.settings</field>
        <field name="inherit_id" ref="base.res_config_settings_view_form"/>
        <field name="arch" type="xml">
            <xpath expr="//div[hasclass('settings')]" position="inside">
                <div class="app_settings_block" data-string="Nostr Bridge" string="Nostr Bridge" data-key="nostr_bridge">
                    <h2>Nostr Settings</h2>
                    <div class="row mt16 o_settings_container">
                        <div class="col-12 col-lg-6 o_setting_box">
                            <div class="o_setting_left_pane"/>
                            <div class="o_setting_right_pane">
                                <span class="o_form_label">Nostr Relay URLs</span>
                                <div class="text-muted">
                                    Comma-separated list of Nostr relay URLs
                                </div>
                                <div class="content-group">
                                    <div class="mt16">
                                        <field name="nostr_relay_urls" class="o_light_label"/>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </xpath>
        </field>
    </record>
</odoo>
=== ./nostr_bridge/views/templates.xml ===
<odoo>
    <template id="assets_backend" name="nostr_bridge assets" inherit_id="web.assets_backend">
        <xpath expr="." position="inside">
            <script type="text/javascript" src="/nostr_bridge/static/src/js/nostr_client.js"/>
        </xpath>
    </template>
</odoo>
=== ./nostr_bridge/views/git_repository_views.xml ===
<!-- File: odoo_custom_addons/nostr_bridge/views/git_repository_views.xml -->

<odoo>
    <record id="view_git_repository_form" model="ir.ui.view">
        <field name="name">git.repository.form</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="path"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="action_git_repository" model="ir.actions.act_window">
        <field name="name">Git Repositories</field>
        <field name="res_model">git.repository</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_git_repository" name="Git Repositories" action="action_git_repository" parent="base.menu_custom"/>
</odoo>
=== ./nostr_bridge/controllers/__init__.py ===
from . import main
=== ./nostr_bridge/controllers/main.py ===
from odoo import http
from odoo.http import request
import json
from nostr.event import Event
from nostr.key import PrivateKey

class NostrController(http.Controller):

    @http.route('/nostr/authenticate', type='json', auth='public')
    def authenticate(self, public_key, signature, message):
        User = request.env['res.users'].sudo()
        user_id = User.authenticate_nostr(public_key, signature, message)
        if user_id:
            request.session.authenticate(request.db, user_id, public_key)
            return {'success': True, 'uid': user_id}
        return {'success': False, 'error': 'Authentication failed'}

    @http.route('/nostr/publish', type='json', auth='user')
    def publish_event(self, event_data):
        nostr_adapter = request.env['nostr.adapter'].sudo().get_adapter()
        try:
            nostr_adapter.publish_event(event_data)
            return {'success': True}
        except Exception as e:
            return {'success': False, 'error': str(e)}

    @http.route('/nostr/subscribe', type='json', auth='user')
    def subscribe_to_events(self, filters):
        nostr_adapter = request.env['nostr.adapter'].sudo().get_adapter()
        try:
            def callback(event):
                # Process the event, e.g., create a message in Odoo
                request.env['nostr.event.handler'].sudo().handle_event(event)

            nostr_adapter.subscribe_to_events(filters, callback)
            return {'success': True}
        except Exception as e:
            return {'success': False, 'error': str(e)}

    @http.route('/nostr/get_public_key', type='json', auth='user')
    def get_public_key(self):
        user = request.env.user
        return {'public_key': user.nostr_public_key}

    @http.route('/nostr/create_event', type='json', auth='user')
    def create_event(self, kind, content, tags=None):
        user = request.env.user
        private_key = PrivateKey.from_nsec(user.nostr_private_key)
        event = Event(kind=kind, content=json.dumps(content), tags=tags or [])
        event.sign(private_key.hex())
        return {
            'id': event.id,
            'pubkey': event.public_key,
            'created_at': event.created_at,
            'kind': event.kind,
            'tags': event.tags,
            'content': event.content,
            'sig': event.signature,
        }
=== ./decentralized_sync/models/supporting_models.py ===
from odoo import models, fields, api

class DAO(models.Model):
    _name = 'decentralized.sync.dao'
    _description = 'DAO'

    manager_id = fields.Many2one('decentralized.sync.manager', string='Sync Manager')
    tier = fields.Selection([('primary', 'Primary'), ('secondary', 'Secondary'), ('tertiary', 'Tertiary')], string='Tier')
    location_lat = fields.Float(string='Latitude')
    location_lon = fields.Float(string='Longitude')
    storage_capacity = fields.Float(string='Storage Capacity')
    network_speed = fields.Float(string='Network Speed')
    local_state = fields.Text(string='Local State')

class Creator(models.Model):
    _name = 'decentralized.sync.creator'
    _description = 'Creator'

    manager_id = fields.Many2one('decentralized.sync.manager', string='Sync Manager')
    location_lat = fields.Float(string='Latitude')
    location_lon = fields.Float(string='Longitude')
    productivity = fields.Float(string='Productivity')
    dao_id = fields.Many2one('decentralized.sync.dao', string='Associated DAO')

class Program(models.Model):
    _name = 'decentralized.sync.program'
    _description = 'Program'

    manager_id = fields.Many2one('decentralized.sync.manager', string='Sync Manager')
    creator_id = fields.Many2one('decentralized.sync.creator', string='Creator')
    size = fields.Float(string='Size')
    version = fields.Integer(string='Version')
    content = fields.Text(string='Content')
    host_ids = fields.Many2many('decentralized.sync.dao', string='Hosts')

class Event(models.Model):
    _name = 'decentralized.sync.event'
    _description = 'Sync Event'

    manager_id = fields.Many2one('decentralized.sync.manager', string='Sync Manager')
    description = fields.Text(string='Event Description')
    timestamp = fields.Datetime(string='Timestamp', default=fields.Datetime.now)

class Connection(models.Model):
    _name = 'decentralized.sync.connection'
    _description = 'Connection between Creator and DAO'

    manager_id = fields.Many2one('decentralized.sync.manager', string='Sync Manager')
    creator_id = fields.Many2one('decentralized.sync.creator', string='Creator')
    dao_id = fields.Many2one('decentralized.sync.dao', string='DAO')
=== ./decentralized_sync/models/sync_manager.py ===
from odoo import models, fields, api
import logging
from nostr.key import PrivateKey
from nostr.event import Event
from nostr.relay_manager import RelayManager
import git
import os

_logger = logging.getLogger(__name__)

class DecentralizedNostrSyncManager(models.Model):
    _name = 'decentralized.sync.manager'
    _description = 'Decentralized Nostr Sync Manager'

    name = fields.Char(string='Name', required=True)
    relay_urls = fields.Text(string='Relay URLs', required=True)
    private_key = fields.Char(string='Private Key')
    public_key = fields.Char(string='Public Key', compute='_compute_public_key')

    @api.depends('private_key')
    def _compute_public_key(self):
        for record in self:
            if record.private_key:
                private_key = PrivateKey.from_nsec(record.private_key)
                record.public_key = private_key.public_key.bech32()
            else:
                record.public_key = False

    def initialize_nostr(self):
        if not self.private_key:
            private_key = PrivateKey()
            self.private_key = private_key.bech32()
        
        self.relay_manager = RelayManager()
        for url in self.relay_urls.split(','):
            self.relay_manager.add_relay(url.strip())
        self.relay_manager.open_connections()

    def publish_event(self, content, tags=None):
        if not hasattr(self, 'relay_manager'):
            self.initialize_nostr()

        private_key = PrivateKey.from_nsec(self.private_key)
        event = Event(content=content, tags=tags or [])
        private_key.sign_event(event)
        
        self.relay_manager.publish_event(event)
        return event

    def sync_git_repository(self, repo_path):
        repo = git.Repo(repo_path)
        if not repo.remotes:
            raise ValueError('No remote repository configured')

        origin = repo.remotes.origin
        origin.fetch()
        
        current_branch = repo.active_branch
        if f'origin/{current_branch.name}' not in repo.refs:
            origin.push(current_branch)
        else:
            origin.pull(current_branch)

        for commit in repo.iter_commits(f'{current_branch.name}@{{u}}..{current_branch.name}'):
            self.publish_event(
                content=f"New commit: {commit.hexsha}",
                tags=[['c', commit.hexsha], ['t', 'git_commit']]
            )

    @api.model
    def create(self, vals):
        manager = super(DecentralizedNostrSyncManager, self).create(vals)
        manager.initialize_nostr()
        return manager

    def write(self, vals):
        result = super(DecentralizedNostrSyncManager, self).write(vals)
        if 'relay_urls' in vals:
            self.initialize_nostr()
        return result
=== ./decentralized_sync/__init__.py ===
from . import models
from . import controllers
=== ./decentralized_sync/__manifest__.py ===
{
    'name': 'Decentralized Nostr Sync Manager',
    'version': '1.0',
    'category': 'Tools',
    'summary': 'Manage decentralized synchronization with Nostr and Git',
    'depends': ['base', 'ivcs_git', 'nostr_bridge'],
    'data': [
        'security/ir.model.access.csv',
        'views/sync_manager_views.xml',
        'views/dao_views.xml',
        'views/creator_views.xml',
        'views/program_views.xml',
        'views/event_views.xml',
        'views/menu_items.xml',
    ],
    'installable': True,
    'application': False,
    'auto_install': False,
}
=== ./decentralized_sync/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_decentralized_sync_manager_user,decentralized.sync.manager user,model_decentralized_sync_manager,base.group_user,1,1,1,1
access_decentralized_sync_dao_user,decentralized.sync.dao user,model_decentralized_sync_dao,base.group_user,1,1,1,1
access_decentralized_sync_creator_user,decentralized.sync.creator user,model_decentralized_sync_creator,base.group_user,1,1,1,1
access_decentralized_sync_program_user,decentralized.sync.program user,model_decentralized_sync_program,base.group_user,1,1,1,1
access_decentralized_sync_event_user,decentralized.sync.event user,model_decentralized_sync_event,base.group_user,1,1,1,1
access_decentralized_sync_connection_user,decentralized.sync.connection user,model_decentralized_sync_connection,base.group_user,1,1,1,1
=== ./decentralized_sync/controllers/main.py ===
from odoo import http
from odoo.http import request
from nostr.event import Event
import json

class DecentralizedSyncController(http.Controller):

    @http.route('/api/decentralized_sync/publish', type='json', auth='user')
    def publish_event(self, manager_id, content, tags=None):
        manager = request.env['decentralized.sync.manager'].browse(int(manager_id))
        event = manager.publish_event(content, tags)
        return {'status': 'success', 'event_id': event.id}

    @http.route('/api/decentralized_sync/sync_repo', type='json', auth='user')
    def sync_repository(self, manager_id, repo_path):
        manager = request.env['decentralized.sync.manager'].browse(int(manager_id))
        manager.sync_git_repository(repo_path)
        return {'status': 'success', 'message': 'Repository synced and events published'}

    @http.route('/api/decentralized_sync/events', type='json', auth='user')
    def get_events(self, manager_id):
        manager = request.env['decentralized.sync.manager'].browse(int(manager_id))
        # This would typically fetch events from Nostr relays
        # For now, we'll return an empty list
        return {'events': []}
=== ./nostr_auth_test/nostr_auth_module.py ===
import os
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import hashes
from odoo import models, fields, api
from odoo.exceptions import ValidationError
import base64

class NostrAuthModule(models.AbstractModel):
    _name = 'nostr.auth'
    _description = 'Nostr Authentication Module'

    @api.model
    def generate_keypair(self):
        """
        Generate a new Nostr keypair.
        This represents the 'Cause' in our 'Causal Relationship'.
        """
        private_key = ec.generate_private_key(ec.SECP256K1())
        public_key = private_key.public_key()
        
        private_bytes = private_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=serialization.NoEncryption()
        )
        public_bytes = public_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        )
        
        return {
            'private_key': base64.b64encode(private_bytes).decode('utf-8'),
            'public_key': base64.b64encode(public_bytes).decode('utf-8')
        }

    @api.model
    def store_keys(self, user_id, public_key, private_key):
        """
        Store the Nostr keys for a user.
        This action creates an 'Effect' in our 'Causal Relationship'.
        """
        user = self.env['res.users'].browse(user_id)
        if not user.exists():
            raise ValidationError("User does not exist")
        
        user.write({
            'nostr_public_key': public_key,
            'nostr_private_key': private_key  # In a real-world scenario, encrypt this before storage
        })

    @api.model
    def verify_signature(self, public_key, message, signature):
        """
        Verify a Nostr signature.
        This verification process is another 'Effect' in our 'Causal Relationship'.
        """
        try:
            public_key_obj = serialization.load_pem_public_key(base64.b64decode(public_key))
            signature_bytes = base64.b64decode(signature)
            public_key_obj.verify(
                signature_bytes,
                message.encode('utf-8'),
                ec.ECDSA(hashes.SHA256())
            )
            return True
        except:
            return False

    @api.model
    def authenticate_nostr(self, public_key, signature, message):
        """
        Authenticate a user using Nostr.
        This method embodies the complete 'Causal Relationship':
        The provided credentials (Cause) lead to authentication success or failure (Effect).
        """
        user = self.env['res.users'].search([('nostr_public_key', '=', public_key)], limit=1)
        if user and self.verify_signature(user.nostr_public_key, message, signature):
            return user.id
        return False

# For console testing
if __name__ == "__main__":
    # Simulate Odoo environment
    class MockEnv:
        def __init__(self):
            self.users = {}
        
        def __getitem__(self, key):
            return self
        
        def search(self, domain, limit=None):
            for user_id, user in self.users.items():
                if user['nostr_public_key'] == domain[0][2]:
                    return [MockUser(user_id, user)]
            return []
    
    class MockUser:
        def __init__(self, id, data):
            self.id = id
            self.__dict__.update(data)
        
        def exists(self):
            return True
        
        def write(self, vals):
            self.__dict__.update(vals)

    mock_env = MockEnv()
    
    # Create an instance of NostrAuthModule
    nostr_auth = NostrAuthModule()
    nostr_auth.env = mock_env

    # Test key generation
    print("Generating keypair...")
    keys = nostr_auth.generate_keypair()
    print(f"Public Key: {keys['public_key'][:32]}...")
    print(f"Private Key: {keys['private_key'][:32]}...")

    # Test key storage
    print("\nStoring keys...")
    mock_env.users[1] = {'name': 'Test User'}
    try:
        nostr_auth.store_keys(1, keys['public_key'], keys['private_key'])
        print("Keys stored successfully")
    except Exception as e:
        print(f"Error storing keys: {str(e)}")

    # Test signature verification
    print("\nTesting signature verification...")
    message = "Test message"
    private_key = serialization.load_pem_private_key(base64.b64decode(keys['private_key']), password=None)
    signature = base64.b64encode(private_key.sign(
        message.encode('utf-8'),
        ec.ECDSA(hashes.SHA256())
    )).decode('utf-8')
    
    is_valid = nostr_auth.verify_signature(keys['public_key'], message, signature)
    print(f"Signature valid: {is_valid}")

    # Test authentication
    print("\nTesting authentication...")
    user_id = nostr_auth.authenticate_nostr(keys['public_key'], signature, message)
    print(f"Authenticated user ID: {user_id}")

    print("\nAll tests completed.")
=== ./allfiles.txt ===
=== ./git_nostr_object/models/git_repository.py ===
# models/git_repository.py
from odoo import models, fields, api
import git
import json

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Name', required=True)
    path = fields.Char(string='Path', required=True)
    logs = fields.Text(string='Logs')

    def traverse_and_publish(self):
        self.ensure_one()
        logs = []
        try:
            git_repo = git.Repo(self.path)
            for commit in git_repo.iter_commits():
                nostr_event = self.env['nostr.event.object'].create({
                    'kind': 1,
                    'content': commit.message,
                    'tags': json.dumps([['commit', commit.hexsha]]),
                    'created_at': commit.committed_date,
                })
                nostr_event.action_publish()
                logs.append(f"Published commit {commit.hexsha}")

            self.write({'logs': '\n'.join(logs)})
            self.env['bus.bus']._sendone(self.env.user.partner_id, 'simple_notification', {
                'title': _("Git Repository Traversed"),
                'message': _("All commits published to Nostr network"),
            })
        except Exception as e:
            error_msg = f"Error traversing repository: {e}"
            logs.append(error_msg)
            self.write({'logs': '\n'.join(logs)})
            raise UserError(_(error_msg))

        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _("Git Repository"),
                'message': _("Repository traversed and commits published. Check logs for details."),
                'sticky': False,
                'type': 'success',
            }
        }
=== ./git_nostr_object/models/git_commit.py ===
from odoo import models, fields, api
from .git_object import GitObject

class GitCommit(models.Model):
    _name = 'git.commit'
    _inherit = 'git.object'
    _description = 'Git Commit'

    message = fields.Text(string='Commit Message')
    author = fields.Char(string='Author')
    timestamp = fields.Datetime(string='Timestamp')

    def to_nostr_event(self):
        return self.env['nostr.event.object'].create({
            'kind': 3121,
            'content': self.data,
            'tags': [['sha', self.sha]],
        })

    @api.model
    def create_from_nostr_event(self, event):
        git_commit = GitObject.from_nostr_event(event)
        return self.create({
            'sha': git_commit.sha,
            'data': git_commit.data.decode('utf-8', errors='replace'),
            'message': git_commit.message,
            'author': git_commit.author,
            'timestamp': git_commit.timestamp,
        })
    @api.model
    def create_from_git_commit(self, commit):
        return self.create({
            'sha': commit.hexsha,
            'message': commit.message,
            'author': f"{commit.author.name} <{commit.author.email}>",
            'timestamp': commit.committed_datetime,
            'data': commit.tree.data_stream.read().decode('utf-8', errors='replace'),
        })
=== ./git_nostr_object/models/nostr_websocket_client.py ===
import websocket
import json
import logging
import time

_logger = logging.getLogger(__name__)

class NostrWebSocketClient:
    def __init__(self, relay_urls):
        self.relay_urls = relay_urls

    def connect_and_publish(self, event_data):
        responses = []
        for url in self.relay_urls:
            try:
                _logger.info(f"Attempting to connect to {url}")
                start_time = time.time()
                ws = websocket.create_connection(url, timeout=10)
                _logger.info(f"Connected to {url} in {time.time() - start_time:.2f} seconds")

                # Construct the message correctly
                message = ["EVENT", event_data]
                _logger.debug(f"Raw event message: {message}")

                ws.send(json.dumps(message))
                _logger.info(f"Sent message to {url} in {time.time() - start_time:.2f} seconds")

                _logger.info(f"Waiting for response from {url}")
                response = ws.recv()
                _logger.info(f"Received response from {url} in {time.time() - start_time:.2f} seconds: {response}")

                responses.append(json.loads(response))
                ws.close()
            except Exception as e:
                _logger.error(f"Error publishing to {url}: {str(e)}")
                responses.append(["ERROR", str(e)])
        return responses
=== ./git_nostr_object/models/__init__.py ===
# __init__.py
from . import git_object
from . import git_commit
from . import git_tree
from . import git_blob
from . import git_repository
from . import nostr_event
from . import admin_test
from . import git_commit_wizard
=== ./git_nostr_object/models/git_object.py ===
from odoo import models, fields, api

class GitObject(models.AbstractModel):
    _name = 'git.object'
    _description = 'Git Object'

    sha = fields.Char(string='SHA', required=True)
    data = fields.Text(string='Data', required=True)

    def to_nostr_event(self):
        raise NotImplementedError("This method should be implemented by subclasses")

    @api.model
    def create_from_nostr_event(self, event):
        raise NotImplementedError("This method should be implemented by subclasses")
=== ./git_nostr_object/models/git_nostr_object.py ===
# models/git_nostr_event.py
from odoo import models, fields, api
from utils.nostr_websocket_client import NostrWebSocketClient
from nostr.event import Event as NostrEvent
import logging
import time
import json

_logger = logging.getLogger(__name__)

class GitNostrEventObject(models.Model):
    _name = 'git_nostr.event.object'
    _description = 'Git Nostr Event Object'

    kind = fields.Integer(string='Event Kind', required=True)
    content = fields.Text(string='Content', required=True)
    tags = fields.Text(string='Tags')
    created_at = fields.Integer(string='Created At', required=True)
    signature = fields.Char(string='Signature', required=True)
    public_key = fields.Char(string='Public Key', required=True)
    published = fields.Boolean(string='Published', default=False)

    def action_publish(self):
        """
        Publish the Nostr event to the configured relays.
        """
        relay_urls = [
            'wss://relay.damus.io',
            'wss://nostr-pub.wellorder.net',
            'wss://nostr.mom',
            'wss://nostr.slothy.win',
            'wss://relay.stoner.com'
        ]

        event_data = {
            'kind': self.kind,
            'content': self.content,
            'tags': self.tags,
            'created_at': self.created_at,
            'pubkey': self.public_key,
            'sig': self.signature,
        }

        websocket_client = NostrWebSocketClient(relay_urls)

        try:
            responses = websocket_client.connect_and_publish(event_data)
            if all(response[0] == 'OK' and response[2] for response in responses):
                self.write({'published': True})
                _logger.info(f"Nostr event successfully published: {self.id}")
            else:
                self.write({'published': False})
                _logger.error(f"Error publishing Nostr event {self.id}: {responses}")
        except Exception as e:
            self.write({'published': False})
            _logger.error(f"Error publishing Nostr event {self.id}: {e}")

    def to_nostr_event(self):
        try:
            tags = json.loads(self.tags) if self.tags else []
        except json.JSONDecodeError:
            _logger.warning(f"Invalid JSON in tags for event {self.id}. Using empty tags list.")
            tags = []

        return NostrEvent(
            kind=self.kind,
            content=self.content,
            tags=tags,
            public_key=self.public_key,
            created_at=self.created_at,
            sig=self.signature
        )
=== ./git_nostr_object/models/git_blob.py ===
from odoo import models, fields, api
from .git_object import GitObject

class GitBlob(models.Model):
    _name = 'git.blob'
    _inherit = 'git.object'
    _description = 'Git Blob'

    def to_nostr_event(self):
        return self.env['nostr.event.object'].create({
            'kind': 3123,
            'content': self.data,
            'tags': [['sha', self.sha]],
        })

    @api.model
    def create_from_nostr_event(self, event):
        git_blob = GitObject.from_nostr_event(event)
        return self.create({
            'sha': git_blob.sha,
            'data': git_blob.data.hex(),
        })
=== ./git_nostr_object/models/git_tree.py ===
from odoo import models, fields, api
from .git_object import GitObject

class GitTree(models.Model):
    _name = 'git.tree'
    _inherit = 'git.object'
    _description = 'Git Tree'

    def to_nostr_event(self):
        return self.env['nostr.event.object'].create({
            'kind': 3122,
            'content': self.data,
            'tags': [['sha', self.sha]],
        })

    @api.model
    def create_from_nostr_event(self, event):
        git_tree = GitObject.from_nostr_event(event)
        return self.create({
            'sha': git_tree.sha,
            'data': git_tree.data.decode('utf-8', errors='replace'),
        })
=== ./git_nostr_object/models/nostr_event.py ===
# models/nostr_event.py
from odoo import models, fields, api, _
from odoo.exceptions import UserError
from ..utils.nostr_websocket_client import NostrWebSocketClient
from nostr.event import Event as NostrEvent
from nostr.key import PrivateKey
import logging
import json
import time

_logger = logging.getLogger(__name__)

class NostrEventObject(models.Model):
    _name = 'nostr.event.object'
    _description = 'Nostr Event Object'

    kind = fields.Integer(string='Event Kind', required=True)
    content = fields.Text(string='Content', required=True)
    tags = fields.Text(string='Tags')
    created_at = fields.Integer(string='Created At', required=True)
    signature = fields.Char(string='Signature')
    public_key = fields.Char(string='Public Key', required=True)
    published = fields.Boolean(string='Published', default=False)
    logs = fields.Text(string='Logs')

    def action_publish(self):
        self.ensure_one()
        if self.published:
            raise UserError(_("This event has already been published."))

        start_time = time.time()
        logs = []

        # Get the user's private key
        user = self.env.user
        private_key_nsec = user.nostr_private_key
        if not private_key_nsec:
            raise UserError(_("Nostr private key is not set for the current user."))

        try:
            private_key = PrivateKey.from_nsec(private_key_nsec)
        except Exception as e:
            raise UserError(_("Invalid Nostr private key: %s") % str(e))

        logs.append(f"Key preparation took {time.time() - start_time:.4f} seconds")

        # Create and sign the Nostr event
        event_creation_start = time.time()
        event = NostrEvent(
            kind=self.kind,
            content=self.content,
            tags=json.loads(self.tags) if self.tags else [],
            public_key=private_key.public_key.hex(),
            created_at=int(time.time())
        )
        private_key.sign_event(event)
        logs.append(f"Event creation and signing took {time.time() - event_creation_start:.4f} seconds")

        # Update the record
        self.write({
            'signature': event.signature,
            'public_key': event.public_key,
            'created_at': event.created_at
        })

        relay_urls = [
            'wss://relay.damus.io',
            'wss://nostr-pub.wellorder.net',
            'wss://nostr.mom',
            'wss://nostr.slothy.win',
            'wss://relay.stoner.com'
        ]

        event_data = json.loads(event.to_message())[1]
        websocket_client = NostrWebSocketClient(relay_urls)

        publish_start = time.time()
        try:
            responses, ws_logs = websocket_client.connect_and_publish(event_data)
            logs.extend(ws_logs)
            if any(response[0] == 'OK' for response in responses):
                self.write({'published': True})
                logs.append(f"Nostr event successfully published: {self.id}")
                self.env['bus.bus']._sendone(self.env.user.partner_id, 'simple_notification', {
                    'title': _("Nostr Event Published"),
                    'message': _("Event successfully published to Nostr network"),
                })
            else:
                error_msg = f"Error publishing Nostr event {self.id}: {responses}"
                logs.append(error_msg)
                raise UserError(_(error_msg))
        except Exception as e:
            error_msg = f"Error publishing Nostr event {self.id}: {e}"
            logs.append(error_msg)
            raise UserError(_(error_msg))
        finally:
            logs.append(f"Publishing process took {time.time() - publish_start:.4f} seconds")

        logs.append(f"Total publish action took {time.time() - start_time:.4f} seconds")
        self.write({'logs': '\n'.join(logs)})

        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _("Nostr Event"),
                'message': _("Event published successfully. Check logs for details."),
                'sticky': False,
                'type': 'success',
            }
        }
=== ./git_nostr_object/models/git_commit_wizard.py ===
from odoo import models, fields, api

class GitCommitWizard(models.TransientModel):
    _name = 'git.commit.wizard'
    _description = 'Git Commit Wizard'

    repository_id = fields.Many2one('git.repository', string='Repository', required=True)
    message = fields.Text(string='Commit Message', required=True)
    file_data = fields.Text(string='File Content')
    file_name = fields.Char(string='File Name')

    def action_create_commit(self):
        repo = self.repository_id
        with open(f"{repo.path}/{self.file_name}", 'w') as f:
            f.write(self.file_data)
        commit = repo.create_commit(self.message, [self.file_name])
        return {'type': 'ir.actions.act_window_close'}
=== ./git_nostr_object/models/admin_test.py ===
# /opt/odoo/custom_addons/git_nostr_object/models/admin_test.py
from odoo import models, api
from ..tests.test_git_nostr_object import test_git_nostr_object, test_nostr_auth

class AdminTest(models.TransientModel):
    _name = 'git_nostr_object.admin_test'
    _description = 'Admin Test for Git-Nostr Object'

    def run_tests(self):
        test_git_nostr_object()
        test_nostr_auth()
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': 'Test Results',
                'message': 'Tests completed. Check the logs for details.',
                'sticky': False,
            }
        }
=== ./git_nostr_object/__init__.py ===
from . import models
from . import controllers
=== ./git_nostr_object/utils/nostr_websocket_client.py ===
# utils/nostr_websocket_client.py
import logging
import time
import websocket
import json

_logger = logging.getLogger(__name__)

class NostrWebSocketClient:
    def __init__(self, relay_urls):
        self.relay_urls = relay_urls

    def connect_and_publish(self, event_data):
        responses = []
        logs = []
        for url in self.relay_urls:
            try:
                response, log = self._connect_and_publish_to_relay(url, event_data)
                responses.append(response)
                logs.extend(log)
            except Exception as e:
                error_message = f"Error publishing event to relay {url}: {e}"
                _logger.error(error_message)
                logs.append(error_message)
        return responses, logs

    def _connect_and_publish_to_relay(self, relay_url, event_data):
        log = []
        log.append(f"Attempting to connect to {relay_url}")
        start_time = time.time()

        ws = websocket.create_connection(relay_url)
        log.append(f"Connected to {relay_url} in {time.time() - start_time:.2f} seconds")

        event_message = json.dumps(["EVENT", event_data])
        log.append(f"Sending Nostr event to {relay_url}")
        ws.send(event_message)
        log.append(f"Sent message to {relay_url} in {time.time() - start_time:.2f} seconds")

        log.append(f"Waiting for response from {relay_url}")
        response = ws.recv()
        log.append(f"Received response from {relay_url} in {time.time() - start_time:.2f} seconds: {response}")
        ws.close()
        return json.loads(response), log
=== ./git_nostr_object/__manifest__.py ===
{
    'name': 'git_nostr_object',
    'version': '1.0',
    'depends': ['base', 'bus'],
    'data': [
        'security/ir.model.access.csv',
        'views/git_repository_views.xml',
        'views/git_commit_views.xml',
        'views/git_tree_views.xml',
        'views/git_blob_views.xml',
        'views/git_object_views.xml',
        'views/nostr_event_object_views.xml',
        'views/actions.xml',
        'views/menus.xml',
        'views/admin_test_views.xml',
        'views/git_commit_wizard_views.xml'
    ],
    'assets': {
        'web.assets_backend': [
            'git_nostr_object/static/src/js/git_nostr_notifications.js',
        ],
    },
    'installable': True,
    'application': True,
    'auto_install': False,
}
=== ./git_nostr_object/static/src/js/git_nostr_notifications.js ===
// static/src/js/git_nostr_notifications.js
odoo.define('git_nostr_object.notifications', function (require) {
    "use strict";

    var core = require('web.core');
    var session = require('web.session');
    var BusService = require('bus.BusService');

    BusService.include({
        _onNotification: function (notifications) {
            var self = this;
            _.each(notifications, function (notification) {
                if (notification[0][1] === 'simple_notification') {
                    self.displayNotification({
                        title: notification[1].title,
                        message: notification[1].message,
                        type: 'info',
                    });
                }
            });
            this._super.apply(this, arguments);
        },
    });
});
=== ./git_nostr_object/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_git_commit,access_git_commit,model_git_commit,base.group_user,1,1,1,1
access_git_tree,access_git_tree,model_git_tree,base.group_user,1,1,1,1
access_git_blob,access_git_blob,model_git_blob,base.group_user,1,1,1,1
access_git_repository,access_git_repository,model_git_repository,base.group_user,1,1,1,1
access_nostr_event_object,access_nostr_event_object,model_nostr_event_object,base.group_user,1,1,1,1
=== ./git_nostr_object/tests/__init__.py ===
# /opt/odoo/custom_addons/git_nostr_object/tests/__init__.py
from . import test_git_nostr_object
=== ./git_nostr_object/tests/test_git_nostr_object.py ===
from odoo.tests.common import TransactionCase
from datetime import datetime
import random
import string
import logging
import os

_logger = logging.getLogger(__name__)

def random_string(length=10):
    return ''.join(random.choices(string.ascii_letters + string.digits, k=length))

def generate_sha():
    """Generate a random 40-character SHA hash"""
    return ''.join(random.choices('0123456789abcdef', k=40))

def get_current_timestamp():
    """Return the current timestamp"""
    return int(datetime.now().timestamp())

def get_author(env):
    """Return the logged-in user's name as the author"""
    return env.user.name

def get_local_path():
    """Return the Odoo installation path as the local path"""
    return '/opt/odoo'

def generate_nostr_keys():
    """Generate random 64-character Nostr public and private keys for the logged-in user"""
    public_key = random_string(64)
    private_key = random_string(64)
    return public_key, private_key

def get_event_type(content):
    """Extract the event type from the first line of the content"""
    return int(content.split('\n')[0].strip('# '))

def get_event_name(content):
    """Extract the event name from the first line of the content"""
    return content.split('\n', 1)[0]

def check_method_existence(env, methods):
    """Check if the required methods exist in the corresponding models"""
    for model, method_name in methods.items():
        model_obj = env[model]
        if not hasattr(model_obj, method_name):
            return False, f"Method '{method_name}' not found in model '{model}'"
    return True, "All required methods found"

class TestGitNostrObject(TransactionCase):

    def setUp(self):
        super(TestGitNostrObject, self).setUp()
        self.GitRepository = self.env['git.repository']
        self.GitCommit = self.env['git.commit']
        self.GitTree = self.env['git.tree']
        self.GitBlob = self.env['git.blob']
        self.GitNostrEventObject = self.env['git_nostr.event.object']
        self.NostrKey = self.env['nostr.key']
        self.NostrRelay = self.env['nostr.relay']
        self.NostrProfile = self.env['nostr.profile']

        # Check if required methods exist in the corresponding models
        required_methods = {
            'git.repository': 'traverse_and_publish',
            'nostr.event.object': 'action_publish',
            'nostr.key': 'generate_key_pair',
            'nostr.key': 'sign_event'
        }
        success, message = check_method_existence(self.env, required_methods)
        if not success:
            self.fail(message)

    def test_git_nostr_object(self):
        _logger.info("Testing Git-Nostr Object module...")

        # Test Git Repository
        repo_name = f'Test Repo {random_string()}'
        repo_path = f'{get_local_path()}/custom_addons/git_nostr_object/tests/test_repo_{random_string()}'
        repo = self.GitRepository.create({
            'name': repo_name,
            'path': repo_path
        })
        _logger.info(f"Created Git Repository with ID: {repo.id}")

        # Test traverse_and_publish
        try:
            repo.traverse_and_publish()
            _logger.info("traverse_and_publish executed successfully")
        except Exception as e:
            _logger.error(f"Error in traverse_and_publish: {e}")

        # Test Git Commit
        commit_sha = generate_sha()
        commit_author = get_author(self.env)
        commit_timestamp = get_current_timestamp()
        commit_data = 'Test commit data'
        commit = self.GitCommit.create({
            'sha': commit_sha,
            'message': 'Test commit message',
            'author': commit_author,
            'timestamp': commit_timestamp,
            'data': commit_data
        })
        _logger.info(f"Created Git Commit with ID: {commit.id}")

        # Test Git Tree
        tree_sha = generate_sha()
        tree_data = 'Test tree data'
        tree = self.GitTree.create({
            'sha': tree_sha,
            'data': tree_data
        })
        _logger.info(f"Created Git Tree with ID: {tree.id}")

        # Test Git Blob
        blob_sha = generate_sha()
        blob_data = 'Test blob data'
        blob = self.GitBlob.create({
            'sha': blob_sha,
            'data': blob_data
        })
        _logger.info(f"Created Git Blob with ID: {blob.id}")

        # Test Nostr Event Object
        event_content = '# 1\nTest Nostr event content'
        event_type = get_event_type(event_content)
        event_tags = '[]'
        event_created_at = get_current_timestamp()
        event_signature = random_string(64)
        event_name = get_event_name(event_content)
        event = self.GitNostrEventObject.create({
            'kind': event_type,
            'content': event_content,
            'tags': event_tags,
            'created_at': event_created_at,
            'signature': event_signature,
            'name': event_name
        })
        _logger.info(f"Created Nostr Event Object with ID: {event.id}")

        # Test action_publish
        try:
            event.action_publish()
            _logger.info("action_publish executed successfully")
        except Exception as e:
            _logger.error(f"Error in action_publish: {e}")

    def test_nostr_auth(self):
        _logger.info("Testing Nostr Authentication module...")

        # Test Nostr Key
        public_key, private_key = generate_nostr_keys()
        key = self.NostrKey.create({
            'public_key': public_key,
            'private_key': private_key,
            'user_id': self.env.user.id
        })
        _logger.info(f"Created Nostr Key with ID: {key.id}")

        # Test Nostr Relay
        relay_url = f'wss://relay{random_string()}.com'
        relay = self.NostrRelay.create({
            'url': relay_url,
            'is_active': True
        })
        _logger.info(f"Created Nostr Relay with ID: {relay.id}")

        # Test Nostr Profile
        profile_name = f'Test Profile {random_string()}'
        profile_about = 'Test profile description'
        profile_picture = 'http://example.com/pic.jpg'
        profile = self.NostrProfile.create({
            'name': profile_name,
            'about': profile_about,
            'picture': profile_picture,
            'user_id': self.env.user.id
        })
        _logger.info(f"Created Nostr Profile with ID: {profile.id}")

        # Test generate_key_pair method
        try:
            result = self.NostrKey.generate_key_pair()
            _logger.info(f"Generated key pair: {result}")
        except Exception as e:
            _logger.error(f"Error in generate_key_pair: {e}")

        # Test sign_event method (assuming it exists)
        try:
            event_data = {
                'kind': 1,
                'content': 'Test content',
                'created_at': get_current_timestamp(),
                'tags': []
            }
            result = key.sign_event(event_data)
            _logger.info(f"Signed event: {result}")
        except Exception as e:
            _logger.error(f"Error in sign_event: {e}")

def test_git_nostr_object():
    test_case = TestGitNostrObject.create({})
    test_case.test_git_nostr_object()

def test_nostr_auth():
    test_case = TestGitNostrObject.create({})
    test_case.test_nostr_auth()

# This allows running the test from the Odoo shell
if __name__ == '__main__':
    test_git_nostr_object()
    test_nostr_auth()
=== ./git_nostr_object/views/git_blob_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_blob_form" model="ir.ui.view">
        <field name="name">git.blob.form</field>
        <field name="model">git.blob</field>
        <field name="arch" type="xml">
            <form>
                <group>
                    <field name="sha"/>
                    <field name="data"/>
                </group>
            </form>
        </field>
    </record>

    <record id="view_git_blob_tree" model="ir.ui.view">
        <field name="name">git.blob.tree</field>
        <field name="model">git.blob</field>
        <field name="arch" type="xml">
            <tree>
                <field name="sha"/>
            </tree>
        </field>
    </record>

    <record id="action_git_blob" model="ir.actions.act_window">
        <field name="name">Git Blobs</field>
        <field name="res_model">git.blob</field>
        <field name="view_mode">tree,form</field>
    </record>
</odoo>
=== ./git_nostr_object/views/menus.xml ===
<!-- views/menus.xml -->
<odoo>
    <menuitem id="menu_git_nostr_object_root" name="Git-Nostr Object">
        <menuitem id="menu_git_repository" name="Repositories" action="action_git_repository"/>
        <menuitem id="menu_git_commit" name="Commits" action="action_git_commit"/>
        <menuitem id="menu_git_tree" name="Trees" action="action_git_tree"/>
        <menuitem id="menu_git_blob" name="Blobs" action="action_git_blob"/>
        <menuitem id="menu_git_nostr_event_object" name="Nostr Event Objects" action="action_git_nostr_event_object"/>
    </menuitem>
</odoo>
=== ./git_nostr_object/views/git_commit_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_commit_form" model="ir.ui.view">
        <field name="name">git.commit.form</field>
        <field name="model">git.commit</field>
        <field name="arch" type="xml">
            <form>
                <group>
                    <field name="sha"/>
                    <field name="message"/>
                    <field name="author"/>
                    <field name="timestamp"/>
                    <field name="data"/>
                </group>
            </form>
        </field>
    </record>

    <record id="view_git_commit_tree" model="ir.ui.view">
        <field name="name">git.commit.tree</field>
        <field name="model">git.commit</field>
        <field name="arch" type="xml">
            <tree>
                <field name="sha"/>
                <field name="message"/>
                <field name="author"/>
                <field name="timestamp"/>
            </tree>
        </field>
    </record>

    <record id="action_git_commit" model="ir.actions.act_window">
        <field name="name">Git Commits</field>
        <field name="res_model">git.commit</field>
        <field name="view_mode">tree,form</field>
    </record>
</odoo>
=== ./git_nostr_object/views/git_object_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_object_form" model="ir.ui.view">
        <field name="name">git.object.form</field>
        <field name="model">git.object</field>
        <field name="arch" type="xml">
            <form>
                <group>
                    <field name="sha"/>
                    <field name="data"/>
                </group>
            </form>
        </field>
    </record>

    <record id="view_git_object_tree" model="ir.ui.view">
        <field name="name">git.object.tree</field>
        <field name="model">git.object</field>
        <field name="arch" type="xml">
            <tree>
                <field name="sha"/>
            </tree>
        </field>
    </record>
</odoo>
=== ./git_nostr_object/views/admin_test_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_admin_test_form" model="ir.ui.view">
        <field name="name">git_nostr_object.admin_test.form</field>
        <field name="model">git_nostr_object.admin_test</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="run_tests" string="Run Tests" type="object" class="oe_highlight"/>
                </header>
                <div>
                    <p>Click the button to run the Git-Nostr Object tests.</p>
                </div>
            </form>
        </field>
    </record>

    <record id="action_admin_test" model="ir.actions.act_window">
        <field name="name">Admin Tests</field>
        <field name="res_model">git_nostr_object.admin_test</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
    </record>

    <menuitem id="menu_admin_test" name="Admin Tests" parent="menu_git_nostr_object_root" action="action_admin_test" groups="base.group_system"/>
</odoo>
=== ./git_nostr_object/views/git_commit_wizard_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_commit_wizard_form" model="ir.ui.view">
        <field name="name">git.commit.wizard.form</field>
        <field name="model">git.commit.wizard</field>
        <field name="arch" type="xml">
            <form string="Create Commit">
                <group>
                    <field name="repository_id" invisible="1"/>
                    <field name="message"/>
                    <field name="file_name"/>
                    <field name="file_data"/>
                </group>
                <footer>
                    <button name="action_create_commit" string="Create Commit" type="object" class="btn-primary"/>
                    <button string="Cancel" class="btn-secondary" special="cancel"/>
                </footer>
            </form>
        </field>
    </record>
</odoo>
=== ./git_nostr_object/views/git_tree_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_tree_form" model="ir.ui.view">
        <field name="name">git.tree.form</field>
        <field name="model">git.tree</field>
        <field name="arch" type="xml">
            <form>
                <group>
                    <field name="sha"/>
                    <field name="data"/>
                </group>
            </form>
        </field>
    </record>

    <record id="view_git_tree_tree" model="ir.ui.view">
        <field name="name">git.tree.tree</field>
        <field name="model">git.tree</field>
        <field name="arch" type="xml">
            <tree>
                <field name="sha"/>
            </tree>
        </field>
    </record>

    <record id="action_git_tree" model="ir.actions.act_window">
        <field name="name">Git Trees</field>
        <field name="res_model">git.tree</field>
        <field name="view_mode">tree,form</field>
    </record>
</odoo>
=== ./git_nostr_object/views/nostr_event_object_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_nostr_event_object_form" model="ir.ui.view">
        <field name="name">nostr.event.object.form</field>
        <field name="model">nostr.event.object</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="action_publish" string="Publish Event" type="object" class="oe_highlight" attrs="{'invisible': [('published', '=', True)]}"/>
                </header>
                <sheet>
                    <group>
                        <field name="kind"/>
                        <field name="content"/>
                        <field name="tags"/>
                        <field name="created_at"/>
                        <field name="signature"/>
                        <field name="public_key"/>
                        <field name="published"/>
                    </group>
                    <notebook>
                        <page string="Logs">
                            <field name="logs" widget="text" readonly="1"/>
                        </page>
                    </notebook>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_nostr_event_object_tree" model="ir.ui.view">
        <field name="name">nostr.event.object.tree</field>
        <field name="model">nostr.event.object</field>
        <field name="arch" type="xml">
            <tree string="Nostr Event Objects">
                <field name="kind"/>
                <field name="content"/>
                <field name="tags"/>
                <field name="created_at"/>
                <field name="signature"/>
                <field name="public_key"/>
                <field name="published"/>
            </tree>
        </field>
    </record>

    <record id="action_nostr_event_object" model="ir.actions.act_window">
        <field name="name">Nostr Event Objects</field>
        <field name="res_model">nostr.event.object</field>
        <field name="view_mode">tree,form</field>
    </record>
</odoo>
=== ./git_nostr_object/views/git_repository_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_repository_form" model="ir.ui.view">
        <field name="name">git.repository.form</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="traverse_and_publish" string="Traverse and Publish" type="object" class="oe_highlight"/>
                </header>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="path" string="Local Path"/>
                    </group>
                    <notebook>
                        <page string="Logs">
                            <field name="logs" widget="text" readonly="1"/>
                        </page>
                    </notebook>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_git_repository_tree" model="ir.ui.view">
        <field name="name">git.repository.tree</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="path"/>
            </tree>
        </field>
    </record>

    <record id="action_git_repository" model="ir.actions.act_window">
        <field name="name">Git Repositories</field>
        <field name="res_model">git.repository</field>
        <field name="view_mode">tree,form</field>
    </record>
</odoo>
=== ./git_nostr_object/views/actions.xml ===
<!-- views/actions.xml -->
<odoo>
    <record id="action_git_nostr_event_object" model="ir.actions.act_window">
        <field name="name">Nostr Event Objects</field>
        <field name="res_model">nostr.event.object</field>
        <field name="view_mode">tree,form</field>
    </record>
</odoo>
=== ./git_nostr_object/controllers/git_controller.py ===
from odoo import http
from odoo.http import request
import logging

_logger = logging.getLogger(__name__)

class GitController(http.Controller):

    @http.route('/git_nostr_object/traverse_repo', type='json', auth='user')
    def traverse_repo(self, repo_id):
        try:
            repo = request.env['git.repository'].browse(repo_id)
            repo.traverse_and_publish()
            return {'status': 'success'}
        except Exception as e:
            _logger.exception("Error traversing repository")
            return {'status': 'error', 'message': str(e)}

    @http.route('/git_nostr_object/publish_event', type='json', auth='user')
    def publish_event(self, event_id):
        try:
            event = request.env['git_nostr.event.object'].browse(event_id)
            event.action_publish()
            return {'status': 'success'}
        except Exception as e:
            _logger.exception("Error publishing Nostr event")
            return {'status': 'error', 'message': str(e)}
=== ./custom_thunderbird_mail/models/custom_mail.py ===
import smtplib
from email.mime.text import MIMEText
from odoo import models, fields, api

class CustomMail(models.Model):
    _name = 'custom.mail'
    _description = 'Custom Mail Integration with Thunderbird Mail'

    @api.model
    def send_thunderbird_mail(self, recipient, subject, body):
        # Thunderbird SMTP server configuration
        smtp_server = 'test'
        smtp_port = 587
        smtp_user = 'g'
        smtp_password = 'your_thunderbird_password'  # Replace with the actual password

        # Create the email message
        msg = MIMEText(body)
        msg['Subject'] = subject
        msg['From'] = smtp_user
        msg['To'] = recipient

        # Send the email
        try:
            with smtplib.SMTP(smtp_server, smtp_port) as server:
                server.login(smtp_user, smtp_password)
                server.sendmail(smtp_user, [recipient], msg.as_string())
            return True
        except Exception as e:
            _logger.error('Failed to send email: %s', e)
            return False
=== ./custom_thunderbird_mail/__init__.py ===
from . import models
=== ./custom_thunderbird_mail/__manifest__.py ===
{
    'name': 'Custom Thunderbird Mail Integration',
    'version': '1.0',
    'category': 'Tools',
    'summary': 'Integrate Odoo with Thunderbird Mail',
    'description': 'A module to integrate Odoo with Thunderbird Mail for sending emails.',
    'depends': ['base'],
    'data': [],
    'installable': True,
    'application': True,
}
=== ./custom_thunderbird_mail/wizard/create_nostr_event_wizard.py ===
# wizard/create_nostr_event_wizard.py
from odoo import models, fields, api
import git
import json

class CreateNostrEventWizard(models.TransientModel):
    _name = 'create.nostr.event.wizard'
    _description = 'Create Nostr Event Wizard'

    repository_id = fields.Many2one('git.repository', string='Repository', required=True)
    event_type = fields.Selection([
        ('repo_anchor', 'Repository Anchor'),
        ('branch', 'Branch'),
        ('commit', 'Commit'),
        ('tree', 'Tree'),
        ('blob', 'Blob'),
    ], string='Event Type', required=True)
    commit_message = fields.Text(string='Commit Message')
    branch_name = fields.Char(string='Branch Name')
    file_content = fields.Text(string='File Content')
    file_name = fields.Char(string='File Name')

    def action_create_event(self):
        repo = git.Repo(self.repository_id.path)
        
        if self.event_type == 'commit':
            # Stage all changes
            repo.git.add(A=True)
            # Commit changes
            commit = repo.index.commit(self.commit_message)
            self.repository_id.last_commit = commit.hexsha
            content = json.dumps({
                'type': 'commit',
                'repository': self.repository_id.name,
                'commit_hash': commit.hexsha,
                'message': self.commit_message,
            })
        elif self.event_type == 'branch':
            repo.git.checkout('-b', self.branch_name)
            self.repository_id.branch = self.branch_name
            content = json.dumps({
                'type': 'branch',
                'repository': self.repository_id.name,
                'branch_name': self.branch_name,
            })
        elif self.event_type == 'blob':
            with open(os.path.join(self.repository_id.path, self.file_name), 'w') as f:
                f.write(self.file_content)
            repo.index.add([self.file_name])
            commit = repo.index.commit(f"Add file: {self.file_name}")
            self.repository_id.last_commit = commit.hexsha
            content = json.dumps({
                'type': 'blob',
                'repository': self.repository_id.name,
                'file_name': self.file_name,
                'commit_hash': commit.hexsha,
            })
        
        self.env['nostr.event'].create({
            'name': f"{self.event_type.capitalize()} - {self.repository_id.name}",
            'event_type': self.event_type,
            'content': content,
            'tags': json.dumps([['r', self.repository_id.remote_url]]),
        })

        return {'type': 'ir.actions.act_window_close'}
=== ./custom_thunderbird_mail/wizard/__init__.py ===
# wizard/__init__.py
from . import create_nostr_event_wizard
=== ./custom_thunderbird_mail/wizard/create_nostr_event_wizard_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_create_nostr_event_wizard_form" model="ir.ui.view">
        <field name="name">create.nostr.event.wizard.form</field>
        <field name="model">create.nostr.event.wizard</field>
        <field name="arch" type="xml">
            <form string="Create Nostr Event">
                <group>
                    <field name="repository_id"/>
                    <field name="event_type"/>
                    <field name="commit_message" attrs="{'invisible': [('event_type', '!=', 'commit')], 'required': [('event_type', '=', 'commit')]}"/>
                    <field name="branch_name" attrs="{'invisible': [('event_type', '!=', 'branch')], 'required': [('event_type', '=', 'branch')]}"/>
                    <field name="file_name" attrs="{'invisible': [('event_type', '!=', 'blob')], 'required': [('event_type', '=', 'blob')]}"/>
                    <field name="file_content" attrs="{'invisible': [('event_type', '!=', 'blob')], 'required': [('event_type', '=', 'blob')]}" widget="ace" options="{'mode': 'xml'}"/>
                </group>
                <footer>
                    <button name="action_create_event" string="Create Event" type="object" class="btn-primary"/>
                    <button string="Cancel" class="btn-secondary" special="cancel"/>
                </footer>
            </form>
        </field>
    </record>

    <record id="action_create_nostr_event_wizard" model="ir.actions.act_window">
        <field name="name">Create Nostr Event</field>
        <field name="res_model">create.nostr.event.wizard</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
    </record>
</odoo>
=== ./custom_thunderbird_mail/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_git_repository,access_git_repository,model_git_repository,base.group_user,1,1,1,1
access_nostr_event,access_nostr_event,model_nostr_event,base.group_user,1,1,1,1
access_create_nostr_event_wizard,access_create_nostr_event_wizard,model_create_nostr_event_wizard,base.group_user,1,1,1,0
=== ./custom_thunderbird_mail/views/res_users_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_users_form_inherit_git_nostr" model="ir.ui.view">
        <field name="name">res.users.form.inherit.git.nostr</field>
        <field name="model">res.users</field>
        <field name="inherit_id" ref="base.view_users_form"/>
        <field name="arch" type="xml">
            <notebook position="inside">
                <page string="Nostr Settings" name="nostr_settings">
                    <group>
                        <field name="nostr_private_key" password="True"/>
                        <field name="nostr_public_key"/>
                    </group>
                </page>
            </notebook>
        </field>
    </record>
</odoo>
=== ./custom_thunderbird_mail/views/res_config_settings_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="res_config_settings_view_form" model="ir.ui.view">
        <field name="name">res.config.settings.view.form.inherit.git_nostr_bridge</field>
        <field name="model">res.config.settings</field>
        <field name="inherit_id" ref="base.res_config_settings_view_form"/>
        <field name="arch" type="xml">
            <xpath expr="//div[hasclass('settings')]" position="inside">
                <div class="app_settings_block" data-string="Git-Nostr Bridge" string="Git-Nostr Bridge" data-key="git_nostr_bridge">
                    <h2>Nostr Settings</h2>
                    <div class="row mt16 o_settings_container">
                        <div class="col-12 col-lg-6 o_setting_box">
                            <div class="o_setting_left_pane"/>
                            <div class="o_setting_right_pane">
                                <span class="o_form_label">Nostr Relay URLs</span>
                                <div class="text-muted">
                                    Comma-separated list of Nostr relay URLs
                                </div>
                                <div class="content-group">
                                    <div class="mt16">
                                        <field name="git_nostr_relay_urls"/>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </xpath>
        </field>
    </record>
</odoo>
=== ./custom_thunderbird_mail/views/nostr_event_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_nostr_event_form" model="ir.ui.view">
        <field name="name">nostr.event.form</field>
        <field name="model">nostr.event</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="action_publish" string="Publish" type="object" class="oe_highlight" attrs="{'invisible': [('published', '=', True)]}"/>
                </header>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="event_type"/>
                        <field name="content"/>
                        <field name="tags"/>
                        <field name="published"/>
                        <field name="event_id"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_nostr_event_form_git_nostr" model="ir.ui.view">
        <field name="name">nostr.event.form.git.nostr</field>
        <field name="model">nostr.event</field>
        <field name="inherit_id" ref="integrated_ivcs.view_nostr_event_form"/>
        <field name="arch" type="xml">
            <xpath expr="//field[@name='event_type']" position="after">
                <field name="repository_id" attrs="{'invisible': [('event_type', 'not in', ['repo_anchor', 'branch', 'commit', 'tree', 'blob'])]}"/>
            </xpath>
        </field>
    </record>

    <record id="action_nostr_event" model="ir.actions.act_window">
        <field name="name">Nostr Events</field>
        <field name="res_model">nostr.event</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_nostr_event_git" name="Git Nostr Events" parent="menu_git_nostr_bridge" action="integrated_ivcs.action_nostr_event" sequence="20"/>
</odoo>
=== ./custom_thunderbird_mail/views/git_repository_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_repository_form" model="ir.ui.view">
        <field name="name">git.repository.form</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="action_pull" string="Pull" type="object" class="oe_highlight"/>
                    <button name="action_push" string="Push" type="object" class="oe_highlight"/>
                    <button name="action_commit" string="Commit" type="object" class="oe_highlight"/>
                </header>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="path"/>
                        <field name="remote_url"/>
                        <field name="branch"/>
                        <field name="last_commit"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="action_git_repository" model="ir.actions.act_window">
        <field name="name">Git Repositories</field>
        <field name="res_model">git.repository</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_git_nostr_bridge" name="Git-Nostr Bridge" sequence="10"/>
    <menuitem id="menu_git_repository" name="Git Repositories" parent="menu_git_nostr_bridge" action="action_git_repository" sequence="10"/>
</odoo>
=== ./git_nostr_bridge/models/git_repository.py ===
# models/git_repository.py
import os
import git
from odoo import models, fields, api, _
from odoo.exceptions import UserError

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Name', required=True)
    path = fields.Char(string='Local Path', required=True)
    remote_url = fields.Char(string='Remote URL')
    branch = fields.Char(string='Current Branch', default='main')
    last_commit = fields.Char(string='Last Commit', readonly=True)

    @api.model
    def create(self, vals):
        repo = super(GitRepository, self).create(vals)
        repo._initialize_repository()
        return repo

    def _initialize_repository(self):
        if not os.path.exists(self.path):
            os.makedirs(self.path)
            repo = git.Repo.init(self.path)
            if self.remote_url:
                repo.create_remote('origin', self.remote_url)
            open(os.path.join(self.path, 'README.md'), 'w').close()
            repo.index.add(['README.md'])
            repo.index.commit('Initial commit')
            self.last_commit = repo.head.commit.hexsha

    def action_pull(self):
        repo = git.Repo(self.path)
        origin = repo.remotes.origin
        origin.pull()
        self.last_commit = repo.head.commit.hexsha

    def action_push(self):
        repo = git.Repo(self.path)
        origin = repo.remotes.origin
        origin.push()

    def action_commit(self):
        return {
            'name': _('Create Commit'),
            'type': 'ir.actions.act_window',
            'res_model': 'create.nostr.event.wizard',
            'view_mode': 'form',
            'target': 'new',
            'context': {'default_repository_id': self.id, 'default_event_type': 'commit'},
        }
=== ./git_nostr_bridge/models/__init__.py ===
from . import git_repository
from . import nostr_event
from . import res_config_settings
=== ./git_nostr_bridge/models/res_users.py ===
from odoo import models, fields, api
from nostr.key import PrivateKey

class ResUsers(models.Model):
    _inherit = 'res.users'

    nostr_public_key = fields.Char(string="Nostr Public Key")
    nostr_private_key = fields.Char(string="Nostr Private Key")
    nostr_relay_url = fields.Char(string="Nostr Relay URL")

    @api.depends('nostr_private_key')
    def _compute_public_key(self):
        for user in self:
            if user.nostr_private_key:
                try:
                    private_key = PrivateKey.from_nsec(user.nostr_private_key)
                    user.nostr_public_key = private_key.public_key.hex()
                except Exception:
                    user.nostr_public_key = False
            else:
                user.nostr_public_key = False

    @api.model
    def create(self, vals):
        if 'nostr_private_key' not in vals or not vals['nostr_private_key']:
            private_key = PrivateKey()
            vals['nostr_private_key'] = private_key.bech32()
        return super(ResUsers, self).create(vals)
=== ./git_nostr_bridge/models/nostr_event.py ===
# File: /opt/odoo/custom_addons/git_nostr_bridge/models/nostr_event.py

import asyncio
import json
import logging
import websockets
from urllib.parse import urlparse
import time
import traceback

from odoo import models, fields, api, _
from odoo.exceptions import UserError
from nostr.event import Event as NostrLibEvent
from nostr.key import PrivateKey

_logger = logging.getLogger(__name__)

class NostrEvent(models.Model):
    _name = 'nostr.event'
    _description = 'Nostr Event'
    _inherit = 'nostr.event'

    name = fields.Char(string='Name', required=True)
    event_type = fields.Selection([
        ('repo_anchor', 'Repository Anchor'),
        ('branch', 'Branch'),
        ('commit', 'Commit'),
        ('tree', 'Tree'),
        ('blob', 'Blob'),
    ], string='Event Type', required=True)
    content = fields.Text(string='Content')
    tags = fields.Text(string='Tags')
    published = fields.Boolean(string='Published', default=False)
    event_id = fields.Char(string='Event ID', readonly=True)
    kind = fields.Integer(string='Nostr Event Kind', default=1)
    repository_id = fields.Many2one('git.repository', string='Related Repository')
    signature = fields.Char(string='Signature', readonly=True)
    public_key = fields.Char(string='Public Key', readonly=True)
    created_at = fields.Integer(string='Created At', readonly=True)

    @api.model
    def create(self, vals):
        record = super(NostrEvent, self).create(vals)
        record.generate_event_details()
        return record

    def generate_event_details(self):
        if not self.event_id or not self.signature:
            try:
                private_key = PrivateKey()
                public_key = private_key.public_key.hex()
                
                event = NostrLibEvent(
                    kind=self.kind,
                    content=self.content or '',
                    tags=json.loads(self.tags) if self.tags else [],
                    public_key=public_key,
                    created_at=int(time.time())
                )
                
                private_key.sign_event(event)
                
                self.write({
                    'event_id': event.id,
                    'signature': event.signature,
                    'public_key': public_key,
                    'created_at': event.created_at
                })
            except Exception as e:
                _logger.error(f"Error generating Nostr event details: {str(e)}")
                # Not raising UserError here to avoid disrupting the creation process

    @api.model
    def action_publish(self, event_id):
        event = self.browse(event_id)
        _logger.info(f"Starting publish action for event: {event.name}")
        start_time = time.time()

        try:
            if not self.env.user.nostr_private_key:
                raise UserError(_("Nostr private key is not set for the current user."))

            _logger.info("Generating private key")
            try:
                private_key = PrivateKey.from_nsec(self.env.user.nostr_private_key)
                _logger.info("Private key generated successfully")
            except Exception as e:
                _logger.error(f"Failed to generate private key: {str(e)}")
                _logger.error(traceback.format_exc())
                raise UserError(_("Invalid Nostr private key: %s") % str(e))

            public_key = private_key.public_key.hex()
            _logger.info(f"Public key: {public_key}")

            _logger.info("Parsing tags")
            try:
                tags = json.loads(event.tags) if event.tags else []
                _logger.info(f"Parsed tags: {tags}")
                if not isinstance(tags, list):
                    raise ValueError("Tags must be a list of lists")
                for tag in tags:
                    if not isinstance(tag, list):
                        raise ValueError("Each tag must be a list")
            except json.JSONDecodeError as e:
                _logger.error(f"JSON decode error: {str(e)}")
                _logger.error(traceback.format_exc())
                raise UserError(_("Invalid tags format. Please ensure tags are in valid JSON format."))
            except ValueError as e:
                _logger.error(f"Value error: {str(e)}")
                _logger.error(traceback.format_exc())
                raise UserError(_("Invalid tags format: %s") % str(e))

            _logger.info("Creating Nostr event")
            nostr_event = NostrLibEvent(
                kind=1,  # Assuming TEXT_NOTE, adjust if needed
                content=str(event.content),
                tags=tags,
                public_key=public_key  # Ensure public_key is provided
            )
            private_key.sign_event(nostr_event)
            _logger.info(f"Event created: {nostr_event.to_message()}")

            _logger.info("Fetching relay URLs")
            relay_urls = self.env['ir.config_parameter'].sudo().get_param('git_nostr_bridge.relay_urls', '').split(',')
            relay_urls = [url.strip() for url in relay_urls if url.strip()][:5]  # Limit to 5 relays
            _logger.info(f"Relay URLs: {relay_urls}")

            if not relay_urls:
                raise UserError(_("No Nostr relay URLs configured. Please set them in the settings."))

            _logger.info("Validating relay URLs")
            for url in relay_urls:
                parsed = urlparse(url)
                if parsed.scheme not in ('ws', 'wss'):
                    _logger.error(f"Invalid relay URL: {url}")
                    raise UserError(_("Invalid relay URL: %s. Must start with ws:// or wss://") % url)

            async def publish_to_relay(relay_url, nostr_event, retries=3):
                for attempt in range(retries):
                    try:
                        _logger.info(f"Attempting to connect to {relay_url} (attempt {attempt + 1})")
                        connection_start = time.time()
                        async with websockets.connect(relay_url, timeout=30) as websocket:
                            connection_end = time.time()
                            _logger.info(f"Connected to {relay_url} in {connection_end - connection_start:.2f} seconds")
                            
                            message = nostr_event.to_message()
                            _logger.debug(f"Raw event message: {message}")
                            
                            _logger.info(f"Sending Nostr event to {relay_url}: {message}")
                            
                            send_start = time.time()
                            await websocket.send(message)
                            send_end = time.time()
                            _logger.info(f"Sent message to {relay_url} in {send_end - send_start:.2f} seconds")
                            
                            _logger.info(f"Waiting for response from {relay_url}")
                            response_start = time.time()
                            response = await asyncio.wait_for(websocket.recv(), timeout=10.0)
                            response_end = time.time()
                            _logger.info(f"Received response from {relay_url} in {response_end - response_start:.2f} seconds: {response}")
                            
                            try:
                                return json.loads(response)
                            except json.JSONDecodeError as e:
                                _logger.error(f"Failed to parse response from {relay_url}: {str(e)}")
                                return f"Invalid response from {relay_url}: {response}"
                    except (websockets.exceptions.WebSocketException, asyncio.TimeoutError) as e:
                        _logger.error(f"Error publishing to {relay_url} (attempt {attempt + 1}): {str(e)}")
                        _logger.error(traceback.format_exc())
                        await asyncio.sleep(5 * (attempt + 1))  # Increased delay between attempts
                return f"Failed to publish to {relay_url} after {retries} attempts"

            async def publish_with_timeout():
                tasks = [publish_to_relay(url, nostr_event) for url in relay_urls]
                return await asyncio.gather(*tasks, return_exceptions=True)

            async def run_publication():
                _logger.info("Starting publication process")
                try:
                    results = await asyncio.wait_for(publish_with_timeout(), timeout=120)  # Increased overall timeout
                    _logger.info(f"Publication results: {results}")
                    return results
                except asyncio.TimeoutError:
                    _logger.error("Publication process timed out after 120 seconds")
                    raise UserError(_("Publishing timed out after 120 seconds"))

            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            try:
                results = loop.run_until_complete(run_publication())
            finally:
                loop.close()

            success = any(isinstance(result, list) and result[0] == "OK" for result in results)
            if success:
                event.write({
                    'published': True,
                    'event_id': nostr_event.id
                })
                _logger.info(f"Successfully published Nostr event: {nostr_event.id}")
                
                # Verify event publication
                self.verify_event_publication(nostr_event.id, relay_urls)
                
                end_time = time.time()
                _logger.info(f"Total publish action time: {end_time - start_time:.2f} seconds")
                
                return {
                    'type': 'ir.actions.client',
                    'tag': 'display_notification',
                    'params': {
                        'message': _("Nostr event successfully published to at least one relay."),
                        'type': 'success',
                        'sticky': False,
                    }
                }
            else:
                error_messages = [str(result) for result in results if isinstance(result, str)]
                _logger.error(f"Failed to publish Nostr event: {'; '.join(error_messages)}")
                raise UserError(_("Failed to publish Nostr event: %s") % "; ".join(error_messages))

        except Exception as e:
            _logger.error(f"Unexpected error in action_publish: {str(e)}")
            _logger.error(traceback.format_exc())
            raise UserError(_("An unexpected error occurred: %s") % str(e))

    @api.model
    def verify_event_publication(self, event_id, relay_urls, max_attempts=5, delay=2):
        _logger.info(f"Starting verification for event: {event_id}")
        for attempt in range(max_attempts):
            _logger.info(f"Verification attempt {attempt + 1}")
            for url in relay_urls:
                try:
                    loop = asyncio.new_event_loop()
                    asyncio.set_event_loop(loop)
                    result = loop.run_until_complete(self.query_event(url, event_id))
                    if result:
                        _logger.info(f"Event {event_id} found on relay {url}")
                        return True
                except Exception as e:
                    _logger.error(f"Error querying event from {url}: {str(e)}")
                    _logger.error(traceback.format_exc())
                finally:
                    loop.close()
            _logger.info(f"Waiting {delay} seconds before next attempt")
            time.sleep(delay)
        _logger.warning(f"Event {event_id} not found on any relay after {max_attempts} attempts")
        return False

    async def query_event(self, relay_url, event_id):
        _logger.info(f"Querying event {event_id} from {relay_url}")
        start_time = time.time()
        try:
            async with websockets.connect(relay_url, timeout=10) as websocket:
                request = json.dumps(["REQ", "query", {"ids": [event_id]}])
                _logger.info(f"Sending query to {relay_url}: {request}")
                await websocket.send(request)
                response = await asyncio.wait_for(websocket.recv(), timeout=5.0)
                _logger.info(f"Response from {relay_url}: {response}")
                end_time = time.time()
                _logger.info(f"Query to {relay_url} took {end_time - start_time:.2f} seconds")
                return json.loads(response)
        except Exception as e:
            _logger.error(f"Error querying {relay_url}: {str(e)}")
            _logger.error(traceback.format_exc())
            end_time = time.time()
            _logger.info(f"Failed query to {relay_url} took {end_time - start_time:.2f} seconds")
            return None
=== ./git_nostr_bridge/models/res_config_settings.py ===
import requests
import json
from odoo import fields, models, api
import logging

_logger = logging.getLogger(__name__)

class ResConfigSettings(models.TransientModel):
    _inherit = 'res.config.settings'

    git_nostr_relay_urls = fields.Char(
        string="Nostr Relay URLs", 
        config_parameter='git_nostr_bridge.relay_urls',
        default=lambda self: self._default_nostr_relays()
    )

    def _default_nostr_relays(self):
        return self._get_top_nostr_relays()

    @api.model
    def _get_top_nostr_relays(self, limit=108):
        url = "https://api.nostr.watch/v1/online"
        try:
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
            }
            response = requests.get(url, headers=headers, timeout=10)
            response.raise_for_status()
            _logger.info(f"Response status code: {response.status_code}")
            
            data = response.json()
            _logger.info(f"API response (first 108 items): {data[:108]}")
            
            relays = data[:108]
            _logger.info(f"Number of relay links found: {len(relays)}")
            _logger.info(f"Extracted relays (first 5): {relays[:5]}")
            
            relay_urls = ",".join(relays)
            return relay_urls
        except requests.RequestException as e:
            _logger.error(f"Error fetching Nostr relays: {e}")
            return "wss://nostr-relay.app,wss://nos.lol,wss://relay.snort.social,wss://relay.nostr.net"

    nostr_relay_urls = fields.Char(
        string="Nostr Relay URLs", 
        config_parameter='nostr_bridge.relay_urls',
        default=_default_nostr_relays
    )

    @api.model
    def get_values(self):
        res = super(ResConfigSettings, self).get_values()
        ICPSudo = self.env['ir.config_parameter'].sudo()
        
        relay_urls = ICPSudo.get_param('git_nostr_bridge.relay_urls')
        if not relay_urls:
            relay_urls = self._default_nostr_relays()
            ICPSudo.set_param('git_nostr_bridge.relay_urls', relay_urls)
            _logger.info(f"Set new relay URLs: {relay_urls[:100]}...")
        else:
            _logger.info(f"Using existing relay URLs: {relay_urls[:100]}...")
        
        res.update(git_nostr_relay_urls=relay_urls)
        return res

    def set_values(self):
        super(ResConfigSettings, self).set_values()
        ICPSudo = self.env['ir.config_parameter'].sudo()
        if self.git_nostr_relay_urls:
            ICPSudo.set_param('git_nostr_bridge.relay_urls', self.git_nostr_relay_urls)
            _logger.info(f"Updated relay URLs: {self.git_nostr_relay_urls[:100]}...")
        else:
            default_urls = self._default_nostr_relays()
            ICPSudo.set_param('git_nostr_bridge.relay_urls', default_urls)
            _logger.info(f"Set default relay URLs: {default_urls[:100]}...")
=== ./git_nostr_bridge/models/git_repository ===
# models/git_repository.py
import os
import git
from odoo import models, fields, api, _
from odoo.exceptions import UserError

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Name', required=True)
    path = fields.Char(string='Local Path', required=True)
    remote_url = fields.Char(string='Remote URL')
    branch = fields.Char(string='Current Branch', default='main')
    last_commit = fields.Char(string='Last Commit', readonly=True)

    @api.model
    def create(self, vals):
        repo = super(GitRepository, self).create(vals)
        repo._initialize_repository()
        return repo

    def _initialize_repository(self):
        if not os.path.exists(self.path):
            os.makedirs(self.path)
            repo = git.Repo.init(self.path)
            if self.remote_url:
                repo.create_remote('origin', self.remote_url)
            open(os.path.join(self.path, 'README.md'), 'w').close()
            repo.index.add(['README.md'])
            repo.index.commit('Initial commit')
            self.last_commit = repo.head.commit.hexsha

    def action_pull(self):
        repo = git.Repo(self.path)
        origin = repo.remotes.origin
        origin.pull()
        self.last_commit = repo.head.commit.hexsha

    def action_push(self):
        repo = git.Repo(self.path)
        origin = repo.remotes.origin
        origin.push()

    def action_commit(self):
        return {
            'name': _('Create Commit'),
            'type': 'ir.actions.act_window',
            'res_model': 'create.nostr.event.wizard',
            'view_mode': 'form',
            'target': 'new',
            'context': {'default_repository_id': self.id, 'default_event_type': 'commit'},
        }
=== ./git_nostr_bridge/__init__.py ===
from . import models
from . import wizard
=== ./git_nostr_bridge/__manifest__.py ===
{
    'name': 'Git-Nostr Bridge',
    'version': '1.0',
    'category': 'Tools',
    'summary': 'Integrates Git repositories with Nostr network',
    'author': 'Your Name',
    'website': 'https://www.example.com',
    'depends': ['base', 'mail', 'nostr_auth', 'nostr_bridge', 'integrated_ivcs'],
    'data': [
        'security/ir.model.access.csv',
        'views/git_repository_views.xml',
        'views/nostr_event_views.xml',
        'views/res_config_settings_views.xml',
        'views/res_users_views.xml',
        'wizard/create_nostr_event_wizard_views.xml',
    ],
    'installable': True,
    'application': True,
    'auto_install': False,
    'external_dependencies': {
        'python': ['git', 'nostr', 'websockets'],
    },
}
=== ./git_nostr_bridge/wizard/create_nostr_event_wizard.py ===
# wizard/create_nostr_event_wizard.py
from odoo import models, fields, api
import git
import json

class CreateNostrEventWizard(models.TransientModel):
    _name = 'create.nostr.event.wizard'
    _description = 'Create Nostr Event Wizard'

    repository_id = fields.Many2one('git.repository', string='Repository', required=True)
    event_type = fields.Selection([
        ('repo_anchor', 'Repository Anchor'),
        ('branch', 'Branch'),
        ('commit', 'Commit'),
        ('tree', 'Tree'),
        ('blob', 'Blob'),
    ], string='Event Type', required=True)
    commit_message = fields.Text(string='Commit Message')
    branch_name = fields.Char(string='Branch Name')
    file_content = fields.Text(string='File Content')
    file_name = fields.Char(string='File Name')

    def action_create_event(self):
        repo = git.Repo(self.repository_id.path)
        
        if self.event_type == 'commit':
            # Stage all changes
            repo.git.add(A=True)
            # Commit changes
            commit = repo.index.commit(self.commit_message)
            self.repository_id.last_commit = commit.hexsha
            content = json.dumps({
                'type': 'commit',
                'repository': self.repository_id.name,
                'commit_hash': commit.hexsha,
                'message': self.commit_message,
            })
        elif self.event_type == 'branch':
            repo.git.checkout('-b', self.branch_name)
            self.repository_id.branch = self.branch_name
            content = json.dumps({
                'type': 'branch',
                'repository': self.repository_id.name,
                'branch_name': self.branch_name,
            })
        elif self.event_type == 'blob':
            with open(os.path.join(self.repository_id.path, self.file_name), 'w') as f:
                f.write(self.file_content)
            repo.index.add([self.file_name])
            commit = repo.index.commit(f"Add file: {self.file_name}")
            self.repository_id.last_commit = commit.hexsha
            content = json.dumps({
                'type': 'blob',
                'repository': self.repository_id.name,
                'file_name': self.file_name,
                'commit_hash': commit.hexsha,
            })
        
        self.env['nostr.event'].create({
            'name': f"{self.event_type.capitalize()} - {self.repository_id.name}",
            'event_type': self.event_type,
            'content': content,
            'tags': json.dumps([['r', self.repository_id.remote_url]]),
        })

        return {'type': 'ir.actions.act_window_close'}
=== ./git_nostr_bridge/wizard/__init__.py ===
# wizard/__init__.py
from . import create_nostr_event_wizard
=== ./git_nostr_bridge/wizard/create_nostr_event_wizard_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_create_nostr_event_wizard_form" model="ir.ui.view">
        <field name="name">create.nostr.event.wizard.form</field>
        <field name="model">create.nostr.event.wizard</field>
        <field name="arch" type="xml">
            <form string="Create Nostr Event">
                <group>
                    <field name="repository_id"/>
                    <field name="event_type"/>
                    <field name="commit_message" attrs="{'invisible': [('event_type', '!=', 'commit')], 'required': [('event_type', '=', 'commit')]}"/>
                    <field name="branch_name" attrs="{'invisible': [('event_type', '!=', 'branch')], 'required': [('event_type', '=', 'branch')]}"/>
                    <field name="file_name" attrs="{'invisible': [('event_type', '!=', 'blob')], 'required': [('event_type', '=', 'blob')]}"/>
                    <field name="file_content" attrs="{'invisible': [('event_type', '!=', 'blob')], 'required': [('event_type', '=', 'blob')]}" widget="ace" options="{'mode': 'xml'}"/>
                </group>
                <footer>
                    <button name="action_create_event" string="Create Event" type="object" class="btn-primary"/>
                    <button string="Cancel" class="btn-secondary" special="cancel"/>
                </footer>
            </form>
        </field>
    </record>

    <record id="action_create_nostr_event_wizard" model="ir.actions.act_window">
        <field name="name">Create Nostr Event</field>
        <field name="res_model">create.nostr.event.wizard</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
    </record>
</odoo>
=== ./git_nostr_bridge/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_git_repository,access_git_repository,model_git_repository,base.group_user,1,1,1,1
access_nostr_event,access_nostr_event,model_nostr_event,base.group_user,1,1,1,1
access_create_nostr_event_wizard,access_create_nostr_event_wizard,model_create_nostr_event_wizard,base.group_user,1,1,1,0
=== ./git_nostr_bridge/views/res_users_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_users_form_inherit_git_nostr" model="ir.ui.view">
        <field name="name">res.users.form.inherit.git.nostr</field>
        <field name="model">res.users</field>
        <field name="inherit_id" ref="base.view_users_form"/>
        <field name="arch" type="xml">
            <notebook position="inside">
                <page string="Nostr Settings" name="nostr_settings">
                    <group>
                        <field name="nostr_private_key" password="True"/>
                        <field name="nostr_public_key"/>
                    </group>
                </page>
            </notebook>
        </field>
    </record>
</odoo>
=== ./git_nostr_bridge/views/res_config_settings_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="res_config_settings_view_form" model="ir.ui.view">
        <field name="name">res.config.settings.view.form.inherit.git_nostr_bridge</field>
        <field name="model">res.config.settings</field>
        <field name="inherit_id" ref="base.res_config_settings_view_form"/>
        <field name="arch" type="xml">
            <xpath expr="//div[hasclass('settings')]" position="inside">
                <div class="app_settings_block" data-string="Git-Nostr Bridge" string="Git-Nostr Bridge" data-key="git_nostr_bridge">
                    <h2>Nostr Settings</h2>
                    <div class="row mt16 o_settings_container">
                        <div class="col-12 col-lg-6 o_setting_box">
                            <div class="o_setting_left_pane"/>
                            <div class="o_setting_right_pane">
                                <span class="o_form_label">Nostr Relay URLs</span>
                                <div class="text-muted">
                                    Comma-separated list of Nostr relay URLs
                                </div>
                                <div class="content-group">
                                    <div class="mt16">
                                        <field name="git_nostr_relay_urls"/>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </xpath>
        </field>
    </record>
</odoo>
=== ./git_nostr_bridge/views/nostr_event_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_nostr_event_form" model="ir.ui.view">
        <field name="name">nostr.event.form</field>
        <field name="model">nostr.event</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="action_publish" string="Publish" type="object" class="oe_highlight" attrs="{'invisible': [('published', '=', True)]}"/>
                </header>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="event_type"/>
                        <field name="content"/>
                        <field name="tags"/>
                        <field name="published"/>
                        <field name="event_id"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_nostr_event_form_git_nostr" model="ir.ui.view">
        <field name="name">nostr.event.form.git.nostr</field>
        <field name="model">nostr.event</field>
        <field name="inherit_id" ref="integrated_ivcs.view_nostr_event_form"/>
        <field name="arch" type="xml">
            <xpath expr="//field[@name='event_type']" position="after">
                <field name="repository_id" attrs="{'invisible': [('event_type', 'not in', ['repo_anchor', 'branch', 'commit', 'tree', 'blob'])]}"/>
            </xpath>
        </field>
    </record>

    <record id="action_nostr_event" model="ir.actions.act_window">
        <field name="name">Nostr Events</field>
        <field name="res_model">nostr.event</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_nostr_event_git" name="Git Nostr Events" parent="menu_git_nostr_bridge" action="integrated_ivcs.action_nostr_event" sequence="20"/>
</odoo>
=== ./git_nostr_bridge/views/git_repository_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_repository_form" model="ir.ui.view">
        <field name="name">git.repository.form</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="action_pull" string="Pull" type="object" class="oe_highlight"/>
                    <button name="action_push" string="Push" type="object" class="oe_highlight"/>
                    <button name="action_commit" string="Commit" type="object" class="oe_highlight"/>
                </header>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="path"/>
                        <field name="remote_url"/>
                        <field name="branch"/>
                        <field name="last_commit"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="action_git_repository" model="ir.actions.act_window">
        <field name="name">Git Repositories</field>
        <field name="res_model">git.repository</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_git_nostr_bridge" name="Git-Nostr Bridge" sequence="10"/>
    <menuitem id="menu_git_repository" name="Git Repositories" parent="menu_git_nostr_bridge" action="action_git_repository" sequence="10"/>
</odoo>
=== ./custom_auth/models/res_users.py ===
from odoo import models, api
from odoo.exceptions import AccessDenied
import requests

class ResUsers(models.Model):
    _inherit = 'res.users'

    @classmethod
    def _login(cls, db, login, password):
        if not cls.validate_external_auth(login, password):
            raise AccessDenied()
        return super(ResUsers, cls)._login(db, login, password)

    @classmethod
    def validate_external_auth(cls, login, token):
        # Replace with your actual localhost API endpoint
        validation_url = 'http://localhost/validate_admin'
        response = requests.post(validation_url, json={'login': login, 'token': token})
        return response.status_code == 200 and response.json().get('is_admin', False)
=== ./custom_auth/__manifest__.py ===
{
    'name': 'Custom External Authentication',
    'version': '1.0',
    'category': 'Hidden',
    'summary': 'Custom authentication for external admin access',
    'depends': ['base'],
    'data': [],
    'installable': True,
}
=== ./opinion_reputation_nostr/models/__init__.py ===
from . import opinion_reputation
from . import nostr_event
=== ./opinion_reputation_nostr/models/nostr_event.py ===
from odoo import models, api, _
from odoo.exceptions import UserError
import json
import logging

_logger = logging.getLogger(__name__)

class NostrEvent(models.AbstractModel):
    _name = 'opinion.nostr.event'
    _description = 'Nostr Event for Opinion Reputation'

    @api.model
    def create_prediction_event(self, prediction):
        content = json.dumps({
            'question_id': prediction.question_id.id,
            'question_text': prediction.question_id.text,
            'answer': prediction.answer,
            'confidence': prediction.confidence
        })
        
        try:
            nostr_event = self.env['nostr.event']
            event = nostr_event.create_event(
                kind=1,  # You might want to use a custom event kind for predictions
                content=content,
                tags=[['p', prediction.user_id.nostr_public_key]],
                private_key=prediction.user_id.nostr_private_key
            )
            
            nostr_event.publish_event(event)
            _logger.info(f"Nostr event created and published for prediction {prediction.id}")
        except AttributeError:
            _logger.warning("Nostr bridge not available. Prediction event not published to Nostr.")
        except Exception as e:
            _logger.error(f"Error creating Nostr event: {str(e)}")
            raise UserError(_("Failed to create Nostr event: %s") % str(e))
=== ./opinion_reputation_nostr/models/opinion_reputation.py ===
from odoo import models, fields, api
from odoo.exceptions import UserError
import enum
import logging

_logger = logging.getLogger(__name__)

class AnswerChoice(enum.Enum):
    AGREE = "I Agree"
    DO_NOT_DISAGREE = "I do not disagree"
    DO_NOT_AGREE = "I do not agree"
    DISAGREE = "I Disagree"

class User(models.Model):
    _inherit = 'res.users'

    reputation = fields.Float(default=0)

class Question(models.Model):
    _name = 'opinion.question'
    _description = 'Opinion Question'

    text = fields.Text(required=True)
    explanation = fields.Text()
    created_by = fields.Many2one('res.users', string='Created By')
    created_at = fields.Datetime(default=fields.Datetime.now)
    is_settled = fields.Boolean(default=False)
    last_revisited = fields.Datetime()

class Prediction(models.Model):
    _name = 'opinion.prediction'
    _description = 'Opinion Prediction'

    user_id = fields.Many2one('res.users', required=True)
    question_id = fields.Many2one('opinion.question', required=True)
    answer = fields.Selection([
        ('AGREE', 'I Agree'),
        ('DO_NOT_DISAGREE', 'I do not disagree'),
        ('DO_NOT_AGREE', 'I do not agree'),
        ('DISAGREE', 'I Disagree')
    ], required=True)
    confidence = fields.Float(required=True)
    timestamp = fields.Datetime(default=fields.Datetime.now)
    is_correct = fields.Boolean()

    @api.model
    def create(self, vals):
        prediction = super(Prediction, self).create(vals)
        try:
            self.env['opinion.nostr.event'].create_prediction_event(prediction)
        except Exception as e:
            _logger.error(f"Failed to create Nostr event for prediction {prediction.id}: {str(e)}")
        self.update_reputation(prediction.user_id.id)
        return prediction

    def update_reputation(self, user_id):
        user = self.env['res.users'].browse(user_id)
        predictions = self.search([('user_id', '=', user_id)])
        correct_predictions = predictions.filtered(lambda p: p.is_correct)
        if predictions:
            user.reputation = (len(correct_predictions) / len(predictions)) * 100

class OpinionReputationSystem(models.AbstractModel):
    _name = 'opinion.reputation.system'
    _description = 'Opinion Reputation System'

    @api.model
    def revisit_question(self, question_id):
        question = self.env['opinion.question'].browse(question_id)
        if (fields.Datetime.now() - question.created_at).days >= 4*365:
            predictions = self.env['opinion.prediction'].search([('question_id', '=', question_id)])
            total_votes = len(predictions)
            if total_votes > 0:
                agreement_ratio = len(predictions.filtered(lambda p: p.answer in ['AGREE', 'DO_NOT_DISAGREE'])) / total_votes
                question.write({
                    'is_settled': agreement_ratio >= 0.8333334,
                    'last_revisited': fields.Datetime.now()
                })

    @api.model
    def explain_answer_choices(self):
        return """
        Answer choices explanation:
        1. I Agree: You fully support and believe in the statement.
        2. I do not disagree: You somewhat agree or have no strong objection to the statement.
        3. I do not agree: You somewhat disagree or have some reservations about the statement.
        4. I Disagree: You fully oppose or do not believe in the statement.
        """
=== ./opinion_reputation_nostr/__init__.py ===
from . import models
=== ./opinion_reputation_nostr/__manifest__.py ===
{
    'name': 'Opinion Reputation with Nostr',
    'version': '1.0',
    'category': 'Tools',
    'summary': 'Opinion Reputation System with optional Nostr integration',
    'depends': ['base'],
    'data': [
        'security/ir.model.access.csv',
        'views/opinion_reputation_views.xml',
        'data/default_questions.xml',
    ],
    'installable': True,
    'application': True,
}
=== ./opinion_reputation_nostr/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_opinion_question,access_opinion_question,model_opinion_question,base.group_user,1,1,1,1
access_opinion_prediction,access_opinion_prediction,model_opinion_prediction,base.group_user,1,1,1,1
access_opinion_nostr_event,access_opinion_nostr_event,model_opinion_nostr_event,base.group_user,1,1,1,1
=== ./opinion_reputation_nostr/data/default_questions.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <!-- Add your default questions here -->
        <record id="question_1" model="opinion.question">
            <field name="text">Do life's challenges sometimes lead to self-doubt?</field>
            <field name="explanation">Sometimes when things get tough, we might wonder if we're good enough or if we can handle it.</field>
        </record>
        <!-- Add more questions as needed -->
    </data>
</odoo>
=== ./opinion_reputation_nostr/views/opinion_reputation_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_question_form" model="ir.ui.view">
        <field name="name">opinion.question.form</field>
        <field name="model">opinion.question</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="text"/>
                        <field name="explanation"/>
                        <field name="created_by"/>
                        <field name="created_at"/>
                        <field name="is_settled"/>
                        <field name="last_revisited"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_prediction_form" model="ir.ui.view">
        <field name="name">opinion.prediction.form</field>
        <field name="model">opinion.prediction</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="user_id"/>
                        <field name="question_id"/>
                        <field name="answer"/>
                        <field name="confidence"/>
                        <field name="timestamp"/>
                        <field name="is_correct"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="action_questions" model="ir.actions.act_window">
        <field name="name">Questions</field>
        <field name="res_model">opinion.question</field>
        <field name="view_mode">tree,form</field>
    </record>

    <record id="action_predictions" model="ir.actions.act_window">
        <field name="name">Predictions</field>
        <field name="res_model">opinion.prediction</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_opinion_reputation" name="Opinion Reputation"/>
    <menuitem id="menu_questions" parent="menu_opinion_reputation" action="action_questions"/>
    <menuitem id="menu_predictions" parent="menu_opinion_reputation" action="action_predictions"/>
</odoo>
=== ./integrated_ivcs/models/git_repository.py ===
from odoo import models, fields, api
import git
import os

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Repository Name', required=True)
    path = fields.Char(string='Repository Path', required=True)
    
    @api.model
    def create(self, vals):
        repo = super(GitRepository, self).create(vals)
        if not os.path.exists(repo.path):
            os.makedirs(repo.path)
            git.Repo.init(repo.path)
        return repo

    def commit_changes(self, message):
        repo = git.Repo(self.path)
        repo.git.add(A=True)
        commit = repo.index.commit(message)
        
        self.env['nostr.event'].create_git_event(self.path, commit.hexsha)
        
        return commit.hexsha
=== ./integrated_ivcs/models/__init__.py ===
from . import ivcs_item
from . import ivcs_version
from . import ivcs_commit
from . import git_repository
from . import nostr_event
from . import branch_manager
from . import res_config_settings
=== ./integrated_ivcs/models/ivcs_version.py ===
from odoo import models, fields, api

class IVCSVersion(models.Model):
    _name = 'ivcs.version'
    _description = 'IVCS Version'

    name = fields.Char(string='Version Name', required=True)
    description = fields.Text(string='Description')
    item_id = fields.Many2one('ivcs.item', string='IVCS Item', required=True, ondelete='cascade')
    commit_id = fields.Many2one('ivcs.commit', string='Associated Commit')
    create_date = fields.Datetime(string='Created On', readonly=True, default=fields.Datetime.now)

    @api.model
    def create(self, vals):
        version = super(IVCSVersion, self).create(vals)
        if not version.item_id.current_version_id:
            version.item_id.current_version_id = version.id
        return version

    def name_get(self):
        result = []
        for version in self:
            name = f"{version.item_id.name} - {version.name}"
            result.append((version.id, name))
        return result
=== ./integrated_ivcs/models/nostr_event.py ===
from odoo import models, fields, api, _
from odoo.exceptions import UserError
from nostr.event import Event
from nostr.key import PrivateKey
import json
import logging
import time
import git

_logger = logging.getLogger(__name__)

class NostrEvent(models.Model):
    _name = 'nostr.event'
    _description = 'Nostr Event'

    event_id = fields.Char(string='Event ID', required=True)
    kind = fields.Integer(string='Event Kind', required=True)
    content = fields.Text(string='Content', required=True)
    tags = fields.Text(string='Tags')
    public_key = fields.Char(string='Public Key')
    created_at = fields.Integer(string='Created At', required=True)
    signature = fields.Char(string='Signature', required=True)
    published = fields.Boolean(string='Published', default=False)
    name = fields.Char(string='Name')
    event_type = fields.Selection([
        ('repo_anchor', 'Repository Anchor'),
        ('branch', 'Branch'),
        ('commit', 'Commit'),
        ('tree', 'Tree'),
        ('blob', 'Blob'),
    ], string='Event Type')

    def create_and_publish(self, event):
        vals = {
            'event_id': event.id,
            'kind': event.kind,
            'content': event.content,
            'tags': json.dumps(event.tags),
            'public_key': event.public_key,
            'created_at': event.created_at,
            'signature': event.signature,
        }
        nostr_event = self.create(vals)
        nostr_event.publish_event()
        return nostr_event

    def publish_event(self):
        self.ensure_one()
        relay_urls = self.env['ir.config_parameter'].sudo().get_param('integrated_ivcs.relay_urls', '').split(',')
        
        event_data = {
            'id': self.event_id,
            'kind': self.kind,
            'created_at': self.created_at,
            'tags': json.loads(self.tags),
            'content': self.content,
            'pubkey': self.public_key,
            'sig': self.signature,
        }

        for url in relay_urls:
            try:
                # Here you would typically use a Nostr client library to publish the event
                # For simplicity, we'll just log the action
                _logger.info(f"Publishing event {self.event_id} to relay: {url}")
                # Example: nostr_client.publish_event(url, event_data)
                self.published = True
            except Exception as e:
                _logger.error(f"Failed to publish event to {url}: {str(e)}")

    @api.model
    def create_git_event(self, repo_path, commit_hash):
        repo = git.Repo(repo_path)
        commit = repo.commit(commit_hash)
        
        content = json.dumps({
            "action": "commit",
            "message": commit.message,
            "author": commit.author.name,
            "email": commit.author.email,
            "date": commit.authored_datetime.isoformat(),
            "hash": commit_hash,
            "parent_hashes": [c.hexsha for c in commit.parents],
            "tree_hash": commit.tree.hexsha,
        })
        
        event = Event(
            kind=3121,
            content=content,
            tags=[
                ["r", repo_path],
                ["h", commit_hash],
            ],
            public_key=self.env.user.nostr_public_key,
        )
        
        private_key = PrivateKey(bytes.fromhex(self.env.user.nostr_private_key))
        private_key.sign_event(event)
        
        return self.create_and_publish(event)

    @api.model
    def create_tree_event(self, repo_path, tree_hash):
        repo = git.Repo(repo_path)
        tree = repo.tree(tree_hash)
        
        content = json.dumps({
            "action": "tree",
            "hash": tree_hash,
            "items": [{"mode": item.mode, "type": item.type, "hash": item.hexsha, "path": item.path} for item in tree.traverse()],
        })
        
        event = Event(
            kind=3122,
            content=content,
            tags=[
                ["r", repo_path],
                ["h", tree_hash],
            ],
            public_key=self.env.user.nostr_public_key,
        )
        
        private_key = PrivateKey(bytes.fromhex(self.env.user.nostr_private_key))
        private_key.sign_event(event)
        
        return self.create_and_publish(event)

    @api.model
    def create_blob_event(self, repo_path, blob_hash):
        repo = git.Repo(repo_path)
        blob = repo.blob(blob_hash)
        
        content = json.dumps({
            "action": "blob",
            "hash": blob_hash,
            "size": blob.size,
            "data": blob.data_stream.read().decode('utf-8', errors='replace'),
        })
        
        event = Event(
            kind=3123,
            content=content,
            tags=[
                ["r", repo_path],
                ["h", blob_hash],
            ],
            public_key=self.env.user.nostr_public_key,
        )
        
        private_key = PrivateKey(bytes.fromhex(self.env.user.nostr_private_key))
        private_key.sign_event(event)
        
        return self.create_and_publish(event)

    @api.model
    def reconstruct_git_objects(self, repo_path):
        repo = git.Repo(repo_path)
        events = self.search([('tags', 'ilike', repo_path)])
        
        for event in events:
            content = json.loads(event.content)
            if event.kind == 3121:  # Commit
                self._reconstruct_commit(repo, content)
            elif event.kind == 3122:  # Tree
                self._reconstruct_tree(repo, content)
            elif event.kind == 3123:  # Blob
                self._reconstruct_blob(repo, content)

    def _reconstruct_commit(self, repo, content):
        commit_hash = content['hash']
        if commit_hash not in repo.objects:
            repo.create_commit(
                tree=repo.tree(content['tree_hash']),
                message=content['message'],
                author=git.Actor(content['author'], content['email']),
                committer=git.Actor(content['author'], content['email']),
                parent_commits=[repo.commit(p) for p in content['parent_hashes']],
                commit_timestamp=int(content['date']),
                ref=f'refs/heads/{content["branch"]}' if 'branch' in content else None
            )

    def _reconstruct_tree(self, repo, content):
        tree_hash = content['hash']
        if tree_hash not in repo.objects:
            tree_items = []
            for item in content['items']:
                if item['type'] == 'blob':
                    tree_items.append((item['mode'], 'blob', item['hash'], item['path']))
                elif item['type'] == 'tree':
                    tree_items.append((item['mode'], 'tree', item['hash'], item['path']))
            repo.create_tree(tree_items)

    def _reconstruct_blob(self, repo, content):
        blob_hash = content['hash']
        if blob_hash not in repo.objects:
            repo.create_blob(content['data'].encode('utf-8'))

    def sync_git_nostr(self, repo_path):
        repo = git.Repo(repo_path)
        for obj in repo.objects:
            if isinstance(obj, git.Commit):
                self.create_git_event(repo_path, obj.hexsha)
            elif isinstance(obj, git.Tree):
                self.create_tree_event(repo_path, obj.hexsha)
            elif isinstance(obj, git.Blob):
                self.create_blob_event(repo_path, obj.hexsha)

        self.reconstruct_git_objects(repo_path)
=== ./integrated_ivcs/models/res_config_settings.py ===
from odoo import fields, models

class ResConfigSettings(models.TransientModel):
    _inherit = 'res.config.settings'

    integrated_ivcs_relay_urls = fields.Char(string="Nostr Relay URLs", config_parameter='integrated_ivcs.relay_urls')
=== ./integrated_ivcs/models/ivcs_commit.py ===
from odoo import models, fields, api
import json
from nostr.event import Event
from nostr.key import PrivateKey
import logging

_logger = logging.getLogger(__name__)

class IVCSCommit(models.Model):
    _name = 'ivcs.commit'
    _description = 'IVCS Commit'

    hash = fields.Char(string='Commit Hash', required=True)
    message = fields.Text(string='Commit Message', required=True)
    author = fields.Char(string='Author', required=True, default=lambda self: self.env.user.name)
    date = fields.Datetime(string='Commit Date', required=True, default=fields.Datetime.now)
    item_id = fields.Many2one('ivcs.item', string='IVCS Item', required=True, ondelete='cascade')
    version_id = fields.Many2one('ivcs.version', string='Associated Version')

    @api.model
    def create(self, vals):
        commit = super(IVCSCommit, self).create(vals)
        try:
            commit._create_nostr_commit_event()
        except Exception as e:
            _logger.error(f"Failed to create Nostr commit event: {str(e)}")
        return commit

    def _create_nostr_commit_event(self):
        if not self.item_id.nostr_private_key:
            _logger.warning(f"No Nostr private key set for IVCS Item {self.item_id.name}")
            return

        try:
            private_key = PrivateKey.from_nsec(self.item_id.nostr_private_key)
        except Exception as e:
            _logger.error(f"Invalid Nostr private key for IVCS Item {self.item_id.name}: {str(e)}")
            return

        event = Event(
            kind=3121,
            content=json.dumps({
                "hash": self.hash,
                "message": self.message,
                "author": self.author,
                "date": self.date.isoformat(),
            }),
            tags=[['r', self.item_id.repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)
        
        try:
            self.env['nostr.event'].create_and_publish(event)
            _logger.info(f"Nostr commit event created and published for commit {self.hash}")
        except Exception as e:
            _logger.error(f"Failed to create and publish Nostr event for commit {self.hash}: {str(e)}")
=== ./integrated_ivcs/models/ivcs_item.py ===
from odoo import models, fields, api, _
from odoo.exceptions import UserError
import git
import json
from nostr.event import Event
from nostr.key import PrivateKey
import os
import logging

_logger = logging.getLogger(__name__)

class IVCSItem(models.Model):
    _name = 'ivcs.item'
    _description = 'IVCS Item'

    name = fields.Char(string='Name', required=True)
    description = fields.Text('Description')
    current_version_id = fields.Many2one('ivcs.version', string='Current Version', compute='_compute_current_version', store=True)
    version_ids = fields.One2many('ivcs.version', 'item_id', string='Versions')
    repo_path = fields.Char('Repository Path', compute='_compute_repo_path', store=True)
    current_branch = fields.Char('Current Branch', default='main')
    commit_ids = fields.One2many('ivcs.commit', 'item_id', string='Commits')
    nostr_private_key = fields.Char(string="Nostr Private Key")
    branch_manager_id = fields.Many2one('ivcs.branch.manager', string='Branch Manager')

    @api.depends('name')
    def _compute_repo_path(self):
        for item in self:
            item.repo_path = f"/opt/ivcs_repos/item_{item.id}"

    @api.depends('version_ids')
    def _compute_current_version(self):
        for item in self:
            if item.version_ids:
                item.current_version_id = item.version_ids.sorted(lambda v: v.create_date, reverse=True)[0]
            else:
                item.current_version_id = False

    @api.model
    def create(self, vals):
        if 'nostr_private_key' in vals and vals['nostr_private_key']:
            try:
                # Validate and format the private key
                private_key = PrivateKey.from_nsec(vals['nostr_private_key'])
                vals['nostr_private_key'] = private_key.hex()  # Store the private key as a hex string
            except Exception as e:
                raise UserError(_("Invalid Nostr private key: %s") % str(e))
        return super(IVCSItem, self).create(vals)

    def write(self, vals):
        if 'nostr_private_key' in vals and vals['nostr_private_key']:
            try:
                # Validate and format the private key
                private_key = PrivateKey.from_nsec(vals['nostr_private_key'])
                vals['nostr_private_key'] = private_key.hex()  # Store the private key as a hex string
            except Exception as e:
                raise UserError(_("Invalid Nostr private key: %s") % str(e))
        return super(IVCSItem, self).write(vals)

    def _initialize_repository(self):
        self.ensure_one()
        if not os.path.exists(self.repo_path):
            os.makedirs(self.repo_path)
            repo = git.Repo.init(self.repo_path)
            readme_path = os.path.join(self.repo_path, 'README.md')
            with open(readme_path, 'w') as f:
                f.write(f"# {self.name}\n\n{self.description}")
            repo.index.add(['README.md'])
            commit = repo.index.commit("Initial commit")
            self._create_initial_version(commit.hexsha)
            self._create_nostr_repo_event()

    def _create_initial_version(self, commit_hash):
        version = self.env['ivcs.version'].create({
            'name': 'v1.0',
            'description': 'Initial version',
            'item_id': self.id,
        })
        self.env['ivcs.commit'].create({
            'hash': commit_hash,
            'message': "Initial commit",
            'item_id': self.id,
            'version_id': version.id,
        })

    def _create_nostr_repo_event(self):
        if not self.nostr_private_key:
            raise UserError(_("Nostr private key is not set for this item."))
    
        private_key = PrivateKey(bytes.fromhex(self.nostr_private_key))
        event = Event(
            kind=31228,
            content=json.dumps({
                "action": "create_repository",
                "repo_name": self.name,
                "description": self.description
            }),
            tags=[['r', self.repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)
        
        self.env['nostr.event'].create_and_publish(event)

    def create_branch(self, branch_name):
        self.ensure_one()
        repo = git.Repo(self.repo_path)
        if not self.branch_manager_id:
            self.branch_manager_id = self.env['ivcs.branch.manager'].create({
                'name': f"Branch Manager for {self.name}",
                'item_id': self.id,
            })
        if branch_name not in repo.heads:
            repo.create_head(branch_name)
            self.current_branch = branch_name
            self._create_nostr_branch_event(branch_name)
            if self.branch_manager_id:
                self.branch_manager_id.create_branch(branch_name)
            return self._return_success('Branch Created', f'Branch {branch_name} has been created.')
        else:
            return self._return_warning('Branch Exists', f'Branch {branch_name} already exists.')

    def _create_nostr_branch_event(self, branch_name):
        if not self.nostr_private_key:
            raise UserError(_("Nostr private key is not set for this item."))
        
        private_key = PrivateKey(bytes.fromhex(self.nostr_private_key))
        event = Event(
            kind=31227,
            content=json.dumps({
                "action": "create_branch",
                "branch_name": branch_name,
                "repo_name": self.name
            }),
            tags=[['r', self.repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)
        
        self.env['nostr.event'].create_and_publish(event)

    def _return_success(self, title, message):
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _(title),
                'message': _(message),
                'type': 'success',
            }
        }

    def _return_warning(self, title, message):
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _(title),
                'message': _(message),
                'type': 'warning',
            }
        }

    def delete_branch(self, branch_name):
        self.ensure_one()
        if self.branch_manager_id.delete_branch(branch_name):
            return self._return_success('Branch Deleted', f'Branch {branch_name} has been deleted.')
        else:
            return self._return_warning('Branch Not Found', f'Branch {branch_name} does not exist.')

    def merge_branches(self, source_branch, target_branch):
        self.ensure_one()
        if self.branch_manager_id.merge_branches(source_branch, target_branch):
            return self._return_success('Branches Merged', f'Branch {source_branch} has been merged into {target_branch}.')
        else:
            return self._return_warning('Merge Failed', f'Failed to merge {source_branch} into {target_branch}.')

    def reconstruct_branches(self):
        self.ensure_one()
        branches = self.branch_manager_id.reconstruct_branches_from_events()
        return self._return_success('Branches Reconstructed', f'Reconstructed {len(branches)} branches from Nostr events.')

    # Add other methods as needed (e.g., commit, push, pull, etc.)
=== ./integrated_ivcs/models/branch_manager.py ===
from odoo import models, fields, api
from git import Repo, GitCommandError
import json
from nostr.event import Event
from nostr.key import PrivateKey
import logging

_logger = logging.getLogger(__name__)

class BranchManager(models.Model):
    _name = 'ivcs.branch.manager'
    _description = 'IVCS Branch Manager'

    name = fields.Char(string='Name', required=True)
    item_id = fields.Many2one('ivcs.item', string='IVCS Item', required=True)

    def create_branch(self, branch_name):
        self.ensure_one()
        repo = Repo(self.item_id.repo_path)
        if branch_name not in repo.heads:
            repo.create_head(branch_name)
            self._create_branch_event(branch_name, 'create')
            return True
        return False

    def delete_branch(self, branch_name):
        self.ensure_one()
        repo = Repo(self.item_id.repo_path)
        if branch_name in repo.heads:
            repo.delete_head(branch_name, force=True)
            self._create_branch_event(branch_name, 'delete')
            return True
        return False

    def update_branch(self, branch_name, new_commit):
        self.ensure_one()
        repo = Repo(self.item_id.repo_path)
        if branch_name in repo.heads:
            branch = repo.heads[branch_name]
            branch.set_commit(new_commit)
            self._create_branch_event(branch_name, 'update', new_commit)
            return True
        return False

    def merge_branches(self, source_branch, target_branch):
        self.ensure_one()
        repo = Repo(self.item_id.repo_path)
        if source_branch in repo.heads and target_branch in repo.heads:
            try:
                repo.git.checkout(target_branch)
                repo.git.merge(source_branch)
                self._create_branch_event(target_branch, 'merge', source_branch)
                return True
            except GitCommandError as e:
                _logger.error(f"Merge conflict: {str(e)}")
                repo.git.merge('--abort')
                return False
        return False

    def _create_branch_event(self, branch_name, action, additional_info=None):
        if not self.item_id.nostr_private_key:
            _logger.warning(f"No Nostr private key for item {self.item_id.name}")
            return

        private_key = PrivateKey(bytes.fromhex(self.item_id.nostr_private_key))
        content = {
            "action": action,
            "branch_name": branch_name,
            "repo_name": self.item_id.name
        }
        if additional_info:
            content["additional_info"] = additional_info

        event = Event(
            kind=31227,
            content=json.dumps(content),
            tags=[['r', self.item_id.repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)
        
        self.env['nostr.event'].create_and_publish(event)

    def list_branches(self):
        self.ensure_one()
        repo = Repo(self.item_id.repo_path)
        return [head.name for head in repo.heads]

    def reconstruct_branches_from_events(self):
        self.ensure_one()
        events = self.env['nostr.event'].search([
            ('kind', '=', 31227),
            ('tags', 'ilike', self.item_id.repo_path)
        ], order='created_at asc')

        branches = {}
        for event in events:
            content = json.loads(event.content)
            action = content.get('action')
            branch_name = content.get('branch_name')

            if action == 'create':
                branches[branch_name] = {'created_at': event.created_at}
            elif action == 'delete':
                branches.pop(branch_name, None)
            elif action == 'update':
                if branch_name in branches:
                    branches[branch_name]['last_updated'] = event.created_at
            elif action == 'merge':
                if branch_name in branches:
                    branches[branch_name]['last_merged'] = event.created_at
                    branches[branch_name]['merged_from'] = content.get('additional_info')

        return branches
=== ./integrated_ivcs/__init__.py ===
from . import models
from . import wizards
=== ./integrated_ivcs/wizards/create_commit_wizard_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_create_commit_wizard_form" model="ir.ui.view">
        <field name="name">create.commit.wizard.form</field>
        <field name="model">create.commit.wizard</field>
        <field name="arch" type="xml">
            <form string="Create Commit">
                <group>
                    <field name="item_id"/>
                    <field name="message"/>
                </group>
                <footer>
                    <button name="action_create_commit" string="Create Commit" type="object" class="btn-primary"/>
                    <button string="Cancel" class="btn-secondary" special="cancel"/>
                </footer>
            </form>
        </field>
    </record>

    <record id="action_create_commit_wizard" model="ir.actions.act_window">
        <field name="name">Create Commit</field>
        <field name="res_model">create.commit.wizard</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
    </record>
</odoo>
=== ./integrated_ivcs/wizards/__init__.py ===
from . import create_branch_wizard
from . import create_commit_wizard
=== ./integrated_ivcs/wizards/create_commit_wizard.py ===
from odoo import models, fields, api

class CreateCommitWizard(models.TransientModel):
    _name = 'create.commit.wizard'
    _description = 'Create Commit Wizard'

    item_id = fields.Many2one('ivcs.item', string='IVCS Item', required=True)
    message = fields.Text(string='Commit Message', required=True)

    def action_create_commit(self):
        self.ensure_one()
        repo = self.env['git.repository'].search([('path', '=', self.item_id.repo_path)])
        commit_hash = repo.commit_changes(self.message)
        self.env['ivcs.commit'].create({
            'hash': commit_hash,
            'message': self.message,
            'author': self.env.user.name,
            'date': fields.Datetime.now(),
            'item_id': self.item_id.id,
        })
        return {'type': 'ir.actions.act_window_close'}
=== ./integrated_ivcs/wizards/create_branch_wizard.py ===
from odoo import models, fields, api

class CreateBranchWizard(models.TransientModel):
    _name = 'create.branch.wizard'
    _description = 'Create Branch Wizard'

    item_id = fields.Many2one('ivcs.item', string='IVCS Item', required=True)
    branch_name = fields.Char(string='Branch Name', required=True)

    def action_create_branch(self):
        self.ensure_one()
        return self.item_id.create_branch(self.branch_name)
=== ./integrated_ivcs/wizards/create_branch_wizard_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_create_branch_wizard_form" model="ir.ui.view">
        <field name="name">create.branch.wizard.form</field>
        <field name="model">create.branch.wizard</field>
        <field name="arch" type="xml">
            <form string="Create Branch">
                <group>
                    <field name="item_id"/>
                    <field name="branch_name"/>
                </group>
                <footer>
                    <button name="action_create_branch" string="Create Branch" type="object" class="btn-primary"/>
                    <button string="Cancel" class="btn-secondary" special="cancel"/>
                </footer>
            </form>
        </field>
    </record>

    <record id="action_create_branch_wizard" model="ir.actions.act_window">
        <field name="name">Create Branch</field>
        <field name="res_model">create.branch.wizard</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
    </record>
</odoo>
=== ./integrated_ivcs/cli.py ===
import argparse
import os
import git
from nostr.event import Event
from nostr.key import PrivateKey
import json
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class GitNostrCLI:
    def __init__(self, repo_path):
        self.repo_path = repo_path
        self.repo = git.Repo(repo_path)
        self.private_key = PrivateKey()

    def create_branch(self, branch_name):
        logger.info(f"Creating branch: {branch_name}")
        self.repo.create_head(branch_name)
        self._create_branch_event(branch_name, 'create')
        logger.info(f"Branch {branch_name} created successfully")

    def delete_branch(self, branch_name):
        logger.info(f"Deleting branch: {branch_name}")
        self.repo.delete_head(branch_name, force=True)
        self._create_branch_event(branch_name, 'delete')
        logger.info(f"Branch {branch_name} deleted successfully")

    def merge_branches(self, source_branch, target_branch):
        logger.info(f"Merging {source_branch} into {target_branch}")
        self.repo.git.checkout(target_branch)
        try:
            self.repo.git.merge(source_branch)
            self._create_branch_event(target_branch, 'merge', source_branch)
            logger.info(f"Merged {source_branch} into {target_branch} successfully")
        except git.GitCommandError as e:
            logger.error(f"Merge conflict: {str(e)}")
            self.repo.git.merge('--abort')
            logger.info("Merge aborted due to conflicts")

    def commit_changes(self, message):
        logger.info(f"Committing changes with message: {message}")
        self.repo.git.add(A=True)
        commit = self.repo.index.commit(message)
        self._create_commit_event(commit)
        logger.info(f"Changes committed successfully. Commit hash: {commit.hexsha}")

    def _create_branch_event(self, branch_name, action, additional_info=None):
        logger.info(f"Creating Nostr event for branch action: {action}")
        content = {
            "action": action,
            "branch_name": branch_name,
            "repo_name": os.path.basename(self.repo_path)
        }
        if additional_info:
            content["additional_info"] = additional_info

        event = Event(
            kind=31227,
            content=json.dumps(content),
            tags=[['r', self.repo_path]],
            public_key=self.private_key.public_key.hex()
        )
        self.private_key.sign_event(event)
        logger.info(f"Nostr event created: {event.id}")
        # Here you would typically publish the event to Nostr relays

    def _create_commit_event(self, commit):
        logger.info(f"Creating Nostr event for commit: {commit.hexsha}")
        content = json.dumps({
            "action": "commit",
            "message": commit.message,
            "author": commit.author.name,
            "email": commit.author.email,
            "date": commit.authored_datetime.isoformat(),
            "hash": commit.hexsha,
            "parent_hashes": [c.hexsha for c in commit.parents],
            "tree_hash": commit.tree.hexsha,
        })
        
        event = Event(
            kind=3121,
            content=content,
            tags=[
                ["r", self.repo_path],
                ["h", commit.hexsha],
            ],
            public_key=self.private_key.public_key.hex()
        )
        self.private_key.sign_event(event)
        logger.info(f"Nostr event created: {event.id}")
        # Here you would typically publish the event to Nostr relays

def main():
    parser = argparse.ArgumentParser(description="Git-Nostr CLI")
    parser.add_argument('repo_path', help="Path to the Git repository")
    parser.add_argument('action', choices=['create-branch', 'delete-branch', 'merge-branches', 'commit'])
    parser.add_argument('--branch-name', help="Name of the branch (for create-branch and delete-branch)")
    parser.add_argument('--source-branch', help="Source branch for merge")
    parser.add_argument('--target-branch', help="Target branch for merge")
    parser.add_argument('--commit-message', help="Commit message")

    args = parser.parse_args()

    cli = GitNostrCLI(args.repo_path)

    if args.action == 'create-branch':
        cli.create_branch(args.branch_name)
    elif args.action == 'delete-branch':
        cli.delete_branch(args.branch_name)
    elif args.action == 'merge-branches':
        cli.merge_branches(args.source_branch, args.target_branch)
    elif args.action == 'commit':
        cli.commit_changes(args.commit_message)

if __name__ == "__main__":
    main()
=== ./integrated_ivcs/__manifest__.py ===
{
    'name': 'Integrated IVCS',
    'version': '1.0',
    'category': 'Development',
    'summary': 'Integrated Version Control System with Git and Nostr',
    'author': 'Your Name',
    'website': 'https://www.example.com',
    'depends': ['base', 'mail'],
    'data': [
        'security/ir.model.access.csv',
        'views/ivcs_item_views.xml',
        'views/ivcs_version_views.xml',
        'views/ivcs_commit_views.xml',
        'views/git_repository_views.xml',
        'views/nostr_event_views.xml',
        'views/res_config_settings_views.xml',
        'wizards/create_branch_wizard_views.xml',
        'wizards/create_commit_wizard_views.xml',
    ],
    'external_dependencies': {
        'python': ['git', 'nostr'],
    },
    'installable': True,
    'application': True,
    'auto_install': False,
}
=== ./integrated_ivcs/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_ivcs_item_user,ivcs.item user,model_ivcs_item,base.group_user,1,1,1,1
access_ivcs_version_user,ivcs.version user,model_ivcs_version,base.group_user,1,1,1,1
access_ivcs_commit_user,ivcs.commit user,model_ivcs_commit,base.group_user,1,1,1,1
access_git_repository_user,git.repository user,model_git_repository,base.group_user,1,1,1,1
access_nostr_event_user,nostr.event user,model_nostr_event,base.group_user,1,1,1,1
access_ivcs_branch_manager_user,ivcs.branch.manager user,model_ivcs_branch_manager,base.group_user,1,1,1,1
access_create_branch_wizard_user,create.branch.wizard user,model_create_branch_wizard,base.group_user,1,1,1,0
access_create_commit_wizard_user,create.commit.wizard user,model_create_commit_wizard,base.group_user,1,1,1,0
=== ./integrated_ivcs/tests/test_git_nostr_integration.py ===
import unittest
import tempfile
import os
import git
import json
from nostr.event import Event
from nostr.key import PrivateKey
from odoo.tests.common import TransactionCase
from odoo.exceptions import UserError

class TestGitNostrIntegration(TransactionCase):

    def setUp(self):
        super(TestGitNostrIntegration, self).setUp()
        self.IVCSItem = self.env['ivcs.item']
        self.NostrEvent = self.env['nostr.event']
        self.temp_dir = tempfile.mkdtemp()
        self.repo_path = os.path.join(self.temp_dir, 'test_repo')

    def tearDown(self):
        super(TestGitNostrIntegration, self).tearDown()
        if os.path.exists(self.temp_dir):
            import shutil
            shutil.rmtree(self.temp_dir)

    def test_create_repository(self):
        item = self.IVCSItem.create({
            'name': 'Test Repo',
            'description': 'Test repository',
            'repo_path': self.repo_path,
        })
        self.assertTrue(os.path.exists(self.repo_path))
        self.assertTrue(os.path.exists(os.path.join(self.repo_path, '.git')))
        self.assertTrue(os.path.exists(os.path.join(self.repo_path, 'README.md')))

    def test_create_branch(self):
        item = self.IVCSItem.create({
            'name': 'Test Repo',
            'description': 'Test repository',
            'repo_path': self.repo_path,
        })
        result = item.create_branch('test-branch')
        self.assertEqual(result['type'], 'ir.actions.client')
        self.assertEqual(result['params']['type'], 'success')
        repo = git.Repo(self.repo_path)
        self.assertIn('test-branch', repo.heads)

    def test_merge_branches(self):
        item = self.IVCSItem.create({
            'name': 'Test Repo',
            'description': 'Test repository',
            'repo_path': self.repo_path,
        })
        item.create_branch('branch1')
        item.create_branch('branch2')
        repo = git.Repo(self.repo_path)
        repo.heads.branch1.checkout()
        with open(os.path.join(self.repo_path, 'file1.txt'), 'w') as f:
            f.write('Content in branch1')
        repo.index.add(['file1.txt'])
        repo.index.commit('Commit in branch1')
        
        result = item.merge_branches('branch1', 'branch2')
        self.assertEqual(result['type'], 'ir.actions.client')
        self.assertEqual(result['params']['type'], 'success')
        
        repo.heads.branch2.checkout()
        self.assertTrue(os.path.exists(os.path.join(self.repo_path, 'file1.txt')))

    def test_create_nostr_events(self):
        item = self.IVCSItem.create({
            'name': 'Test Repo',
            'description': 'Test repository',
            'repo_path': self.repo_path,
        })
        repo = git.Repo(self.repo_path)
        with open(os.path.join(self.repo_path, 'test.txt'), 'w') as f:
            f.write('Test content')
        repo.index.add(['test.txt'])
        commit = repo.index.commit('Test commit')
        
        event = self.NostrEvent.create_git_event(self.repo_path, commit.hexsha)
        self.assertEqual(event.kind, 3121)
        self.assertIn(commit.hexsha, event.content)

    def test_reconstruct_git_objects(self):
        item = self.IVCSItem.create({
            'name': 'Test Repo',
            'description': 'Test repository',
            'repo_path': self.repo_path,
        })
        repo = git.Repo(self.repo_path)
        with open(os.path.join(self.repo_path, 'test.txt'), 'w') as f:
            f.write('Test content')
        repo.index.add(['test.txt'])
        commit = repo.index.commit('Test commit')
        
        self.NostrEvent.create_git_event(self.repo_path, commit.hexsha)
        
        # Delete the .git directory to simulate a fresh repository
        import shutil
        shutil.rmtree(os.path.join(self.repo_path, '.git'))
        
        # Reconstruct the repository from Nostr events
        self.NostrEvent.reconstruct_git_objects(self.repo_path)
        
        reconstructed_repo = git.Repo(self.repo_path)
        self.assertIn(commit.hexsha, reconstructed_repo.heads.master.commit.hexsha)
        self.assertTrue(os.path.exists(os.path.join(self.repo_path, 'test.txt')))

if __name__ == '__main__':
    unittest.main()
=== ./integrated_ivcs/views/res_config_settings_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="res_config_settings_view_form" model="ir.ui.view">
        <field name="name">res.config.settings.view.form.inherit.integrated_ivcs</field>
        <field name="model">res.config.settings</field>
        <field name="inherit_id" ref="base.res_config_settings_view_form"/>
        <field name="arch" type="xml">
            <xpath expr="//div[hasclass('settings')]" position="inside">
                <div class="app_settings_block" data-string="Integrated IVCS" string="Integrated IVCS" data-key="integrated_ivcs">
                    <h2>Nostr Settings</h2>
                    <div class="row mt16 o_settings_container">
                        <div class="col-12 col-lg-6 o_setting_box">
                            <div class="o_setting_left_pane"/>
                            <div class="o_setting_right_pane">
                                <span class="o_form_label">Nostr Relay URLs</span>
                                <div class="text-muted">
                                    Comma-separated list of Nostr relay URLs
                                </div>
                                <div class="content-group">
                                    <field name="integrated_ivcs_relay_urls"/>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </xpath>
        </field>
    </record>
</odoo>
=== ./integrated_ivcs/views/ivcs_version_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_ivcs_version_form" model="ir.ui.view">
        <field name="name">ivcs.version.form</field>
        <field name="model">ivcs.version</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="description"/>
                        <field name="item_id"/>
                        <field name="commit_id"/>
                        <field name="create_date"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_ivcs_version_tree" model="ir.ui.view">
        <field name="name">ivcs.version.tree</field>
        <field name="model">ivcs.version</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="item_id"/>
                <field name="create_date"/>
            </tree>
        </field>
    </record>

    <record id="action_ivcs_version" model="ir.actions.act_window">
        <field name="name">IVCS Versions</field>
        <field name="res_model">ivcs.version</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_ivcs_version" name="Versions" parent="menu_ivcs_root" action="action_ivcs_version"/>
</odoo>
=== ./integrated_ivcs/views/nostr_event_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_nostr_event_form" model="ir.ui.view">
        <field name="name">nostr.event.form</field>
        <field name="model">nostr.event</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="event_id"/>
                        <field name="kind"/>
                        <field name="event_type"/>
                        <field name="content"/>
                        <field name="tags"/>
                        <field name="public_key"/>
                        <field name="created_at"/>
                        <field name="signature"/>
                        <field name="published"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_nostr_event_tree" model="ir.ui.view">
        <field name="name">nostr.event.tree</field>
        <field name="model">nostr.event</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="event_id"/>
                <field name="kind"/>
                <field name="event_type"/>
                <field name="public_key"/>
                <field name="created_at"/>
                <field name="published"/>
            </tree>
        </field>
    </record>

    <record id="action_nostr_event" model="ir.actions.act_window">
        <field name="name">Nostr Events</field>
        <field name="res_model">nostr.event</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_nostr_event" name="Nostr Events" parent="menu_ivcs_root" action="action_nostr_event"/>
</odoo>
=== ./integrated_ivcs/views/ivcs_item_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_ivcs_item_form" model="ir.ui.view">
        <field name="name">ivcs.item.form</field>
        <field name="model">ivcs.item</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="description"/>
                        <field name="repo_path"/>
                        <field name="current_branch"/>
                        <field name="current_version_id"/>
                        <field name="nostr_private_key" password="True"/>
                    </group>
                    <notebook>
                        <page string="Versions">
                            <field name="version_ids"/>
                        </page>
                        <page string="Commits">
                            <field name="commit_ids"/>
                        </page>
                    </notebook>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_ivcs_item_tree" model="ir.ui.view">
        <field name="name">ivcs.item.tree</field>
        <field name="model">ivcs.item</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="repo_path"/>
                <field name="current_branch"/>
                <field name="current_version_id"/>
            </tree>
        </field>
    </record>

    <record id="action_ivcs_item" model="ir.actions.act_window">
        <field name="name">IVCS Items</field>
        <field name="res_model">ivcs.item</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_ivcs_root" name="Integrated IVCS"/>
    <menuitem id="menu_ivcs_item" name="IVCS Items" parent="menu_ivcs_root" action="action_ivcs_item"/>
</odoo>
=== ./integrated_ivcs/views/git_repository_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_repository_form" model="ir.ui.view">
        <field name="name">git.repository.form</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="path"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_git_repository_tree" model="ir.ui.view">
        <field name="name">git.repository.tree</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="path"/>
            </tree>
        </field>
    </record>

    <record id="action_git_repository" model="ir.actions.act_window">
        <field name="name">Git Repositories</field>
        <field name="res_model">git.repository</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_git_repository" name="Git Repositories" parent="menu_ivcs_root" action="action_git_repository"/>
</odoo>
=== ./integrated_ivcs/views/ivcs_commit_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_ivcs_commit_form" model="ir.ui.view">
        <field name="name">ivcs.commit.form</field>
        <field name="model">ivcs.commit</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="hash"/>
                        <field name="message"/>
                        <field name="author"/>
                        <field name="date"/>
                        <field name="item_id"/>
                        <field name="version_id"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_ivcs_commit_tree" model="ir.ui.view">
        <field name="name">ivcs.commit.tree</field>
        <field name="model">ivcs.commit</field>
        <field name="arch" type="xml">
            <tree>
                <field name="hash"/>
                <field name="message"/>
                <field name="author"/>
                <field name="date"/>
                <field name="item_id"/>
            </tree>
        </field>
    </record>

    <record id="action_ivcs_commit" model="ir.actions.act_window">
        <field name="name">IVCS Commits</field>
        <field name="res_model">ivcs.commit</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_ivcs_commit" name="Commits" parent="menu_ivcs_root" action="action_ivcs_commit"/>
</odoo>







Additional considerations:


The attached codebase does not directly implement the specific Nostr event kinds and structures as defined by Snub (31228, 31227, 3121, 3122, 3123) in the way described in the prompt. While the codebase does include some Nostr-related functionality, it doesn't match the exact requirements outlined in the prompt. Here's a breakdown:

1. The codebase does not contain separate classes for each event type inheriting from a base NostrEvent class.

2. There are no specific methods for serialization to JSON and deserialization from JSON for each event type.

3. The validation for required and optional fields for each event type is not explicitly implemented as described in the prompt.

4. The unit tests specifically requested in the prompt are not present.

However, the codebase does show integration with Odoo and includes some Nostr-related functionality:

1. There is a `NostrEvent` model in `integrated_ivcs/models/nostr_event.py` which handles some Nostr event creation and publishing.

2. The `create_git_event`, `create_tree_event`, and `create_blob_event` methods in the `NostrEvent` model do use some of the event kinds mentioned (3121, 3122, 3123).

3. The codebase is integrated into Odoo, with proper model definitions, views, and manifest files.

4. There are some methods for creating and publishing Nostr events, but they don't fully match the structure requested in the prompt.

In conclusion, while the codebase does implement some Nostr functionality and is integrated into Odoo, it does not strictly adhere to the specific requirements outlined in the prompt. The implementation is more focused on integrating Nostr events with Git operations in an Odoo environment, rather than creating a standalone Python script with the specified event classes and unit tests.




Based on the provided codebase, the system does partially implement the functionality described in the prompt, but it's not a complete or standalone implementation. It is integrated into Odoo, but some aspects are missing or not fully developed. Let's break it down:

1. Git tree and blob representation:
   - The system does have support for git trees and blobs as Nostr events.
   - In `integrated_ivcs/models/nostr_event.py`, there are methods `create_tree_event` and `create_blob_event` that create Nostr events for git trees and blobs (kinds 3122 and 3123).

2. GitTree and GitBlob classes:
   - There are no separate `GitTree` and `GitBlob` classes as described in the prompt.
   - Instead, the functionality is integrated into the `NostrEvent` model in Odoo.

3. Serialization and deserialization:
   - The system implements serialization of git objects into Nostr events.
   - Deserialization is partially implemented in the `reconstruct_git_objects` method.

4. Repository traversal and reconstruction:
   - The `sync_git_nostr` method in the `NostrEvent` model traverses a git repository and converts objects into Nostr events.
   - The `reconstruct_git_objects` method attempts to reconstruct a repository from Nostr events.

5. Testing:
   - There is a test file `integrated_ivcs/tests/test_git_nostr_integration.py` that includes some tests for the functionality.
   - However, the tests are not as comprehensive as described in the prompt, and they're integrated into Odoo's testing framework rather than being standalone console tests.

6. Odoo integration:
   - The functionality is integrated into Odoo models, views, and actions.
   - There are appropriate Odoo model definitions, views, and menu items for interacting with the git-nostr functionality.

In conclusion:
The system does implement significant parts of the requested functionality and integrates it into Odoo. However, it doesn't fully match the prompt's requirements:

1. It lacks separate `GitTree` and `GitBlob` classes.
2. The serialization and deserialization are not as clearly defined as requested.
3. The testing is not as comprehensive as described and is not designed for a standalone console environment.
4. The implementation is tightly coupled with Odoo, rather than being a separate Python script that could work independently.

While the core ideas are present and integrated into Odoo, the implementation doesn't fully meet the standalone nature and comprehensive testing described in the prompt. It's more of an Odoo-specific implementation of git-nostr integration rather than a standalone Python script with the specified classes and console-based testing.





The system does implement some aspects of the prompt, but it's not a full implementation of the described BranchManager class. Let's analyze the implementation:

1. BranchManager class:
   - There is a `BranchManager` model in `integrated_ivcs/models/branch_manager.py`.
   - It's implemented as an Odoo model rather than a standalone Python class.

2. Branch operations:
   - The class includes methods for creating branches (`create_branch`), deleting branches (`delete_branch`), and updating branches (`update_branch`).
   - There's also a `merge_branches` method, which goes beyond the basic operations mentioned in the prompt.

3. Nostr event generation:
   - Branch operations do generate Nostr events using kind 31227, as specified in the prompt.
   - This is implemented in the `_create_branch_event` method.

4. Branch reconstruction:
   - There's a `reconstruct_branches_from_events` method that attempts to reconstruct the branch structure from Nostr events.

5. Listing branches:
   - The `list_branches` method is implemented to list all branches in the repository.

6. Integration with Odoo:
   - The BranchManager is fully integrated into the Odoo framework as a model.
   - It's associated with the `ivcs.item` model, which represents a repository.

7. Testing:
   - There are no specific tests for the BranchManager in the provided codebase.
   - The testing described in the prompt (covering branch creation, deletion, updating, and reconstruction from events) is not present.

8. Console verification:
   - As this is implemented as an Odoo module, there's no direct console interface for testing as described in the prompt.

In conclusion:
The system partially implements the functionality described in the prompt and integrates it into Odoo. However, there are some key differences and missing elements:

1. It's implemented as an Odoo model rather than a standalone Python class.
2. While core branch operations are implemented, they're adapted to work within the Odoo framework.
3. The testing described in the prompt is not implemented.
4. There's no console interface for direct testing as described.
5. The handling of complex scenarios like multiple branches and merges is partially implemented but not extensively tested.

The implementation is tailored for integration with Odoo rather than being a standalone system that can be tested from the console. While it covers many of the core concepts described in the prompt, it doesn't fully meet the requirements of a standalone BranchManager class with comprehensive console-based testing.





Based on the provided codebase, the system partially implements some aspects of the RepositoryAnchor functionality described in the prompt, but it's not a complete or standalone implementation. Let's analyze the implementation:

1. RepositoryAnchor class:
   - There isn't a specific `RepositoryAnchor` class as described in the prompt.
   - Some of the functionality is spread across different Odoo models, particularly in `integrated_ivcs/models/ivcs_item.py` and `integrated_ivcs/models/nostr_event.py`.

2. Anchor event creation (kind 31228):
   - The `_create_nostr_repo_event` method in the `IVCSItem` model creates an event of kind 31228 for repository anchoring.

3. Updating anchor:
   - There's no specific method for updating the anchor event when maintainers change.

4. Resolving repository state:
   - The system doesn't have a dedicated method to resolve the current state of a repository from its anchor event.

5. Maintainer management:
   - There's no explicit method for listing maintainers or checking permissions based on the anchor event.

6. Repository forking:
   - The provided code doesn't include specific functionality for handling repository forking as described in the prompt.

7. Integration with git object and branch management:
   - The system does integrate with git object management (commits, trees, blobs) and has some branch management functionality, but it's not explicitly tied to the anchoring mechanism as described in the prompt.

8. Testing:
   - There are no specific tests for the repository anchoring functionality as described in the prompt.

9. Odoo Integration:
   - The implemented functionality is integrated into Odoo models and views, rather than being a standalone class.

10. Console verification:
    - As this is implemented as an Odoo module, there's no direct console interface for testing as described in the prompt.

In conclusion:
The system partially implements some concepts related to repository anchoring and integrates them into Odoo, but it doesn't fully match the requirements outlined in the prompt:

1. There's no standalone RepositoryAnchor class; the functionality is spread across Odoo models.
2. While there is basic support for creating anchor events, many of the specified methods (updating anchors, resolving state, listing maintainers, checking permissions, forking) are either missing or not fully implemented.
3. The testing described in the prompt is not present.
4. There's no console interface for direct testing as described.

The implementation is designed to work within the Odoo framework rather than as a standalone system that can be tested from the console. While it touches on some of the concepts described in the prompt, it doesn't fully meet the requirements of a comprehensive RepositoryAnchor class with the specified functionality and testing capabilities.






Based on the analysis of the existing codebase and the requirements outlined in the prompts, here's a deep dive into what needs to be done to fully implement the Git-Nostr integration:

1. Nostr Event Kinds Implementation:

- Create a base `NostrEvent` class with common attributes and methods.
- Implement separate classes for each event kind (31228, 31227, 3121, 3122, 3123) inheriting from `NostrEvent`.
- For each class, implement:
  - Proper validation for required and optional fields
  - Serialization to JSON
  - Deserialization from JSON
  - Any kind-specific methods (e.g., specific getters/setters)
- Write comprehensive unit tests for each event type
- Ensure these classes can work independently of Odoo

This foundation will allow for consistent handling of different Nostr event types related to Git operations.

2. Git Object Representation:

- Implement `GitTree` and `GitBlob` classes that can:
  - Serialize git tree and blob objects into Nostr events (kinds 3122 and 3123)
  - Deserialize Nostr events back into git objects
- Enhance the existing git commit representation to work seamlessly with trees and blobs
- Create methods to traverse a git repository and convert all objects (commits, trees, blobs) into Nostr events
- Implement repository reconstruction from a set of Nostr events
- Develop comprehensive tests for serialization, deserialization, traversal, and reconstruction

This will enable full representation of Git repositories in Nostr events, allowing for decentralized storage and sharing of repositories.

3. Branch Management:

- Develop a standalone `BranchManager` class (not tied to Odoo) that:
  - Creates branches and generates corresponding Nostr events (kind 31227)
  - Updates branch heads
  - Deletes branches
  - Lists all branches in a repository
  - Handles merges between branches
- Implement methods to reconstruct the branch structure from Nostr events
- Create comprehensive tests for all branch operations and reconstruction
- Ensure the `BranchManager` can handle complex scenarios like multiple branches and merges

This will allow for decentralized management of Git branches using Nostr events.

4. Repository Anchoring:

- Create a standalone `RepositoryAnchor` class that:
  - Generates the initial anchor event (kind 31228) for a new repository
  - Updates the anchor event when repository details change (e.g., maintainers)
  - Resolves the current state of a repository from its anchor event
  - Lists maintainers and checks permissions based on the anchor event
  - Handles repository forking
- Implement methods to integrate anchoring with git object and branch management
- Develop tests for anchor creation, updates, permission checks, and fork management

This will provide a robust mechanism for managing repository metadata and permissions in a decentralized manner.

5. Integration and Consilidation:

- Create a high-level `GitNostrManager` class that:
  - Utilizes all the above components (NostrEvents, GitObjects, BranchManager, RepositoryAnchor)
  - Provides a unified interface for all Git-Nostr operations
  - Handles the flow of data between different components
- Implement comprehensive integration tests that cover end-to-end scenarios

This will tie all the components together into a cohesive system.

6. Odoo Integration:

- Create Odoo models that wrap the standalone classes:
  - `NostrEventModel` that can create and manage different types of Nostr events
  - `GitRepositoryModel` that uses `GitNostrManager` for repository operations
  - `BranchManagerModel` that interfaces with the `BranchManager` class
  - `RepositoryAnchorModel` that manages repository anchoring within Odoo
- Implement Odoo views and controllers to interact with these models
- Ensure all Odoo-specific code is separate from the core Git-Nostr logic

This will allow the Git-Nostr functionality to be used within Odoo while maintaining the ability to use it independently.

7. Console Interface:

- Develop a command-line interface that interacts with the `GitNostrManager`
- Implement commands for all major operations (create repository, commit, branch, merge, etc.)
- Create a test suite that uses this console interface to verify functionality

This will provide a way to test and use the system outside of Odoo.

8. Documentation and Examples:

- Write detailed documentation for each component
- Create example scripts demonstrating various use cases
- Provide guidelines for extending the system

To implement this, you'd start by creating the core classes and their unit tests. Then, build the integration layer (`GitNostrManager`) and its tests. After that, implement the Odoo integration and the console interface. Throughout the process, maintain a separation between the core Git-Nostr logic and the Odoo-specific code to ensure the system can function both within and outside of Odoo.

This approach will result in a flexible, well-tested system that fully implements the Git-Nostr integration as described in the prompts, while also providing Odoo integration for those who need it.






You've provided excellent suggestions that will indeed enhance the integration of Git with Nostr and create a more robust, user-friendly, and secure system. Let's dive deeper into each of these points and discuss how they can be implemented:

1. Detailed Documentation:
   - Create a comprehensive API reference for all classes and methods.
   - Write tutorials covering basic to advanced usage scenarios.
   - Use tools like Sphinx or MkDocs to generate navigable documentation.
   - Include inline comments in the code for better maintainability.

2. Security Considerations:
   - Implement encryption for storing private keys, possibly using libraries like cryptography.
   - Use OAuth or a similar protocol for user authentication in Odoo.
   - Implement role-based access control (RBAC) for repository operations.
   - Regularly audit the codebase for security vulnerabilities.

3. Error Handling:
   - Create custom exception classes for different types of errors (e.g., NostrConnectionError, GitOperationError).
   - Implement proper exception handling and logging throughout the codebase.
   - Develop a user-friendly error reporting system in the Odoo interface.

4. Performance Optimization:
   - Use caching mechanisms to store frequently accessed data (e.g., repository metadata).
   - Implement pagination for large datasets (e.g., when listing commits or branches).
   - Use asynchronous programming (e.g., asyncio in Python) for I/O-bound operations like Nostr event publishing.

5. Testing:
   - Use a testing framework like pytest for unit and integration tests.
   - Implement property-based testing for complex operations using libraries like Hypothesis.
   - Set up continuous integration (CI) to run tests automatically on each commit.
   - Create a comprehensive test suite covering all components and their interactions.

6. User Interface:
   - Design intuitive forms and views in Odoo for repository management.
   - Implement real-time notifications for long-running operations.
   - Use Odoo's QWeb framework to create dynamic, responsive interfaces.
   - Consider adding visualizations (e.g., commit graphs) using libraries like D3.js.

7. Scalability:
   - Implement database indexing for frequently queried fields.
   - Use background jobs (e.g., Odoo's queue_job module) for time-consuming tasks.
   - Consider implementing sharding for large-scale deployments.
   - Optimize database queries to handle large volumes of data efficiently.

8. Interoperability:
   - Provide clear documentation on how to import existing Git repositories.
   - Implement export functionality to standard Git formats.
   - Ensure compatibility with common Git workflows (e.g., GitFlow, GitHub Flow).
   - Create hooks or plugins for popular Git hosting platforms (e.g., GitHub, GitLab).

9. Community Feedback:
   - Set up a public repository for the project on GitHub or GitLab.
   - Implement a system for tracking feature requests and bug reports (e.g., using GitHub Issues).
   - Create a roadmap for future development and share it with the community.
   - Consider setting up a discussion forum or chat channel for user support.

10. CLI Integration:
    - Use a library like Click or argparse to create a user-friendly CLI.
    - Implement shell completion for CLI commands.
    - Ensure the CLI can be used both with local Git repositories and Odoo-managed ones.
    - Provide options for output formatting (e.g., JSON, YAML) for easy integration with other tools.

Additional considerations:

11. Versioning and Migrations:
    - Implement a clear versioning system for your Odoo module.
    - Provide migration scripts for updates that change data structures.

12. Localization:
    - Use Odoo's built-in translation system to make the interface multilingual.
    - Ensure all user-facing strings are translatable.

13. API Development:
    - Create a RESTful API to allow third-party integrations.
    - Use OpenAPI (Swagger) to document the API endpoints.

14. Monitoring and Logging:
    - Implement comprehensive logging throughout the system.
    - Consider integrating with monitoring tools like Prometheus for production deployments.

By addressing these points, you'll create a robust, scalable, and user-friendly system that integrates Git with Nostr while leveraging Odoo's capabilities. This approach will result in a solution that's not only powerful but also accessible to a wide range of users, from developers working via CLI to non-technical users managing repositories through the Odoo interface.





Absolutely! Adding example items or demo data to each part of these new modules is an excellent idea. It provides users with a practical understanding of how the system works and serves as a template for their own usage. Here's how you could implement this for different components of the Git-Nostr integration in Odoo:

1. Example Repositories:
   - Create a few sample repositories with different characteristics:
     * A simple "Hello World" project
     * A more complex project with multiple branches
     * A forked repository to demonstrate the forking process

2. Sample Commits:
   - Populate the example repositories with a series of commits:
     * Initial commit with basic project structure
     * Feature addition commits
     * Bug fix commits
     * Merge commits

3. Branch Examples:
   - Create various types of branches in the sample repositories:
     * Main/master branch
     * Feature branches (e.g., "feature/new-login")
     * Hotfix branches (e.g., "hotfix/critical-bug")
     * Release branches (e.g., "release/v1.0")

4. Nostr Events:
   - Generate example Nostr events for each type (31228, 31227, 3121, 3122, 3123):
     * Repository anchor events
     * Branch creation and update events
     * Commit events
     * Tree and blob events

5. User Accounts:
   - Create demo user accounts with different roles:
     * Repository owner
     * Contributor
     * Read-only user

6. Permission Examples:
   - Set up various permission scenarios:
     * Public repository accessible to all
     * Private repository with limited access
     * Repository with multiple collaborators having different access levels

7. Merge and Fork Examples:
   - Include examples of:
     * A successfully merged pull request
     * A fork of one of the sample repositories
     * A merge conflict scenario

8. Anchor Updates:
   - Demonstrate anchor event updates:
     * Initial repository creation
     * Adding a new maintainer
     * Changing repository metadata

9. CLI Command Examples:
   - Provide a script or documentation with example CLI commands:
     * Creating a new repository
     * Making a commit
     * Creating and switching branches
     * Publishing events to Nostr

10. Odoo Views:
    - Populate Odoo views with these examples:
      * List view of repositories
      * Form view of a repository with commits and branches
      * Kanban view for visualizing repository status

Implementation Steps:

1. Data Files:
   - Create XML data files in your Odoo module to define these examples.
   - Use `noupdate="1"` to prevent overwriting user changes on module updates.

2. Demo Flag:
   - Mark these data files as demo data in the module's `__manifest__.py`:
     ```python
     {
         'name': 'Git-Nostr Integration',
         # ... other keys ...
         'demo': [
             'data/demo_repositories.xml',
             'data/demo_commits.xml',
             'data/demo_branches.xml',
             'data/demo_nostr_events.xml',
             'data/demo_users.xml',
         ],
     }
     ```

3. Documentation:
   - In your module's documentation, reference these examples and explain how users can explore them.
   - Provide a guide on how users can recreate similar structures for their own use.

4. Tour:
   - Implement an Odoo tour that guides new users through the example data, explaining each component.

5. Sample Code:
   - In your documentation or as comments in the demo data files, include sample Python code for interacting with these examples programmatically.

Example XML for demo data:

```xml
<odoo>
    <data noupdate="1">
        <!-- Sample Repository -->
        <record id="demo_repo_hello_world" model="ivcs.item">
            <field name="name">Hello World Project</field>
            <field name="description">A simple demo repository</field>
            <field name="repo_path">/path/to/hello_world</field>
        </record>

        <!-- Sample Commit -->
        <record id="demo_commit_initial" model="ivcs.commit">
            <field name="hash">abcdef1234567890</field>
            <field name="message">Initial commit</field>
            <field name="author">Demo User</field>
            <field name="item_id" ref="demo_repo_hello_world"/>
        </record>

        <!-- Sample Branch -->
        <record id="demo_branch_feature" model="ivcs.branch">
            <field name="name">feature/new-login</field>
            <field name="item_id" ref="demo_repo_hello_world"/>
        </record>

        <!-- More examples... -->
    </data>
</odoo>
```

By providing these examples, you give users a concrete starting point to understand and explore the Git-Nostr integration. They can see how different components interact, experiment with the system safely, and use these examples as templates for their own repositories and workflows.
=== ./odoo_custom_addons (copy)/git_nostr_object/models/git_repository.py ===
# models/git_repository.py
from odoo import models, fields, api
import git
import json

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Name', required=True)
    path = fields.Char(string='Path', required=True)
    logs = fields.Text(string='Logs')

    def traverse_and_publish(self):
        self.ensure_one()
        logs = []
        try:
            git_repo = git.Repo(self.path)
            for commit in git_repo.iter_commits():
                nostr_event = self.env['nostr.event.object'].create({
                    'kind': 1,
                    'content': commit.message,
                    'tags': json.dumps([['commit', commit.hexsha]]),
                    'created_at': commit.committed_date,
                })
                nostr_event.action_publish()
                logs.append(f"Published commit {commit.hexsha}")

            self.write({'logs': '\n'.join(logs)})
            self.env['bus.bus']._sendone(self.env.user.partner_id, 'simple_notification', {
                'title': _("Git Repository Traversed"),
                'message': _("All commits published to Nostr network"),
            })
        except Exception as e:
            error_msg = f"Error traversing repository: {e}"
            logs.append(error_msg)
            self.write({'logs': '\n'.join(logs)})
            raise UserError(_(error_msg))

        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _("Git Repository"),
                'message': _("Repository traversed and commits published. Check logs for details."),
                'sticky': False,
                'type': 'success',
            }
        }
=== ./odoo_custom_addons (copy)/git_nostr_object/models/git_commit.py ===
from odoo import models, fields, api
from .git_object import GitObject

class GitCommit(models.Model):
    _name = 'git.commit'
    _inherit = 'git.object'
    _description = 'Git Commit'

    message = fields.Text(string='Commit Message')
    author = fields.Char(string='Author')
    timestamp = fields.Datetime(string='Timestamp')

    def to_nostr_event(self):
        return self.env['nostr.event.object'].create({
            'kind': 3121,
            'content': self.data,
            'tags': [['sha', self.sha]],
        })

    @api.model
    def create_from_nostr_event(self, event):
        git_commit = GitObject.from_nostr_event(event)
        return self.create({
            'sha': git_commit.sha,
            'data': git_commit.data.decode('utf-8', errors='replace'),
            'message': git_commit.message,
            'author': git_commit.author,
            'timestamp': git_commit.timestamp,
        })
    @api.model
    def create_from_git_commit(self, commit):
        return self.create({
            'sha': commit.hexsha,
            'message': commit.message,
            'author': f"{commit.author.name} <{commit.author.email}>",
            'timestamp': commit.committed_datetime,
            'data': commit.tree.data_stream.read().decode('utf-8', errors='replace'),
        })
=== ./odoo_custom_addons (copy)/git_nostr_object/models/nostr_websocket_client.py ===
import websocket
import json
import logging
import time

_logger = logging.getLogger(__name__)

class NostrWebSocketClient:
    def __init__(self, relay_urls):
        self.relay_urls = relay_urls

    def connect_and_publish(self, event_data):
        responses = []
        for url in self.relay_urls:
            try:
                _logger.info(f"Attempting to connect to {url}")
                start_time = time.time()
                ws = websocket.create_connection(url, timeout=10)
                _logger.info(f"Connected to {url} in {time.time() - start_time:.2f} seconds")

                # Construct the message correctly
                message = ["EVENT", event_data]
                _logger.debug(f"Raw event message: {message}")

                ws.send(json.dumps(message))
                _logger.info(f"Sent message to {url} in {time.time() - start_time:.2f} seconds")

                _logger.info(f"Waiting for response from {url}")
                response = ws.recv()
                _logger.info(f"Received response from {url} in {time.time() - start_time:.2f} seconds: {response}")

                responses.append(json.loads(response))
                ws.close()
            except Exception as e:
                _logger.error(f"Error publishing to {url}: {str(e)}")
                responses.append(["ERROR", str(e)])
        return responses
=== ./odoo_custom_addons (copy)/git_nostr_object/models/__init__.py ===
# __init__.py
from . import git_object
from . import git_commit
from . import git_tree
from . import git_blob
from . import git_repository
from . import nostr_event
from . import admin_test
from . import git_commit_wizard
=== ./odoo_custom_addons (copy)/git_nostr_object/models/git_object.py ===
from odoo import models, fields, api

class GitObject(models.AbstractModel):
    _name = 'git.object'
    _description = 'Git Object'

    sha = fields.Char(string='SHA', required=True)
    data = fields.Text(string='Data', required=True)

    def to_nostr_event(self):
        raise NotImplementedError("This method should be implemented by subclasses")

    @api.model
    def create_from_nostr_event(self, event):
        raise NotImplementedError("This method should be implemented by subclasses")
=== ./odoo_custom_addons (copy)/git_nostr_object/models/git_nostr_object.py ===
# models/git_nostr_event.py
from odoo import models, fields, api
from utils.nostr_websocket_client import NostrWebSocketClient
from nostr.event import Event as NostrEvent
import logging
import time
import json

_logger = logging.getLogger(__name__)

class GitNostrEventObject(models.Model):
    _name = 'git_nostr.event.object'
    _description = 'Git Nostr Event Object'

    kind = fields.Integer(string='Event Kind', required=True)
    content = fields.Text(string='Content', required=True)
    tags = fields.Text(string='Tags')
    created_at = fields.Integer(string='Created At', required=True)
    signature = fields.Char(string='Signature', required=True)
    public_key = fields.Char(string='Public Key', required=True)
    published = fields.Boolean(string='Published', default=False)

    def action_publish(self):
        """
        Publish the Nostr event to the configured relays.
        """
        relay_urls = [
            'wss://relay.damus.io',
            'wss://nostr-pub.wellorder.net',
            'wss://nostr.mom',
            'wss://nostr.slothy.win',
            'wss://relay.stoner.com'
        ]

        event_data = {
            'kind': self.kind,
            'content': self.content,
            'tags': self.tags,
            'created_at': self.created_at,
            'pubkey': self.public_key,
            'sig': self.signature,
        }

        websocket_client = NostrWebSocketClient(relay_urls)

        try:
            responses = websocket_client.connect_and_publish(event_data)
            if all(response[0] == 'OK' and response[2] for response in responses):
                self.write({'published': True})
                _logger.info(f"Nostr event successfully published: {self.id}")
            else:
                self.write({'published': False})
                _logger.error(f"Error publishing Nostr event {self.id}: {responses}")
        except Exception as e:
            self.write({'published': False})
            _logger.error(f"Error publishing Nostr event {self.id}: {e}")

    def to_nostr_event(self):
        try:
            tags = json.loads(self.tags) if self.tags else []
        except json.JSONDecodeError:
            _logger.warning(f"Invalid JSON in tags for event {self.id}. Using empty tags list.")
            tags = []

        return NostrEvent(
            kind=self.kind,
            content=self.content,
            tags=tags,
            public_key=self.public_key,
            created_at=self.created_at,
            sig=self.signature
        )
=== ./odoo_custom_addons (copy)/git_nostr_object/models/git_blob.py ===
from odoo import models, fields, api
from .git_object import GitObject

class GitBlob(models.Model):
    _name = 'git.blob'
    _inherit = 'git.object'
    _description = 'Git Blob'

    def to_nostr_event(self):
        return self.env['nostr.event.object'].create({
            'kind': 3123,
            'content': self.data,
            'tags': [['sha', self.sha]],
        })

    @api.model
    def create_from_nostr_event(self, event):
        git_blob = GitObject.from_nostr_event(event)
        return self.create({
            'sha': git_blob.sha,
            'data': git_blob.data.hex(),
        })
=== ./odoo_custom_addons (copy)/git_nostr_object/models/git_tree.py ===
from odoo import models, fields, api
from .git_object import GitObject

class GitTree(models.Model):
    _name = 'git.tree'
    _inherit = 'git.object'
    _description = 'Git Tree'

    def to_nostr_event(self):
        return self.env['nostr.event.object'].create({
            'kind': 3122,
            'content': self.data,
            'tags': [['sha', self.sha]],
        })

    @api.model
    def create_from_nostr_event(self, event):
        git_tree = GitObject.from_nostr_event(event)
        return self.create({
            'sha': git_tree.sha,
            'data': git_tree.data.decode('utf-8', errors='replace'),
        })
=== ./odoo_custom_addons (copy)/git_nostr_object/models/nostr_event.py ===
# models/nostr_event.py
from odoo import models, fields, api, _
from odoo.exceptions import UserError
from ..utils.nostr_websocket_client import NostrWebSocketClient
from nostr.event import Event as NostrEvent
from nostr.key import PrivateKey
import logging
import json
import time

_logger = logging.getLogger(__name__)

class NostrEventObject(models.Model):
    _name = 'nostr.event.object'
    _description = 'Nostr Event Object'

    kind = fields.Integer(string='Event Kind', required=True)
    content = fields.Text(string='Content', required=True)
    tags = fields.Text(string='Tags')
    created_at = fields.Integer(string='Created At', required=True)
    signature = fields.Char(string='Signature')
    public_key = fields.Char(string='Public Key', required=True)
    published = fields.Boolean(string='Published', default=False)
    logs = fields.Text(string='Logs')

    def action_publish(self):
        self.ensure_one()
        if self.published:
            raise UserError(_("This event has already been published."))

        start_time = time.time()
        logs = []

        # Get the user's private key
        user = self.env.user
        private_key_nsec = user.nostr_private_key
        if not private_key_nsec:
            raise UserError(_("Nostr private key is not set for the current user."))

        try:
            private_key = PrivateKey.from_nsec(private_key_nsec)
        except Exception as e:
            raise UserError(_("Invalid Nostr private key: %s") % str(e))

        logs.append(f"Key preparation took {time.time() - start_time:.4f} seconds")

        # Create and sign the Nostr event
        event_creation_start = time.time()
        event = NostrEvent(
            kind=self.kind,
            content=self.content,
            tags=json.loads(self.tags) if self.tags else [],
            public_key=private_key.public_key.hex(),
            created_at=int(time.time())
        )
        private_key.sign_event(event)
        logs.append(f"Event creation and signing took {time.time() - event_creation_start:.4f} seconds")

        # Update the record
        self.write({
            'signature': event.signature,
            'public_key': event.public_key,
            'created_at': event.created_at
        })

        relay_urls = [
            'wss://relay.damus.io',
            'wss://nostr-pub.wellorder.net',
            'wss://nostr.mom',
            'wss://nostr.slothy.win',
            'wss://relay.stoner.com'
        ]

        event_data = json.loads(event.to_message())[1]
        websocket_client = NostrWebSocketClient(relay_urls)

        publish_start = time.time()
        try:
            responses, ws_logs = websocket_client.connect_and_publish(event_data)
            logs.extend(ws_logs)
            if any(response[0] == 'OK' for response in responses):
                self.write({'published': True})
                logs.append(f"Nostr event successfully published: {self.id}")
                self.env['bus.bus']._sendone(self.env.user.partner_id, 'simple_notification', {
                    'title': _("Nostr Event Published"),
                    'message': _("Event successfully published to Nostr network"),
                })
            else:
                error_msg = f"Error publishing Nostr event {self.id}: {responses}"
                logs.append(error_msg)
                raise UserError(_(error_msg))
        except Exception as e:
            error_msg = f"Error publishing Nostr event {self.id}: {e}"
            logs.append(error_msg)
            raise UserError(_(error_msg))
        finally:
            logs.append(f"Publishing process took {time.time() - publish_start:.4f} seconds")

        logs.append(f"Total publish action took {time.time() - start_time:.4f} seconds")
        self.write({'logs': '\n'.join(logs)})

        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _("Nostr Event"),
                'message': _("Event published successfully. Check logs for details."),
                'sticky': False,
                'type': 'success',
            }
        }
=== ./odoo_custom_addons (copy)/git_nostr_object/models/git_commit_wizard.py ===
from odoo import models, fields, api

class GitCommitWizard(models.TransientModel):
    _name = 'git.commit.wizard'
    _description = 'Git Commit Wizard'

    repository_id = fields.Many2one('git.repository', string='Repository', required=True)
    message = fields.Text(string='Commit Message', required=True)
    file_data = fields.Text(string='File Content')
    file_name = fields.Char(string='File Name')

    def action_create_commit(self):
        repo = self.repository_id
        with open(f"{repo.path}/{self.file_name}", 'w') as f:
            f.write(self.file_data)
        commit = repo.create_commit(self.message, [self.file_name])
        return {'type': 'ir.actions.act_window_close'}
=== ./odoo_custom_addons (copy)/git_nostr_object/models/admin_test.py ===
# /opt/odoo/custom_addons/git_nostr_object/models/admin_test.py
from odoo import models, api
from ..tests.test_git_nostr_object import test_git_nostr_object, test_nostr_auth

class AdminTest(models.TransientModel):
    _name = 'git_nostr_object.admin_test'
    _description = 'Admin Test for Git-Nostr Object'

    def run_tests(self):
        test_git_nostr_object()
        test_nostr_auth()
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': 'Test Results',
                'message': 'Tests completed. Check the logs for details.',
                'sticky': False,
            }
        }
=== ./odoo_custom_addons (copy)/git_nostr_object/__init__.py ===
from . import models
from . import controllers
=== ./odoo_custom_addons (copy)/git_nostr_object/utils/nostr_websocket_client.py ===
# utils/nostr_websocket_client.py
import logging
import time
import websocket
import json

_logger = logging.getLogger(__name__)

class NostrWebSocketClient:
    def __init__(self, relay_urls):
        self.relay_urls = relay_urls

    def connect_and_publish(self, event_data):
        responses = []
        logs = []
        for url in self.relay_urls:
            try:
                response, log = self._connect_and_publish_to_relay(url, event_data)
                responses.append(response)
                logs.extend(log)
            except Exception as e:
                error_message = f"Error publishing event to relay {url}: {e}"
                _logger.error(error_message)
                logs.append(error_message)
        return responses, logs

    def _connect_and_publish_to_relay(self, relay_url, event_data):
        log = []
        log.append(f"Attempting to connect to {relay_url}")
        start_time = time.time()

        ws = websocket.create_connection(relay_url)
        log.append(f"Connected to {relay_url} in {time.time() - start_time:.2f} seconds")

        event_message = json.dumps(["EVENT", event_data])
        log.append(f"Sending Nostr event to {relay_url}")
        ws.send(event_message)
        log.append(f"Sent message to {relay_url} in {time.time() - start_time:.2f} seconds")

        log.append(f"Waiting for response from {relay_url}")
        response = ws.recv()
        log.append(f"Received response from {relay_url} in {time.time() - start_time:.2f} seconds: {response}")
        ws.close()
        return json.loads(response), log
=== ./odoo_custom_addons (copy)/git_nostr_object/__manifest__.py ===
{
    'name': 'git_nostr_object',
    'version': '1.0',
    'depends': ['base', 'bus'],
    'data': [
        'security/ir.model.access.csv',
        'views/git_repository_views.xml',
        'views/git_commit_views.xml',
        'views/git_tree_views.xml',
        'views/git_blob_views.xml',
        'views/git_object_views.xml',
        'views/nostr_event_object_views.xml',
        'views/actions.xml',
        'views/menus.xml',
        'views/admin_test_views.xml',
        'views/git_commit_wizard_views.xml'
    ],
    'assets': {
        'web.assets_backend': [
            'git_nostr_object/static/src/js/git_nostr_notifications.js',
        ],
    },
    'installable': True,
    'application': True,
    'auto_install': False,
}
=== ./odoo_custom_addons (copy)/git_nostr_object/static/src/js/git_nostr_notifications.js ===
// static/src/js/git_nostr_notifications.js
odoo.define('git_nostr_object.notifications', function (require) {
    "use strict";

    var core = require('web.core');
    var session = require('web.session');
    var BusService = require('bus.BusService');

    BusService.include({
        _onNotification: function (notifications) {
            var self = this;
            _.each(notifications, function (notification) {
                if (notification[0][1] === 'simple_notification') {
                    self.displayNotification({
                        title: notification[1].title,
                        message: notification[1].message,
                        type: 'info',
                    });
                }
            });
            this._super.apply(this, arguments);
        },
    });
});
=== ./odoo_custom_addons (copy)/git_nostr_object/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_git_commit,access_git_commit,model_git_commit,base.group_user,1,1,1,1
access_git_tree,access_git_tree,model_git_tree,base.group_user,1,1,1,1
access_git_blob,access_git_blob,model_git_blob,base.group_user,1,1,1,1
access_git_repository,access_git_repository,model_git_repository,base.group_user,1,1,1,1
access_nostr_event_object,access_nostr_event_object,model_nostr_event_object,base.group_user,1,1,1,1
=== ./odoo_custom_addons (copy)/git_nostr_object/tests/__init__.py ===
# /opt/odoo/custom_addons/git_nostr_object/tests/__init__.py
from . import test_git_nostr_object
=== ./odoo_custom_addons (copy)/git_nostr_object/tests/test_git_nostr_object.py ===
from odoo.tests.common import TransactionCase
from datetime import datetime
import random
import string
import logging
import os

_logger = logging.getLogger(__name__)

def random_string(length=10):
    return ''.join(random.choices(string.ascii_letters + string.digits, k=length))

def generate_sha():
    """Generate a random 40-character SHA hash"""
    return ''.join(random.choices('0123456789abcdef', k=40))

def get_current_timestamp():
    """Return the current timestamp"""
    return int(datetime.now().timestamp())

def get_author(env):
    """Return the logged-in user's name as the author"""
    return env.user.name

def get_local_path():
    """Return the Odoo installation path as the local path"""
    return '/opt/odoo'

def generate_nostr_keys():
    """Generate random 64-character Nostr public and private keys for the logged-in user"""
    public_key = random_string(64)
    private_key = random_string(64)
    return public_key, private_key

def get_event_type(content):
    """Extract the event type from the first line of the content"""
    return int(content.split('\n')[0].strip('# '))

def get_event_name(content):
    """Extract the event name from the first line of the content"""
    return content.split('\n', 1)[0]

def check_method_existence(env, methods):
    """Check if the required methods exist in the corresponding models"""
    for model, method_name in methods.items():
        model_obj = env[model]
        if not hasattr(model_obj, method_name):
            return False, f"Method '{method_name}' not found in model '{model}'"
    return True, "All required methods found"

class TestGitNostrObject(TransactionCase):

    def setUp(self):
        super(TestGitNostrObject, self).setUp()
        self.GitRepository = self.env['git.repository']
        self.GitCommit = self.env['git.commit']
        self.GitTree = self.env['git.tree']
        self.GitBlob = self.env['git.blob']
        self.GitNostrEventObject = self.env['git_nostr.event.object']
        self.NostrKey = self.env['nostr.key']
        self.NostrRelay = self.env['nostr.relay']
        self.NostrProfile = self.env['nostr.profile']

        # Check if required methods exist in the corresponding models
        required_methods = {
            'git.repository': 'traverse_and_publish',
            'nostr.event.object': 'action_publish',
            'nostr.key': 'generate_key_pair',
            'nostr.key': 'sign_event'
        }
        success, message = check_method_existence(self.env, required_methods)
        if not success:
            self.fail(message)

    def test_git_nostr_object(self):
        _logger.info("Testing Git-Nostr Object module...")

        # Test Git Repository
        repo_name = f'Test Repo {random_string()}'
        repo_path = f'{get_local_path()}/custom_addons/git_nostr_object/tests/test_repo_{random_string()}'
        repo = self.GitRepository.create({
            'name': repo_name,
            'path': repo_path
        })
        _logger.info(f"Created Git Repository with ID: {repo.id}")

        # Test traverse_and_publish
        try:
            repo.traverse_and_publish()
            _logger.info("traverse_and_publish executed successfully")
        except Exception as e:
            _logger.error(f"Error in traverse_and_publish: {e}")

        # Test Git Commit
        commit_sha = generate_sha()
        commit_author = get_author(self.env)
        commit_timestamp = get_current_timestamp()
        commit_data = 'Test commit data'
        commit = self.GitCommit.create({
            'sha': commit_sha,
            'message': 'Test commit message',
            'author': commit_author,
            'timestamp': commit_timestamp,
            'data': commit_data
        })
        _logger.info(f"Created Git Commit with ID: {commit.id}")

        # Test Git Tree
        tree_sha = generate_sha()
        tree_data = 'Test tree data'
        tree = self.GitTree.create({
            'sha': tree_sha,
            'data': tree_data
        })
        _logger.info(f"Created Git Tree with ID: {tree.id}")

        # Test Git Blob
        blob_sha = generate_sha()
        blob_data = 'Test blob data'
        blob = self.GitBlob.create({
            'sha': blob_sha,
            'data': blob_data
        })
        _logger.info(f"Created Git Blob with ID: {blob.id}")

        # Test Nostr Event Object
        event_content = '# 1\nTest Nostr event content'
        event_type = get_event_type(event_content)
        event_tags = '[]'
        event_created_at = get_current_timestamp()
        event_signature = random_string(64)
        event_name = get_event_name(event_content)
        event = self.GitNostrEventObject.create({
            'kind': event_type,
            'content': event_content,
            'tags': event_tags,
            'created_at': event_created_at,
            'signature': event_signature,
            'name': event_name
        })
        _logger.info(f"Created Nostr Event Object with ID: {event.id}")

        # Test action_publish
        try:
            event.action_publish()
            _logger.info("action_publish executed successfully")
        except Exception as e:
            _logger.error(f"Error in action_publish: {e}")

    def test_nostr_auth(self):
        _logger.info("Testing Nostr Authentication module...")

        # Test Nostr Key
        public_key, private_key = generate_nostr_keys()
        key = self.NostrKey.create({
            'public_key': public_key,
            'private_key': private_key,
            'user_id': self.env.user.id
        })
        _logger.info(f"Created Nostr Key with ID: {key.id}")

        # Test Nostr Relay
        relay_url = f'wss://relay{random_string()}.com'
        relay = self.NostrRelay.create({
            'url': relay_url,
            'is_active': True
        })
        _logger.info(f"Created Nostr Relay with ID: {relay.id}")

        # Test Nostr Profile
        profile_name = f'Test Profile {random_string()}'
        profile_about = 'Test profile description'
        profile_picture = 'http://example.com/pic.jpg'
        profile = self.NostrProfile.create({
            'name': profile_name,
            'about': profile_about,
            'picture': profile_picture,
            'user_id': self.env.user.id
        })
        _logger.info(f"Created Nostr Profile with ID: {profile.id}")

        # Test generate_key_pair method
        try:
            result = self.NostrKey.generate_key_pair()
            _logger.info(f"Generated key pair: {result}")
        except Exception as e:
            _logger.error(f"Error in generate_key_pair: {e}")

        # Test sign_event method (assuming it exists)
        try:
            event_data = {
                'kind': 1,
                'content': 'Test content',
                'created_at': get_current_timestamp(),
                'tags': []
            }
            result = key.sign_event(event_data)
            _logger.info(f"Signed event: {result}")
        except Exception as e:
            _logger.error(f"Error in sign_event: {e}")

def test_git_nostr_object():
    test_case = TestGitNostrObject.create({})
    test_case.test_git_nostr_object()

def test_nostr_auth():
    test_case = TestGitNostrObject.create({})
    test_case.test_nostr_auth()

# This allows running the test from the Odoo shell
if __name__ == '__main__':
    test_git_nostr_object()
    test_nostr_auth()
=== ./odoo_custom_addons (copy)/git_nostr_object/views/git_blob_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_blob_form" model="ir.ui.view">
        <field name="name">git.blob.form</field>
        <field name="model">git.blob</field>
        <field name="arch" type="xml">
            <form>
                <group>
                    <field name="sha"/>
                    <field name="data"/>
                </group>
            </form>
        </field>
    </record>

    <record id="view_git_blob_tree" model="ir.ui.view">
        <field name="name">git.blob.tree</field>
        <field name="model">git.blob</field>
        <field name="arch" type="xml">
            <tree>
                <field name="sha"/>
            </tree>
        </field>
    </record>

    <record id="action_git_blob" model="ir.actions.act_window">
        <field name="name">Git Blobs</field>
        <field name="res_model">git.blob</field>
        <field name="view_mode">tree,form</field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/git_nostr_object/views/menus.xml ===
<!-- views/menus.xml -->
<odoo>
    <menuitem id="menu_git_nostr_object_root" name="Git-Nostr Object">
        <menuitem id="menu_git_repository" name="Repositories" action="action_git_repository"/>
        <menuitem id="menu_git_commit" name="Commits" action="action_git_commit"/>
        <menuitem id="menu_git_tree" name="Trees" action="action_git_tree"/>
        <menuitem id="menu_git_blob" name="Blobs" action="action_git_blob"/>
        <menuitem id="menu_git_nostr_event_object" name="Nostr Event Objects" action="action_git_nostr_event_object"/>
    </menuitem>
</odoo>
=== ./odoo_custom_addons (copy)/git_nostr_object/views/git_commit_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_commit_form" model="ir.ui.view">
        <field name="name">git.commit.form</field>
        <field name="model">git.commit</field>
        <field name="arch" type="xml">
            <form>
                <group>
                    <field name="sha"/>
                    <field name="message"/>
                    <field name="author"/>
                    <field name="timestamp"/>
                    <field name="data"/>
                </group>
            </form>
        </field>
    </record>

    <record id="view_git_commit_tree" model="ir.ui.view">
        <field name="name">git.commit.tree</field>
        <field name="model">git.commit</field>
        <field name="arch" type="xml">
            <tree>
                <field name="sha"/>
                <field name="message"/>
                <field name="author"/>
                <field name="timestamp"/>
            </tree>
        </field>
    </record>

    <record id="action_git_commit" model="ir.actions.act_window">
        <field name="name">Git Commits</field>
        <field name="res_model">git.commit</field>
        <field name="view_mode">tree,form</field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/git_nostr_object/views/git_object_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_object_form" model="ir.ui.view">
        <field name="name">git.object.form</field>
        <field name="model">git.object</field>
        <field name="arch" type="xml">
            <form>
                <group>
                    <field name="sha"/>
                    <field name="data"/>
                </group>
            </form>
        </field>
    </record>

    <record id="view_git_object_tree" model="ir.ui.view">
        <field name="name">git.object.tree</field>
        <field name="model">git.object</field>
        <field name="arch" type="xml">
            <tree>
                <field name="sha"/>
            </tree>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/git_nostr_object/views/admin_test_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_admin_test_form" model="ir.ui.view">
        <field name="name">git_nostr_object.admin_test.form</field>
        <field name="model">git_nostr_object.admin_test</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="run_tests" string="Run Tests" type="object" class="oe_highlight"/>
                </header>
                <div>
                    <p>Click the button to run the Git-Nostr Object tests.</p>
                </div>
            </form>
        </field>
    </record>

    <record id="action_admin_test" model="ir.actions.act_window">
        <field name="name">Admin Tests</field>
        <field name="res_model">git_nostr_object.admin_test</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
    </record>

    <menuitem id="menu_admin_test" name="Admin Tests" parent="menu_git_nostr_object_root" action="action_admin_test" groups="base.group_system"/>
</odoo>
=== ./odoo_custom_addons (copy)/git_nostr_object/views/git_commit_wizard_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_commit_wizard_form" model="ir.ui.view">
        <field name="name">git.commit.wizard.form</field>
        <field name="model">git.commit.wizard</field>
        <field name="arch" type="xml">
            <form string="Create Commit">
                <group>
                    <field name="repository_id" invisible="1"/>
                    <field name="message"/>
                    <field name="file_name"/>
                    <field name="file_data"/>
                </group>
                <footer>
                    <button name="action_create_commit" string="Create Commit" type="object" class="btn-primary"/>
                    <button string="Cancel" class="btn-secondary" special="cancel"/>
                </footer>
            </form>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/git_nostr_object/views/git_tree_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_tree_form" model="ir.ui.view">
        <field name="name">git.tree.form</field>
        <field name="model">git.tree</field>
        <field name="arch" type="xml">
            <form>
                <group>
                    <field name="sha"/>
                    <field name="data"/>
                </group>
            </form>
        </field>
    </record>

    <record id="view_git_tree_tree" model="ir.ui.view">
        <field name="name">git.tree.tree</field>
        <field name="model">git.tree</field>
        <field name="arch" type="xml">
            <tree>
                <field name="sha"/>
            </tree>
        </field>
    </record>

    <record id="action_git_tree" model="ir.actions.act_window">
        <field name="name">Git Trees</field>
        <field name="res_model">git.tree</field>
        <field name="view_mode">tree,form</field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/git_nostr_object/views/nostr_event_object_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_nostr_event_object_form" model="ir.ui.view">
        <field name="name">nostr.event.object.form</field>
        <field name="model">nostr.event.object</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="action_publish" string="Publish Event" type="object" class="oe_highlight" attrs="{'invisible': [('published', '=', True)]}"/>
                </header>
                <sheet>
                    <group>
                        <field name="kind"/>
                        <field name="content"/>
                        <field name="tags"/>
                        <field name="created_at"/>
                        <field name="signature"/>
                        <field name="public_key"/>
                        <field name="published"/>
                    </group>
                    <notebook>
                        <page string="Logs">
                            <field name="logs" widget="text" readonly="1"/>
                        </page>
                    </notebook>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_nostr_event_object_tree" model="ir.ui.view">
        <field name="name">nostr.event.object.tree</field>
        <field name="model">nostr.event.object</field>
        <field name="arch" type="xml">
            <tree string="Nostr Event Objects">
                <field name="kind"/>
                <field name="content"/>
                <field name="tags"/>
                <field name="created_at"/>
                <field name="signature"/>
                <field name="public_key"/>
                <field name="published"/>
            </tree>
        </field>
    </record>

    <record id="action_nostr_event_object" model="ir.actions.act_window">
        <field name="name">Nostr Event Objects</field>
        <field name="res_model">nostr.event.object</field>
        <field name="view_mode">tree,form</field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/git_nostr_object/views/git_repository_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_repository_form" model="ir.ui.view">
        <field name="name">git.repository.form</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="traverse_and_publish" string="Traverse and Publish" type="object" class="oe_highlight"/>
                </header>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="path" string="Local Path"/>
                    </group>
                    <notebook>
                        <page string="Logs">
                            <field name="logs" widget="text" readonly="1"/>
                        </page>
                    </notebook>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_git_repository_tree" model="ir.ui.view">
        <field name="name">git.repository.tree</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="path"/>
            </tree>
        </field>
    </record>

    <record id="action_git_repository" model="ir.actions.act_window">
        <field name="name">Git Repositories</field>
        <field name="res_model">git.repository</field>
        <field name="view_mode">tree,form</field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/git_nostr_object/views/actions.xml ===
<!-- views/actions.xml -->
<odoo>
    <record id="action_git_nostr_event_object" model="ir.actions.act_window">
        <field name="name">Nostr Event Objects</field>
        <field name="res_model">nostr.event.object</field>
        <field name="view_mode">tree,form</field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/git_nostr_object/controllers/git_controller.py ===
from odoo import http
from odoo.http import request
import logging

_logger = logging.getLogger(__name__)

class GitController(http.Controller):

    @http.route('/git_nostr_object/traverse_repo', type='json', auth='user')
    def traverse_repo(self, repo_id):
        try:
            repo = request.env['git.repository'].browse(repo_id)
            repo.traverse_and_publish()
            return {'status': 'success'}
        except Exception as e:
            _logger.exception("Error traversing repository")
            return {'status': 'error', 'message': str(e)}

    @http.route('/git_nostr_object/publish_event', type='json', auth='user')
    def publish_event(self, event_id):
        try:
            event = request.env['git_nostr.event.object'].browse(event_id)
            event.action_publish()
            return {'status': 'success'}
        except Exception as e:
            _logger.exception("Error publishing Nostr event")
            return {'status': 'error', 'message': str(e)}
=== ./odoo_custom_addons (copy)/custom_thunderbird_mail/models/custom_mail.py ===
import smtplib
from email.mime.text import MIMEText
from odoo import models, fields, api

class CustomMail(models.Model):
    _name = 'custom.mail'
    _description = 'Custom Mail Integration with Thunderbird Mail'

    @api.model
    def send_thunderbird_mail(self, recipient, subject, body):
        # Thunderbird SMTP server configuration
        smtp_server = 'test'
        smtp_port = 587
        smtp_user = 'g'
        smtp_password = 'your_thunderbird_password'  # Replace with the actual password

        # Create the email message
        msg = MIMEText(body)
        msg['Subject'] = subject
        msg['From'] = smtp_user
        msg['To'] = recipient

        # Send the email
        try:
            with smtplib.SMTP(smtp_server, smtp_port) as server:
                server.login(smtp_user, smtp_password)
                server.sendmail(smtp_user, [recipient], msg.as_string())
            return True
        except Exception as e:
            _logger.error('Failed to send email: %s', e)
            return False
=== ./odoo_custom_addons (copy)/custom_thunderbird_mail/__init__.py ===
from . import models
=== ./odoo_custom_addons (copy)/custom_thunderbird_mail/__manifest__.py ===
{
    'name': 'Custom Thunderbird Mail Integration',
    'version': '1.0',
    'category': 'Tools',
    'summary': 'Integrate Odoo with Thunderbird Mail',
    'description': 'A module to integrate Odoo with Thunderbird Mail for sending emails.',
    'depends': ['base'],
    'data': [],
    'installable': True,
    'application': True,
}
=== ./odoo_custom_addons (copy)/custom_thunderbird_mail/wizard/create_nostr_event_wizard.py ===
# wizard/create_nostr_event_wizard.py
from odoo import models, fields, api
import git
import json

class CreateNostrEventWizard(models.TransientModel):
    _name = 'create.nostr.event.wizard'
    _description = 'Create Nostr Event Wizard'

    repository_id = fields.Many2one('git.repository', string='Repository', required=True)
    event_type = fields.Selection([
        ('repo_anchor', 'Repository Anchor'),
        ('branch', 'Branch'),
        ('commit', 'Commit'),
        ('tree', 'Tree'),
        ('blob', 'Blob'),
    ], string='Event Type', required=True)
    commit_message = fields.Text(string='Commit Message')
    branch_name = fields.Char(string='Branch Name')
    file_content = fields.Text(string='File Content')
    file_name = fields.Char(string='File Name')

    def action_create_event(self):
        repo = git.Repo(self.repository_id.path)
        
        if self.event_type == 'commit':
            # Stage all changes
            repo.git.add(A=True)
            # Commit changes
            commit = repo.index.commit(self.commit_message)
            self.repository_id.last_commit = commit.hexsha
            content = json.dumps({
                'type': 'commit',
                'repository': self.repository_id.name,
                'commit_hash': commit.hexsha,
                'message': self.commit_message,
            })
        elif self.event_type == 'branch':
            repo.git.checkout('-b', self.branch_name)
            self.repository_id.branch = self.branch_name
            content = json.dumps({
                'type': 'branch',
                'repository': self.repository_id.name,
                'branch_name': self.branch_name,
            })
        elif self.event_type == 'blob':
            with open(os.path.join(self.repository_id.path, self.file_name), 'w') as f:
                f.write(self.file_content)
            repo.index.add([self.file_name])
            commit = repo.index.commit(f"Add file: {self.file_name}")
            self.repository_id.last_commit = commit.hexsha
            content = json.dumps({
                'type': 'blob',
                'repository': self.repository_id.name,
                'file_name': self.file_name,
                'commit_hash': commit.hexsha,
            })
        
        self.env['nostr.event'].create({
            'name': f"{self.event_type.capitalize()} - {self.repository_id.name}",
            'event_type': self.event_type,
            'content': content,
            'tags': json.dumps([['r', self.repository_id.remote_url]]),
        })

        return {'type': 'ir.actions.act_window_close'}
=== ./odoo_custom_addons (copy)/custom_thunderbird_mail/wizard/__init__.py ===
# wizard/__init__.py
from . import create_nostr_event_wizard
=== ./odoo_custom_addons (copy)/custom_thunderbird_mail/wizard/create_nostr_event_wizard_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_create_nostr_event_wizard_form" model="ir.ui.view">
        <field name="name">create.nostr.event.wizard.form</field>
        <field name="model">create.nostr.event.wizard</field>
        <field name="arch" type="xml">
            <form string="Create Nostr Event">
                <group>
                    <field name="repository_id"/>
                    <field name="event_type"/>
                    <field name="commit_message" attrs="{'invisible': [('event_type', '!=', 'commit')], 'required': [('event_type', '=', 'commit')]}"/>
                    <field name="branch_name" attrs="{'invisible': [('event_type', '!=', 'branch')], 'required': [('event_type', '=', 'branch')]}"/>
                    <field name="file_name" attrs="{'invisible': [('event_type', '!=', 'blob')], 'required': [('event_type', '=', 'blob')]}"/>
                    <field name="file_content" attrs="{'invisible': [('event_type', '!=', 'blob')], 'required': [('event_type', '=', 'blob')]}" widget="ace" options="{'mode': 'xml'}"/>
                </group>
                <footer>
                    <button name="action_create_event" string="Create Event" type="object" class="btn-primary"/>
                    <button string="Cancel" class="btn-secondary" special="cancel"/>
                </footer>
            </form>
        </field>
    </record>

    <record id="action_create_nostr_event_wizard" model="ir.actions.act_window">
        <field name="name">Create Nostr Event</field>
        <field name="res_model">create.nostr.event.wizard</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/custom_thunderbird_mail/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_git_repository,access_git_repository,model_git_repository,base.group_user,1,1,1,1
access_nostr_event,access_nostr_event,model_nostr_event,base.group_user,1,1,1,1
access_create_nostr_event_wizard,access_create_nostr_event_wizard,model_create_nostr_event_wizard,base.group_user,1,1,1,0
=== ./odoo_custom_addons (copy)/custom_thunderbird_mail/views/res_users_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_users_form_inherit_git_nostr" model="ir.ui.view">
        <field name="name">res.users.form.inherit.git.nostr</field>
        <field name="model">res.users</field>
        <field name="inherit_id" ref="base.view_users_form"/>
        <field name="arch" type="xml">
            <notebook position="inside">
                <page string="Nostr Settings" name="nostr_settings">
                    <group>
                        <field name="nostr_private_key" password="True"/>
                        <field name="nostr_public_key"/>
                    </group>
                </page>
            </notebook>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/custom_thunderbird_mail/views/res_config_settings_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="res_config_settings_view_form" model="ir.ui.view">
        <field name="name">res.config.settings.view.form.inherit.git_nostr_bridge</field>
        <field name="model">res.config.settings</field>
        <field name="inherit_id" ref="base.res_config_settings_view_form"/>
        <field name="arch" type="xml">
            <xpath expr="//div[hasclass('settings')]" position="inside">
                <div class="app_settings_block" data-string="Git-Nostr Bridge" string="Git-Nostr Bridge" data-key="git_nostr_bridge">
                    <h2>Nostr Settings</h2>
                    <div class="row mt16 o_settings_container">
                        <div class="col-12 col-lg-6 o_setting_box">
                            <div class="o_setting_left_pane"/>
                            <div class="o_setting_right_pane">
                                <span class="o_form_label">Nostr Relay URLs</span>
                                <div class="text-muted">
                                    Comma-separated list of Nostr relay URLs
                                </div>
                                <div class="content-group">
                                    <div class="mt16">
                                        <field name="git_nostr_relay_urls"/>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </xpath>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/custom_thunderbird_mail/views/nostr_event_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_nostr_event_form" model="ir.ui.view">
        <field name="name">nostr.event.form</field>
        <field name="model">nostr.event</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="action_publish" string="Publish" type="object" class="oe_highlight" attrs="{'invisible': [('published', '=', True)]}"/>
                </header>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="event_type"/>
                        <field name="content"/>
                        <field name="tags"/>
                        <field name="published"/>
                        <field name="event_id"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_nostr_event_form_git_nostr" model="ir.ui.view">
        <field name="name">nostr.event.form.git.nostr</field>
        <field name="model">nostr.event</field>
        <field name="inherit_id" ref="integrated_ivcs.view_nostr_event_form"/>
        <field name="arch" type="xml">
            <xpath expr="//field[@name='event_type']" position="after">
                <field name="repository_id" attrs="{'invisible': [('event_type', 'not in', ['repo_anchor', 'branch', 'commit', 'tree', 'blob'])]}"/>
            </xpath>
        </field>
    </record>

    <record id="action_nostr_event" model="ir.actions.act_window">
        <field name="name">Nostr Events</field>
        <field name="res_model">nostr.event</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_nostr_event_git" name="Git Nostr Events" parent="menu_git_nostr_bridge" action="integrated_ivcs.action_nostr_event" sequence="20"/>
</odoo>
=== ./odoo_custom_addons (copy)/custom_thunderbird_mail/views/git_repository_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_repository_form" model="ir.ui.view">
        <field name="name">git.repository.form</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="action_pull" string="Pull" type="object" class="oe_highlight"/>
                    <button name="action_push" string="Push" type="object" class="oe_highlight"/>
                    <button name="action_commit" string="Commit" type="object" class="oe_highlight"/>
                </header>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="path"/>
                        <field name="remote_url"/>
                        <field name="branch"/>
                        <field name="last_commit"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="action_git_repository" model="ir.actions.act_window">
        <field name="name">Git Repositories</field>
        <field name="res_model">git.repository</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_git_nostr_bridge" name="Git-Nostr Bridge" sequence="10"/>
    <menuitem id="menu_git_repository" name="Git Repositories" parent="menu_git_nostr_bridge" action="action_git_repository" sequence="10"/>
</odoo>
=== ./odoo_custom_addons (copy)/git_nostr_bridge/models/git_repository.py ===
# models/git_repository.py
import os
import git
from odoo import models, fields, api, _
from odoo.exceptions import UserError

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Name', required=True)
    path = fields.Char(string='Local Path', required=True)
    remote_url = fields.Char(string='Remote URL')
    branch = fields.Char(string='Current Branch', default='main')
    last_commit = fields.Char(string='Last Commit', readonly=True)

    @api.model
    def create(self, vals):
        repo = super(GitRepository, self).create(vals)
        repo._initialize_repository()
        return repo

    def _initialize_repository(self):
        if not os.path.exists(self.path):
            os.makedirs(self.path)
            repo = git.Repo.init(self.path)
            if self.remote_url:
                repo.create_remote('origin', self.remote_url)
            open(os.path.join(self.path, 'README.md'), 'w').close()
            repo.index.add(['README.md'])
            repo.index.commit('Initial commit')
            self.last_commit = repo.head.commit.hexsha

    def action_pull(self):
        repo = git.Repo(self.path)
        origin = repo.remotes.origin
        origin.pull()
        self.last_commit = repo.head.commit.hexsha

    def action_push(self):
        repo = git.Repo(self.path)
        origin = repo.remotes.origin
        origin.push()

    def action_commit(self):
        return {
            'name': _('Create Commit'),
            'type': 'ir.actions.act_window',
            'res_model': 'create.nostr.event.wizard',
            'view_mode': 'form',
            'target': 'new',
            'context': {'default_repository_id': self.id, 'default_event_type': 'commit'},
        }
=== ./odoo_custom_addons (copy)/git_nostr_bridge/models/__init__.py ===
from . import git_repository
from . import nostr_event
from . import res_config_settings
=== ./odoo_custom_addons (copy)/git_nostr_bridge/models/res_users.py ===
from odoo import models, fields, api
from nostr.key import PrivateKey

class ResUsers(models.Model):
    _inherit = 'res.users'

    nostr_public_key = fields.Char(string="Nostr Public Key")
    nostr_private_key = fields.Char(string="Nostr Private Key")
    nostr_relay_url = fields.Char(string="Nostr Relay URL")

    @api.depends('nostr_private_key')
    def _compute_public_key(self):
        for user in self:
            if user.nostr_private_key:
                try:
                    private_key = PrivateKey.from_nsec(user.nostr_private_key)
                    user.nostr_public_key = private_key.public_key.hex()
                except Exception:
                    user.nostr_public_key = False
            else:
                user.nostr_public_key = False

    @api.model
    def create(self, vals):
        if 'nostr_private_key' not in vals or not vals['nostr_private_key']:
            private_key = PrivateKey()
            vals['nostr_private_key'] = private_key.bech32()
        return super(ResUsers, self).create(vals)
=== ./odoo_custom_addons (copy)/git_nostr_bridge/models/nostr_event.py ===
# File: /opt/odoo/custom_addons/git_nostr_bridge/models/nostr_event.py

import asyncio
import json
import logging
import websockets
from urllib.parse import urlparse
import time
import traceback

from odoo import models, fields, api, _
from odoo.exceptions import UserError
from nostr.event import Event as NostrLibEvent
from nostr.key import PrivateKey

_logger = logging.getLogger(__name__)

class NostrEvent(models.Model):
    _name = 'nostr.event'
    _description = 'Nostr Event'
    _inherit = 'nostr.event'

    name = fields.Char(string='Name', required=True)
    event_type = fields.Selection([
        ('repo_anchor', 'Repository Anchor'),
        ('branch', 'Branch'),
        ('commit', 'Commit'),
        ('tree', 'Tree'),
        ('blob', 'Blob'),
    ], string='Event Type', required=True)
    content = fields.Text(string='Content')
    tags = fields.Text(string='Tags')
    published = fields.Boolean(string='Published', default=False)
    event_id = fields.Char(string='Event ID', readonly=True)
    kind = fields.Integer(string='Nostr Event Kind', default=1)
    repository_id = fields.Many2one('git.repository', string='Related Repository')
    signature = fields.Char(string='Signature', readonly=True)
    public_key = fields.Char(string='Public Key', readonly=True)
    created_at = fields.Integer(string='Created At', readonly=True)

    @api.model
    def create(self, vals):
        record = super(NostrEvent, self).create(vals)
        record.generate_event_details()
        return record

    def generate_event_details(self):
        if not self.event_id or not self.signature:
            try:
                private_key = PrivateKey()
                public_key = private_key.public_key.hex()
                
                event = NostrLibEvent(
                    kind=self.kind,
                    content=self.content or '',
                    tags=json.loads(self.tags) if self.tags else [],
                    public_key=public_key,
                    created_at=int(time.time())
                )
                
                private_key.sign_event(event)
                
                self.write({
                    'event_id': event.id,
                    'signature': event.signature,
                    'public_key': public_key,
                    'created_at': event.created_at
                })
            except Exception as e:
                _logger.error(f"Error generating Nostr event details: {str(e)}")
                # Not raising UserError here to avoid disrupting the creation process

    @api.model
    def action_publish(self, event_id):
        event = self.browse(event_id)
        _logger.info(f"Starting publish action for event: {event.name}")
        start_time = time.time()

        try:
            if not self.env.user.nostr_private_key:
                raise UserError(_("Nostr private key is not set for the current user."))

            _logger.info("Generating private key")
            try:
                private_key = PrivateKey.from_nsec(self.env.user.nostr_private_key)
                _logger.info("Private key generated successfully")
            except Exception as e:
                _logger.error(f"Failed to generate private key: {str(e)}")
                _logger.error(traceback.format_exc())
                raise UserError(_("Invalid Nostr private key: %s") % str(e))

            public_key = private_key.public_key.hex()
            _logger.info(f"Public key: {public_key}")

            _logger.info("Parsing tags")
            try:
                tags = json.loads(event.tags) if event.tags else []
                _logger.info(f"Parsed tags: {tags}")
                if not isinstance(tags, list):
                    raise ValueError("Tags must be a list of lists")
                for tag in tags:
                    if not isinstance(tag, list):
                        raise ValueError("Each tag must be a list")
            except json.JSONDecodeError as e:
                _logger.error(f"JSON decode error: {str(e)}")
                _logger.error(traceback.format_exc())
                raise UserError(_("Invalid tags format. Please ensure tags are in valid JSON format."))
            except ValueError as e:
                _logger.error(f"Value error: {str(e)}")
                _logger.error(traceback.format_exc())
                raise UserError(_("Invalid tags format: %s") % str(e))

            _logger.info("Creating Nostr event")
            nostr_event = NostrLibEvent(
                kind=1,  # Assuming TEXT_NOTE, adjust if needed
                content=str(event.content),
                tags=tags,
                public_key=public_key  # Ensure public_key is provided
            )
            private_key.sign_event(nostr_event)
            _logger.info(f"Event created: {nostr_event.to_message()}")

            _logger.info("Fetching relay URLs")
            relay_urls = self.env['ir.config_parameter'].sudo().get_param('git_nostr_bridge.relay_urls', '').split(',')
            relay_urls = [url.strip() for url in relay_urls if url.strip()][:5]  # Limit to 5 relays
            _logger.info(f"Relay URLs: {relay_urls}")

            if not relay_urls:
                raise UserError(_("No Nostr relay URLs configured. Please set them in the settings."))

            _logger.info("Validating relay URLs")
            for url in relay_urls:
                parsed = urlparse(url)
                if parsed.scheme not in ('ws', 'wss'):
                    _logger.error(f"Invalid relay URL: {url}")
                    raise UserError(_("Invalid relay URL: %s. Must start with ws:// or wss://") % url)

            async def publish_to_relay(relay_url, nostr_event, retries=3):
                for attempt in range(retries):
                    try:
                        _logger.info(f"Attempting to connect to {relay_url} (attempt {attempt + 1})")
                        connection_start = time.time()
                        async with websockets.connect(relay_url, timeout=30) as websocket:
                            connection_end = time.time()
                            _logger.info(f"Connected to {relay_url} in {connection_end - connection_start:.2f} seconds")
                            
                            message = nostr_event.to_message()
                            _logger.debug(f"Raw event message: {message}")
                            
                            _logger.info(f"Sending Nostr event to {relay_url}: {message}")
                            
                            send_start = time.time()
                            await websocket.send(message)
                            send_end = time.time()
                            _logger.info(f"Sent message to {relay_url} in {send_end - send_start:.2f} seconds")
                            
                            _logger.info(f"Waiting for response from {relay_url}")
                            response_start = time.time()
                            response = await asyncio.wait_for(websocket.recv(), timeout=10.0)
                            response_end = time.time()
                            _logger.info(f"Received response from {relay_url} in {response_end - response_start:.2f} seconds: {response}")
                            
                            try:
                                return json.loads(response)
                            except json.JSONDecodeError as e:
                                _logger.error(f"Failed to parse response from {relay_url}: {str(e)}")
                                return f"Invalid response from {relay_url}: {response}"
                    except (websockets.exceptions.WebSocketException, asyncio.TimeoutError) as e:
                        _logger.error(f"Error publishing to {relay_url} (attempt {attempt + 1}): {str(e)}")
                        _logger.error(traceback.format_exc())
                        await asyncio.sleep(5 * (attempt + 1))  # Increased delay between attempts
                return f"Failed to publish to {relay_url} after {retries} attempts"

            async def publish_with_timeout():
                tasks = [publish_to_relay(url, nostr_event) for url in relay_urls]
                return await asyncio.gather(*tasks, return_exceptions=True)

            async def run_publication():
                _logger.info("Starting publication process")
                try:
                    results = await asyncio.wait_for(publish_with_timeout(), timeout=120)  # Increased overall timeout
                    _logger.info(f"Publication results: {results}")
                    return results
                except asyncio.TimeoutError:
                    _logger.error("Publication process timed out after 120 seconds")
                    raise UserError(_("Publishing timed out after 120 seconds"))

            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            try:
                results = loop.run_until_complete(run_publication())
            finally:
                loop.close()

            success = any(isinstance(result, list) and result[0] == "OK" for result in results)
            if success:
                event.write({
                    'published': True,
                    'event_id': nostr_event.id
                })
                _logger.info(f"Successfully published Nostr event: {nostr_event.id}")
                
                # Verify event publication
                self.verify_event_publication(nostr_event.id, relay_urls)
                
                end_time = time.time()
                _logger.info(f"Total publish action time: {end_time - start_time:.2f} seconds")
                
                return {
                    'type': 'ir.actions.client',
                    'tag': 'display_notification',
                    'params': {
                        'message': _("Nostr event successfully published to at least one relay."),
                        'type': 'success',
                        'sticky': False,
                    }
                }
            else:
                error_messages = [str(result) for result in results if isinstance(result, str)]
                _logger.error(f"Failed to publish Nostr event: {'; '.join(error_messages)}")
                raise UserError(_("Failed to publish Nostr event: %s") % "; ".join(error_messages))

        except Exception as e:
            _logger.error(f"Unexpected error in action_publish: {str(e)}")
            _logger.error(traceback.format_exc())
            raise UserError(_("An unexpected error occurred: %s") % str(e))

    @api.model
    def verify_event_publication(self, event_id, relay_urls, max_attempts=5, delay=2):
        _logger.info(f"Starting verification for event: {event_id}")
        for attempt in range(max_attempts):
            _logger.info(f"Verification attempt {attempt + 1}")
            for url in relay_urls:
                try:
                    loop = asyncio.new_event_loop()
                    asyncio.set_event_loop(loop)
                    result = loop.run_until_complete(self.query_event(url, event_id))
                    if result:
                        _logger.info(f"Event {event_id} found on relay {url}")
                        return True
                except Exception as e:
                    _logger.error(f"Error querying event from {url}: {str(e)}")
                    _logger.error(traceback.format_exc())
                finally:
                    loop.close()
            _logger.info(f"Waiting {delay} seconds before next attempt")
            time.sleep(delay)
        _logger.warning(f"Event {event_id} not found on any relay after {max_attempts} attempts")
        return False

    async def query_event(self, relay_url, event_id):
        _logger.info(f"Querying event {event_id} from {relay_url}")
        start_time = time.time()
        try:
            async with websockets.connect(relay_url, timeout=10) as websocket:
                request = json.dumps(["REQ", "query", {"ids": [event_id]}])
                _logger.info(f"Sending query to {relay_url}: {request}")
                await websocket.send(request)
                response = await asyncio.wait_for(websocket.recv(), timeout=5.0)
                _logger.info(f"Response from {relay_url}: {response}")
                end_time = time.time()
                _logger.info(f"Query to {relay_url} took {end_time - start_time:.2f} seconds")
                return json.loads(response)
        except Exception as e:
            _logger.error(f"Error querying {relay_url}: {str(e)}")
            _logger.error(traceback.format_exc())
            end_time = time.time()
            _logger.info(f"Failed query to {relay_url} took {end_time - start_time:.2f} seconds")
            return None
=== ./odoo_custom_addons (copy)/git_nostr_bridge/models/res_config_settings.py ===
import requests
import json
from odoo import fields, models, api
import logging

_logger = logging.getLogger(__name__)

class ResConfigSettings(models.TransientModel):
    _inherit = 'res.config.settings'

    git_nostr_relay_urls = fields.Char(
        string="Nostr Relay URLs", 
        config_parameter='git_nostr_bridge.relay_urls',
        default=lambda self: self._default_nostr_relays()
    )

    def _default_nostr_relays(self):
        return self._get_top_nostr_relays()

    @api.model
    def _get_top_nostr_relays(self, limit=108):
        url = "https://api.nostr.watch/v1/online"
        try:
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
            }
            response = requests.get(url, headers=headers, timeout=10)
            response.raise_for_status()
            _logger.info(f"Response status code: {response.status_code}")
            
            data = response.json()
            _logger.info(f"API response (first 108 items): {data[:108]}")
            
            relays = data[:108]
            _logger.info(f"Number of relay links found: {len(relays)}")
            _logger.info(f"Extracted relays (first 5): {relays[:5]}")
            
            relay_urls = ",".join(relays)
            return relay_urls
        except requests.RequestException as e:
            _logger.error(f"Error fetching Nostr relays: {e}")
            return "wss://nostr-relay.app,wss://nos.lol,wss://relay.snort.social,wss://relay.nostr.net"

    nostr_relay_urls = fields.Char(
        string="Nostr Relay URLs", 
        config_parameter='nostr_bridge.relay_urls',
        default=_default_nostr_relays
    )

    @api.model
    def get_values(self):
        res = super(ResConfigSettings, self).get_values()
        ICPSudo = self.env['ir.config_parameter'].sudo()
        
        relay_urls = ICPSudo.get_param('git_nostr_bridge.relay_urls')
        if not relay_urls:
            relay_urls = self._default_nostr_relays()
            ICPSudo.set_param('git_nostr_bridge.relay_urls', relay_urls)
            _logger.info(f"Set new relay URLs: {relay_urls[:100]}...")
        else:
            _logger.info(f"Using existing relay URLs: {relay_urls[:100]}...")
        
        res.update(git_nostr_relay_urls=relay_urls)
        return res

    def set_values(self):
        super(ResConfigSettings, self).set_values()
        ICPSudo = self.env['ir.config_parameter'].sudo()
        if self.git_nostr_relay_urls:
            ICPSudo.set_param('git_nostr_bridge.relay_urls', self.git_nostr_relay_urls)
            _logger.info(f"Updated relay URLs: {self.git_nostr_relay_urls[:100]}...")
        else:
            default_urls = self._default_nostr_relays()
            ICPSudo.set_param('git_nostr_bridge.relay_urls', default_urls)
            _logger.info(f"Set default relay URLs: {default_urls[:100]}...")
=== ./odoo_custom_addons (copy)/git_nostr_bridge/models/git_repository ===
# models/git_repository.py
import os
import git
from odoo import models, fields, api, _
from odoo.exceptions import UserError

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Name', required=True)
    path = fields.Char(string='Local Path', required=True)
    remote_url = fields.Char(string='Remote URL')
    branch = fields.Char(string='Current Branch', default='main')
    last_commit = fields.Char(string='Last Commit', readonly=True)

    @api.model
    def create(self, vals):
        repo = super(GitRepository, self).create(vals)
        repo._initialize_repository()
        return repo

    def _initialize_repository(self):
        if not os.path.exists(self.path):
            os.makedirs(self.path)
            repo = git.Repo.init(self.path)
            if self.remote_url:
                repo.create_remote('origin', self.remote_url)
            open(os.path.join(self.path, 'README.md'), 'w').close()
            repo.index.add(['README.md'])
            repo.index.commit('Initial commit')
            self.last_commit = repo.head.commit.hexsha

    def action_pull(self):
        repo = git.Repo(self.path)
        origin = repo.remotes.origin
        origin.pull()
        self.last_commit = repo.head.commit.hexsha

    def action_push(self):
        repo = git.Repo(self.path)
        origin = repo.remotes.origin
        origin.push()

    def action_commit(self):
        return {
            'name': _('Create Commit'),
            'type': 'ir.actions.act_window',
            'res_model': 'create.nostr.event.wizard',
            'view_mode': 'form',
            'target': 'new',
            'context': {'default_repository_id': self.id, 'default_event_type': 'commit'},
        }
=== ./odoo_custom_addons (copy)/git_nostr_bridge/__init__.py ===
from . import models
from . import wizard
=== ./odoo_custom_addons (copy)/git_nostr_bridge/__manifest__.py ===
{
    'name': 'Git-Nostr Bridge',
    'version': '1.0',
    'category': 'Tools',
    'summary': 'Integrates Git repositories with Nostr network',
    'author': 'Your Name',
    'website': 'https://www.example.com',
    'depends': ['base', 'mail', 'nostr_auth', 'nostr_bridge', 'integrated_ivcs'],
    'data': [
        'security/ir.model.access.csv',
        'views/git_repository_views.xml',
        'views/nostr_event_views.xml',
        'views/res_config_settings_views.xml',
        'views/res_users_views.xml',
        'wizard/create_nostr_event_wizard_views.xml',
    ],
    'installable': True,
    'application': True,
    'auto_install': False,
    'external_dependencies': {
        'python': ['git', 'nostr', 'websockets'],
    },
}
=== ./odoo_custom_addons (copy)/git_nostr_bridge/wizard/create_nostr_event_wizard.py ===
# wizard/create_nostr_event_wizard.py
from odoo import models, fields, api
import git
import json

class CreateNostrEventWizard(models.TransientModel):
    _name = 'create.nostr.event.wizard'
    _description = 'Create Nostr Event Wizard'

    repository_id = fields.Many2one('git.repository', string='Repository', required=True)
    event_type = fields.Selection([
        ('repo_anchor', 'Repository Anchor'),
        ('branch', 'Branch'),
        ('commit', 'Commit'),
        ('tree', 'Tree'),
        ('blob', 'Blob'),
    ], string='Event Type', required=True)
    commit_message = fields.Text(string='Commit Message')
    branch_name = fields.Char(string='Branch Name')
    file_content = fields.Text(string='File Content')
    file_name = fields.Char(string='File Name')

    def action_create_event(self):
        repo = git.Repo(self.repository_id.path)
        
        if self.event_type == 'commit':
            # Stage all changes
            repo.git.add(A=True)
            # Commit changes
            commit = repo.index.commit(self.commit_message)
            self.repository_id.last_commit = commit.hexsha
            content = json.dumps({
                'type': 'commit',
                'repository': self.repository_id.name,
                'commit_hash': commit.hexsha,
                'message': self.commit_message,
            })
        elif self.event_type == 'branch':
            repo.git.checkout('-b', self.branch_name)
            self.repository_id.branch = self.branch_name
            content = json.dumps({
                'type': 'branch',
                'repository': self.repository_id.name,
                'branch_name': self.branch_name,
            })
        elif self.event_type == 'blob':
            with open(os.path.join(self.repository_id.path, self.file_name), 'w') as f:
                f.write(self.file_content)
            repo.index.add([self.file_name])
            commit = repo.index.commit(f"Add file: {self.file_name}")
            self.repository_id.last_commit = commit.hexsha
            content = json.dumps({
                'type': 'blob',
                'repository': self.repository_id.name,
                'file_name': self.file_name,
                'commit_hash': commit.hexsha,
            })
        
        self.env['nostr.event'].create({
            'name': f"{self.event_type.capitalize()} - {self.repository_id.name}",
            'event_type': self.event_type,
            'content': content,
            'tags': json.dumps([['r', self.repository_id.remote_url]]),
        })

        return {'type': 'ir.actions.act_window_close'}
=== ./odoo_custom_addons (copy)/git_nostr_bridge/wizard/__init__.py ===
# wizard/__init__.py
from . import create_nostr_event_wizard
=== ./odoo_custom_addons (copy)/git_nostr_bridge/wizard/create_nostr_event_wizard_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_create_nostr_event_wizard_form" model="ir.ui.view">
        <field name="name">create.nostr.event.wizard.form</field>
        <field name="model">create.nostr.event.wizard</field>
        <field name="arch" type="xml">
            <form string="Create Nostr Event">
                <group>
                    <field name="repository_id"/>
                    <field name="event_type"/>
                    <field name="commit_message" attrs="{'invisible': [('event_type', '!=', 'commit')], 'required': [('event_type', '=', 'commit')]}"/>
                    <field name="branch_name" attrs="{'invisible': [('event_type', '!=', 'branch')], 'required': [('event_type', '=', 'branch')]}"/>
                    <field name="file_name" attrs="{'invisible': [('event_type', '!=', 'blob')], 'required': [('event_type', '=', 'blob')]}"/>
                    <field name="file_content" attrs="{'invisible': [('event_type', '!=', 'blob')], 'required': [('event_type', '=', 'blob')]}" widget="ace" options="{'mode': 'xml'}"/>
                </group>
                <footer>
                    <button name="action_create_event" string="Create Event" type="object" class="btn-primary"/>
                    <button string="Cancel" class="btn-secondary" special="cancel"/>
                </footer>
            </form>
        </field>
    </record>

    <record id="action_create_nostr_event_wizard" model="ir.actions.act_window">
        <field name="name">Create Nostr Event</field>
        <field name="res_model">create.nostr.event.wizard</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/git_nostr_bridge/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_git_repository,access_git_repository,model_git_repository,base.group_user,1,1,1,1
access_nostr_event,access_nostr_event,model_nostr_event,base.group_user,1,1,1,1
access_create_nostr_event_wizard,access_create_nostr_event_wizard,model_create_nostr_event_wizard,base.group_user,1,1,1,0
=== ./odoo_custom_addons (copy)/git_nostr_bridge/views/res_users_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_users_form_inherit_git_nostr" model="ir.ui.view">
        <field name="name">res.users.form.inherit.git.nostr</field>
        <field name="model">res.users</field>
        <field name="inherit_id" ref="base.view_users_form"/>
        <field name="arch" type="xml">
            <notebook position="inside">
                <page string="Nostr Settings" name="nostr_settings">
                    <group>
                        <field name="nostr_private_key" password="True"/>
                        <field name="nostr_public_key"/>
                    </group>
                </page>
            </notebook>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/git_nostr_bridge/views/res_config_settings_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="res_config_settings_view_form" model="ir.ui.view">
        <field name="name">res.config.settings.view.form.inherit.git_nostr_bridge</field>
        <field name="model">res.config.settings</field>
        <field name="inherit_id" ref="base.res_config_settings_view_form"/>
        <field name="arch" type="xml">
            <xpath expr="//div[hasclass('settings')]" position="inside">
                <div class="app_settings_block" data-string="Git-Nostr Bridge" string="Git-Nostr Bridge" data-key="git_nostr_bridge">
                    <h2>Nostr Settings</h2>
                    <div class="row mt16 o_settings_container">
                        <div class="col-12 col-lg-6 o_setting_box">
                            <div class="o_setting_left_pane"/>
                            <div class="o_setting_right_pane">
                                <span class="o_form_label">Nostr Relay URLs</span>
                                <div class="text-muted">
                                    Comma-separated list of Nostr relay URLs
                                </div>
                                <div class="content-group">
                                    <div class="mt16">
                                        <field name="git_nostr_relay_urls"/>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </xpath>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/git_nostr_bridge/views/nostr_event_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_nostr_event_form" model="ir.ui.view">
        <field name="name">nostr.event.form</field>
        <field name="model">nostr.event</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="action_publish" string="Publish" type="object" class="oe_highlight" attrs="{'invisible': [('published', '=', True)]}"/>
                </header>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="event_type"/>
                        <field name="content"/>
                        <field name="tags"/>
                        <field name="published"/>
                        <field name="event_id"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_nostr_event_form_git_nostr" model="ir.ui.view">
        <field name="name">nostr.event.form.git.nostr</field>
        <field name="model">nostr.event</field>
        <field name="inherit_id" ref="integrated_ivcs.view_nostr_event_form"/>
        <field name="arch" type="xml">
            <xpath expr="//field[@name='event_type']" position="after">
                <field name="repository_id" attrs="{'invisible': [('event_type', 'not in', ['repo_anchor', 'branch', 'commit', 'tree', 'blob'])]}"/>
            </xpath>
        </field>
    </record>

    <record id="action_nostr_event" model="ir.actions.act_window">
        <field name="name">Nostr Events</field>
        <field name="res_model">nostr.event</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_nostr_event_git" name="Git Nostr Events" parent="menu_git_nostr_bridge" action="integrated_ivcs.action_nostr_event" sequence="20"/>
</odoo>
=== ./odoo_custom_addons (copy)/git_nostr_bridge/views/git_repository_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_repository_form" model="ir.ui.view">
        <field name="name">git.repository.form</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="action_pull" string="Pull" type="object" class="oe_highlight"/>
                    <button name="action_push" string="Push" type="object" class="oe_highlight"/>
                    <button name="action_commit" string="Commit" type="object" class="oe_highlight"/>
                </header>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="path"/>
                        <field name="remote_url"/>
                        <field name="branch"/>
                        <field name="last_commit"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="action_git_repository" model="ir.actions.act_window">
        <field name="name">Git Repositories</field>
        <field name="res_model">git.repository</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_git_nostr_bridge" name="Git-Nostr Bridge" sequence="10"/>
    <menuitem id="menu_git_repository" name="Git Repositories" parent="menu_git_nostr_bridge" action="action_git_repository" sequence="10"/>
</odoo>
=== ./odoo_custom_addons (copy)/custom_auth/models/res_users.py ===
from odoo import models, api
from odoo.exceptions import AccessDenied
import requests

class ResUsers(models.Model):
    _inherit = 'res.users'

    @classmethod
    def _login(cls, db, login, password):
        if not cls.validate_external_auth(login, password):
            raise AccessDenied()
        return super(ResUsers, cls)._login(db, login, password)

    @classmethod
    def validate_external_auth(cls, login, token):
        # Replace with your actual localhost API endpoint
        validation_url = 'http://localhost/validate_admin'
        response = requests.post(validation_url, json={'login': login, 'token': token})
        return response.status_code == 200 and response.json().get('is_admin', False)
=== ./odoo_custom_addons (copy)/custom_auth/__manifest__.py ===
{
    'name': 'Custom External Authentication',
    'version': '1.0',
    'category': 'Hidden',
    'summary': 'Custom authentication for external admin access',
    'depends': ['base'],
    'data': [],
    'installable': True,
}
=== ./odoo_custom_addons (copy)/opinion_reputation_nostr/models/__init__.py ===
from . import opinion_reputation
from . import nostr_event
=== ./odoo_custom_addons (copy)/opinion_reputation_nostr/models/nostr_event.py ===
from odoo import models, api, _
from odoo.exceptions import UserError
import json
import logging

_logger = logging.getLogger(__name__)

class NostrEvent(models.AbstractModel):
    _name = 'opinion.nostr.event'
    _description = 'Nostr Event for Opinion Reputation'

    @api.model
    def create_prediction_event(self, prediction):
        content = json.dumps({
            'question_id': prediction.question_id.id,
            'question_text': prediction.question_id.text,
            'answer': prediction.answer,
            'confidence': prediction.confidence
        })
        
        try:
            nostr_event = self.env['nostr.event']
            event = nostr_event.create_event(
                kind=1,  # You might want to use a custom event kind for predictions
                content=content,
                tags=[['p', prediction.user_id.nostr_public_key]],
                private_key=prediction.user_id.nostr_private_key
            )
            
            nostr_event.publish_event(event)
            _logger.info(f"Nostr event created and published for prediction {prediction.id}")
        except AttributeError:
            _logger.warning("Nostr bridge not available. Prediction event not published to Nostr.")
        except Exception as e:
            _logger.error(f"Error creating Nostr event: {str(e)}")
            raise UserError(_("Failed to create Nostr event: %s") % str(e))
=== ./odoo_custom_addons (copy)/opinion_reputation_nostr/models/opinion_reputation.py ===
from odoo import models, fields, api
from odoo.exceptions import UserError
import enum
import logging

_logger = logging.getLogger(__name__)

class AnswerChoice(enum.Enum):
    AGREE = "I Agree"
    DO_NOT_DISAGREE = "I do not disagree"
    DO_NOT_AGREE = "I do not agree"
    DISAGREE = "I Disagree"

class User(models.Model):
    _inherit = 'res.users'

    reputation = fields.Float(default=0)

class Question(models.Model):
    _name = 'opinion.question'
    _description = 'Opinion Question'

    text = fields.Text(required=True)
    explanation = fields.Text()
    created_by = fields.Many2one('res.users', string='Created By')
    created_at = fields.Datetime(default=fields.Datetime.now)
    is_settled = fields.Boolean(default=False)
    last_revisited = fields.Datetime()

class Prediction(models.Model):
    _name = 'opinion.prediction'
    _description = 'Opinion Prediction'

    user_id = fields.Many2one('res.users', required=True)
    question_id = fields.Many2one('opinion.question', required=True)
    answer = fields.Selection([
        ('AGREE', 'I Agree'),
        ('DO_NOT_DISAGREE', 'I do not disagree'),
        ('DO_NOT_AGREE', 'I do not agree'),
        ('DISAGREE', 'I Disagree')
    ], required=True)
    confidence = fields.Float(required=True)
    timestamp = fields.Datetime(default=fields.Datetime.now)
    is_correct = fields.Boolean()

    @api.model
    def create(self, vals):
        prediction = super(Prediction, self).create(vals)
        try:
            self.env['opinion.nostr.event'].create_prediction_event(prediction)
        except Exception as e:
            _logger.error(f"Failed to create Nostr event for prediction {prediction.id}: {str(e)}")
        self.update_reputation(prediction.user_id.id)
        return prediction

    def update_reputation(self, user_id):
        user = self.env['res.users'].browse(user_id)
        predictions = self.search([('user_id', '=', user_id)])
        correct_predictions = predictions.filtered(lambda p: p.is_correct)
        if predictions:
            user.reputation = (len(correct_predictions) / len(predictions)) * 100

class OpinionReputationSystem(models.AbstractModel):
    _name = 'opinion.reputation.system'
    _description = 'Opinion Reputation System'

    @api.model
    def revisit_question(self, question_id):
        question = self.env['opinion.question'].browse(question_id)
        if (fields.Datetime.now() - question.created_at).days >= 4*365:
            predictions = self.env['opinion.prediction'].search([('question_id', '=', question_id)])
            total_votes = len(predictions)
            if total_votes > 0:
                agreement_ratio = len(predictions.filtered(lambda p: p.answer in ['AGREE', 'DO_NOT_DISAGREE'])) / total_votes
                question.write({
                    'is_settled': agreement_ratio >= 0.8333334,
                    'last_revisited': fields.Datetime.now()
                })

    @api.model
    def explain_answer_choices(self):
        return """
        Answer choices explanation:
        1. I Agree: You fully support and believe in the statement.
        2. I do not disagree: You somewhat agree or have no strong objection to the statement.
        3. I do not agree: You somewhat disagree or have some reservations about the statement.
        4. I Disagree: You fully oppose or do not believe in the statement.
        """
=== ./odoo_custom_addons (copy)/opinion_reputation_nostr/__init__.py ===
from . import models
=== ./odoo_custom_addons (copy)/opinion_reputation_nostr/__manifest__.py ===
{
    'name': 'Opinion Reputation with Nostr',
    'version': '1.0',
    'category': 'Tools',
    'summary': 'Opinion Reputation System with optional Nostr integration',
    'depends': ['base'],
    'data': [
        'security/ir.model.access.csv',
        'views/opinion_reputation_views.xml',
        'data/default_questions.xml',
    ],
    'installable': True,
    'application': True,
}
=== ./odoo_custom_addons (copy)/opinion_reputation_nostr/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_opinion_question,access_opinion_question,model_opinion_question,base.group_user,1,1,1,1
access_opinion_prediction,access_opinion_prediction,model_opinion_prediction,base.group_user,1,1,1,1
access_opinion_nostr_event,access_opinion_nostr_event,model_opinion_nostr_event,base.group_user,1,1,1,1
=== ./odoo_custom_addons (copy)/opinion_reputation_nostr/data/default_questions.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <!-- Add your default questions here -->
        <record id="question_1" model="opinion.question">
            <field name="text">Do life's challenges sometimes lead to self-doubt?</field>
            <field name="explanation">Sometimes when things get tough, we might wonder if we're good enough or if we can handle it.</field>
        </record>
        <!-- Add more questions as needed -->
    </data>
</odoo>
=== ./odoo_custom_addons (copy)/opinion_reputation_nostr/views/opinion_reputation_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_question_form" model="ir.ui.view">
        <field name="name">opinion.question.form</field>
        <field name="model">opinion.question</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="text"/>
                        <field name="explanation"/>
                        <field name="created_by"/>
                        <field name="created_at"/>
                        <field name="is_settled"/>
                        <field name="last_revisited"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_prediction_form" model="ir.ui.view">
        <field name="name">opinion.prediction.form</field>
        <field name="model">opinion.prediction</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="user_id"/>
                        <field name="question_id"/>
                        <field name="answer"/>
                        <field name="confidence"/>
                        <field name="timestamp"/>
                        <field name="is_correct"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="action_questions" model="ir.actions.act_window">
        <field name="name">Questions</field>
        <field name="res_model">opinion.question</field>
        <field name="view_mode">tree,form</field>
    </record>

    <record id="action_predictions" model="ir.actions.act_window">
        <field name="name">Predictions</field>
        <field name="res_model">opinion.prediction</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_opinion_reputation" name="Opinion Reputation"/>
    <menuitem id="menu_questions" parent="menu_opinion_reputation" action="action_questions"/>
    <menuitem id="menu_predictions" parent="menu_opinion_reputation" action="action_predictions"/>
</odoo>
=== ./odoo_custom_addons (copy)/integrated_ivcs/models/git_repository.py ===
from odoo import models, fields, api
import git
import os

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Repository Name', required=True)
    path = fields.Char(string='Repository Path', required=True)
    
    @api.model
    def create(self, vals):
        repo = super(GitRepository, self).create(vals)
        if not os.path.exists(repo.path):
            os.makedirs(repo.path)
            git.Repo.init(repo.path)
        return repo

    def commit_changes(self, message):
        repo = git.Repo(self.path)
        repo.git.add(A=True)
        commit = repo.index.commit(message)
        
        self.env['nostr.event'].create_git_event(self.path, commit.hexsha)
        
        return commit.hexsha
=== ./odoo_custom_addons (copy)/integrated_ivcs/models/__init__.py ===
from . import ivcs_item
from . import ivcs_version
from . import ivcs_commit
from . import git_repository
from . import nostr_event
from . import branch_manager
from . import res_config_settings
=== ./odoo_custom_addons (copy)/integrated_ivcs/models/ivcs_version.py ===
from odoo import models, fields, api

class IVCSVersion(models.Model):
    _name = 'ivcs.version'
    _description = 'IVCS Version'

    name = fields.Char(string='Version Name', required=True)
    description = fields.Text(string='Description')
    item_id = fields.Many2one('ivcs.item', string='IVCS Item', required=True, ondelete='cascade')
    commit_id = fields.Many2one('ivcs.commit', string='Associated Commit')
    create_date = fields.Datetime(string='Created On', readonly=True, default=fields.Datetime.now)

    @api.model
    def create(self, vals):
        version = super(IVCSVersion, self).create(vals)
        if not version.item_id.current_version_id:
            version.item_id.current_version_id = version.id
        return version

    def name_get(self):
        result = []
        for version in self:
            name = f"{version.item_id.name} - {version.name}"
            result.append((version.id, name))
        return result
=== ./odoo_custom_addons (copy)/integrated_ivcs/models/nostr_event.py ===
from odoo import models, fields, api, _
from odoo.exceptions import UserError
from nostr.event import Event
from nostr.key import PrivateKey
import json
import logging
import time
import git

_logger = logging.getLogger(__name__)

class NostrEvent(models.Model):
    _name = 'nostr.event'
    _description = 'Nostr Event'

    event_id = fields.Char(string='Event ID', required=True)
    kind = fields.Integer(string='Event Kind', required=True)
    content = fields.Text(string='Content', required=True)
    tags = fields.Text(string='Tags')
    public_key = fields.Char(string='Public Key')
    created_at = fields.Integer(string='Created At', required=True)
    signature = fields.Char(string='Signature', required=True)
    published = fields.Boolean(string='Published', default=False)
    name = fields.Char(string='Name')
    event_type = fields.Selection([
        ('repo_anchor', 'Repository Anchor'),
        ('branch', 'Branch'),
        ('commit', 'Commit'),
        ('tree', 'Tree'),
        ('blob', 'Blob'),
    ], string='Event Type')

    def create_and_publish(self, event):
        vals = {
            'event_id': event.id,
            'kind': event.kind,
            'content': event.content,
            'tags': json.dumps(event.tags),
            'public_key': event.public_key,
            'created_at': event.created_at,
            'signature': event.signature,
        }
        nostr_event = self.create(vals)
        nostr_event.publish_event()
        return nostr_event

    def publish_event(self):
        self.ensure_one()
        relay_urls = self.env['ir.config_parameter'].sudo().get_param('integrated_ivcs.relay_urls', '').split(',')
        
        event_data = {
            'id': self.event_id,
            'kind': self.kind,
            'created_at': self.created_at,
            'tags': json.loads(self.tags),
            'content': self.content,
            'pubkey': self.public_key,
            'sig': self.signature,
        }

        for url in relay_urls:
            try:
                # Here you would typically use a Nostr client library to publish the event
                # For simplicity, we'll just log the action
                _logger.info(f"Publishing event {self.event_id} to relay: {url}")
                # Example: nostr_client.publish_event(url, event_data)
                self.published = True
            except Exception as e:
                _logger.error(f"Failed to publish event to {url}: {str(e)}")

    @api.model
    def create_git_event(self, repo_path, commit_hash):
        repo = git.Repo(repo_path)
        commit = repo.commit(commit_hash)
        
        content = json.dumps({
            "action": "commit",
            "message": commit.message,
            "author": commit.author.name,
            "email": commit.author.email,
            "date": commit.authored_datetime.isoformat(),
            "hash": commit_hash,
            "parent_hashes": [c.hexsha for c in commit.parents],
            "tree_hash": commit.tree.hexsha,
        })
        
        event = Event(
            kind=3121,
            content=content,
            tags=[
                ["r", repo_path],
                ["h", commit_hash],
            ],
            public_key=self.env.user.nostr_public_key,
        )
        
        private_key = PrivateKey(bytes.fromhex(self.env.user.nostr_private_key))
        private_key.sign_event(event)
        
        return self.create_and_publish(event)

    @api.model
    def create_tree_event(self, repo_path, tree_hash):
        repo = git.Repo(repo_path)
        tree = repo.tree(tree_hash)
        
        content = json.dumps({
            "action": "tree",
            "hash": tree_hash,
            "items": [{"mode": item.mode, "type": item.type, "hash": item.hexsha, "path": item.path} for item in tree.traverse()],
        })
        
        event = Event(
            kind=3122,
            content=content,
            tags=[
                ["r", repo_path],
                ["h", tree_hash],
            ],
            public_key=self.env.user.nostr_public_key,
        )
        
        private_key = PrivateKey(bytes.fromhex(self.env.user.nostr_private_key))
        private_key.sign_event(event)
        
        return self.create_and_publish(event)

    @api.model
    def create_blob_event(self, repo_path, blob_hash):
        repo = git.Repo(repo_path)
        blob = repo.blob(blob_hash)
        
        content = json.dumps({
            "action": "blob",
            "hash": blob_hash,
            "size": blob.size,
            "data": blob.data_stream.read().decode('utf-8', errors='replace'),
        })
        
        event = Event(
            kind=3123,
            content=content,
            tags=[
                ["r", repo_path],
                ["h", blob_hash],
            ],
            public_key=self.env.user.nostr_public_key,
        )
        
        private_key = PrivateKey(bytes.fromhex(self.env.user.nostr_private_key))
        private_key.sign_event(event)
        
        return self.create_and_publish(event)

    @api.model
    def reconstruct_git_objects(self, repo_path):
        repo = git.Repo(repo_path)
        events = self.search([('tags', 'ilike', repo_path)])
        
        for event in events:
            content = json.loads(event.content)
            if event.kind == 3121:  # Commit
                self._reconstruct_commit(repo, content)
            elif event.kind == 3122:  # Tree
                self._reconstruct_tree(repo, content)
            elif event.kind == 3123:  # Blob
                self._reconstruct_blob(repo, content)

    def _reconstruct_commit(self, repo, content):
        commit_hash = content['hash']
        if commit_hash not in repo.objects:
            repo.create_commit(
                tree=repo.tree(content['tree_hash']),
                message=content['message'],
                author=git.Actor(content['author'], content['email']),
                committer=git.Actor(content['author'], content['email']),
                parent_commits=[repo.commit(p) for p in content['parent_hashes']],
                commit_timestamp=int(content['date']),
                ref=f'refs/heads/{content["branch"]}' if 'branch' in content else None
            )

    def _reconstruct_tree(self, repo, content):
        tree_hash = content['hash']
        if tree_hash not in repo.objects:
            tree_items = []
            for item in content['items']:
                if item['type'] == 'blob':
                    tree_items.append((item['mode'], 'blob', item['hash'], item['path']))
                elif item['type'] == 'tree':
                    tree_items.append((item['mode'], 'tree', item['hash'], item['path']))
            repo.create_tree(tree_items)

    def _reconstruct_blob(self, repo, content):
        blob_hash = content['hash']
        if blob_hash not in repo.objects:
            repo.create_blob(content['data'].encode('utf-8'))

    def sync_git_nostr(self, repo_path):
        repo = git.Repo(repo_path)
        for obj in repo.objects:
            if isinstance(obj, git.Commit):
                self.create_git_event(repo_path, obj.hexsha)
            elif isinstance(obj, git.Tree):
                self.create_tree_event(repo_path, obj.hexsha)
            elif isinstance(obj, git.Blob):
                self.create_blob_event(repo_path, obj.hexsha)

        self.reconstruct_git_objects(repo_path)
=== ./odoo_custom_addons (copy)/integrated_ivcs/models/res_config_settings.py ===
from odoo import fields, models

class ResConfigSettings(models.TransientModel):
    _inherit = 'res.config.settings'

    integrated_ivcs_relay_urls = fields.Char(string="Nostr Relay URLs", config_parameter='integrated_ivcs.relay_urls')
=== ./odoo_custom_addons (copy)/integrated_ivcs/models/ivcs_commit.py ===
from odoo import models, fields, api
import json
from nostr.event import Event
from nostr.key import PrivateKey
import logging

_logger = logging.getLogger(__name__)

class IVCSCommit(models.Model):
    _name = 'ivcs.commit'
    _description = 'IVCS Commit'

    hash = fields.Char(string='Commit Hash', required=True)
    message = fields.Text(string='Commit Message', required=True)
    author = fields.Char(string='Author', required=True, default=lambda self: self.env.user.name)
    date = fields.Datetime(string='Commit Date', required=True, default=fields.Datetime.now)
    item_id = fields.Many2one('ivcs.item', string='IVCS Item', required=True, ondelete='cascade')
    version_id = fields.Many2one('ivcs.version', string='Associated Version')

    @api.model
    def create(self, vals):
        commit = super(IVCSCommit, self).create(vals)
        try:
            commit._create_nostr_commit_event()
        except Exception as e:
            _logger.error(f"Failed to create Nostr commit event: {str(e)}")
        return commit

    def _create_nostr_commit_event(self):
        if not self.item_id.nostr_private_key:
            _logger.warning(f"No Nostr private key set for IVCS Item {self.item_id.name}")
            return

        try:
            private_key = PrivateKey.from_nsec(self.item_id.nostr_private_key)
        except Exception as e:
            _logger.error(f"Invalid Nostr private key for IVCS Item {self.item_id.name}: {str(e)}")
            return

        event = Event(
            kind=3121,
            content=json.dumps({
                "hash": self.hash,
                "message": self.message,
                "author": self.author,
                "date": self.date.isoformat(),
            }),
            tags=[['r', self.item_id.repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)
        
        try:
            self.env['nostr.event'].create_and_publish(event)
            _logger.info(f"Nostr commit event created and published for commit {self.hash}")
        except Exception as e:
            _logger.error(f"Failed to create and publish Nostr event for commit {self.hash}: {str(e)}")
=== ./odoo_custom_addons (copy)/integrated_ivcs/models/ivcs_item.py ===
from odoo import models, fields, api, _
from odoo.exceptions import UserError
import git
import json
from nostr.event import Event
from nostr.key import PrivateKey
import os
import logging

_logger = logging.getLogger(__name__)

class IVCSItem(models.Model):
    _name = 'ivcs.item'
    _description = 'IVCS Item'

    name = fields.Char(string='Name', required=True)
    description = fields.Text('Description')
    current_version_id = fields.Many2one('ivcs.version', string='Current Version', compute='_compute_current_version', store=True)
    version_ids = fields.One2many('ivcs.version', 'item_id', string='Versions')
    repo_path = fields.Char('Repository Path', compute='_compute_repo_path', store=True)
    current_branch = fields.Char('Current Branch', default='main')
    commit_ids = fields.One2many('ivcs.commit', 'item_id', string='Commits')
    nostr_private_key = fields.Char(string="Nostr Private Key")
    branch_manager_id = fields.Many2one('ivcs.branch.manager', string='Branch Manager')

    @api.depends('name')
    def _compute_repo_path(self):
        for item in self:
            item.repo_path = f"/opt/ivcs_repos/item_{item.id}"

    @api.depends('version_ids')
    def _compute_current_version(self):
        for item in self:
            if item.version_ids:
                item.current_version_id = item.version_ids.sorted(lambda v: v.create_date, reverse=True)[0]
            else:
                item.current_version_id = False

    @api.model
    def create(self, vals):
        if 'nostr_private_key' in vals and vals['nostr_private_key']:
            try:
                # Validate and format the private key
                private_key = PrivateKey.from_nsec(vals['nostr_private_key'])
                vals['nostr_private_key'] = private_key.hex()  # Store the private key as a hex string
            except Exception as e:
                raise UserError(_("Invalid Nostr private key: %s") % str(e))
        return super(IVCSItem, self).create(vals)

    def write(self, vals):
        if 'nostr_private_key' in vals and vals['nostr_private_key']:
            try:
                # Validate and format the private key
                private_key = PrivateKey.from_nsec(vals['nostr_private_key'])
                vals['nostr_private_key'] = private_key.hex()  # Store the private key as a hex string
            except Exception as e:
                raise UserError(_("Invalid Nostr private key: %s") % str(e))
        return super(IVCSItem, self).write(vals)

    def _initialize_repository(self):
        self.ensure_one()
        if not os.path.exists(self.repo_path):
            os.makedirs(self.repo_path)
            repo = git.Repo.init(self.repo_path)
            readme_path = os.path.join(self.repo_path, 'README.md')
            with open(readme_path, 'w') as f:
                f.write(f"# {self.name}\n\n{self.description}")
            repo.index.add(['README.md'])
            commit = repo.index.commit("Initial commit")
            self._create_initial_version(commit.hexsha)
            self._create_nostr_repo_event()

    def _create_initial_version(self, commit_hash):
        version = self.env['ivcs.version'].create({
            'name': 'v1.0',
            'description': 'Initial version',
            'item_id': self.id,
        })
        self.env['ivcs.commit'].create({
            'hash': commit_hash,
            'message': "Initial commit",
            'item_id': self.id,
            'version_id': version.id,
        })

    def _create_nostr_repo_event(self):
        if not self.nostr_private_key:
            raise UserError(_("Nostr private key is not set for this item."))
    
        private_key = PrivateKey(bytes.fromhex(self.nostr_private_key))
        event = Event(
            kind=31228,
            content=json.dumps({
                "action": "create_repository",
                "repo_name": self.name,
                "description": self.description
            }),
            tags=[['r', self.repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)
        
        self.env['nostr.event'].create_and_publish(event)

    def create_branch(self, branch_name):
        self.ensure_one()
        repo = git.Repo(self.repo_path)
        if not self.branch_manager_id:
            self.branch_manager_id = self.env['ivcs.branch.manager'].create({
                'name': f"Branch Manager for {self.name}",
                'item_id': self.id,
            })
        if branch_name not in repo.heads:
            repo.create_head(branch_name)
            self.current_branch = branch_name
            self._create_nostr_branch_event(branch_name)
            if self.branch_manager_id:
                self.branch_manager_id.create_branch(branch_name)
            return self._return_success('Branch Created', f'Branch {branch_name} has been created.')
        else:
            return self._return_warning('Branch Exists', f'Branch {branch_name} already exists.')

    def _create_nostr_branch_event(self, branch_name):
        if not self.nostr_private_key:
            raise UserError(_("Nostr private key is not set for this item."))
        
        private_key = PrivateKey(bytes.fromhex(self.nostr_private_key))
        event = Event(
            kind=31227,
            content=json.dumps({
                "action": "create_branch",
                "branch_name": branch_name,
                "repo_name": self.name
            }),
            tags=[['r', self.repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)
        
        self.env['nostr.event'].create_and_publish(event)

    def _return_success(self, title, message):
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _(title),
                'message': _(message),
                'type': 'success',
            }
        }

    def _return_warning(self, title, message):
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _(title),
                'message': _(message),
                'type': 'warning',
            }
        }

    def delete_branch(self, branch_name):
        self.ensure_one()
        if self.branch_manager_id.delete_branch(branch_name):
            return self._return_success('Branch Deleted', f'Branch {branch_name} has been deleted.')
        else:
            return self._return_warning('Branch Not Found', f'Branch {branch_name} does not exist.')

    def merge_branches(self, source_branch, target_branch):
        self.ensure_one()
        if self.branch_manager_id.merge_branches(source_branch, target_branch):
            return self._return_success('Branches Merged', f'Branch {source_branch} has been merged into {target_branch}.')
        else:
            return self._return_warning('Merge Failed', f'Failed to merge {source_branch} into {target_branch}.')

    def reconstruct_branches(self):
        self.ensure_one()
        branches = self.branch_manager_id.reconstruct_branches_from_events()
        return self._return_success('Branches Reconstructed', f'Reconstructed {len(branches)} branches from Nostr events.')

    # Add other methods as needed (e.g., commit, push, pull, etc.)
=== ./odoo_custom_addons (copy)/integrated_ivcs/models/branch_manager.py ===
from odoo import models, fields, api
from git import Repo, GitCommandError
import json
from nostr.event import Event
from nostr.key import PrivateKey
import logging

_logger = logging.getLogger(__name__)

class BranchManager(models.Model):
    _name = 'ivcs.branch.manager'
    _description = 'IVCS Branch Manager'

    name = fields.Char(string='Name', required=True)
    item_id = fields.Many2one('ivcs.item', string='IVCS Item', required=True)

    def create_branch(self, branch_name):
        self.ensure_one()
        repo = Repo(self.item_id.repo_path)
        if branch_name not in repo.heads:
            repo.create_head(branch_name)
            self._create_branch_event(branch_name, 'create')
            return True
        return False

    def delete_branch(self, branch_name):
        self.ensure_one()
        repo = Repo(self.item_id.repo_path)
        if branch_name in repo.heads:
            repo.delete_head(branch_name, force=True)
            self._create_branch_event(branch_name, 'delete')
            return True
        return False

    def update_branch(self, branch_name, new_commit):
        self.ensure_one()
        repo = Repo(self.item_id.repo_path)
        if branch_name in repo.heads:
            branch = repo.heads[branch_name]
            branch.set_commit(new_commit)
            self._create_branch_event(branch_name, 'update', new_commit)
            return True
        return False

    def merge_branches(self, source_branch, target_branch):
        self.ensure_one()
        repo = Repo(self.item_id.repo_path)
        if source_branch in repo.heads and target_branch in repo.heads:
            try:
                repo.git.checkout(target_branch)
                repo.git.merge(source_branch)
                self._create_branch_event(target_branch, 'merge', source_branch)
                return True
            except GitCommandError as e:
                _logger.error(f"Merge conflict: {str(e)}")
                repo.git.merge('--abort')
                return False
        return False

    def _create_branch_event(self, branch_name, action, additional_info=None):
        if not self.item_id.nostr_private_key:
            _logger.warning(f"No Nostr private key for item {self.item_id.name}")
            return

        private_key = PrivateKey(bytes.fromhex(self.item_id.nostr_private_key))
        content = {
            "action": action,
            "branch_name": branch_name,
            "repo_name": self.item_id.name
        }
        if additional_info:
            content["additional_info"] = additional_info

        event = Event(
            kind=31227,
            content=json.dumps(content),
            tags=[['r', self.item_id.repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)
        
        self.env['nostr.event'].create_and_publish(event)

    def list_branches(self):
        self.ensure_one()
        repo = Repo(self.item_id.repo_path)
        return [head.name for head in repo.heads]

    def reconstruct_branches_from_events(self):
        self.ensure_one()
        events = self.env['nostr.event'].search([
            ('kind', '=', 31227),
            ('tags', 'ilike', self.item_id.repo_path)
        ], order='created_at asc')

        branches = {}
        for event in events:
            content = json.loads(event.content)
            action = content.get('action')
            branch_name = content.get('branch_name')

            if action == 'create':
                branches[branch_name] = {'created_at': event.created_at}
            elif action == 'delete':
                branches.pop(branch_name, None)
            elif action == 'update':
                if branch_name in branches:
                    branches[branch_name]['last_updated'] = event.created_at
            elif action == 'merge':
                if branch_name in branches:
                    branches[branch_name]['last_merged'] = event.created_at
                    branches[branch_name]['merged_from'] = content.get('additional_info')

        return branches
=== ./odoo_custom_addons (copy)/integrated_ivcs/__init__.py ===
from . import models
from . import wizards
=== ./odoo_custom_addons (copy)/integrated_ivcs/wizards/create_commit_wizard_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_create_commit_wizard_form" model="ir.ui.view">
        <field name="name">create.commit.wizard.form</field>
        <field name="model">create.commit.wizard</field>
        <field name="arch" type="xml">
            <form string="Create Commit">
                <group>
                    <field name="item_id"/>
                    <field name="message"/>
                </group>
                <footer>
                    <button name="action_create_commit" string="Create Commit" type="object" class="btn-primary"/>
                    <button string="Cancel" class="btn-secondary" special="cancel"/>
                </footer>
            </form>
        </field>
    </record>

    <record id="action_create_commit_wizard" model="ir.actions.act_window">
        <field name="name">Create Commit</field>
        <field name="res_model">create.commit.wizard</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/integrated_ivcs/wizards/__init__.py ===
from . import create_branch_wizard
from . import create_commit_wizard
=== ./odoo_custom_addons (copy)/integrated_ivcs/wizards/create_commit_wizard.py ===
from odoo import models, fields, api

class CreateCommitWizard(models.TransientModel):
    _name = 'create.commit.wizard'
    _description = 'Create Commit Wizard'

    item_id = fields.Many2one('ivcs.item', string='IVCS Item', required=True)
    message = fields.Text(string='Commit Message', required=True)

    def action_create_commit(self):
        self.ensure_one()
        repo = self.env['git.repository'].search([('path', '=', self.item_id.repo_path)])
        commit_hash = repo.commit_changes(self.message)
        self.env['ivcs.commit'].create({
            'hash': commit_hash,
            'message': self.message,
            'author': self.env.user.name,
            'date': fields.Datetime.now(),
            'item_id': self.item_id.id,
        })
        return {'type': 'ir.actions.act_window_close'}
=== ./odoo_custom_addons (copy)/integrated_ivcs/wizards/create_branch_wizard.py ===
from odoo import models, fields, api

class CreateBranchWizard(models.TransientModel):
    _name = 'create.branch.wizard'
    _description = 'Create Branch Wizard'

    item_id = fields.Many2one('ivcs.item', string='IVCS Item', required=True)
    branch_name = fields.Char(string='Branch Name', required=True)

    def action_create_branch(self):
        self.ensure_one()
        return self.item_id.create_branch(self.branch_name)
=== ./odoo_custom_addons (copy)/integrated_ivcs/wizards/create_branch_wizard_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_create_branch_wizard_form" model="ir.ui.view">
        <field name="name">create.branch.wizard.form</field>
        <field name="model">create.branch.wizard</field>
        <field name="arch" type="xml">
            <form string="Create Branch">
                <group>
                    <field name="item_id"/>
                    <field name="branch_name"/>
                </group>
                <footer>
                    <button name="action_create_branch" string="Create Branch" type="object" class="btn-primary"/>
                    <button string="Cancel" class="btn-secondary" special="cancel"/>
                </footer>
            </form>
        </field>
    </record>

    <record id="action_create_branch_wizard" model="ir.actions.act_window">
        <field name="name">Create Branch</field>
        <field name="res_model">create.branch.wizard</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/integrated_ivcs/cli.py ===
import argparse
import os
import git
from nostr.event import Event
from nostr.key import PrivateKey
import json
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class GitNostrCLI:
    def __init__(self, repo_path):
        self.repo_path = repo_path
        self.repo = git.Repo(repo_path)
        self.private_key = PrivateKey()

    def create_branch(self, branch_name):
        logger.info(f"Creating branch: {branch_name}")
        self.repo.create_head(branch_name)
        self._create_branch_event(branch_name, 'create')
        logger.info(f"Branch {branch_name} created successfully")

    def delete_branch(self, branch_name):
        logger.info(f"Deleting branch: {branch_name}")
        self.repo.delete_head(branch_name, force=True)
        self._create_branch_event(branch_name, 'delete')
        logger.info(f"Branch {branch_name} deleted successfully")

    def merge_branches(self, source_branch, target_branch):
        logger.info(f"Merging {source_branch} into {target_branch}")
        self.repo.git.checkout(target_branch)
        try:
            self.repo.git.merge(source_branch)
            self._create_branch_event(target_branch, 'merge', source_branch)
            logger.info(f"Merged {source_branch} into {target_branch} successfully")
        except git.GitCommandError as e:
            logger.error(f"Merge conflict: {str(e)}")
            self.repo.git.merge('--abort')
            logger.info("Merge aborted due to conflicts")

    def commit_changes(self, message):
        logger.info(f"Committing changes with message: {message}")
        self.repo.git.add(A=True)
        commit = self.repo.index.commit(message)
        self._create_commit_event(commit)
        logger.info(f"Changes committed successfully. Commit hash: {commit.hexsha}")

    def _create_branch_event(self, branch_name, action, additional_info=None):
        logger.info(f"Creating Nostr event for branch action: {action}")
        content = {
            "action": action,
            "branch_name": branch_name,
            "repo_name": os.path.basename(self.repo_path)
        }
        if additional_info:
            content["additional_info"] = additional_info

        event = Event(
            kind=31227,
            content=json.dumps(content),
            tags=[['r', self.repo_path]],
            public_key=self.private_key.public_key.hex()
        )
        self.private_key.sign_event(event)
        logger.info(f"Nostr event created: {event.id}")
        # Here you would typically publish the event to Nostr relays

    def _create_commit_event(self, commit):
        logger.info(f"Creating Nostr event for commit: {commit.hexsha}")
        content = json.dumps({
            "action": "commit",
            "message": commit.message,
            "author": commit.author.name,
            "email": commit.author.email,
            "date": commit.authored_datetime.isoformat(),
            "hash": commit.hexsha,
            "parent_hashes": [c.hexsha for c in commit.parents],
            "tree_hash": commit.tree.hexsha,
        })
        
        event = Event(
            kind=3121,
            content=content,
            tags=[
                ["r", self.repo_path],
                ["h", commit.hexsha],
            ],
            public_key=self.private_key.public_key.hex()
        )
        self.private_key.sign_event(event)
        logger.info(f"Nostr event created: {event.id}")
        # Here you would typically publish the event to Nostr relays

def main():
    parser = argparse.ArgumentParser(description="Git-Nostr CLI")
    parser.add_argument('repo_path', help="Path to the Git repository")
    parser.add_argument('action', choices=['create-branch', 'delete-branch', 'merge-branches', 'commit'])
    parser.add_argument('--branch-name', help="Name of the branch (for create-branch and delete-branch)")
    parser.add_argument('--source-branch', help="Source branch for merge")
    parser.add_argument('--target-branch', help="Target branch for merge")
    parser.add_argument('--commit-message', help="Commit message")

    args = parser.parse_args()

    cli = GitNostrCLI(args.repo_path)

    if args.action == 'create-branch':
        cli.create_branch(args.branch_name)
    elif args.action == 'delete-branch':
        cli.delete_branch(args.branch_name)
    elif args.action == 'merge-branches':
        cli.merge_branches(args.source_branch, args.target_branch)
    elif args.action == 'commit':
        cli.commit_changes(args.commit_message)

if __name__ == "__main__":
    main()
=== ./odoo_custom_addons (copy)/integrated_ivcs/__manifest__.py ===
{
    'name': 'Integrated IVCS',
    'version': '1.0',
    'category': 'Development',
    'summary': 'Integrated Version Control System with Git and Nostr',
    'author': 'Your Name',
    'website': 'https://www.example.com',
    'depends': ['base', 'mail'],
    'data': [
        'security/ir.model.access.csv',
        'views/ivcs_item_views.xml',
        'views/ivcs_version_views.xml',
        'views/ivcs_commit_views.xml',
        'views/git_repository_views.xml',
        'views/nostr_event_views.xml',
        'views/res_config_settings_views.xml',
        'wizards/create_branch_wizard_views.xml',
        'wizards/create_commit_wizard_views.xml',
    ],
    'external_dependencies': {
        'python': ['git', 'nostr'],
    },
    'installable': True,
    'application': True,
    'auto_install': False,
}
=== ./odoo_custom_addons (copy)/integrated_ivcs/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_ivcs_item_user,ivcs.item user,model_ivcs_item,base.group_user,1,1,1,1
access_ivcs_version_user,ivcs.version user,model_ivcs_version,base.group_user,1,1,1,1
access_ivcs_commit_user,ivcs.commit user,model_ivcs_commit,base.group_user,1,1,1,1
access_git_repository_user,git.repository user,model_git_repository,base.group_user,1,1,1,1
access_nostr_event_user,nostr.event user,model_nostr_event,base.group_user,1,1,1,1
access_ivcs_branch_manager_user,ivcs.branch.manager user,model_ivcs_branch_manager,base.group_user,1,1,1,1
access_create_branch_wizard_user,create.branch.wizard user,model_create_branch_wizard,base.group_user,1,1,1,0
access_create_commit_wizard_user,create.commit.wizard user,model_create_commit_wizard,base.group_user,1,1,1,0
=== ./odoo_custom_addons (copy)/integrated_ivcs/tests/test_git_nostr_integration.py ===
import unittest
import tempfile
import os
import git
import json
from nostr.event import Event
from nostr.key import PrivateKey
from odoo.tests.common import TransactionCase
from odoo.exceptions import UserError

class TestGitNostrIntegration(TransactionCase):

    def setUp(self):
        super(TestGitNostrIntegration, self).setUp()
        self.IVCSItem = self.env['ivcs.item']
        self.NostrEvent = self.env['nostr.event']
        self.temp_dir = tempfile.mkdtemp()
        self.repo_path = os.path.join(self.temp_dir, 'test_repo')

    def tearDown(self):
        super(TestGitNostrIntegration, self).tearDown()
        if os.path.exists(self.temp_dir):
            import shutil
            shutil.rmtree(self.temp_dir)

    def test_create_repository(self):
        item = self.IVCSItem.create({
            'name': 'Test Repo',
            'description': 'Test repository',
            'repo_path': self.repo_path,
        })
        self.assertTrue(os.path.exists(self.repo_path))
        self.assertTrue(os.path.exists(os.path.join(self.repo_path, '.git')))
        self.assertTrue(os.path.exists(os.path.join(self.repo_path, 'README.md')))

    def test_create_branch(self):
        item = self.IVCSItem.create({
            'name': 'Test Repo',
            'description': 'Test repository',
            'repo_path': self.repo_path,
        })
        result = item.create_branch('test-branch')
        self.assertEqual(result['type'], 'ir.actions.client')
        self.assertEqual(result['params']['type'], 'success')
        repo = git.Repo(self.repo_path)
        self.assertIn('test-branch', repo.heads)

    def test_merge_branches(self):
        item = self.IVCSItem.create({
            'name': 'Test Repo',
            'description': 'Test repository',
            'repo_path': self.repo_path,
        })
        item.create_branch('branch1')
        item.create_branch('branch2')
        repo = git.Repo(self.repo_path)
        repo.heads.branch1.checkout()
        with open(os.path.join(self.repo_path, 'file1.txt'), 'w') as f:
            f.write('Content in branch1')
        repo.index.add(['file1.txt'])
        repo.index.commit('Commit in branch1')
        
        result = item.merge_branches('branch1', 'branch2')
        self.assertEqual(result['type'], 'ir.actions.client')
        self.assertEqual(result['params']['type'], 'success')
        
        repo.heads.branch2.checkout()
        self.assertTrue(os.path.exists(os.path.join(self.repo_path, 'file1.txt')))

    def test_create_nostr_events(self):
        item = self.IVCSItem.create({
            'name': 'Test Repo',
            'description': 'Test repository',
            'repo_path': self.repo_path,
        })
        repo = git.Repo(self.repo_path)
        with open(os.path.join(self.repo_path, 'test.txt'), 'w') as f:
            f.write('Test content')
        repo.index.add(['test.txt'])
        commit = repo.index.commit('Test commit')
        
        event = self.NostrEvent.create_git_event(self.repo_path, commit.hexsha)
        self.assertEqual(event.kind, 3121)
        self.assertIn(commit.hexsha, event.content)

    def test_reconstruct_git_objects(self):
        item = self.IVCSItem.create({
            'name': 'Test Repo',
            'description': 'Test repository',
            'repo_path': self.repo_path,
        })
        repo = git.Repo(self.repo_path)
        with open(os.path.join(self.repo_path, 'test.txt'), 'w') as f:
            f.write('Test content')
        repo.index.add(['test.txt'])
        commit = repo.index.commit('Test commit')
        
        self.NostrEvent.create_git_event(self.repo_path, commit.hexsha)
        
        # Delete the .git directory to simulate a fresh repository
        import shutil
        shutil.rmtree(os.path.join(self.repo_path, '.git'))
        
        # Reconstruct the repository from Nostr events
        self.NostrEvent.reconstruct_git_objects(self.repo_path)
        
        reconstructed_repo = git.Repo(self.repo_path)
        self.assertIn(commit.hexsha, reconstructed_repo.heads.master.commit.hexsha)
        self.assertTrue(os.path.exists(os.path.join(self.repo_path, 'test.txt')))

if __name__ == '__main__':
    unittest.main()
=== ./odoo_custom_addons (copy)/integrated_ivcs/views/res_config_settings_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="res_config_settings_view_form" model="ir.ui.view">
        <field name="name">res.config.settings.view.form.inherit.integrated_ivcs</field>
        <field name="model">res.config.settings</field>
        <field name="inherit_id" ref="base.res_config_settings_view_form"/>
        <field name="arch" type="xml">
            <xpath expr="//div[hasclass('settings')]" position="inside">
                <div class="app_settings_block" data-string="Integrated IVCS" string="Integrated IVCS" data-key="integrated_ivcs">
                    <h2>Nostr Settings</h2>
                    <div class="row mt16 o_settings_container">
                        <div class="col-12 col-lg-6 o_setting_box">
                            <div class="o_setting_left_pane"/>
                            <div class="o_setting_right_pane">
                                <span class="o_form_label">Nostr Relay URLs</span>
                                <div class="text-muted">
                                    Comma-separated list of Nostr relay URLs
                                </div>
                                <div class="content-group">
                                    <field name="integrated_ivcs_relay_urls"/>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </xpath>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/integrated_ivcs/views/ivcs_version_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_ivcs_version_form" model="ir.ui.view">
        <field name="name">ivcs.version.form</field>
        <field name="model">ivcs.version</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="description"/>
                        <field name="item_id"/>
                        <field name="commit_id"/>
                        <field name="create_date"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_ivcs_version_tree" model="ir.ui.view">
        <field name="name">ivcs.version.tree</field>
        <field name="model">ivcs.version</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="item_id"/>
                <field name="create_date"/>
            </tree>
        </field>
    </record>

    <record id="action_ivcs_version" model="ir.actions.act_window">
        <field name="name">IVCS Versions</field>
        <field name="res_model">ivcs.version</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_ivcs_version" name="Versions" parent="menu_ivcs_root" action="action_ivcs_version"/>
</odoo>
=== ./odoo_custom_addons (copy)/integrated_ivcs/views/nostr_event_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_nostr_event_form" model="ir.ui.view">
        <field name="name">nostr.event.form</field>
        <field name="model">nostr.event</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="event_id"/>
                        <field name="kind"/>
                        <field name="event_type"/>
                        <field name="content"/>
                        <field name="tags"/>
                        <field name="public_key"/>
                        <field name="created_at"/>
                        <field name="signature"/>
                        <field name="published"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_nostr_event_tree" model="ir.ui.view">
        <field name="name">nostr.event.tree</field>
        <field name="model">nostr.event</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="event_id"/>
                <field name="kind"/>
                <field name="event_type"/>
                <field name="public_key"/>
                <field name="created_at"/>
                <field name="published"/>
            </tree>
        </field>
    </record>

    <record id="action_nostr_event" model="ir.actions.act_window">
        <field name="name">Nostr Events</field>
        <field name="res_model">nostr.event</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_nostr_event" name="Nostr Events" parent="menu_ivcs_root" action="action_nostr_event"/>
</odoo>
=== ./odoo_custom_addons (copy)/integrated_ivcs/views/ivcs_item_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_ivcs_item_form" model="ir.ui.view">
        <field name="name">ivcs.item.form</field>
        <field name="model">ivcs.item</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="description"/>
                        <field name="repo_path"/>
                        <field name="current_branch"/>
                        <field name="current_version_id"/>
                        <field name="nostr_private_key" password="True"/>
                    </group>
                    <notebook>
                        <page string="Versions">
                            <field name="version_ids"/>
                        </page>
                        <page string="Commits">
                            <field name="commit_ids"/>
                        </page>
                    </notebook>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_ivcs_item_tree" model="ir.ui.view">
        <field name="name">ivcs.item.tree</field>
        <field name="model">ivcs.item</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="repo_path"/>
                <field name="current_branch"/>
                <field name="current_version_id"/>
            </tree>
        </field>
    </record>

    <record id="action_ivcs_item" model="ir.actions.act_window">
        <field name="name">IVCS Items</field>
        <field name="res_model">ivcs.item</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_ivcs_root" name="Integrated IVCS"/>
    <menuitem id="menu_ivcs_item" name="IVCS Items" parent="menu_ivcs_root" action="action_ivcs_item"/>
</odoo>
=== ./odoo_custom_addons (copy)/integrated_ivcs/views/git_repository_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_repository_form" model="ir.ui.view">
        <field name="name">git.repository.form</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="path"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_git_repository_tree" model="ir.ui.view">
        <field name="name">git.repository.tree</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="path"/>
            </tree>
        </field>
    </record>

    <record id="action_git_repository" model="ir.actions.act_window">
        <field name="name">Git Repositories</field>
        <field name="res_model">git.repository</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_git_repository" name="Git Repositories" parent="menu_ivcs_root" action="action_git_repository"/>
</odoo>
=== ./odoo_custom_addons (copy)/integrated_ivcs/views/ivcs_commit_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_ivcs_commit_form" model="ir.ui.view">
        <field name="name">ivcs.commit.form</field>
        <field name="model">ivcs.commit</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="hash"/>
                        <field name="message"/>
                        <field name="author"/>
                        <field name="date"/>
                        <field name="item_id"/>
                        <field name="version_id"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_ivcs_commit_tree" model="ir.ui.view">
        <field name="name">ivcs.commit.tree</field>
        <field name="model">ivcs.commit</field>
        <field name="arch" type="xml">
            <tree>
                <field name="hash"/>
                <field name="message"/>
                <field name="author"/>
                <field name="date"/>
                <field name="item_id"/>
            </tree>
        </field>
    </record>

    <record id="action_ivcs_commit" model="ir.actions.act_window">
        <field name="name">IVCS Commits</field>
        <field name="res_model">ivcs.commit</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_ivcs_commit" name="Commits" parent="menu_ivcs_root" action="action_ivcs_commit"/>
</odoo>
=== ./allfiles.txt ===
=== ./check_nostr_bridge.sh ===
#!/bin/bash

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Function to print colored output
print_status() {
    if [ $1 -eq 0 ]; then
        echo -e "${GREEN}[OK]${NC} $2"
    else
        echo -e "${RED}[FAIL]${NC} $2"
    fi
}

echo "Running pre-update checks for nostr_bridge module..."

# 1. Verify required Python libraries
echo -e "\n${YELLOW}Checking required Python libraries...${NC}"
required_libs=("websockets" "nostr")
for lib in "${required_libs[@]}"; do
    if pip3 list | grep -F "$lib" > /dev/null; then
        print_status 0 "$lib is installed"
    else
        print_status 1 "$lib is not installed"
    fi
done

# 2. Check module file location
echo -e "\n${YELLOW}Checking module file location...${NC}"
module_path="/opt/odoo/custom_addons/nostr_bridge"
if [ -d "$module_path" ]; then
    print_status 0 "Module directory exists at $module_path"
    if [ -f "$module_path/__manifest__.py" ]; then
        print_status 0 "__manifest__.py file exists"
    else
        print_status 1 "__manifest__.py file not found in $module_path"
    fi
else
    print_status 1 "Module directory not found at $module_path"
fi

# 3. Check __manifest__.py content
echo -e "\n${YELLOW}Checking __manifest__.py content...${NC}"
manifest_file="$module_path/__manifest__.py"
if [ -f "$manifest_file" ]; then
    if grep -q "'depends':" "$manifest_file" && grep -q "'data':" "$manifest_file"; then
        print_status 0 "__manifest__.py contains 'depends' and 'data' sections"
    else
        print_status 1 "__manifest__.py might be missing 'depends' or 'data' sections"
    fi
else
    print_status 1 "__manifest__.py file not found"
fi

# 4. Verify configuration parameters
echo -e "\n${YELLOW}Checking configuration parameters...${NC}"
odoo_db="odoodb"  # Replace with your actual database name if different
config_param="git_nostr_bridge.relay_urls"
relay_urls=$(psql -d $odoo_db -t -c "SELECT value FROM ir_config_parameter WHERE key='$config_param';")
if [ -n "$relay_urls" ]; then
    print_status 0 "Relay URLs are set: $relay_urls"
else
    print_status 1 "Relay URLs are not set in the database"
fi

# 5. Test network connectivity
echo -e "\n${YELLOW}Testing network connectivity...${NC}"
test_urls=("wss://nostr-pub.wellorder.net" "wss://relay.nostr.info" "wss://nostr.zebedee.cloud")
for url in "${test_urls[@]}"; do
    if curl --output /dev/null --silent --head --fail "$url"; then
        print_status 0 "Connection to $url successful"
    else
        print_status 1 "Failed to connect to $url"
    fi
done

echo -e "\n${YELLOW}Pre-update checks completed.${NC}"
=== ./Dockerfile ===
FROM ubuntu:22.04
ENV ODOO_VERSION 16.0
ENV OPENEDUCAT_VERSION 16.0
ENV DEBIAN_FRONTEND noninteractive

# Install dependencies
RUN apt-get update && apt-get install -y \
    python3 python3-pip python3-dev python3-venv \
    postgresql-client \
    nodejs npm \
    git \
    wget \
    libxml2-dev libxslt1-dev \
    libjpeg-dev libfreetype6-dev \
    libpq-dev \
    build-essential \
    libldap2-dev libsasl2-dev \
    libssl-dev \
    libffi-dev \
    iputils-ping \
    curl \
    && rm -rf /var/lib/apt/lists/*

# Create Odoo user
RUN useradd -m -d /opt/odoo -U -r -s /bin/bash odoo

# Clone Odoo and OpenEduCat
RUN git clone https://github.com/odoo/odoo.git --depth 1 --branch ${ODOO_VERSION} /opt/odoo/odoo
RUN git clone https://github.com/openeducat/openeducat_erp.git --depth 1 --branch ${OPENEDUCAT_VERSION} /opt/odoo/openeducat

# Install Python dependencies
RUN pip3 install --upgrade pip
RUN pip3 install --no-cache-dir -r /opt/odoo/odoo/requirements.txt
RUN pip3 install cryptography pyopenssl==22.1.0 psycopg2-binary bs4 BeautifulSoup4 gitpython bech32 websocket-client websockets
RUN pip3 install nostr

# Copy OpenEduCat addons
RUN cp -r /opt/odoo/openeducat/* /opt/odoo/odoo/addons/

# Copy custom files
COPY ./nostr_auth.py /opt/odoo/
COPY ./custom_odoo_server.py /opt/odoo/
COPY ./odoo_custom_addons /opt/odoo/custom_addons
COPY ./check_nostr_bridge.sh /opt/odoo/check_nostr_bridge.sh

# Set up directories and permissions
RUN mkdir -p /etc/odoo /opt/ivcs_repos /var/lib/odoo /opt/odoo/.local/share/Odoo/filestore /opt/odoo/.local/share/Odoo/sessions
RUN chown -R odoo:odoo /opt/odoo /etc/odoo /opt/ivcs_repos /var/lib/odoo
RUN chmod +x /opt/odoo/check_nostr_bridge.sh /opt/odoo/custom_odoo_server.py

# Switch to odoo user
USER odoo

# Patch OpenSSL
RUN echo "from OpenSSL import crypto" > /tmp/patch_openssl.py && \
    echo "if not hasattr(crypto, 'X509_V_FLAG_EXPLICIT_POLICY'):" >> /tmp/patch_openssl.py && \
    echo "    crypto.X509_V_FLAG_EXPLICIT_POLICY = 0x8000" >> /tmp/patch_openssl.py && \
    echo "exec(open('/tmp/patch_openssl.py').read())" >> /opt/odoo/odoo/odoo/addons/base/models/ir_mail_server.py

# Initialize the database and start Odoo
CMD ["/bin/bash", "-c", "\
    /opt/odoo/check_nostr_bridge.sh && \
    python3 /opt/odoo/odoo/odoo-bin -c /etc/odoo/odoo.conf -d odoodb -i base && \
    python3 /opt/odoo/custom_odoo_server.py -c /etc/odoo/odoo.conf \
    "]
=== ./COPY OF THE Git Nostr Bridge Test Code ===
import asyncio
import json
import logging
import websockets
from urllib.parse import urlparse
import time
import traceback

from odoo import models, fields, api, _
from odoo.exceptions import UserError
from nostr.event import Event as NostrLibEvent
from nostr.key import PrivateKey

_logger = logging.getLogger(__name__)

class NostrEvent(models.Model):
    _name = 'nostr.event'
    _description = 'Nostr Event'

    name = fields.Char(string='Name', required=True)
    event_type = fields.Selection([
        ('repo_anchor', 'Repository Anchor'),
        ('branch', 'Branch'),
        ('commit', 'Commit'),
        ('tree', 'Tree'),
        ('blob', 'Blob'),
    ], string='Event Type', required=True)
    content = fields.Text(string='Content')
    tags = fields.Text(string='Tags')
    published = fields.Boolean(string='Published', default=False)
    event_id = fields.Char(string='Event ID', readonly=True)

    @api.model
    def action_publish(self, event_id):
        event = self.browse(event_id)
        _logger.info(f"Starting publish action for event: {event.name}")
        start_time = time.time()

        try:
            if not self.env.user.nostr_private_key:
                raise UserError(_("Nostr private key is not set for the current user."))

            _logger.info("Generating private key")
            try:
                private_key = PrivateKey.from_nsec(self.env.user.nostr_private_key)
                _logger.info("Private key generated successfully")
            except Exception as e:
                _logger.error(f"Failed to generate private key: {str(e)}")
                _logger.error(traceback.format_exc())
                raise UserError(_("Invalid Nostr private key: %s") % str(e))

            public_key = private_key.public_key.hex()
            _logger.info(f"Public key: {public_key}")

            _logger.info("Parsing tags")
            try:
                tags = json.loads(event.tags) if event.tags else []
                _logger.info(f"Parsed tags: {tags}")
                if not isinstance(tags, list):
                    raise ValueError("Tags must be a list of lists")
                for tag in tags:
                    if not isinstance(tag, list):
                        raise ValueError("Each tag must be a list")
            except json.JSONDecodeError as e:
                _logger.error(f"JSON decode error: {str(e)}")
                _logger.error(traceback.format_exc())
                raise UserError(_("Invalid tags format. Please ensure tags are in valid JSON format."))
            except ValueError as e:
                _logger.error(f"Value error: {str(e)}")
                _logger.error(traceback.format_exc())
                raise UserError(_("Invalid tags format: %s") % str(e))

            _logger.info("Creating Nostr event")
            nostr_event = NostrLibEvent(
                kind=1,  # Assuming TEXT_NOTE, adjust if needed
                content=str(event.content),
                tags=tags,
                public_key=public_key  # Ensure public_key is provided
            )
            private_key.sign_event(nostr_event)
            _logger.info(f"Event created: {nostr_event.to_message()}")

            _logger.info("Fetching relay URLs")
            relay_urls = self.env['ir.config_parameter'].sudo().get_param('git_nostr_bridge.relay_urls', '').split(',')
            relay_urls = [url.strip() for url in relay_urls if url.strip()][:5]  # Limit to 5 relays
            _logger.info(f"Relay URLs: {relay_urls}")

            if not relay_urls:
                raise UserError(_("No Nostr relay URLs configured. Please set them in the settings."))

            _logger.info("Validating relay URLs")
            for url in relay_urls:
                parsed = urlparse(url)
                if parsed.scheme not in ('ws', 'wss'):
                    _logger.error(f"Invalid relay URL: {url}")
                    raise UserError(_("Invalid relay URL: %s. Must start with ws:// or wss://") % url)

            async def publish_to_relay(relay_url, nostr_event, retries=3):
                for attempt in range(retries):
                    try:
                        _logger.info(f"Attempting to connect to {relay_url} (attempt {attempt + 1})")
                        connection_start = time.time()
                        async with websockets.connect(relay_url, timeout=30) as websocket:
                            connection_end = time.time()
                            _logger.info(f"Connected to {relay_url} in {connection_end - connection_start:.2f} seconds")
                            
                            message = nostr_event.to_message()
                            _logger.debug(f"Raw event message: {message}")
                            
                            # The message is already in the correct format, so we don't need to modify it
                            _logger.info(f"Sending Nostr event to {relay_url}: {message}")
                            
                            send_start = time.time()
                            await websocket.send(message)
                            send_end = time.time()
                            _logger.info(f"Sent message to {relay_url} in {send_end - send_start:.2f} seconds")
                            
                            _logger.info(f"Waiting for response from {relay_url}")
                            response_start = time.time()
                            response = await asyncio.wait_for(websocket.recv(), timeout=10.0)
                            response_end = time.time()
                            _logger.info(f"Received response from {relay_url} in {response_end - response_start:.2f} seconds: {response}")
                            
                            try:
                                return json.loads(response)
                            except json.JSONDecodeError as e:
                                _logger.error(f"Failed to parse response from {relay_url}: {str(e)}")
                                return f"Invalid response from {relay_url}: {response}"
                    except (websockets.exceptions.WebSocketException, asyncio.TimeoutError) as e:
                        _logger.error(f"Error publishing to {relay_url} (attempt {attempt + 1}): {str(e)}")
                        _logger.error(traceback.format_exc())
                        await asyncio.sleep(5 * (attempt + 1))  # Increased delay between attempts
                return f"Failed to publish to {relay_url} after {retries} attempts"

            async def publish_with_timeout():
                tasks = [publish_to_relay(url, nostr_event) for url in relay_urls]
                return await asyncio.gather(*tasks, return_exceptions=True)

            async def run_publication():
                _logger.info("Starting publication process")
                try:
                    results = await asyncio.wait_for(publish_with_timeout(), timeout=120)  # Increased overall timeout
                    _logger.info(f"Publication results: {results}")
                    return results
                except asyncio.TimeoutError:
                    _logger.error("Publication process timed out after 120 seconds")
                    raise UserError(_("Publishing timed out after 120 seconds"))

            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            try:
                results = loop.run_until_complete(run_publication())
            finally:
                loop.close()

            success = any(isinstance(result, list) and result[0] == "OK" for result in results)
            if success:
                event.write({
                    'published': True,
                    'event_id': nostr_event.id
                })
                _logger.info(f"Successfully published Nostr event: {nostr_event.id}")
                
                # Verify event publication
                self.verify_event_publication(nostr_event.id, relay_urls)
                
                end_time = time.time()
                _logger.info(f"Total publish action time: {end_time - start_time:.2f} seconds")
                
                return {
                    'type': 'ir.actions.client',
                    'tag': 'display_notification',
                    'params': {
                        'message': _("Nostr event successfully published to at least one relay."),
                        'type': 'success',
                        'sticky': False,
                    }
                }
            else:
                error_messages = [str(result) for result in results if isinstance(result, str)]
                _logger.error(f"Failed to publish Nostr event: {'; '.join(error_messages)}")
                raise UserError(_("Failed to publish Nostr event: %s") % "; ".join(error_messages))

        except Exception as e:
            _logger.error(f"Unexpected error in action_publish: {str(e)}")
            _logger.error(traceback.format_exc())
            raise UserError(_("An unexpected error occurred: %s") % str(e))

    @api.model
    def verify_event_publication(self, event_id, relay_urls, max_attempts=5, delay=2):
        _logger.info(f"Starting verification for event: {event_id}")
        for attempt in range(max_attempts):
            _logger.info(f"Verification attempt {attempt + 1}")
            for url in relay_urls:
                try:
                    loop = asyncio.new_event_loop()
                    asyncio.set_event_loop(loop)
                    result = loop.run_until_complete(self.query_event(url, event_id))
                    if result:
                        _logger.info(f"Event {event_id} found on relay {url}")
                        return True
                except Exception as e:
                    _logger.error(f"Error querying event from {url}: {str(e)}")
                    _logger.error(traceback.format_exc())
                finally:
                    loop.close()
            _logger.info(f"Waiting {delay} seconds before next attempt")
            time.sleep(delay)
        _logger.warning(f"Event {event_id} not found on any relay after {max_attempts} attempts")
        return False

    async def query_event(self, relay_url, event_id):
        _logger.info(f"Querying event {event_id} from {relay_url}")
        start_time = time.time()
        try:
            async with websockets.connect(relay_url, timeout=10) as websocket:
                request = json.dumps(["REQ", "query", {"ids": [event_id]}])
                _logger.info(f"Sending query to {relay_url}: {request}")
                await websocket.send(request)
                response = await asyncio.wait_for(websocket.recv(), timeout=5.0)
                _logger.info(f"Response from {relay_url}: {response}")
                end_time = time.time()
                _logger.info(f"Query to {relay_url} took {end_time - start_time:.2f} seconds")
                return json.loads(response)
        except Exception as e:
            _logger.error(f"Error querying {relay_url}: {str(e)}")
            _logger.error(traceback.format_exc())
            end_time = time.time()
            _logger.info(f"Failed query to {relay_url} took {end_time - start_time:.2f} seconds")
            return None
=== ./custom_odoo_server.py ===
#!/usr/bin/env python3
import sys
import os

# Add Odoo to Python path
odoo_path = '/opt/odoo/odoo'
sys.path.append(odoo_path)

import odoo
from odoo.tools import config
from odoo.exceptions import AccessDenied

if __name__ == "__main__":
    config.parse_config(sys.argv[1:])
    
    if config.get('auth_method') == 'nostr':
        def check_security(method, *args, **kwargs):
            if odoo.http.request and odoo.http.request.params:
                public_key = odoo.http.request.params.get('public_key')
                signature = odoo.http.request.params.get('signature')
                message = odoo.http.request.params.get('message')
                
                if public_key and signature and message:
                    user_id = odoo.http.request.env['res.users'].sudo().authenticate_nostr(public_key, signature, message)
                    if user_id:
                        odoo.http.request.uid = user_id
                        return
            
            return method(*args, **kwargs)

        odoo.http.Root.check_security = check_security

    # Force database initialization
    db_name = config['db_name']
    if not odoo.service.db.exp_db_exist(db_name):
        odoo.service.db.exp_create_database(
            db_name,
            demo=False,
            lang='en_US',
            user_password='admin'
        )
        print(f"Database '{db_name}' created.")
    else:
        print(f"Database '{db_name}' already exists.")

    # Initialize the database with base module
    odoo.modules.registry.Registry.new(db_name, update_module=True)
    
    odoo.cli.main()
=== ./odoo_custom_addons/git_repository_anchor/models/git_repository.py ===
from odoo import models, fields, api, _
from odoo.exceptions import UserError
import git
import os
import logging

_logger = logging.getLogger(__name__)

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'
    _inherit = ['mail.thread', 'mail.activity.mixin']

    name = fields.Char(string='Repository Name', required=True)
    path = fields.Char(string='Repository Path', required=True)
    description = fields.Text(string='Description', tracking=True)
    maintainer_ids = fields.Many2many('res.users', string='Maintainers')
    anchor_event_id = fields.Many2one('nostr.event', string='Anchor Event')
    #company_id = fields.Many2one('res.company', string='Company', required=True, default=lambda self: self.env.company)

    @api.model
    def create(self, vals):
        repo = super(GitRepository, self).create(vals)
        repo._initialize_repository()
        return repo

    def _initialize_repository(self):
        if not os.path.exists(self.path):
            os.makedirs(self.path)
            git.Repo.init(self.path)
            readme_path = os.path.join(self.path, 'README.md')
            with open(readme_path, 'w') as f:
                f.write(f"# {self.name}\n\n{self.description or ''}")
            repo = git.Repo(self.path)
            repo.index.add(['README.md'])
            repo.index.commit("Initial commit")

    def _create_anchor_event(self):
        anchor = self.env['git.repository.anchor']
        event = anchor.create_anchor_event(self.path, self.maintainer_ids.mapped('nostr_public_key'))
        self.env['nostr.event'].create_and_publish(event)
        self.anchor_event_id = self.env['nostr.event'].search([('event_id', '=', event.id)], limit=1).id

    def update_maintainers(self):
        anchor = self.env['git.repository.anchor']
        event = anchor.update_anchor(self.path, self.maintainer_ids.mapped('nostr_public_key'))
        self.env['nostr.event'].create_and_publish(event)
        self.anchor_event_id = self.env['nostr.event'].search([('event_id', '=', event.id)], limit=1).id

    def fork_repository(self, new_name, new_path, new_maintainer_ids):
        anchor = self.env['git.repository.anchor']
        new_maintainers = self.env['res.users'].browse(new_maintainer_ids).mapped('nostr_public_key')
        event = anchor.fork_repository(self.path, new_path, new_maintainers)
        self.env['nostr.event'].create_and_publish(event)
        
        new_repo = self.create({
            'name': new_name,
            'path': new_path,
            'maintainer_ids': [(6, 0, new_maintainer_ids)],
        })
        new_repo.anchor_event_id = self.env['nostr.event'].search([('event_id', '=', event.id)], limit=1).id
        
        # Clone the repository
        git.Repo.clone_from(self.path, new_path)
        
        return new_repo

    def check_permission(self, user_id):
        user = self.env['res.users'].browse(user_id)
        anchor = self.env['git.repository.anchor']
        return anchor.check_permission(self.anchor_event_id, user.nostr_public_key)
=== ./odoo_custom_addons/git_repository_anchor/models/__init__.py ===
from . import repository_anchor
from . import branch_manager
from . import odoo_models
from . import git_repository
from . import nostr_event
=== ./odoo_custom_addons/git_repository_anchor/models/repository_anchor.py ===
from odoo import models, fields, api, _
from odoo.exceptions import UserError
from nostr.event import Event
from nostr.key import PrivateKey
import json
import os
import logging
import time
from functools import wraps  # Add this import

_logger = logging.getLogger(__name__)

def log_execution_time(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        _logger.info(f"{func.__name__} executed in {end_time - start_time:.2f} seconds")
        return result
    return wrapper

class RepositoryAnchor(models.AbstractModel):
    _name = 'git.repository.anchor'
    _description = 'Git Repository Anchor'

    @api.model
    def _get_private_key(self):
        # In practice, you'd retrieve this securely
        return PrivateKey()

    @log_execution_time
    def create_anchor_event(self, repo_path, maintainers):
        _logger.info(f"Creating anchor event for repository: {repo_path}")
        start_time = time.time()

        private_key = self._get_private_key()
        content = json.dumps({
            "action": "create_repository",
            "repo_name": os.path.basename(repo_path),
            "maintainers": maintainers
        })
        event = Event(
            kind=31228,
            content=content,
            tags=[['r', repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)

        end_time = time.time()
        _logger.info(f"Anchor event created in {end_time - start_time:.2f} seconds")
        return event

    def update_anchor(self, repo_path, maintainers):
        _logger.info(f"Updating anchor for repository: {repo_path}")
        start_time = time.time()

        private_key = self._get_private_key()
        content = json.dumps({
            "action": "update_repository",
            "repo_name": os.path.basename(repo_path),
            "maintainers": maintainers
        })
        event = Event(
            kind=31228,
            content=content,
            tags=[['r', repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)

        end_time = time.time()
        _logger.info(f"Anchor updated in {end_time - start_time:.2f} seconds")
        return event

    def resolve_repository_state(self, anchor_event):
        _logger.info("Resolving repository state from anchor event")
        start_time = time.time()

        try:
            content = json.loads(anchor_event.content)
            state = {
                "repo_name": content["repo_name"],
                "maintainers": content["maintainers"]
            }
        except json.JSONDecodeError as e:
            _logger.error(f"Error decoding anchor event content: {str(e)}")
            raise UserError(_("Invalid anchor event content"))
        except KeyError as e:
            _logger.error(f"Missing key in anchor event content: {str(e)}")
            raise UserError(_("Incomplete anchor event content"))

        end_time = time.time()
        _logger.info(f"Repository state resolved in {end_time - start_time:.2f} seconds")
        return state

    def list_maintainers(self, anchor_event):
        _logger.info("Listing maintainers from anchor event")
        start_time = time.time()

        try:
            content = json.loads(anchor_event.content)
            maintainers = content["maintainers"]
        except json.JSONDecodeError as e:
            _logger.error(f"Error decoding anchor event content: {str(e)}")
            raise UserError(_("Invalid anchor event content"))
        except KeyError:
            _logger.error("Maintainers key not found in anchor event content")
            raise UserError(_("Incomplete anchor event content"))

        end_time = time.time()
        _logger.info(f"Maintainers listed in {end_time - start_time:.2f} seconds")
        return maintainers

    def check_permission(self, anchor_event, public_key):
        _logger.info(f"Checking permission for public key: {public_key}")
        start_time = time.time()

        maintainers = self.list_maintainers(anchor_event)
        has_permission = public_key in maintainers

        end_time = time.time()
        _logger.info(f"Permission check completed in {end_time - start_time:.2f} seconds")
        return has_permission

    def fork_repository(self, original_repo_path, new_repo_path, new_maintainers):
        _logger.info(f"Forking repository from {original_repo_path} to {new_repo_path}")
        start_time = time.time()

        private_key = self._get_private_key()
        content = json.dumps({
            "action": "fork_repository",
            "original_repo": original_repo_path,
            "new_repo": new_repo_path,
            "maintainers": new_maintainers
        })
        event = Event(
            kind=31228,
            content=content,
            tags=[['r', new_repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)

        end_time = time.time()
        _logger.info(f"Repository forked in {end_time - start_time:.2f} seconds")
        return event
=== ./odoo_custom_addons/git_repository_anchor/models/nostr_event.py ===
# File: /opt/odoo/custom_addons/git_repository_anchor/models/nostr_event.py

from odoo import models, fields, api, _
from odoo.exceptions import UserError
from nostr.event import Event as NostrLibEvent
from nostr.key import PrivateKey
import json
import time
import logging

_logger = logging.getLogger(__name__)

class NostrEvent(models.Model):
    _name = 'nostr.event'
    _description = 'Nostr Event'

    name = fields.Char(string='Name', required=True)
    event_id = fields.Char(string='Event ID', readonly=True)
    kind = fields.Integer(string='Event Kind', required=True)
    content = fields.Text(string='Content')
    tags = fields.Text(string='Tags')
    public_key = fields.Char(string='Public Key', readonly=True)
    created_at = fields.Integer(string='Created At', readonly=True)
    signature = fields.Char(string='Signature', readonly=True)
    published = fields.Boolean(string='Published', default=False)
    event_type = fields.Selection([
        ('commit', 'Commit'),
        ('branch', 'Branch'),
        ('tree', 'Tree'),
        ('blob', 'Blob'),
    ], string='Event Type')
    repository_id = fields.Many2one('git.repository', string='Related Repository')

    @api.model
    def create(self, vals):
        try:
            # Generate a new private key for this event
            private_key = PrivateKey()
            public_key = private_key.public_key.hex()
            
            created_at = int(time.time())
            tags = json.loads(vals.get('tags', '[]'))
            
            event = NostrLibEvent(
                kind=vals['kind'],
                content=vals.get('content', ''),
                tags=tags,
                pub_key=public_key,
                created_at=created_at
            )
            
            # Sign the event
            private_key.sign_event(event)
            
            # Update vals with generated data
            vals.update({
                'event_id': event.id,
                'public_key': public_key,
                'created_at': created_at,
                'signature': event.sig
            })
            
            _logger.info(f"Created Nostr event: {event.id}")
        except Exception as e:
            _logger.error(f"Error creating Nostr event: {str(e)}")
            raise UserError(_("Failed to create Nostr event: %s") % str(e))
        
        return super(NostrEvent, self).create(vals)

    @api.model
    def create_and_publish(self, event):
        vals = {
            'name': f"Event {event.id[:8]}",  # Use first 8 characters of event ID as name
            'event_id': event.id,
            'kind': event.kind,
            'content': event.content,
            'tags': json.dumps(event.tags),
            'public_key': event.public_key,
            'created_at': event.created_at,
            'signature': event.sig,
        }
        nostr_event = self.create(vals)
        # Here you would typically publish the event to Nostr relays
        # For demonstration purposes, we'll just log it
        _logger.info(f"Published Nostr event: {event.to_message()}")
        return nostr_event
=== ./odoo_custom_addons/git_repository_anchor/models/odoo_models.py ===
from odoo import models, fields, api
import logging

_logger = logging.getLogger(__name__)

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Repository Name', required=True)
    path = fields.Char(string='Repository Path', required=True)
    description = fields.Text(string='Description')
    maintainer_ids = fields.Many2many('res.users', string='Maintainers')
    created_at = fields.Datetime(string='Created At', default=fields.Datetime.now)
    last_updated = fields.Datetime(string='Last Updated', default=fields.Datetime.now)
    branch_ids = fields.One2many('git.branch', 'repository_id', string='Branches')

    @api.model
    def fields_get(self, allfields=None, attributes=None):
        res = super(GitRepository, self).fields_get(allfields, attributes)
        _logger.info(f"Fields in GitRepository model: {res.keys()}")
        return res

    @api.model
    def search_read(self, domain=None, fields=None, offset=0, limit=None, order=None):
        _logger.info(f"Search_read called with fields: {fields}")
        return super(GitRepository, self).search_read(domain=domain, fields=fields, offset=offset, limit=limit, order=order)

    def read(self, fields=None, load='_classic_read'):
        _logger.info(f"Read called with fields: {fields}")
        return super(GitRepository, self).read(fields=fields, load=load)

    @api.model
    def create(self, vals):
        repo = super(GitRepository, self).create(vals)
        repo._create_default_branch()
        return repo

    def _create_default_branch(self):
        self.env['git.branch'].create({
            'name': 'main',
            'repository_id': self.id,
            'head': 'initial commit',
        })

class GitBranch(models.Model):
    _name = 'git.branch'
    _description = 'Git Branch'

    name = fields.Char(string='Branch Name', required=True)
    repository_id = fields.Many2one('git.repository', string='Repository', required=True)
    head = fields.Char(string='Head Commit', required=True)

class GitEvent(models.Model):
    _name = 'git.event'
    _description = 'Git Event'

    event_type = fields.Selection([
        ('create_repository', 'Create Repository'),
        ('update_repository', 'Update Repository'),
        ('fork_repository', 'Fork Repository'),
        ('create_branch', 'Create Branch'),
        ('update_branch', 'Update Branch'),
        ('delete_branch', 'Delete Branch')
    ], string='Event Type')
    content = fields.Text(string='Event Content')
    created_at = fields.Datetime(string='Created At', default=fields.Datetime.now)

class GitRepositoryManager(models.Model):
    _name = 'git.repository.manager'
    _description = 'Git Repository Manager'

    @api.model
    def create_repository(self, name, path, description, maintainer_ids):
        anchor = self.env['git.repository.anchor']
        repo = anchor.create_repository(name, path, description, maintainer_ids)
        return repo.id

    @api.model
    def update_repository(self, repo_id, description=None, maintainer_ids=None):
        anchor = self.env['git.repository.anchor']
        repo = self.env['git.repository'].browse(repo_id)
        updated_repo = anchor.update_repository(repo, description, maintainer_ids)
        return updated_repo.id

    @api.model
    def fork_repository(self, original_repo_id, new_name, new_maintainer_id):
        anchor = self.env['git.repository.anchor']
        original_repo = self.env['git.repository'].browse(original_repo_id)
        forked_repo = anchor.fork_repository(original_repo, new_name, new_maintainer_id)
        return forked_repo.id

    @api.model
    def list_maintainers(self, repo_id):
        anchor = self.env['git.repository.anchor']
        repo = self.env['git.repository'].browse(repo_id)
        maintainers = anchor.list_maintainers(repo)
        return maintainers.ids
=== ./odoo_custom_addons/git_repository_anchor/models/branch_manager.py ===
from odoo import models, fields, api
from .repository_anchor import log_execution_time
from git import Repo, GitCommandError
import json
from nostr.event import Event
from nostr.key import PrivateKey
import logging

_logger = logging.getLogger(__name__)

class BranchManager(models.AbstractModel):
    _name = 'ivcs.branch.manager'
    _description = 'IVCS Branch Manager'

    name = fields.Char(string='Name', required=True)
    item_id = fields.Many2one('ivcs.item', string='IVCS Item', required=True)

    @api.model
    @log_execution_time
    def create_branch(self, repository_id, name, head):
        repo = self.env['git.repository'].browse(repository_id)
        branch = self.env['git.branch'].create({
            'name': name,
            'repository_id': repository_id,
            'head': head,
        })
        self._create_event('create_branch', branch)
        return branch.id

    @api.model
    @log_execution_time
    def update_branch(self, branch_id, new_head):
        branch = self.env['git.branch'].browse(branch_id)
        branch.write({'head': new_head})
        self._create_event('update_branch', branch)
        return branch.id

    @api.model
    @log_execution_time
    def delete_branch(self, branch_id):
        branch = self.env['git.branch'].browse(branch_id)
        self._create_event('delete_branch', branch)
        branch.unlink()
        return True

    @api.model
    def _create_event(self, event_type, branch):
        self.env['git.event'].create({
            'event_type': event_type,
            'content': f"{event_type}: {branch.name} in {branch.repository_id.name}",
        })
=== ./odoo_custom_addons/git_repository_anchor/__init__.py ===
from . import models
from . import controllers
=== ./odoo_custom_addons/git_repository_anchor/__manifest__.py ===
{
    'name': 'Git Repository Anchor',
    'version': '1.0',
    'category': 'Development',
    'summary': 'Manage Git repositories using Nostr events',
    'author': 'Your Name',
    'website': 'https://www.example.com',
    'depends': ['base', 'mail'],
    'data': [
        'security/git_repository_security.xml',
        'security/ir.model.access.csv',
        'views/git_repository_views.xml',
        'views/nostr_event_views.xml',
    ],
    'installable': True,
    'application': True,
    'auto_install': False,
    'external_dependencies': {
        'python': ['git', 'nostr'],
    },
}
=== ./odoo_custom_addons/git_repository_anchor/security/git_repository_security.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="module_category_git_repository" model="ir.module.category">
        <field name="name">Git Repository</field>
        <field name="description">Manage Git repositories</field>
        <field name="sequence">20</field>
    </record>

    <record id="group_git_repository_user" model="res.groups">
        <field name="name">User</field>
        <field name="category_id" ref="module_category_git_repository"/>
    </record>

    <record id="group_git_repository_manager" model="res.groups">
        <field name="name">Manager</field>
        <field name="category_id" ref="module_category_git_repository"/>
        <field name="implied_ids" eval="[(4, ref('group_git_repository_user'))]"/>
        <field name="users" eval="[(4, ref('base.user_root')), (4, ref('base.user_admin'))]"/>
    </record>
</odoo>
=== ./odoo_custom_addons/git_repository_anchor/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_git_repository_user,git.repository user,model_git_repository,group_git_repository_user,1,0,0,0
access_git_repository_manager,git.repository manager,model_git_repository,group_git_repository_manager,1,1,1,1
access_git_branch_user,git.branch user,model_git_branch,group_git_repository_user,1,1,1,0
access_git_branch_manager,git.branch manager,model_git_branch,group_git_repository_manager,1,1,1,1
access_git_event_user,git.event user,model_git_event,group_git_repository_user,1,0,0,0
access_git_event_manager,git.event manager,model_git_event,group_git_repository_manager,1,1,1,1
access_git_repository_manager_user,git.repository.manager user,model_git_repository_manager,group_git_repository_user,1,1,1,0
access_git_repository_manager_manager,git.repository.manager manager,model_git_repository_manager,group_git_repository_manager,1,1,1,1
access_nostr_event_user,nostr.event user,model_nostr_event,group_git_repository_user,1,0,0,0
access_nostr_event_manager,nostr.event manager,model_nostr_event,group_git_repository_manager,1,1,1,1
access_git_repository_user,git.repository user,model_git_repository,base.group_user,1,1,1,0
access_git_repository_manager,git.repository manager,model_git_repository,base.group_system,1,1,1,1
access_nostr_event_user,nostr.event user,model_nostr_event,base.group_user,1,0,0,0
access_nostr_event_manager,nostr.event manager,model_nostr_event,base.group_system,1,1,1,1
=== ./odoo_custom_addons/git_repository_anchor/security/oldgit_repository_security.xml.txt ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="module_category_git_repository" model="ir.module.category">
        <field name="name">Git Repository</field>
        <field name="description">Manage Git repositories</field>
        <field name="sequence">20</field>
    </record>

    <record id="group_git_repository_user" model="res.groups">
        <field name="name">User</field>
        <field name="category_id" ref="module_category_git_repository"/>
    </record>

    <record id="group_git_repository_manager" model="res.groups">
        <field name="name">Manager</field>
        <field name="category_id" ref="module_category_git_repository"/>
        <field name="implied_ids" eval="[(4, ref('group_git_repository_user'))]"/>
        <field name="users" eval="[(4, ref('base.user_root')), (4, ref('base.user_admin'))]"/>
    </record>

    <record id="git_repository_comp_rule" model="ir.rule">
        <field name="name">Git Repository multi-company</field>
        <field name="model_id" ref="model_git_repository"/>
        <field name="global" eval="True"/>
        <field name="domain_force">['|', ('company_id', '=', False), ('company_id', 'in', company_ids)]</field>
    </record>
</odoo>
=== ./odoo_custom_addons/git_repository_anchor/tests/test_repository_anchor.py ===
from odoo.tests.common import TransactionCase
from odoo.exceptions import AccessError

class TestRepositoryAnchor(TransactionCase):

    def setUp(self):
        super(TestRepositoryAnchor, self).setUp()
        self.repo_manager = self.env['git.repository.manager'].sudo()
        self.user_admin = self.env.ref('base.user_admin')
        self.user_demo = self.env.ref('base.user_demo')

    def test_create_repository(self):
        repo_id = self.repo_manager.create_repository(
            "test-repo", "/path/to/test-repo", "Test repository", [self.user_admin.id]
        )
        repo = self.env['git.repository'].browse(repo_id)
        self.assertEqual(repo.name, "test-repo")
        self.assertEqual(repo.path, "/path/to/test-repo")
        self.assertEqual(repo.description, "Test repository")
        self.assertIn(self.user_admin, repo.maintainer_ids)
        self.assertEqual(len(repo.branch_ids), 1)
        self.assertEqual(repo.branch_ids[0].name, 'main')

    def test_update_repository(self):
        repo_id = self.repo_manager.create_repository(
            "test-repo", "Test repository", [self.user_admin.id]
        )
        updated_repo_id = self.repo_manager.update_repository(
            repo_id, "Updated description", [self.user_admin.id, self.user_demo.id]
        )
        repo = self.env['git.repository'].browse(updated_repo_id)
        self.assertEqual(repo.description, "Updated description")
        self.assertIn(self.user_demo, repo.maintainer_ids)

    def test_fork_repository(self):
        original_repo_id = self.repo_manager.create_repository(
            "original-repo", "Original repository", [self.user_admin.id]
        )
        forked_repo_id = self.repo_manager.fork_repository(
            original_repo_id, "forked-repo", self.user_demo.id
        )
        forked_repo = self.env['git.repository'].browse(forked_repo_id)
        self.assertEqual(forked_repo.name, "forked-repo")
        self.assertIn(self.user_demo, forked_repo.maintainer_ids)
        self.assertEqual(len(forked_repo.branch_ids), 1)
        self.assertEqual(forked_repo.branch_ids[0].name, 'main')

    def test_list_maintainers(self):
        repo_id = self.repo_manager.create_repository(
            "test-repo", "Test repository", [self.user_admin.id, self.user_demo.id]
        )
        maintainer_ids = self.repo_manager.list_maintainers(repo_id)
        self.assertIn(self.user_admin.id, maintainer_ids)
        self.assertIn(self.user_demo.id, maintainer_ids)

    def test_access_rights(self):
        repo_id = self.repo_manager.create_repository(
            "test-repo", "Test repository", [self.user_admin.id]
        )
        
        # Test that non-maintainer can't update the repository
        with self.assertRaises(AccessError):
            self.repo_manager.with_user(self.user_demo).update_repository(
                repo_id, "Unauthorized update"
            )

        # Test that maintainer can update the repository
        self.repo_manager.with_user(self.user_admin).update_repository(
            repo_id, "Authorized update"
        )
        repo = self.env['git.repository'].browse(repo_id)
        self.assertEqual(repo.description, "Authorized update")
=== ./odoo_custom_addons/git_repository_anchor/tests/__init__.py ===
from . import test_repository_anchor
=== ./odoo_custom_addons/git_repository_anchor/data/README.md ===
# Git Repository Anchor

This Odoo module provides a system for managing Git repositories using Nostr events. It allows users to create, update, and fork repositories, as well as manage branches and maintainers.

## Features

- Create, update, and fork Git repositories
- Manage repository maintainers
- Create and manage branches
- Log all actions as Nostr events
- Odoo views for easy management through the UI
- CLI for standalone usage

## Installation

1. Place the `git_repository_anchor` directory in your Odoo addons path.
2. Update your Odoo apps list.
3. Install the "Git Repository Anchor" module from the Odoo Apps menu.

## Usage

### Through Odoo Interface

1. Navigate to the "Git Repositories" menu item.
2. Use the provided views to manage repositories, branches, and maintainers.

### Using CLI

A CLI script is provided for standalone usage. Example usage:

```bash
python cli_script.py create --name "New Repo" --description "A new repository" --maintainers 1 2
python cli_script.py update --repo-id 1 --description "Updated description"
python cli_script.py fork --original-repo-id 1 --new-name "Forked Repo"
=== ./odoo_custom_addons/git_repository_anchor/data/git_repository_data.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <!-- Example repository data -->
        <record id="git_repository_example" model="git.repository">
            <field name="name">Example Repository</field>
            <field name="path">/path/to/example-repo</field>
            <field name="description">This is an example repository created during module installation.</field>
            <field name="maintainer_ids" eval="[(4, ref('base.user_admin'))]"/>
        </record>
    </data>
</odoo>
=== ./odoo_custom_addons/git_repository_anchor/views/nostr_event_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_nostr_event_form" model="ir.ui.view">
        <field name="name">nostr.event.form</field>
        <field name="model">nostr.event</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="event_id" readonly="1"/>
                        <field name="kind"/>
                        <field name="content"/>
                        <field name="tags"/>
                        <field name="public_key" readonly="1"/>
                        <field name="created_at" readonly="1"/>
                        <field name="signature" readonly="1"/>
                        <field name="published"/>
                        <field name="event_type"/>
                        <field name="repository_id"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_nostr_event_tree" model="ir.ui.view">
        <field name="name">nostr.event.tree</field>
        <field name="model">nostr.event</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="event_id"/>
                <field name="kind"/>
                <field name="event_type"/>
                <field name="repository_id"/>
                <field name="public_key"/>
                <field name="created_at"/>
                <field name="published"/>
            </tree>
        </field>
    </record>

    <record id="action_nostr_event" model="ir.actions.act_window">
        <field name="name">Nostr Events</field>
        <field name="res_model">nostr.event</field>
        <field name="view_mode">tree,form</field>
    </record>

    <!-- Menu item for Nostr Events -->
    <menuitem id="menu_nostr_event"
              name="Nostr Events"
              parent="menu_git_nostr_bridge_root"
              action="action_nostr_event"
              sequence="20"/>
</odoo>
=== ./odoo_custom_addons/git_repository_anchor/views/git_repository_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_repository_form" model="ir.ui.view">
        <field name="name">git.repository.form</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="path"/>
                        <field name="description"/>
                    </group>
                </sheet>
                <div class="oe_chatter">
                    <field name="message_follower_ids" widget="mail_followers"/>
                    <field name="message_ids" widget="mail_thread"/>
                </div>
            </form>
        </field>
    </record>

    <record id="view_git_repository_tree" model="ir.ui.view">
        <field name="name">git.repository.tree</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="path"/>
            </tree>
        </field>
    </record>

    <record id="action_git_repository" model="ir.actions.act_window">
        <field name="name">Git Repositories</field>
        <field name="res_model">git.repository</field>
        <field name="view_mode">tree,form</field>
    </record>

    <!-- Root menu for the module -->
    <menuitem id="menu_git_nostr_bridge_root"
              name="Git Repository Anchor"
              sequence="10"/>

    <!-- Submenu for Git Repositories -->
    <menuitem id="menu_git_repository"
              name="Git Repositories"
              parent="menu_git_nostr_bridge_root"
              action="action_git_repository"
              sequence="10"/>
</odoo>
=== ./odoo_custom_addons/git_repository_anchor/views/repository_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data>
        <!-- Repository Form View -->
        <record id="view_git_repository_form" model="ir.ui.view">
            <field name="name">git.repository.form</field>
            <field name="model">git.repository</field>
            <field name="arch" type="xml">
                <form string="Git Repository">
                    <sheet>
                        <group>
                            <field name="name"/>
                            <field name="path"/>
                            <field name="description"/>
                            <field name="maintainer_ids" widget="many2many_tags"/>
                            <field name="created_at"/>
                            <field name="last_updated"/>
                        </group>
                        <notebook>
                            <page string="Branches">
                                <field name="branch_ids">
                                    <tree editable="bottom">
                                        <field name="name"/>
                                        <field name="head"/>
                                    </tree>
                                </field>
                            </page>
                        </notebook>
                    </sheet>
                </form>
            </field>
        </record>

        <!-- Repository Tree View -->
        <record id="view_git_repository_tree" model="ir.ui.view">
            <field name="name">git.repository.tree</field>
            <field name="model">git.repository</field>
            <field name="arch" type="xml">
                <tree string="Git Repositories">
                    <field name="name"/>
                    <field name="path"/>
                    <field name="description"/>
                    <field name="created_at"/>
                    <field name="last_updated"/>
                </tree>
            </field>
        </record>

        <!-- Repository Search View -->
        <record id="view_git_repository_search" model="ir.ui.view">
            <field name="name">git.repository.search</field>
            <field name="model">git.repository</field>
            <field name="arch" type="xml">
                <search string="Search Repositories">
                    <field name="name"/>
                    <field name="path"/>
                    <field name="description"/>
                    <field name="maintainer_ids"/>
                    <filter string="My Repositories" name="my_repositories" domain="[('maintainer_ids', 'in', uid)]"/>
                    <group expand="0" string="Group By">
                        <filter string="Created Date" name="group_by_created_at" context="{'group_by': 'created_at:month'}"/>
                    </group>
                </search>
            </field>
        </record>

        <!-- Repository Action -->
        <record id="action_git_repository" model="ir.actions.act_window">
            <field name="name">Git Repositories</field>
            <field name="res_model">git.repository</field>
            <field name="view_mode">tree,form</field>
            <field name="search_view_id" ref="view_git_repository_search"/>
        </record>

        <!-- Menu Items -->
        <menuitem id="menu_git_repository_root" name="Git Repositories" sequence="10"/>
        <menuitem id="menu_git_repository" parent="menu_git_repository_root" action="action_git_repository" sequence="10"/>
    </data>
</odoo>
=== ./odoo_custom_addons/git_repository_anchor/controllers/__init__.py ===
from . import main
=== ./odoo_custom_addons/git_repository_anchor/controllers/main.py ===
from odoo import http
from odoo.http import request

class GitRepositoryController(http.Controller):
    @http.route('/git/repository/create', type='json', auth='user')
    def create_repository(self, name, path, description, maintainer_ids):
        repo_manager = request.env['git.repository.manager'].sudo()
        repo_id = repo_manager.create_repository(name, path, description, maintainer_ids)
        return {'success': True, 'repository_id': repo_id}

    @http.route('/git/repository/update', type='json', auth='user')
    def update_repository(self, repo_id, description=None, maintainer_ids=None):
        repo_manager = request.env['git.repository.manager'].sudo()
        updated_repo_id = repo_manager.update_repository(repo_id, description, maintainer_ids)
        return {'success': True, 'repository_id': updated_repo_id}

    @http.route('/git/repository/fork', type='json', auth='user')
    def fork_repository(self, original_repo_id, new_name):
        repo_manager = request.env['git.repository.manager'].sudo()
        forked_repo_id = repo_manager.fork_repository(original_repo_id, new_name, request.env.user.id)
        return {'success': True, 'repository_id': forked_repo_id}

    @http.route('/git/repository/list_maintainers', type='json', auth='user')
    def list_maintainers(self, repo_id):
        repo_manager = request.env['git.repository.manager'].sudo()
        maintainer_ids = repo_manager.list_maintainers(repo_id)
        return {'success': True, 'maintainer_ids': maintainer_ids}
=== ./odoo_custom_addons/git_branch_manager/git-branch-manager-module.py ===
# Directory structure:
# git_branch_manager/
# ├── __init__.py
# ├── __manifest__.py
# ├── models/
# │   ├── __init__.py
# │   ├── branch.py
# │   ├── event.py
# │   └── branch_manager.py
# ├── controllers/
# │   ├── __init__.py
# │   └── main.py
# ├── security/
# │   └── ir.model.access.csv
# └── views/
#     ├── branch_views.xml
#     └── event_views.xml

# __init__.py
from . import models
from . import controllers

# __manifest__.py
{
    'name': 'Git Branch Manager',
    'version': '1.0',
    'summary': 'Manage Git branches using Nostr events',
    'description': """
    This module allows you to manage Git branches using Nostr events.
    It integrates with the Nostr-Odoo application to handle branch operations.
    """,
    'author': 'Your Name',
    'depends': ['base'],
    'data': [
        'security/ir.model.access.csv',
        'views/branch_views.xml',
        'views/event_views.xml',
    ],
    'installable': True,
    'application': True,
}

# models/__init__.py
from . import branch
from . import event
from . import branch_manager

# models/branch.py
from odoo import models, fields

class GitBranch(models.Model):
    _name = 'git.branch'
    _description = 'Git Branch'

    name = fields.Char(string='Branch Name', required=True)
    head = fields.Char(string='Head Commit', required=True)
    created_at = fields.Datetime(string='Created At')
    last_updated = fields.Datetime(string='Last Updated')

# models/event.py
from odoo import models, fields

class GitEvent(models.Model):
    _name = 'git.event'
    _description = 'Git Event'

    event_type = fields.Selection([('create', 'Create'), ('update', 'Update'), ('delete', 'Delete')], string='Event Type')
    content = fields.Text(string='Event Content')
    created_at = fields.Datetime(string='Created At', default=fields.Datetime.now)

# models/branch_manager.py
from odoo import models, api
from nostr.event import Event
from nostr.key import PrivateKey
import json
import logging
import time

_logger = logging.getLogger(__name__)

class GitBranchManager(models.AbstractModel):
    _name = 'git.branch.manager'
    _description = 'Git Branch Manager'

    @api.model
    def create_branch(self, name, head):
        _logger.info(f"Creating branch: {name} with head: {head}")
        start_time = time.time()

        try:
            if self.env['git.branch'].search([('name', '=', name)]):
                raise ValueError(f"Branch {name} already exists")

            branch = self.env['git.branch'].create({
                'name': name,
                'head': head,
                'created_at': fields.Datetime.now(),
                'last_updated': fields.Datetime.now(),
            })

            event = self._create_branch_event(branch, 'create')
            self._publish_event(event)

            end_time = time.time()
            _logger.info(f"Branch {name} created in {end_time - start_time:.2f} seconds")
            return True
        except Exception as e:
            _logger.exception(f"Error creating branch: {str(e)}")
            raise

    @api.model
    def update_branch(self, name, new_head):
        _logger.info(f"Updating branch: {name} to new head: {new_head}")
        start_time = time.time()

        try:
            branch = self.env['git.branch'].search([('name', '=', name)])
            if not branch:
                raise ValueError(f"Branch {name} does not exist")

            branch.write({
                'head': new_head,
                'last_updated': fields.Datetime.now(),
            })

            event = self._create_branch_event(branch, 'update')
            self._publish_event(event)

            end_time = time.time()
            _logger.info(f"Branch {name} updated in {end_time - start_time:.2f} seconds")
            return True
        except Exception as e:
            _logger.exception(f"Error updating branch: {str(e)}")
            raise

    @api.model
    def delete_branch(self, name):
        _logger.info(f"Deleting branch: {name}")
        start_time = time.time()

        try:
            branch = self.env['git.branch'].search([('name', '=', name)])
            if not branch:
                raise ValueError(f"Branch {name} does not exist")

            event = self._create_branch_event(branch, 'delete')
            branch.unlink()
            self._publish_event(event)

            end_time = time.time()
            _logger.info(f"Branch {name} deleted in {end_time - start_time:.2f} seconds")
            return True
        except Exception as e:
            _logger.exception(f"Error deleting branch: {str(e)}")
            raise

    def _create_branch_event(self, branch, operation):
        event = Event()
        event.kind = 31227  # Custom event kind for git branch operations
        event.content = json.dumps({
            'operation': operation,
            'name': branch.name,
            'head': branch.head,
            'timestamp': fields.Datetime.now().isoformat(),
        })
        event.tags = [['e', 'git_branch']]

        private_key = PrivateKey()  # In practice, securely store and retrieve this
        event.sign(private_key.hex())

        return event

    def _publish_event(self, event):
        self.env['git.event'].create({
            'event_type': json.loads(event.content)['operation'],
            'content': event.to_message(),
        })
        # Here you would also publish the event to the Nostr network
        # This part depends on how you've implemented your Nostr client in Odoo

# controllers/__init__.py
from . import main

# controllers/main.py
from odoo import http
from odoo.http import request

class GitBranchController(http.Controller):

    @http.route('/git/branch/create', type='json', auth='user')
    def create_branch(self, name, head):
        branch_manager = request.env['git.branch.manager'].sudo()
        result = branch_manager.create_branch(name, head)
        return {'success': result}

    @http.route('/git/branch/update', type='json', auth='user')
    def update_branch(self, name, new_head):
        branch_manager = request.env['git.branch.manager'].sudo()
        result = branch_manager.update_branch(name, new_head)
        return {'success': result}

    @http.route('/git/branch/delete', type='json', auth='user')
    def delete_branch(self, name):
        branch_manager = request.env['git.branch.manager'].sudo()
        result = branch_manager.delete_branch(name)
        return {'success': result}

# security/ir.model.access.csv
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_git_branch_user,access_git_branch_user,model_git_branch,,1,1,1,1
access_git_event_user,access_git_event_user,model_git_event,,1,1,1,1

# views/branch_views.xml
<?xml version="1.0" encoding="UTF-8"?>
<odoo>
    <record id="view_git_branch_form" model="ir.ui.view">
        <field name="name">git.branch.form</field>
        <field name="model">git.branch</field>
        <field name="arch" type="xml">
            <form string="Git Branch">
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="head"/>
                        <field name="created_at"/>
                        <field name="last_updated"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_git_branch_tree" model="ir.ui.view">
        <field name="name">git.branch.tree</field>
        <field name="model">git.branch</field>
        <field name="arch" type="xml">
            <tree string="Git Branches">
                <field name="name"/>
                <field name="head"/>
                <field name="created_at"/>
                <field name="last_updated"/>
            </tree>
        </field>
    </record>

    <record id="action_git_branch" model="ir.actions.act_window">
        <field name="name">Branches</field>
        <field name="res_model">git.branch</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_git_branch_root" name="Git Branches" sequence="10"/>
    <menuitem id="menu_git_branch" parent="menu_git_branch_root"
              action="action_git_branch" sequence="10"/>
</odoo>

# views/event_views.xml
<?xml version="1.0" encoding="UTF-8"?>
<odoo>
    <record id="view_git_event_form" model="ir.ui.view">
        <field name="name">git.event.form</field>
        <field name="model">git.event</field>
        <field name="arch" type="xml">
            <form string="Git Event">
                <sheet>
                    <group>
                        <field name="event_type"/>
                        <field name="content"/>
                        <field name="created_at"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_git_event_tree" model="ir.ui.view">
        <field name="name">git.event.tree</field>
        <field name="model">git.event</field>
        <field name="arch" type="xml">
            <tree string="Git Events">
                <field name="event_type"/>
                <field name="content"/>
                <field name="created_at"/>
            </tree>
        </field>
    </record>

    <record id="action_git_event" model="ir.actions.act_window">
        <field name="name">Events</field>
        <field name="res_model">git.event</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_git_events" parent="menu_git_branch_root"
              action="action_git_event" sequence="20"/>
</odoo>
=== ./odoo_custom_addons/nostr_auth/models/__init__.py ===
# File: odoo_custom_addons/nostr_auth/models/__init__.py
from . import res_users
from . import nostr_auth_module
=== ./odoo_custom_addons/nostr_auth/models/res_users.py ===
# File: odoo_custom_addons/nostr_auth/models/res_users.py

from odoo import models, fields, api
from odoo.exceptions import ValidationError
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import hashes
import base64

class ResUsers(models.Model):
    _inherit = 'res.users'

    nostr_public_key = fields.Char(string='Nostr Public Key')
    nostr_private_key = fields.Char(string='Nostr Private Key')
    nostr_relay_url = fields.Char(string='Nostr Relay URL')

    @api.model_create_multi
    def create(self, vals_list):
        nostr_auth = self.env['nostr.auth.module']
        for vals in vals_list:
            if not vals.get('nostr_private_key'):
                keys = nostr_auth.generate_keypair()
                vals['nostr_private_key'] = keys['private_key']
                vals['nostr_public_key'] = keys['public_key']
        return super(ResUsers, self).create(vals_list)

    @api.constrains('nostr_public_key')
    def _check_nostr_public_key(self):
        for user in self:
            if user.nostr_public_key:
                if not user.nostr_public_key.startswith('npub1'):
                    raise ValidationError("Invalid Nostr public key format. It should start with 'npub1'.")

    @api.model
    def authenticate_nostr(self, public_key, signature, message):
        user = self.search([('nostr_public_key', '=', public_key)], limit=1)
        if user:
            nostr_auth = self.env['nostr.auth.module']
            if nostr_auth.verify_signature(public_key, message, signature):
                return user.id
        return False
=== ./odoo_custom_addons/nostr_auth/models/nostr_auth_module.py ===
# File: odoo_custom_addons/nostr_auth/models/nostr_auth_module.py

from odoo import models, api
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.serialization import Encoding, PublicFormat, PrivateFormat, NoEncryption
import base64
from bech32 import bech32_encode, bech32_decode, convertbits

class NostrAuthModule(models.AbstractModel):
    _name = 'nostr.auth.module'
    _description = 'Nostr Authentication Module'

    @api.model
    def generate_keypair(self):
        private_key = ec.generate_private_key(ec.SECP256K1())
        public_key = private_key.public_key()
        
        private_bytes = private_key.private_numbers().private_value.to_bytes(32, 'big')
        public_bytes = public_key.public_bytes(
            encoding=Encoding.X962,
            format=PublicFormat.UncompressedPoint
        )[1:]
        
        return {
            'private_key': self.bytes_to_nsec(private_bytes),
            'public_key': self.bytes_to_npub(public_bytes)
        }

    @api.model
    def verify_signature(self, public_key, message, signature):
        try:
            public_key_bytes = self.npub_to_bytes(public_key)
            public_key_obj = ec.EllipticCurvePublicKey.from_encoded_point(ec.SECP256K1(), b'\x04' + public_key_bytes)
            signature_bytes = base64.b64decode(signature)
            public_key_obj.verify(
                signature_bytes,
                message.encode('utf-8'),
                ec.ECDSA(hashes.SHA256())
            )
            return True
        except:
            return False

    @api.model
    def bytes_to_npub(self, key_bytes):
        data = convertbits(key_bytes[:32], 8, 5)
        return bech32_encode('npub', data)

    @api.model
    def bytes_to_nsec(self, key_bytes):
        data = convertbits(key_bytes[:32], 8, 5)
        return bech32_encode('nsec', data)
        
    @api.model
    def npub_to_bytes(self, npub):
        hrp, data = bech32_decode(npub)
        return bytes(convertbits(data, 5, 8, False))

    @api.model
    def nsec_to_bytes(self, nsec):
        hrp, data = bech32_decode(nsec)
        return bytes(convertbits(data, 5, 8, False))
=== ./odoo_custom_addons/nostr_auth/__init__.py ===
from . import models
=== ./odoo_custom_addons/nostr_auth/__manifest__.py ===
# File: odoo_custom_addons/nostr_auth/__manifest__.py
{
    'name': 'Nostr Authentication',
    'version': '1.0',
    'category': 'Authentication',
    'summary': 'Extends user model with Nostr fields and authentication',
    'depends': ['base', 'auth_signup'],
    'data': [
        'views/res_users_views.xml',
    ],
    'installable': True,
    'application': False,
    'auto_install': False,
    'external_dependencies': {
        'python': ['cryptography', 'bech32'],
    },
}
=== ./odoo_custom_addons/nostr_auth/views/res_users_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_users_form_nostr" model="ir.ui.view">
        <field name="name">res.users.form.nostr</field>
        <field name="model">res.users</field>
        <field name="inherit_id" ref="base.view_users_form"/>
        <field name="arch" type="xml">
            <xpath expr="//page[@name='access_rights']" position="after">
                <page string="Nostr Authentication" name="nostr_auth">
                    <group>
                        <field name="nostr_public_key"/>
                        <field name="nostr_relay_url"/>
                    </group>
                </page>
            </xpath>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons/nostr_auth/controllers/__init__.py ===
from . import main
=== ./odoo_custom_addons/nostr_auth/controllers/main.py ===
# controllers/main.py
from odoo import http
from odoo.http import request
import json

class NostrAuthController(http.Controller):
    @http.route('/web/nostr/authenticate', type='json', auth='none')
    def authenticate(self, public_key, signature, message):
        uid = request.env['res.users'].sudo().authenticate_nostr(public_key, signature, message)
        if uid:
            request.session.authenticate(request.session.db, uid, public_key)
            return {'success': True, 'uid': uid}
        return {'success': False, 'error': 'Authentication failed'}
=== ./odoo_custom_addons/nostr_identity/models/__init__.py ===
# models/__init__.py
from . import nostr_identity
from . import nostr_identity_verifier
from . import nostr_message
=== ./odoo_custom_addons/nostr_identity/models/nostr_identity_verifier.py ===
from odoo import models, fields, api, _
from odoo.exceptions import UserError
import logging
import json
import websocket
import threading
import ssl
import time
from odoo.tools import config

_logger = logging.getLogger(__name__)

class NostrIdentityVerifier(models.Model):
    _name = 'nostr.identity.verifier'
    _description = 'Nostr Identity Verifier'

    name = fields.Char(string='Name', required=True)
    active = fields.Boolean(default=True)
    relay_url = fields.Char(string='Relay URL', required=True)
    websocket_state = fields.Selection([
        ('disconnected', 'Disconnected'),
        ('connecting', 'Connecting'),
        ('connected', 'Connected')
    ], default='disconnected', string='WebSocket State', readonly=True)
    last_error = fields.Text(string='Last Error', readonly=True)

    def _get_ws_connection(self):
        return self.env.context.get('ws_connection')

    def _set_ws_connection(self, ws):
        self = self.with_context(ws_connection=ws)

    def connect_to_relay(self):
        self.ensure_one()
        if self.websocket_state == 'connected':
            return True

        self.websocket_state = 'connecting'
        self.last_error = False

        try:
            ws = self._create_websocket(self.relay_url)
            self._set_ws_connection(ws)
            
            # Wait for connection to establish or fail
            for _ in range(20):  # Wait up to 10 seconds
                if self.websocket_state == 'connected':
                    return True
                elif self.websocket_state == 'disconnected':
                    raise UserError(self.last_error or _("Connection failed"))
                time.sleep(0.5)

            raise UserError(_("Connection timeout"))
        except Exception as e:
            self.websocket_state = 'disconnected'
            self.last_error = str(e)
            _logger.error(f"Failed to connect to {self.relay_url}: {str(e)}")
            return False

    def _create_websocket(self, relay_url):
        def on_message(ws, message):
            with self.pool.cursor() as new_cr:
                self.with_env(self.env(cr=new_cr))._handle_message(message)

        def on_error(ws, error):
            with self.pool.cursor() as new_cr:
                self.with_env(self.env(cr=new_cr))._handle_error(error)

        def on_close(ws, close_status_code, close_msg):
            with self.pool.cursor() as new_cr:
                self.with_env(self.env(cr=new_cr))._handle_close()

        def on_open(ws):
            with self.pool.cursor() as new_cr:
                self.with_env(self.env(cr=new_cr))._handle_open()

        ws = websocket.WebSocketApp(relay_url,
                                    on_message=on_message,
                                    on_error=on_error,
                                    on_close=on_close,
                                    on_open=on_open)

        wst = threading.Thread(target=lambda: ws.run_forever(sslopt={"cert_reqs": ssl.CERT_NONE}))
        wst.daemon = True
        wst.start()

        return ws

    def _handle_message(self, message):
        _logger.info(f"Received message from {self.relay_url}: {message}")
        self.env['nostr.message'].create({
            'verifier_id': self.id,
            'content': message
        })

    def _handle_error(self, error):
        _logger.error(f"WebSocket error for {self.relay_url}: {error}")
        self.write({'last_error': str(error), 'websocket_state': 'disconnected'})

    def _handle_close(self):
        _logger.info(f"WebSocket connection closed for {self.relay_url}")
        self.write({'websocket_state': 'disconnected'})

    def _handle_open(self):
        _logger.info(f"WebSocket connection opened for {self.relay_url}")
        self.write({'websocket_state': 'connected'})

    def publish_event(self, event):
        self.ensure_one()
        if self.websocket_state != 'connected':
            if not self.connect_to_relay():
                raise UserError(_("Failed to connect to relay"))

        try:
            message = json.dumps(["EVENT", event])
            ws = self._get_ws_connection()
            if ws:
                ws.send(message)
                _logger.info(f"Published event to {self.relay_url}")
                return True
            else:
                raise UserError(_("WebSocket connection is not available"))
        except Exception as e:
            _logger.error(f"Failed to publish event to {self.relay_url}: {str(e)}")
            raise UserError(_("Failed to publish event: %s") % str(e))

    @api.model
    def process_messages(self):
        messages = self.env['nostr.message'].search([('processed', '=', False)])
        for message in messages:
            try:
                # Process the message here
                _logger.info(f"Processing message: {message.content}")
                # Add your message processing logic here
                message.write({'processed': True})
            except Exception as e:
                _logger.error(f"Error processing message {message.id}: {str(e)}")

    def close_connection(self):
        self.ensure_one()
        ws = self._get_ws_connection()
        if ws:
            try:
                ws.close()
            except Exception as e:
                _logger.error(f"Error closing WebSocket for {self.relay_url}: {str(e)}")
        self._set_ws_connection(None)
        self.write({'websocket_state': 'disconnected'})
=== ./odoo_custom_addons/nostr_identity/models/nostr_identity.py ===
from odoo import models, fields, api, _
from odoo.exceptions import UserError, ValidationError
import base64
from cryptography.fernet import Fernet
import logging
import secrets
from nostr.key import PrivateKey
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import serialization
import bech32

_logger = logging.getLogger(__name__)

def hex_to_nostr_key(hex_key, prefix):
    # Convert hex to bytes
    data = bytes.fromhex(hex_key)
    
    # Convert to 5-bit words
    words = bech32.convertbits(data, 8, 5)
    
    # Encode with bech32
    encoded = bech32.bech32_encode(prefix, words)
    
    return encoded

class NostrIdentity(models.Model):
    _name = 'nostr.identity'
    _description = 'Nostr Identity'

    name = fields.Char(string='Name', required=True)
    public_key = fields.Char(string='Public Key (hex)', readonly=True)
    private_key = fields.Char(string='Private Key (hex)', readonly=True)
    public_key_bech32 = fields.Char(string='Public Key (npub)', readonly=True, compute='_compute_bech32_keys')
    private_key_bech32 = fields.Char(string='Private Key (nsec)', readonly=True, compute='_compute_bech32_keys')
    relay_urls = fields.Text(string='Relay URLs')
    profile_data = fields.Text(string='Profile Data')

    @api.model
    def create(self, vals):
        if 'public_key' not in vals or 'private_key' not in vals:
            try:
                private_key = PrivateKey()
                public_key = private_key.public_key
                vals['private_key'] = private_key.hex()
                vals['public_key'] = public_key.hex()
            except Exception as e:
                _logger.error(f"Failed to generate Nostr keys: {str(e)}")
                raise UserError(_("Failed to generate Nostr keys: %s") % str(e))
        return super(NostrIdentity, self).create(vals)

    @api.depends('public_key', 'private_key')
    def _compute_bech32_keys(self):
        for record in self:
            if record.public_key:
                record.public_key_bech32 = hex_to_nostr_key(record.public_key, "npub")
            else:
                record.public_key_bech32 = False
            
            if record.private_key:
                record.private_key_bech32 = hex_to_nostr_key(record.private_key, "nsec")
            else:
                record.private_key_bech32 = False

    def get_private_key(self):
        self.ensure_one()
        try:
            encryption_key = self.env['ir.config_parameter'].sudo().get_param('nostr.encryption_key')
            if not encryption_key:
                raise UserError(_("Encryption key not found. Unable to decrypt private key."))
            
            fernet = Fernet(encryption_key.encode())
            decrypted_private_key = fernet.decrypt(base64.b64decode(self.encrypted_private_key))
            return PrivateKey(bytes.fromhex(decrypted_private_key.decode()))
        except Exception as e:
            _logger.error(f"Failed to decrypt private key: {str(e)}")
            raise UserError(_("Failed to decrypt private key: %s") % str(e))

    def get_public_key_bech32(self):
        return self.public_key_bech32
=== ./odoo_custom_addons/nostr_identity/models/nostr_message.py ===
# models/nostr_message.py

from odoo import models, fields

class NostrMessage(models.Model):
    _name = 'nostr.message'
    _description = 'Nostr Message'

    verifier_id = fields.Many2one('nostr.identity.verifier', string='Verifier', required=True, ondelete='cascade')
    content = fields.Text(string='Message Content', required=True)
    processed = fields.Boolean(string='Processed', default=False)
=== ./odoo_custom_addons/nostr_identity/__init__.py ===
# nostr_identity/__init__.py

from . import models
from . import nostr_cleanup

def post_init_hook(cr, registry):
    from odoo import api, SUPERUSER_ID
    env = api.Environment(cr, SUPERUSER_ID, {})
    
    # Generate encryption key if it doesn't exist
    if not env['ir.config_parameter'].get_param('nostr.encryption_key'):
        from cryptography.fernet import Fernet
        encryption_key = Fernet.generate_key()
        env['ir.config_parameter'].set_param('nostr.encryption_key', encryption_key.decode())

def uninstall_hook(cr, registry):
    from odoo import api, SUPERUSER_ID
    env = api.Environment(cr, SUPERUSER_ID, {})
    
    # Remove the encryption key
    env['ir.config_parameter'].set_param('nostr.encryption_key', False)
    
    # Close all active WebSocket connections
    verifiers = env['nostr.identity.verifier'].search([])
    for verifier in verifiers:
        verifier.close_connection()
=== ./odoo_custom_addons/nostr_identity/__manifest__.py ===
# __manifest__.py
{
    'name': 'Nostr Identity Verifier',
    'version': '1.0',
    'category': 'Tools',
    'summary': 'Integrate Nostr identity verification into Odoo',
    'author': 'Your Name',
    'website': 'https://www.example.com',
    'license': 'LGPL-3',
    'depends': ['base', 'mail'],
    'data': [
        'security/nostr_security.xml',
        'security/ir.model.access.csv',
        'views/nostr_identity_views.xml',
        'data/ir_cron_data.xml',
    ],
    'demo': [],
    'external_dependencies': {
        'python': ['websocket-client', 'nostr'],
    },
    'installable': True,
    'application': False,
    'auto_install': False,
    'post_init_hook': 'post_init_hook',
    'uninstall_hook': 'uninstall_hook',
}
=== ./odoo_custom_addons/nostr_identity/nostr_cleanup.py ===
# nostr_identity/nostr_cleanup.py

import atexit
from odoo import api, SUPERUSER_ID

def cleanup_connections():
    try:
        with api.Environment.manage():
            env = api.Environment(odoo.registry(odoo.tools.config['db_name']).cursor(), SUPERUSER_ID, {})
            verifiers = env['nostr.identity.verifier'].search([])
            for verifier in verifiers:
                verifier.close_connection()
            env.cr.commit()
    except Exception as e:
        # Log the error, but don't raise it to avoid interfering with Odoo's shutdown process
        _logger.error(f"Error during Nostr connection cleanup: {e}")
    finally:
        if env and env.cr:
            env.cr.close()

atexit.register(cleanup_connections)
=== ./odoo_custom_addons/nostr_identity/security/nostr_security.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <!-- Rule: Users can only see their own Nostr Identity records -->
        <record id="rule_nostr_identity_users" model="ir.rule">
            <field name="name">Users can only see their own Nostr Identity</field>
            <field name="model_id" ref="model_nostr_identity"/>
            <field name="domain_force">[('create_uid', '=', user.id)]</field>
            <field name="groups" eval="[(4, ref('base.group_user'))]"/>
            <field name="perm_read" eval="True"/>
            <field name="perm_write" eval="False"/>
            <field name="perm_create" eval="False"/>
            <field name="perm_unlink" eval="False"/>
        </record>

        <!-- Rule: Managers can see all Nostr Identity records -->
        <record id="rule_nostr_identity_managers" model="ir.rule">
            <field name="name">Managers can see all Nostr Identity records</field>
            <field name="model_id" ref="model_nostr_identity"/>
            <field name="domain_force">[(1, '=', 1)]</field>
            <field name="groups" eval="[(4, ref('base.group_system'))]"/>
            <field name="perm_read" eval="True"/>
            <field name="perm_write" eval="True"/>
            <field name="perm_create" eval="True"/>
            <field name="perm_unlink" eval="True"/>
        </record>
    </data>
</odoo>
=== ./odoo_custom_addons/nostr_identity/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_nostr_identity_user,nostr.identity user,model_nostr_identity,base.group_user,1,1,1,0
access_nostr_identity_manager,nostr.identity manager,model_nostr_identity,base.group_system,1,1,1,1
access_nostr_identity_verifier_user,nostr.identity.verifier user,model_nostr_identity_verifier,base.group_user,1,0,0,0
access_nostr_identity_verifier_manager,nostr.identity.verifier manager,model_nostr_identity_verifier,base.group_system,1,1,1,1
access_nostr_message_user,nostr.message user,model_nostr_message,base.group_user,1,0,0,0
access_nostr_message_manager,nostr.message manager,model_nostr_message,base.group_system,1,1,1,1
=== ./odoo_custom_addons/nostr_identity/data/ir_cron_data.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <record id="ir_cron_nostr_process_messages" model="ir.cron">
            <field name="name">Nostr: Process Messages</field>
            <field name="model_id" ref="model_nostr_identity_verifier"/>
            <field name="state">code</field>
            <field name="code">model.process_messages()</field>
            <field name="interval_number">5</field>
            <field name="interval_type">minutes</field>
            <field name="numbercall">-1</field>
            <field name="doall" eval="False"/>
            <field name="active" eval="True"/>
        </record>
    </data>
</odoo>
=== ./odoo_custom_addons/nostr_identity/views/nostr_identity_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <!-- Nostr Identity Views -->
    <record id="view_nostr_identity_tree" model="ir.ui.view">
        <field name="name">nostr.identity.tree</field>
        <field name="model">nostr.identity</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="public_key"/>
                <field name="public_key_bech32"/>
            </tree>
        </field>
    </record>

    <record id="view_nostr_identity_form" model="ir.ui.view">
        <field name="name">nostr.identity.form</field>
        <field name="model">nostr.identity</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="public_key"/>
                        <field name="public_key_bech32"/>
                        <field name="relay_urls"/>
                        <field name="profile_data"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <!-- The rest of the XML remains unchanged -->
    <!-- Nostr Identity Verifier Views -->
    <record id="view_nostr_identity_verifier_tree" model="ir.ui.view">
        <field name="name">nostr.identity.verifier.tree</field>
        <field name="model">nostr.identity.verifier</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="relay_url"/>
                <field name="websocket_state"/>
            </tree>
        </field>
    </record>

    <record id="view_nostr_identity_verifier_form" model="ir.ui.view">
        <field name="name">nostr.identity.verifier.form</field>
        <field name="model">nostr.identity.verifier</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="connect_to_relay" string="Connect" type="object" class="oe_highlight" attrs="{'invisible': [('websocket_state', '=', 'connected')]}"/>
                    <button name="close_connection" string="Disconnect" type="object" attrs="{'invisible': [('websocket_state', '!=', 'connected')]}"/>
                </header>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="relay_url"/>
                        <field name="active"/>
                        <field name="websocket_state"/>
                        <field name="last_error"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <!-- Action Windows -->
    <record id="action_nostr_identity" model="ir.actions.act_window">
        <field name="name">Nostr Identities</field>
        <field name="res_model">nostr.identity</field>
        <field name="view_mode">tree,form</field>
    </record>

    <record id="action_nostr_identity_verifier" model="ir.actions.act_window">
        <field name="name">Nostr Identity Verifiers</field>
        <field name="res_model">nostr.identity.verifier</field>
        <field name="view_mode">tree,form</field>
    </record>

    <!-- Menu Items -->
    <menuitem id="menu_nostr_root" name="Nostr" sequence="10"/>
    <menuitem id="menu_nostr_identity" name="Identities" parent="menu_nostr_root" action="action_nostr_identity" sequence="10"/>
    <menuitem id="menu_nostr_identity_verifier" name="Verifiers" parent="menu_nostr_root" action="action_nostr_identity_verifier" sequence="20"/>
</odoo>
=== ./odoo_custom_addons/nostr_bridge/models/git_repository.py ===
# File: odoo_custom_addons/nostr_bridge/models/git_repository.py

from odoo import models, fields, api
import git
import os

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Repository Name', required=True)
    path = fields.Char(string='Repository Path', required=True)
    
    @api.model
    def create(self, vals):
        repo = super(GitRepository, self).create(vals)
        if not os.path.exists(repo.path):
            os.makedirs(repo.path)
            git.Repo.init(repo.path)
        return repo

    def commit_changes(self, message):
        repo = git.Repo(self.path)
        repo.git.add(A=True)
        commit = repo.index.commit(message)
        
        event_manager = self.env['nostr.event.manager']
        event = event_manager.create_git_event(self.path, commit.hexsha)
        event_manager.publish_event(event)
        
        return commit.hexsha
=== ./odoo_custom_addons/nostr_bridge/models/__init__.py ===
# File: odoo_custom_addons/nostr_bridge/models/__init__.py

from . import res_users
from . import mail_message
from . import nostr_adapter
from . import res_config_settings
from . import res_partner
from . import nostr_event_manager
from . import git_repository
=== ./odoo_custom_addons/nostr_bridge/models/res_users.py ===
"""from odoo import models, fields, api
from nostr.key import PrivateKey

class ResUsers(models.Model):
    _inherit = 'res.users'

    #nostr_private_key = fields.Char(string="Nostr Private Key")
    #nostr_public_key = fields.Char(string="Nostr Public Key", compute='_compute_public_key')
    #nostr_relay_url = fields.Char(string="Nostr Relay URL")

    nostr_public_key = fields.Char(string="Nostr Public Key")
    nostr_private_key = fields.Char(string="Nostr Private Key")
    nostr_relay_url = fields.Char(string="Nostr Relay URL")

    @api.model
    def create(self, vals):
        if not vals.get('nostr_private_key'):
            private_key = PrivateKey()
            vals['nostr_private_key'] = private_key.bech32()
        return super(ResUsers, self).create(vals)

    def write(self, vals):
        # Here you might want to handle updates to Nostr fields
        return super(ResUsers, self).write(vals)

    @api.depends('nostr_private_key')
    def _compute_public_key(self):
        for user in self:
            if user.nostr_private_key:
                private_key = PrivateKey.from_nsec(user.nostr_private_key)
                user.nostr_public_key = private_key.public_key.bech32()
            else:
                user.nostr_public_key = False
"""

"""from odoo import models, fields, api

class ResUsers(models.Model):
    _inherit = 'res.users'

    nostr_public_key = fields.Char(string="Nostr Public Key")
    nostr_private_key = fields.Char(string="Nostr Private Key")
    nostr_relay_url = fields.Char(string="Nostr Relay URL")

    @api.model
    def create(self, vals):
        # Here you might want to generate Nostr keys if they're not provided
        return super(ResUsers, self).create(vals)

    def write(self, vals):
        # Here you might want to handle updates to Nostr fields
        return super(ResUsers, self).write(vals)"""
        
        
from odoo import models, fields

class ResUsers(models.Model):
    _inherit = 'res.users'

    nostr_public_key = fields.Char(string="Nostr Public Key")
    nostr_private_key = fields.Char(string="Nostr Private Key")
    nostr_relay_url = fields.Char(string="Nostr Relay URL")
=== ./odoo_custom_addons/nostr_bridge/models/nostr_adapter.py ===
import requests
import websocket
from odoo import models, api
from websocket._exceptions import WebSocketConnectionClosedException
from odoo.exceptions import UserError
from nostr.event import Event
from nostr.key import PrivateKey
from nostr.relay_manager import RelayManager
import logging
import time

_logger = logging.getLogger(__name__)

class NostrAdapter(models.AbstractModel):
    _name = 'nostr.adapter'
    _description = 'Nostr Adapter'

    @api.model
    def get_relay_manager(self):
        ICPSudo = self.env['ir.config_parameter'].sudo()
        relay_urls = ICPSudo.get_param('nostr_bridge.relay_urls', '').split(',')
        if not relay_urls:
            raise UserError("Nostr relay URL is not configured. Please set it in the settings.")
        _logger.info(f"Nostr relay URLs: {relay_urls}")

        relay_manager = RelayManager()
        for url in relay_urls:
            url = url.strip()
            if url:  # Only add non-empty URLs
                _logger.info(f"Adding relay: {url}")
                relay_manager.add_relay(url)
        return relay_manager

    @api.model
    def publish_event(self, event_data, max_retries=3, retry_delay=1):
        for attempt in range(max_retries):
            try:
                private_key = PrivateKey.from_nsec(self.env.user.nostr_private_key)
                public_key = private_key.public_key.hex()
                
                event = Event(
                    kind=event_data['kind'],
                    content=event_data['content'],
                    tags=event_data.get('tags', []),
                    public_key=public_key
                )
                private_key.sign_event(event)
                
                relay_manager = self.get_relay_manager()
                relay_manager.open_connections({"write": True})
                time.sleep(1)  # Give some time for connections to establish
                
                publish_result = relay_manager.publish_event(event)
                _logger.info(f"Relay publish response: {publish_result}")
    
                relay_manager.close_connections()
                return True
            except Exception as e:
                _logger.exception(f"Error publishing event to Nostr: {str(e)}")
                time.sleep(retry_delay)
        
        _logger.error("Failed to publish event after multiple attempts")
        return False
=== ./odoo_custom_addons/nostr_bridge/models/mail_message.py ===
from odoo import models, api
import logging

_logger = logging.getLogger(__name__)

class MailMessage(models.Model):
    _inherit = 'mail.message'

    @api.model_create_multi
    def create(self, vals_list):
        _logger.info("Creating new mail messages")
        messages = super(MailMessage, self).create(vals_list)
        for message in messages:
            self._publish_to_nostr(message)
        return messages

    def _publish_to_nostr(self, message):
        try:
            nostr_adapter = self.env['nostr.adapter'].sudo()
            event_data = {
                'kind': 1,  # Text note
                'content': message.body,
                'tags': [
                    ['e', str(message.parent_id.id)] if message.parent_id else [],
                    ['p', message.author_id.nostr_public_key] if message.author_id and message.author_id.nostr_public_key else [],
                    ['client', 'Odoo Nostr Bridge'],
                ],
            }
            result = nostr_adapter.publish_event(event_data)
            if result:
                _logger.info(f"Successfully published message {message.id} to Nostr")
            else:
                _logger.warning(f"Failed to publish message {message.id} to Nostr")
        except Exception as e:
            _logger.exception(f"Error publishing message {message.id} to Nostr: {str(e)}")
=== ./odoo_custom_addons/nostr_bridge/models/nostr_event_handler.py ===
import json
from odoo import api, models

class NostrEventHandler(models.AbstractModel):
    _name = 'nostr.event.handler'
    _description = 'Nostr Event Handler'

    @api.model
    def handle_event(self, event):
        content = json.loads(event.content)
        if event.kind == 1:  # Text note
            self._handle_message(content)
        elif event.kind == 7:  # Reaction
            self._handle_reaction(content)

    def _handle_message(self, content):
        self.env['mail.message'].create({
            'body': content['body'],
            'author_id': self._get_author_id(content['author']),
            'model': content['channel'],
            'res_id': content['res_id'],
        })

    def _handle_reaction(self, content):
        # Implement reaction handling (e.g., likes, emojis)
        pass

    def _get_author_id(self, author_name):
        partner = self.env['res.partner'].search([('name', '=', author_name)], limit=1)
        if not partner:
            partner = self.env['res.partner'].create({'name': author_name})
        return partner.id
=== ./odoo_custom_addons/nostr_bridge/models/res_config_settings.py ===
import requests
import json
from odoo import fields, models, api
import logging

_logger = logging.getLogger(__name__)

class ResConfigSettings(models.TransientModel):
    _inherit = 'res.config.settings'

    def _default_nostr_relays(self):
        return self._get_top_nostr_relays()

    @api.model
    def _get_top_nostr_relays(self, limit=108):
        url = "https://api.nostr.watch/v1/online"
        try:
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
            }
            response = requests.get(url, headers=headers, timeout=10)
            response.raise_for_status()
            _logger.info(f"Response status code: {response.status_code}")
            
            data = response.json()
            #_logger.info(f"API response (first 108 items): {json.dumps(data)[:1000]}")
            _logger.info(f"API response (first 108 items): {data[:108]}")
            
            relays = data[:108]
            _logger.info(f"Number of relay links found: {len(relays)}")
            _logger.info(f"Extracted relays (first 5): {relays[:5]}")
            
            relay_urls = ",".join(relays)
            return relay_urls
        except requests.RequestException as e:
            _logger.error(f"Error fetching Nostr relays: {e}")
            return "wss://nostr-relay.app,wss://nos.lol,wss://relay.snort.social,wss://relay.nostr.net"

    nostr_relay_urls = fields.Char(
        string="Nostr Relay URLs", 
        config_parameter='nostr_bridge.relay_urls',
        default=_default_nostr_relays
    )

    @api.model
    def get_values(self):
        res = super(ResConfigSettings, self).get_values()
        ICPSudo = self.env['ir.config_parameter'].sudo()
        
        relay_urls = ICPSudo.get_param('nostr_bridge.relay_urls')
        if not relay_urls:
            relay_urls = self._get_top_nostr_relays()
            ICPSudo.set_param('nostr_bridge.relay_urls', relay_urls)
            _logger.info(f"Set new relay URLs: {relay_urls[:100]}...")  # Log first 100 characters
        else:
            _logger.info(f"Using existing relay URLs: {relay_urls[:100]}...")  # Log first 100 characters
        
        res.update(nostr_relay_urls=relay_urls)
        return res

    def set_values(self):
        super(ResConfigSettings, self).set_values()
        ICPSudo = self.env['ir.config_parameter'].sudo()
        if self.nostr_relay_urls:
            ICPSudo.set_param('nostr_bridge.relay_urls', self.nostr_relay_urls)
            _logger.info(f"Updated relay URLs: {self.nostr_relay_urls[:100]}...")  # Log first 100 characters
        else:
            default_urls = self._get_top_nostr_relays()
            ICPSudo.set_param('nostr_bridge.relay_urls', default_urls)
            _logger.info(f"Set default relay URLs: {default_urls[:100]}...")  # Log first 100 characters
=== ./odoo_custom_addons/nostr_bridge/models/res_partner.py ===
from odoo import models, fields

class ResPartner(models.Model):
    _inherit = 'res.partner'

    nostr_public_key = fields.Char(string="Nostr Public Key")
=== ./odoo_custom_addons/nostr_bridge/models/nostr_event_manager.py ===
from odoo import models, fields, api
import json
import time
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.serialization import Encoding, PublicFormat
import logging

_logger = logging.getLogger(__name__)

class NostrEventManager(models.AbstractModel):
    _name = 'nostr.event.manager'
    _description = 'Nostr Event Manager'

    @api.model
    def create_event(self, content, tags, private_key):
        private_key_obj = PrivateKey.from_nsec(private_key)
        event = Event(kind=1, content=content, tags=tags)
        private_key_obj.sign_event(event)
        return event.to_json()

    @api.model
    def get_public_key(self, private_key):
        private_key_obj = ec.derive_private_key(int(private_key, 16), ec.SECP256K1())
        public_key = private_key_obj.public_key()
        return public_key.public_bytes(
            encoding=Encoding.X962,
            format=PublicFormat.UncompressedPoint
        )[1:].hex()

    @api.model
    def calculate_event_id(self, event_data):
        serialized = json.dumps([
            0,
            event_data['pubkey'],
            event_data['created_at'],
            event_data['kind'],
            event_data['tags'],
            event_data['content']
        ], separators=(',', ':'))
        return self.sha256(serialized)

    @api.model
    def sign_event(self, event_data, private_key):
        private_key_obj = ec.derive_private_key(int(private_key, 16), ec.SECP256K1())
        signature = private_key_obj.sign(
            bytes.fromhex(event_data['id']),
            ec.ECDSA(hashes.SHA256())
        )
        return signature.hex()

    @api.model
    def sha256(self, data):
        digest = hashes.Hash(hashes.SHA256())
        digest.update(data.encode())
        return digest.finalize().hex()

    @api.model
    def create_git_event(self, repo_path, commit_hash):
        repo = git.Repo(repo_path)
        commit = repo.commit(commit_hash)
        
        content = json.dumps({
            "action": "commit",
            "message": commit.message,
            "author": commit.author.name,
            "email": commit.author.email,
            "date": commit.authored_datetime.isoformat()
        })
        
        tags = [
            ["t", "commit"],
            ["h", commit_hash],
            ["n", repo.active_branch.name],
            ["m", commit.author.name],
            ["v", "1.0"],
            ["r", repo.remotes.origin.url if repo.remotes else ""],
            ["p", self.env.user.nostr_public_key],
            ["d", commit.message],
            ["s", "success"]
        ]
        
        event = self.create_event(content, tags, self.env.user.nostr_private_key)
        self.publish_event(event)
        return event

    def sync_with_decentralized_manager(self, event):
        sync_managers = self.env['decentralized.sync.manager'].search([])
        for manager in sync_managers:
            program = self.env['decentralized.sync.program'].search([
                ('manager_id', '=', manager.id),
                ('content', '=', event['content'])
            ], limit=1)

            if not program:
                program = self.env['decentralized.sync.program'].create({
                    'manager_id': manager.id,
                    'creator_id': self.env['decentralized.sync.creator'].search([], limit=1).id,
                    'content': event['content'],
                    'version': 1,
                    'size': 0.5  # Arbitrary size
                })

            manager.propagate_update(program)

    @api.model
    def publish_event(self, event):
        sync_managers = self.env['decentralized.sync.manager'].search([])
        for manager in sync_managers:
            manager.publish_event(event['content'], event['tags'])
        return True

    @api.model
    def get_events(self, filters=None):
        nostr_adapter = self.env['nostr.adapter']
        return nostr_adapter.get_events(filters)
=== ./odoo_custom_addons/nostr_bridge/models/ivcs_item.py ===
# File: odoo_custom_addons/nostr_bridge/models/ivcs_item.py

from odoo import models, fields, api, _
from odoo.exceptions import UserError
import git
import os
import logging
from nostr.key import PrivateKey

_logger = logging.getLogger(__name__)

class IVCSItem(models.Model):
    _inherit = 'ivcs.item'

    nostr_private_key = fields.Char(string="Nostr Private Key")

    def _create_nostr_event_and_publish(self, commit):
        if not self.nostr_private_key:
            self.nostr_private_key = PrivateKey().hex()
            self.sudo().write({'nostr_private_key': self.nostr_private_key})

        private_key = PrivateKey(bytes.fromhex(self.nostr_private_key))
        nostr_manager = self.env['nostr.event.manager']
        event = nostr_manager.create_git_event(commit, private_key)

        relay_urls = self.env['ir.config_parameter'].sudo().get_param('nostr_bridge.relay_urls', '').split(',')
        for relay_url in relay_urls:
            if relay_url.strip():
                success = nostr_manager.publish_event_sync(event, relay_url.strip())
                if success:
                    _logger.info(f"Successfully published event to {relay_url}")
                else:
                    _logger.warning(f"Failed to publish event to {relay_url}")

    def sync_repository(self):
        result = super(IVCSItem, self).sync_repository()
        if result.get('type') == 'ir.actions.client' and result['params']['type'] == 'success':
            repo = git.Repo(self.repo_path)
            latest_commit = repo.head.commit
            self._create_nostr_event_and_publish(latest_commit)
        return result

    def create_file(self, filename, content):
        result = super(IVCSItem, self).create_file(filename, content)
        if result.get('type') == 'ir.actions.client' and result['params']['type'] == 'success':
            repo = git.Repo(self.repo_path)
            latest_commit = repo.head.commit
            self._create_nostr_event_and_publish(latest_commit)
        return result

    @api.model
    def create(self, vals):
        item = super(IVCSItem, self).create(vals)
        repo = git.Repo(item.repo_path)
        initial_commit = repo.head.commit
        item._create_nostr_event_and_publish(initial_commit)
        return item
=== ./odoo_custom_addons/nostr_bridge/__init__.py ===
from . import models
from . import controllers
=== ./odoo_custom_addons/nostr_bridge/__manifest__.py ===
# File: odoo_custom_addons/nostr_bridge/__manifest__.py

{
    'name': 'Nostr Bridge',
    'version': '1.0',
    'category': 'Social',
    'summary': 'Bridge between Odoo messages, Git, and Nostr network',
    'depends': ['base', 'mail', 'web'],
    'data': [
        'views/res_config_settings_views.xml',
        'views/res_users_views.xml',
        'views/res_partner_views.xml',
        'views/git_repository_views.xml',
        'security/ir.model.access.csv',
    ],
    'installable': True,
    'application': False,
    'auto_install': False,
    'license': 'LGPL-3',
    'external_dependencies': {
        'python': ['cryptography', 'gitpython', 'nostr'],
    },
}
=== ./odoo_custom_addons/nostr_bridge/static/src/js/nostr_client.js ===
odoo.define('nostr_bridge.NostrClient', function (require) {
    "use strict";

    var Class = require('web.Class');

    var NostrClient = Class.extend({
        init: function (relayUrls) {
            this.relayUrls = relayUrls;
            this.relayPool = new NostrTools.RelayPool(this.relayUrls);
        },

        subscribe: function (filters, callback) {
            this.relayPool.subscribe(filters, callback);
        },

        publish: function (event) {
            this.relayPool.publish(event);
        }
    });

    return NostrClient;
});
=== ./odoo_custom_addons/nostr_bridge/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_git_repository_user,git.repository.user,model_git_repository,base.group_user,1,1,1,1
=== ./odoo_custom_addons/nostr_bridge/data/ir_cron_data.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <record id="ir_cron_migrate_messages_to_nostr" model="ir.cron">
            <field name="name">Migrate Messages to Nostr</field>
            <field name="model_id" ref="model_mail_message"/>
            <field name="state">code</field>
            <field name="code">model.migrate_messages_to_nostr()</field>
            <field name="interval_number">1</field>
            <field name="interval_type">days</field>
            <field name="numbercall">1</field>
            <field name="doall" eval="False"/>
        </record>
    </data>
</odoo>
=== ./odoo_custom_addons/nostr_bridge/views/res_users_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_users_form_nostr" model="ir.ui.view">
        <field name="name">res.users.form.nostr</field>
        <field name="model">res.users</field>
        <field name="inherit_id" ref="base.view_users_form"/>
        <field name="arch" type="xml">
            <xpath expr="//notebook" position="inside">
                <page string="Nostr Settings" name="nostr_settings">
                    <group>
                        <field name="nostr_public_key"/>
                        <field name="nostr_private_key" password="True"/>
                        <field name="nostr_relay_url"/>
                    </group>
                </page>
            </xpath>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons/nostr_bridge/views/res_partner_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_partner_form_nostr" model="ir.ui.view">
        <field name="name">res.partner.form.nostr</field>
        <field name="model">res.partner</field>
        <field name="inherit_id" ref="base.view_partner_form"/>
        <field name="arch" type="xml">
            <xpath expr="//notebook" position="inside">
                <page string="Nostr Settings" name="nostr_settings">
                    <group>
                        <field name="nostr_public_key"/>
                    </group>
                </page>
            </xpath>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons/nostr_bridge/views/res_config_settings_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="res_config_settings_view_form_nostr" model="ir.ui.view">
        <field name="name">res.config.settings.view.form.inherit.nostr</field>
        <field name="model">res.config.settings</field>
        <field name="inherit_id" ref="base.res_config_settings_view_form"/>
        <field name="arch" type="xml">
            <xpath expr="//div[hasclass('settings')]" position="inside">
                <div class="app_settings_block" data-string="Nostr Bridge" string="Nostr Bridge" data-key="nostr_bridge">
                    <h2>Nostr Settings</h2>
                    <div class="row mt16 o_settings_container">
                        <div class="col-12 col-lg-6 o_setting_box">
                            <div class="o_setting_left_pane"/>
                            <div class="o_setting_right_pane">
                                <span class="o_form_label">Nostr Relay URLs</span>
                                <div class="text-muted">
                                    Comma-separated list of Nostr relay URLs
                                </div>
                                <div class="content-group">
                                    <div class="mt16">
                                        <field name="nostr_relay_urls" class="o_light_label"/>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </xpath>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons/nostr_bridge/views/templates.xml ===
<odoo>
    <template id="assets_backend" name="nostr_bridge assets" inherit_id="web.assets_backend">
        <xpath expr="." position="inside">
            <script type="text/javascript" src="/nostr_bridge/static/src/js/nostr_client.js"/>
        </xpath>
    </template>
</odoo>
=== ./odoo_custom_addons/nostr_bridge/views/git_repository_views.xml ===
<!-- File: odoo_custom_addons/nostr_bridge/views/git_repository_views.xml -->

<odoo>
    <record id="view_git_repository_form" model="ir.ui.view">
        <field name="name">git.repository.form</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="path"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="action_git_repository" model="ir.actions.act_window">
        <field name="name">Git Repositories</field>
        <field name="res_model">git.repository</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_git_repository" name="Git Repositories" action="action_git_repository" parent="base.menu_custom"/>
</odoo>
=== ./odoo_custom_addons/nostr_bridge/controllers/__init__.py ===
from . import main
=== ./odoo_custom_addons/nostr_bridge/controllers/main.py ===
from odoo import http
from odoo.http import request
import json
from nostr.event import Event
from nostr.key import PrivateKey

class NostrController(http.Controller):

    @http.route('/nostr/authenticate', type='json', auth='public')
    def authenticate(self, public_key, signature, message):
        User = request.env['res.users'].sudo()
        user_id = User.authenticate_nostr(public_key, signature, message)
        if user_id:
            request.session.authenticate(request.db, user_id, public_key)
            return {'success': True, 'uid': user_id}
        return {'success': False, 'error': 'Authentication failed'}

    @http.route('/nostr/publish', type='json', auth='user')
    def publish_event(self, event_data):
        nostr_adapter = request.env['nostr.adapter'].sudo().get_adapter()
        try:
            nostr_adapter.publish_event(event_data)
            return {'success': True}
        except Exception as e:
            return {'success': False, 'error': str(e)}

    @http.route('/nostr/subscribe', type='json', auth='user')
    def subscribe_to_events(self, filters):
        nostr_adapter = request.env['nostr.adapter'].sudo().get_adapter()
        try:
            def callback(event):
                # Process the event, e.g., create a message in Odoo
                request.env['nostr.event.handler'].sudo().handle_event(event)

            nostr_adapter.subscribe_to_events(filters, callback)
            return {'success': True}
        except Exception as e:
            return {'success': False, 'error': str(e)}

    @http.route('/nostr/get_public_key', type='json', auth='user')
    def get_public_key(self):
        user = request.env.user
        return {'public_key': user.nostr_public_key}

    @http.route('/nostr/create_event', type='json', auth='user')
    def create_event(self, kind, content, tags=None):
        user = request.env.user
        private_key = PrivateKey.from_nsec(user.nostr_private_key)
        event = Event(kind=kind, content=json.dumps(content), tags=tags or [])
        event.sign(private_key.hex())
        return {
            'id': event.id,
            'pubkey': event.public_key,
            'created_at': event.created_at,
            'kind': event.kind,
            'tags': event.tags,
            'content': event.content,
            'sig': event.signature,
        }
=== ./odoo_custom_addons/decentralized_sync/models/supporting_models.py ===
from odoo import models, fields, api

class DAO(models.Model):
    _name = 'decentralized.sync.dao'
    _description = 'DAO'

    manager_id = fields.Many2one('decentralized.sync.manager', string='Sync Manager')
    tier = fields.Selection([('primary', 'Primary'), ('secondary', 'Secondary'), ('tertiary', 'Tertiary')], string='Tier')
    location_lat = fields.Float(string='Latitude')
    location_lon = fields.Float(string='Longitude')
    storage_capacity = fields.Float(string='Storage Capacity')
    network_speed = fields.Float(string='Network Speed')
    local_state = fields.Text(string='Local State')

class Creator(models.Model):
    _name = 'decentralized.sync.creator'
    _description = 'Creator'

    manager_id = fields.Many2one('decentralized.sync.manager', string='Sync Manager')
    location_lat = fields.Float(string='Latitude')
    location_lon = fields.Float(string='Longitude')
    productivity = fields.Float(string='Productivity')
    dao_id = fields.Many2one('decentralized.sync.dao', string='Associated DAO')

class Program(models.Model):
    _name = 'decentralized.sync.program'
    _description = 'Program'

    manager_id = fields.Many2one('decentralized.sync.manager', string='Sync Manager')
    creator_id = fields.Many2one('decentralized.sync.creator', string='Creator')
    size = fields.Float(string='Size')
    version = fields.Integer(string='Version')
    content = fields.Text(string='Content')
    host_ids = fields.Many2many('decentralized.sync.dao', string='Hosts')

class Event(models.Model):
    _name = 'decentralized.sync.event'
    _description = 'Sync Event'

    manager_id = fields.Many2one('decentralized.sync.manager', string='Sync Manager')
    description = fields.Text(string='Event Description')
    timestamp = fields.Datetime(string='Timestamp', default=fields.Datetime.now)

class Connection(models.Model):
    _name = 'decentralized.sync.connection'
    _description = 'Connection between Creator and DAO'

    manager_id = fields.Many2one('decentralized.sync.manager', string='Sync Manager')
    creator_id = fields.Many2one('decentralized.sync.creator', string='Creator')
    dao_id = fields.Many2one('decentralized.sync.dao', string='DAO')
=== ./odoo_custom_addons/decentralized_sync/models/sync_manager.py ===
from odoo import models, fields, api
import logging
from nostr.key import PrivateKey
from nostr.event import Event
from nostr.relay_manager import RelayManager
import git
import os

_logger = logging.getLogger(__name__)

class DecentralizedNostrSyncManager(models.Model):
    _name = 'decentralized.sync.manager'
    _description = 'Decentralized Nostr Sync Manager'

    name = fields.Char(string='Name', required=True)
    relay_urls = fields.Text(string='Relay URLs', required=True)
    private_key = fields.Char(string='Private Key')
    public_key = fields.Char(string='Public Key', compute='_compute_public_key')

    @api.depends('private_key')
    def _compute_public_key(self):
        for record in self:
            if record.private_key:
                private_key = PrivateKey.from_nsec(record.private_key)
                record.public_key = private_key.public_key.bech32()
            else:
                record.public_key = False

    def initialize_nostr(self):
        if not self.private_key:
            private_key = PrivateKey()
            self.private_key = private_key.bech32()
        
        self.relay_manager = RelayManager()
        for url in self.relay_urls.split(','):
            self.relay_manager.add_relay(url.strip())
        self.relay_manager.open_connections()

    def publish_event(self, content, tags=None):
        if not hasattr(self, 'relay_manager'):
            self.initialize_nostr()

        private_key = PrivateKey.from_nsec(self.private_key)
        event = Event(content=content, tags=tags or [])
        private_key.sign_event(event)
        
        self.relay_manager.publish_event(event)
        return event

    def sync_git_repository(self, repo_path):
        repo = git.Repo(repo_path)
        if not repo.remotes:
            raise ValueError('No remote repository configured')

        origin = repo.remotes.origin
        origin.fetch()
        
        current_branch = repo.active_branch
        if f'origin/{current_branch.name}' not in repo.refs:
            origin.push(current_branch)
        else:
            origin.pull(current_branch)

        for commit in repo.iter_commits(f'{current_branch.name}@{{u}}..{current_branch.name}'):
            self.publish_event(
                content=f"New commit: {commit.hexsha}",
                tags=[['c', commit.hexsha], ['t', 'git_commit']]
            )

    @api.model
    def create(self, vals):
        manager = super(DecentralizedNostrSyncManager, self).create(vals)
        manager.initialize_nostr()
        return manager

    def write(self, vals):
        result = super(DecentralizedNostrSyncManager, self).write(vals)
        if 'relay_urls' in vals:
            self.initialize_nostr()
        return result
=== ./odoo_custom_addons/decentralized_sync/__init__.py ===
from . import models
from . import controllers
=== ./odoo_custom_addons/decentralized_sync/__manifest__.py ===
{
    'name': 'Decentralized Nostr Sync Manager',
    'version': '1.0',
    'category': 'Tools',
    'summary': 'Manage decentralized synchronization with Nostr and Git',
    'depends': ['base', 'ivcs_git', 'nostr_bridge'],
    'data': [
        'security/ir.model.access.csv',
        'views/sync_manager_views.xml',
        'views/dao_views.xml',
        'views/creator_views.xml',
        'views/program_views.xml',
        'views/event_views.xml',
        'views/menu_items.xml',
    ],
    'installable': True,
    'application': False,
    'auto_install': False,
}
=== ./odoo_custom_addons/decentralized_sync/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_decentralized_sync_manager_user,decentralized.sync.manager user,model_decentralized_sync_manager,base.group_user,1,1,1,1
access_decentralized_sync_dao_user,decentralized.sync.dao user,model_decentralized_sync_dao,base.group_user,1,1,1,1
access_decentralized_sync_creator_user,decentralized.sync.creator user,model_decentralized_sync_creator,base.group_user,1,1,1,1
access_decentralized_sync_program_user,decentralized.sync.program user,model_decentralized_sync_program,base.group_user,1,1,1,1
access_decentralized_sync_event_user,decentralized.sync.event user,model_decentralized_sync_event,base.group_user,1,1,1,1
access_decentralized_sync_connection_user,decentralized.sync.connection user,model_decentralized_sync_connection,base.group_user,1,1,1,1
=== ./odoo_custom_addons/decentralized_sync/controllers/main.py ===
from odoo import http
from odoo.http import request
from nostr.event import Event
import json

class DecentralizedSyncController(http.Controller):

    @http.route('/api/decentralized_sync/publish', type='json', auth='user')
    def publish_event(self, manager_id, content, tags=None):
        manager = request.env['decentralized.sync.manager'].browse(int(manager_id))
        event = manager.publish_event(content, tags)
        return {'status': 'success', 'event_id': event.id}

    @http.route('/api/decentralized_sync/sync_repo', type='json', auth='user')
    def sync_repository(self, manager_id, repo_path):
        manager = request.env['decentralized.sync.manager'].browse(int(manager_id))
        manager.sync_git_repository(repo_path)
        return {'status': 'success', 'message': 'Repository synced and events published'}

    @http.route('/api/decentralized_sync/events', type='json', auth='user')
    def get_events(self, manager_id):
        manager = request.env['decentralized.sync.manager'].browse(int(manager_id))
        # This would typically fetch events from Nostr relays
        # For now, we'll return an empty list
        return {'events': []}
=== ./odoo_custom_addons/nostr_auth_test/nostr_auth_module.py ===
import os
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import hashes
from odoo import models, fields, api
from odoo.exceptions import ValidationError
import base64

class NostrAuthModule(models.AbstractModel):
    _name = 'nostr.auth'
    _description = 'Nostr Authentication Module'

    @api.model
    def generate_keypair(self):
        """
        Generate a new Nostr keypair.
        This represents the 'Cause' in our 'Causal Relationship'.
        """
        private_key = ec.generate_private_key(ec.SECP256K1())
        public_key = private_key.public_key()
        
        private_bytes = private_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=serialization.NoEncryption()
        )
        public_bytes = public_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        )
        
        return {
            'private_key': base64.b64encode(private_bytes).decode('utf-8'),
            'public_key': base64.b64encode(public_bytes).decode('utf-8')
        }

    @api.model
    def store_keys(self, user_id, public_key, private_key):
        """
        Store the Nostr keys for a user.
        This action creates an 'Effect' in our 'Causal Relationship'.
        """
        user = self.env['res.users'].browse(user_id)
        if not user.exists():
            raise ValidationError("User does not exist")
        
        user.write({
            'nostr_public_key': public_key,
            'nostr_private_key': private_key  # In a real-world scenario, encrypt this before storage
        })

    @api.model
    def verify_signature(self, public_key, message, signature):
        """
        Verify a Nostr signature.
        This verification process is another 'Effect' in our 'Causal Relationship'.
        """
        try:
            public_key_obj = serialization.load_pem_public_key(base64.b64decode(public_key))
            signature_bytes = base64.b64decode(signature)
            public_key_obj.verify(
                signature_bytes,
                message.encode('utf-8'),
                ec.ECDSA(hashes.SHA256())
            )
            return True
        except:
            return False

    @api.model
    def authenticate_nostr(self, public_key, signature, message):
        """
        Authenticate a user using Nostr.
        This method embodies the complete 'Causal Relationship':
        The provided credentials (Cause) lead to authentication success or failure (Effect).
        """
        user = self.env['res.users'].search([('nostr_public_key', '=', public_key)], limit=1)
        if user and self.verify_signature(user.nostr_public_key, message, signature):
            return user.id
        return False

# For console testing
if __name__ == "__main__":
    # Simulate Odoo environment
    class MockEnv:
        def __init__(self):
            self.users = {}
        
        def __getitem__(self, key):
            return self
        
        def search(self, domain, limit=None):
            for user_id, user in self.users.items():
                if user['nostr_public_key'] == domain[0][2]:
                    return [MockUser(user_id, user)]
            return []
    
    class MockUser:
        def __init__(self, id, data):
            self.id = id
            self.__dict__.update(data)
        
        def exists(self):
            return True
        
        def write(self, vals):
            self.__dict__.update(vals)

    mock_env = MockEnv()
    
    # Create an instance of NostrAuthModule
    nostr_auth = NostrAuthModule()
    nostr_auth.env = mock_env

    # Test key generation
    print("Generating keypair...")
    keys = nostr_auth.generate_keypair()
    print(f"Public Key: {keys['public_key'][:32]}...")
    print(f"Private Key: {keys['private_key'][:32]}...")

    # Test key storage
    print("\nStoring keys...")
    mock_env.users[1] = {'name': 'Test User'}
    try:
        nostr_auth.store_keys(1, keys['public_key'], keys['private_key'])
        print("Keys stored successfully")
    except Exception as e:
        print(f"Error storing keys: {str(e)}")

    # Test signature verification
    print("\nTesting signature verification...")
    message = "Test message"
    private_key = serialization.load_pem_private_key(base64.b64decode(keys['private_key']), password=None)
    signature = base64.b64encode(private_key.sign(
        message.encode('utf-8'),
        ec.ECDSA(hashes.SHA256())
    )).decode('utf-8')
    
    is_valid = nostr_auth.verify_signature(keys['public_key'], message, signature)
    print(f"Signature valid: {is_valid}")

    # Test authentication
    print("\nTesting authentication...")
    user_id = nostr_auth.authenticate_nostr(keys['public_key'], signature, message)
    print(f"Authenticated user ID: {user_id}")

    print("\nAll tests completed.")
=== ./odoo_custom_addons/git_nostr_object/models/git_repository.py ===
# models/git_repository.py
from odoo import models, fields, api
import git
import json

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Name', required=True)
    path = fields.Char(string='Path', required=True)
    logs = fields.Text(string='Logs')

    def traverse_and_publish(self):
        self.ensure_one()
        logs = []
        try:
            git_repo = git.Repo(self.path)
            for commit in git_repo.iter_commits():
                nostr_event = self.env['nostr.event.object'].create({
                    'kind': 1,
                    'content': commit.message,
                    'tags': json.dumps([['commit', commit.hexsha]]),
                    'created_at': commit.committed_date,
                })
                nostr_event.action_publish()
                logs.append(f"Published commit {commit.hexsha}")

            self.write({'logs': '\n'.join(logs)})
            self.env['bus.bus']._sendone(self.env.user.partner_id, 'simple_notification', {
                'title': _("Git Repository Traversed"),
                'message': _("All commits published to Nostr network"),
            })
        except Exception as e:
            error_msg = f"Error traversing repository: {e}"
            logs.append(error_msg)
            self.write({'logs': '\n'.join(logs)})
            raise UserError(_(error_msg))

        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _("Git Repository"),
                'message': _("Repository traversed and commits published. Check logs for details."),
                'sticky': False,
                'type': 'success',
            }
        }
=== ./odoo_custom_addons/git_nostr_object/models/git_commit.py ===
from odoo import models, fields, api
from .git_object import GitObject

class GitCommit(models.Model):
    _name = 'git.commit'
    _inherit = 'git.object'
    _description = 'Git Commit'

    message = fields.Text(string='Commit Message')
    author = fields.Char(string='Author')
    timestamp = fields.Datetime(string='Timestamp')

    def to_nostr_event(self):
        return self.env['nostr.event.object'].create({
            'kind': 3121,
            'content': self.data,
            'tags': [['sha', self.sha]],
        })

    @api.model
    def create_from_nostr_event(self, event):
        git_commit = GitObject.from_nostr_event(event)
        return self.create({
            'sha': git_commit.sha,
            'data': git_commit.data.decode('utf-8', errors='replace'),
            'message': git_commit.message,
            'author': git_commit.author,
            'timestamp': git_commit.timestamp,
        })
    @api.model
    def create_from_git_commit(self, commit):
        return self.create({
            'sha': commit.hexsha,
            'message': commit.message,
            'author': f"{commit.author.name} <{commit.author.email}>",
            'timestamp': commit.committed_datetime,
            'data': commit.tree.data_stream.read().decode('utf-8', errors='replace'),
        })
=== ./odoo_custom_addons/git_nostr_object/models/nostr_websocket_client.py ===
import websocket
import json
import logging
import time

_logger = logging.getLogger(__name__)

class NostrWebSocketClient:
    def __init__(self, relay_urls):
        self.relay_urls = relay_urls

    def connect_and_publish(self, event_data):
        responses = []
        for url in self.relay_urls:
            try:
                _logger.info(f"Attempting to connect to {url}")
                start_time = time.time()
                ws = websocket.create_connection(url, timeout=10)
                _logger.info(f"Connected to {url} in {time.time() - start_time:.2f} seconds")

                # Construct the message correctly
                message = ["EVENT", event_data]
                _logger.debug(f"Raw event message: {message}")

                ws.send(json.dumps(message))
                _logger.info(f"Sent message to {url} in {time.time() - start_time:.2f} seconds")

                _logger.info(f"Waiting for response from {url}")
                response = ws.recv()
                _logger.info(f"Received response from {url} in {time.time() - start_time:.2f} seconds: {response}")

                responses.append(json.loads(response))
                ws.close()
            except Exception as e:
                _logger.error(f"Error publishing to {url}: {str(e)}")
                responses.append(["ERROR", str(e)])
        return responses
=== ./odoo_custom_addons/git_nostr_object/models/__init__.py ===
# __init__.py
from . import git_object
from . import git_commit
from . import git_tree
from . import git_blob
from . import git_repository
from . import nostr_event
from . import admin_test
from . import git_commit_wizard
=== ./odoo_custom_addons/git_nostr_object/models/git_object.py ===
from odoo import models, fields, api

class GitObject(models.AbstractModel):
    _name = 'git.object'
    _description = 'Git Object'

    sha = fields.Char(string='SHA', required=True)
    data = fields.Text(string='Data', required=True)

    def to_nostr_event(self):
        raise NotImplementedError("This method should be implemented by subclasses")

    @api.model
    def create_from_nostr_event(self, event):
        raise NotImplementedError("This method should be implemented by subclasses")
=== ./odoo_custom_addons/git_nostr_object/models/git_nostr_object.py ===
# models/git_nostr_event.py
from odoo import models, fields, api
from utils.nostr_websocket_client import NostrWebSocketClient
from nostr.event import Event as NostrEvent
import logging
import time
import json

_logger = logging.getLogger(__name__)

class GitNostrEventObject(models.Model):
    _name = 'git_nostr.event.object'
    _description = 'Git Nostr Event Object'

    kind = fields.Integer(string='Event Kind', required=True)
    content = fields.Text(string='Content', required=True)
    tags = fields.Text(string='Tags')
    created_at = fields.Integer(string='Created At', required=True)
    signature = fields.Char(string='Signature', required=True)
    public_key = fields.Char(string='Public Key', required=True)
    published = fields.Boolean(string='Published', default=False)

    def action_publish(self):
        """
        Publish the Nostr event to the configured relays.
        """
        relay_urls = [
            'wss://relay.damus.io',
            'wss://nostr-pub.wellorder.net',
            'wss://nostr.mom',
            'wss://nostr.slothy.win',
            'wss://relay.stoner.com'
        ]

        event_data = {
            'kind': self.kind,
            'content': self.content,
            'tags': self.tags,
            'created_at': self.created_at,
            'pubkey': self.public_key,
            'sig': self.signature,
        }

        websocket_client = NostrWebSocketClient(relay_urls)

        try:
            responses = websocket_client.connect_and_publish(event_data)
            if all(response[0] == 'OK' and response[2] for response in responses):
                self.write({'published': True})
                _logger.info(f"Nostr event successfully published: {self.id}")
            else:
                self.write({'published': False})
                _logger.error(f"Error publishing Nostr event {self.id}: {responses}")
        except Exception as e:
            self.write({'published': False})
            _logger.error(f"Error publishing Nostr event {self.id}: {e}")

    def to_nostr_event(self):
        try:
            tags = json.loads(self.tags) if self.tags else []
        except json.JSONDecodeError:
            _logger.warning(f"Invalid JSON in tags for event {self.id}. Using empty tags list.")
            tags = []

        return NostrEvent(
            kind=self.kind,
            content=self.content,
            tags=tags,
            public_key=self.public_key,
            created_at=self.created_at,
            sig=self.signature
        )
=== ./odoo_custom_addons/git_nostr_object/models/git_blob.py ===
from odoo import models, fields, api
from .git_object import GitObject

class GitBlob(models.Model):
    _name = 'git.blob'
    _inherit = 'git.object'
    _description = 'Git Blob'

    def to_nostr_event(self):
        return self.env['nostr.event.object'].create({
            'kind': 3123,
            'content': self.data,
            'tags': [['sha', self.sha]],
        })

    @api.model
    def create_from_nostr_event(self, event):
        git_blob = GitObject.from_nostr_event(event)
        return self.create({
            'sha': git_blob.sha,
            'data': git_blob.data.hex(),
        })
=== ./odoo_custom_addons/git_nostr_object/models/git_tree.py ===
from odoo import models, fields, api
from .git_object import GitObject

class GitTree(models.Model):
    _name = 'git.tree'
    _inherit = 'git.object'
    _description = 'Git Tree'

    def to_nostr_event(self):
        return self.env['nostr.event.object'].create({
            'kind': 3122,
            'content': self.data,
            'tags': [['sha', self.sha]],
        })

    @api.model
    def create_from_nostr_event(self, event):
        git_tree = GitObject.from_nostr_event(event)
        return self.create({
            'sha': git_tree.sha,
            'data': git_tree.data.decode('utf-8', errors='replace'),
        })
=== ./odoo_custom_addons/git_nostr_object/models/nostr_event.py ===
# models/nostr_event.py
from odoo import models, fields, api, _
from odoo.exceptions import UserError
from ..utils.nostr_websocket_client import NostrWebSocketClient
from nostr.event import Event as NostrEvent
from nostr.key import PrivateKey
import logging
import json
import time

_logger = logging.getLogger(__name__)

class NostrEventObject(models.Model):
    _name = 'nostr.event.object'
    _description = 'Nostr Event Object'

    kind = fields.Integer(string='Event Kind', required=True)
    content = fields.Text(string='Content', required=True)
    tags = fields.Text(string='Tags')
    created_at = fields.Integer(string='Created At', required=True)
    signature = fields.Char(string='Signature')
    public_key = fields.Char(string='Public Key', required=True)
    published = fields.Boolean(string='Published', default=False)
    logs = fields.Text(string='Logs')

    def action_publish(self):
        self.ensure_one()
        if self.published:
            raise UserError(_("This event has already been published."))

        start_time = time.time()
        logs = []

        # Get the user's private key
        user = self.env.user
        private_key_nsec = user.nostr_private_key
        if not private_key_nsec:
            raise UserError(_("Nostr private key is not set for the current user."))

        try:
            private_key = PrivateKey.from_nsec(private_key_nsec)
        except Exception as e:
            raise UserError(_("Invalid Nostr private key: %s") % str(e))

        logs.append(f"Key preparation took {time.time() - start_time:.4f} seconds")

        # Create and sign the Nostr event
        event_creation_start = time.time()
        event = NostrEvent(
            kind=self.kind,
            content=self.content,
            tags=json.loads(self.tags) if self.tags else [],
            public_key=private_key.public_key.hex(),
            created_at=int(time.time())
        )
        private_key.sign_event(event)
        logs.append(f"Event creation and signing took {time.time() - event_creation_start:.4f} seconds")

        # Update the record
        self.write({
            'signature': event.signature,
            'public_key': event.public_key,
            'created_at': event.created_at
        })

        relay_urls = [
            'wss://relay.damus.io',
            'wss://nostr-pub.wellorder.net',
            'wss://nostr.mom',
            'wss://nostr.slothy.win',
            'wss://relay.stoner.com'
        ]

        event_data = json.loads(event.to_message())[1]
        websocket_client = NostrWebSocketClient(relay_urls)

        publish_start = time.time()
        try:
            responses, ws_logs = websocket_client.connect_and_publish(event_data)
            logs.extend(ws_logs)
            if any(response[0] == 'OK' for response in responses):
                self.write({'published': True})
                logs.append(f"Nostr event successfully published: {self.id}")
                self.env['bus.bus']._sendone(self.env.user.partner_id, 'simple_notification', {
                    'title': _("Nostr Event Published"),
                    'message': _("Event successfully published to Nostr network"),
                })
            else:
                error_msg = f"Error publishing Nostr event {self.id}: {responses}"
                logs.append(error_msg)
                raise UserError(_(error_msg))
        except Exception as e:
            error_msg = f"Error publishing Nostr event {self.id}: {e}"
            logs.append(error_msg)
            raise UserError(_(error_msg))
        finally:
            logs.append(f"Publishing process took {time.time() - publish_start:.4f} seconds")

        logs.append(f"Total publish action took {time.time() - start_time:.4f} seconds")
        self.write({'logs': '\n'.join(logs)})

        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _("Nostr Event"),
                'message': _("Event published successfully. Check logs for details."),
                'sticky': False,
                'type': 'success',
            }
        }
=== ./odoo_custom_addons/git_nostr_object/models/git_commit_wizard.py ===
from odoo import models, fields, api

class GitCommitWizard(models.TransientModel):
    _name = 'git.commit.wizard'
    _description = 'Git Commit Wizard'

    repository_id = fields.Many2one('git.repository', string='Repository', required=True)
    message = fields.Text(string='Commit Message', required=True)
    file_data = fields.Text(string='File Content')
    file_name = fields.Char(string='File Name')

    def action_create_commit(self):
        repo = self.repository_id
        with open(f"{repo.path}/{self.file_name}", 'w') as f:
            f.write(self.file_data)
        commit = repo.create_commit(self.message, [self.file_name])
        return {'type': 'ir.actions.act_window_close'}
=== ./odoo_custom_addons/git_nostr_object/models/admin_test.py ===
# /opt/odoo/custom_addons/git_nostr_object/models/admin_test.py
from odoo import models, api
from ..tests.test_git_nostr_object import test_git_nostr_object, test_nostr_auth

class AdminTest(models.TransientModel):
    _name = 'git_nostr_object.admin_test'
    _description = 'Admin Test for Git-Nostr Object'

    def run_tests(self):
        test_git_nostr_object()
        test_nostr_auth()
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': 'Test Results',
                'message': 'Tests completed. Check the logs for details.',
                'sticky': False,
            }
        }
=== ./odoo_custom_addons/git_nostr_object/__init__.py ===
from . import models
from . import controllers
=== ./odoo_custom_addons/git_nostr_object/utils/nostr_websocket_client.py ===
# utils/nostr_websocket_client.py
import logging
import time
import websocket
import json

_logger = logging.getLogger(__name__)

class NostrWebSocketClient:
    def __init__(self, relay_urls):
        self.relay_urls = relay_urls

    def connect_and_publish(self, event_data):
        responses = []
        logs = []
        for url in self.relay_urls:
            try:
                response, log = self._connect_and_publish_to_relay(url, event_data)
                responses.append(response)
                logs.extend(log)
            except Exception as e:
                error_message = f"Error publishing event to relay {url}: {e}"
                _logger.error(error_message)
                logs.append(error_message)
        return responses, logs

    def _connect_and_publish_to_relay(self, relay_url, event_data):
        log = []
        log.append(f"Attempting to connect to {relay_url}")
        start_time = time.time()

        ws = websocket.create_connection(relay_url)
        log.append(f"Connected to {relay_url} in {time.time() - start_time:.2f} seconds")

        event_message = json.dumps(["EVENT", event_data])
        log.append(f"Sending Nostr event to {relay_url}")
        ws.send(event_message)
        log.append(f"Sent message to {relay_url} in {time.time() - start_time:.2f} seconds")

        log.append(f"Waiting for response from {relay_url}")
        response = ws.recv()
        log.append(f"Received response from {relay_url} in {time.time() - start_time:.2f} seconds: {response}")
        ws.close()
        return json.loads(response), log
=== ./odoo_custom_addons/git_nostr_object/__manifest__.py ===
{
    'name': 'git_nostr_object',
    'version': '1.0',
    'depends': ['base', 'bus'],
    'data': [
        'security/ir.model.access.csv',
        'views/git_repository_views.xml',
        'views/git_commit_views.xml',
        'views/git_tree_views.xml',
        'views/git_blob_views.xml',
        'views/git_object_views.xml',
        'views/nostr_event_object_views.xml',
        'views/actions.xml',
        'views/menus.xml',
        'views/admin_test_views.xml',
        'views/git_commit_wizard_views.xml'
    ],
    'assets': {
        'web.assets_backend': [
            'git_nostr_object/static/src/js/git_nostr_notifications.js',
        ],
    },
    'installable': True,
    'application': True,
    'auto_install': False,
}
=== ./odoo_custom_addons/git_nostr_object/static/src/js/git_nostr_notifications.js ===
// static/src/js/git_nostr_notifications.js
odoo.define('git_nostr_object.notifications', function (require) {
    "use strict";

    var core = require('web.core');
    var session = require('web.session');
    var BusService = require('bus.BusService');

    BusService.include({
        _onNotification: function (notifications) {
            var self = this;
            _.each(notifications, function (notification) {
                if (notification[0][1] === 'simple_notification') {
                    self.displayNotification({
                        title: notification[1].title,
                        message: notification[1].message,
                        type: 'info',
                    });
                }
            });
            this._super.apply(this, arguments);
        },
    });
});
=== ./odoo_custom_addons/git_nostr_object/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_git_commit,access_git_commit,model_git_commit,base.group_user,1,1,1,1
access_git_tree,access_git_tree,model_git_tree,base.group_user,1,1,1,1
access_git_blob,access_git_blob,model_git_blob,base.group_user,1,1,1,1
access_git_repository,access_git_repository,model_git_repository,base.group_user,1,1,1,1
access_nostr_event_object,access_nostr_event_object,model_nostr_event_object,base.group_user,1,1,1,1
=== ./odoo_custom_addons/git_nostr_object/tests/__init__.py ===
# /opt/odoo/custom_addons/git_nostr_object/tests/__init__.py
from . import test_git_nostr_object
=== ./odoo_custom_addons/git_nostr_object/tests/test_git_nostr_object.py ===
from odoo.tests.common import TransactionCase
from datetime import datetime
import random
import string
import logging
import os

_logger = logging.getLogger(__name__)

def random_string(length=10):
    return ''.join(random.choices(string.ascii_letters + string.digits, k=length))

def generate_sha():
    """Generate a random 40-character SHA hash"""
    return ''.join(random.choices('0123456789abcdef', k=40))

def get_current_timestamp():
    """Return the current timestamp"""
    return int(datetime.now().timestamp())

def get_author(env):
    """Return the logged-in user's name as the author"""
    return env.user.name

def get_local_path():
    """Return the Odoo installation path as the local path"""
    return '/opt/odoo'

def generate_nostr_keys():
    """Generate random 64-character Nostr public and private keys for the logged-in user"""
    public_key = random_string(64)
    private_key = random_string(64)
    return public_key, private_key

def get_event_type(content):
    """Extract the event type from the first line of the content"""
    return int(content.split('\n')[0].strip('# '))

def get_event_name(content):
    """Extract the event name from the first line of the content"""
    return content.split('\n', 1)[0]

def check_method_existence(env, methods):
    """Check if the required methods exist in the corresponding models"""
    for model, method_name in methods.items():
        model_obj = env[model]
        if not hasattr(model_obj, method_name):
            return False, f"Method '{method_name}' not found in model '{model}'"
    return True, "All required methods found"

class TestGitNostrObject(TransactionCase):

    def setUp(self):
        super(TestGitNostrObject, self).setUp()
        self.GitRepository = self.env['git.repository']
        self.GitCommit = self.env['git.commit']
        self.GitTree = self.env['git.tree']
        self.GitBlob = self.env['git.blob']
        self.GitNostrEventObject = self.env['git_nostr.event.object']
        self.NostrKey = self.env['nostr.key']
        self.NostrRelay = self.env['nostr.relay']
        self.NostrProfile = self.env['nostr.profile']

        # Check if required methods exist in the corresponding models
        required_methods = {
            'git.repository': 'traverse_and_publish',
            'nostr.event.object': 'action_publish',
            'nostr.key': 'generate_key_pair',
            'nostr.key': 'sign_event'
        }
        success, message = check_method_existence(self.env, required_methods)
        if not success:
            self.fail(message)

    def test_git_nostr_object(self):
        _logger.info("Testing Git-Nostr Object module...")

        # Test Git Repository
        repo_name = f'Test Repo {random_string()}'
        repo_path = f'{get_local_path()}/custom_addons/git_nostr_object/tests/test_repo_{random_string()}'
        repo = self.GitRepository.create({
            'name': repo_name,
            'path': repo_path
        })
        _logger.info(f"Created Git Repository with ID: {repo.id}")

        # Test traverse_and_publish
        try:
            repo.traverse_and_publish()
            _logger.info("traverse_and_publish executed successfully")
        except Exception as e:
            _logger.error(f"Error in traverse_and_publish: {e}")

        # Test Git Commit
        commit_sha = generate_sha()
        commit_author = get_author(self.env)
        commit_timestamp = get_current_timestamp()
        commit_data = 'Test commit data'
        commit = self.GitCommit.create({
            'sha': commit_sha,
            'message': 'Test commit message',
            'author': commit_author,
            'timestamp': commit_timestamp,
            'data': commit_data
        })
        _logger.info(f"Created Git Commit with ID: {commit.id}")

        # Test Git Tree
        tree_sha = generate_sha()
        tree_data = 'Test tree data'
        tree = self.GitTree.create({
            'sha': tree_sha,
            'data': tree_data
        })
        _logger.info(f"Created Git Tree with ID: {tree.id}")

        # Test Git Blob
        blob_sha = generate_sha()
        blob_data = 'Test blob data'
        blob = self.GitBlob.create({
            'sha': blob_sha,
            'data': blob_data
        })
        _logger.info(f"Created Git Blob with ID: {blob.id}")

        # Test Nostr Event Object
        event_content = '# 1\nTest Nostr event content'
        event_type = get_event_type(event_content)
        event_tags = '[]'
        event_created_at = get_current_timestamp()
        event_signature = random_string(64)
        event_name = get_event_name(event_content)
        event = self.GitNostrEventObject.create({
            'kind': event_type,
            'content': event_content,
            'tags': event_tags,
            'created_at': event_created_at,
            'signature': event_signature,
            'name': event_name
        })
        _logger.info(f"Created Nostr Event Object with ID: {event.id}")

        # Test action_publish
        try:
            event.action_publish()
            _logger.info("action_publish executed successfully")
        except Exception as e:
            _logger.error(f"Error in action_publish: {e}")

    def test_nostr_auth(self):
        _logger.info("Testing Nostr Authentication module...")

        # Test Nostr Key
        public_key, private_key = generate_nostr_keys()
        key = self.NostrKey.create({
            'public_key': public_key,
            'private_key': private_key,
            'user_id': self.env.user.id
        })
        _logger.info(f"Created Nostr Key with ID: {key.id}")

        # Test Nostr Relay
        relay_url = f'wss://relay{random_string()}.com'
        relay = self.NostrRelay.create({
            'url': relay_url,
            'is_active': True
        })
        _logger.info(f"Created Nostr Relay with ID: {relay.id}")

        # Test Nostr Profile
        profile_name = f'Test Profile {random_string()}'
        profile_about = 'Test profile description'
        profile_picture = 'http://example.com/pic.jpg'
        profile = self.NostrProfile.create({
            'name': profile_name,
            'about': profile_about,
            'picture': profile_picture,
            'user_id': self.env.user.id
        })
        _logger.info(f"Created Nostr Profile with ID: {profile.id}")

        # Test generate_key_pair method
        try:
            result = self.NostrKey.generate_key_pair()
            _logger.info(f"Generated key pair: {result}")
        except Exception as e:
            _logger.error(f"Error in generate_key_pair: {e}")

        # Test sign_event method (assuming it exists)
        try:
            event_data = {
                'kind': 1,
                'content': 'Test content',
                'created_at': get_current_timestamp(),
                'tags': []
            }
            result = key.sign_event(event_data)
            _logger.info(f"Signed event: {result}")
        except Exception as e:
            _logger.error(f"Error in sign_event: {e}")

def test_git_nostr_object():
    test_case = TestGitNostrObject.create({})
    test_case.test_git_nostr_object()

def test_nostr_auth():
    test_case = TestGitNostrObject.create({})
    test_case.test_nostr_auth()

# This allows running the test from the Odoo shell
if __name__ == '__main__':
    test_git_nostr_object()
    test_nostr_auth()
=== ./odoo_custom_addons/git_nostr_object/views/git_blob_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_blob_form" model="ir.ui.view">
        <field name="name">git.blob.form</field>
        <field name="model">git.blob</field>
        <field name="arch" type="xml">
            <form>
                <group>
                    <field name="sha"/>
                    <field name="data"/>
                </group>
            </form>
        </field>
    </record>

    <record id="view_git_blob_tree" model="ir.ui.view">
        <field name="name">git.blob.tree</field>
        <field name="model">git.blob</field>
        <field name="arch" type="xml">
            <tree>
                <field name="sha"/>
            </tree>
        </field>
    </record>

    <record id="action_git_blob" model="ir.actions.act_window">
        <field name="name">Git Blobs</field>
        <field name="res_model">git.blob</field>
        <field name="view_mode">tree,form</field>
    </record>
</odoo>
=== ./odoo_custom_addons/git_nostr_object/views/menus.xml ===
<!-- views/menus.xml -->
<odoo>
    <menuitem id="menu_git_nostr_object_root" name="Git-Nostr Object">
        <menuitem id="menu_git_repository" name="Repositories" action="action_git_repository"/>
        <menuitem id="menu_git_commit" name="Commits" action="action_git_commit"/>
        <menuitem id="menu_git_tree" name="Trees" action="action_git_tree"/>
        <menuitem id="menu_git_blob" name="Blobs" action="action_git_blob"/>
        <menuitem id="menu_git_nostr_event_object" name="Nostr Event Objects" action="action_git_nostr_event_object"/>
    </menuitem>
</odoo>
=== ./odoo_custom_addons/git_nostr_object/views/git_commit_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_commit_form" model="ir.ui.view">
        <field name="name">git.commit.form</field>
        <field name="model">git.commit</field>
        <field name="arch" type="xml">
            <form>
                <group>
                    <field name="sha"/>
                    <field name="message"/>
                    <field name="author"/>
                    <field name="timestamp"/>
                    <field name="data"/>
                </group>
            </form>
        </field>
    </record>

    <record id="view_git_commit_tree" model="ir.ui.view">
        <field name="name">git.commit.tree</field>
        <field name="model">git.commit</field>
        <field name="arch" type="xml">
            <tree>
                <field name="sha"/>
                <field name="message"/>
                <field name="author"/>
                <field name="timestamp"/>
            </tree>
        </field>
    </record>

    <record id="action_git_commit" model="ir.actions.act_window">
        <field name="name">Git Commits</field>
        <field name="res_model">git.commit</field>
        <field name="view_mode">tree,form</field>
    </record>
</odoo>
=== ./odoo_custom_addons/git_nostr_object/views/git_object_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_object_form" model="ir.ui.view">
        <field name="name">git.object.form</field>
        <field name="model">git.object</field>
        <field name="arch" type="xml">
            <form>
                <group>
                    <field name="sha"/>
                    <field name="data"/>
                </group>
            </form>
        </field>
    </record>

    <record id="view_git_object_tree" model="ir.ui.view">
        <field name="name">git.object.tree</field>
        <field name="model">git.object</field>
        <field name="arch" type="xml">
            <tree>
                <field name="sha"/>
            </tree>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons/git_nostr_object/views/admin_test_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_admin_test_form" model="ir.ui.view">
        <field name="name">git_nostr_object.admin_test.form</field>
        <field name="model">git_nostr_object.admin_test</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="run_tests" string="Run Tests" type="object" class="oe_highlight"/>
                </header>
                <div>
                    <p>Click the button to run the Git-Nostr Object tests.</p>
                </div>
            </form>
        </field>
    </record>

    <record id="action_admin_test" model="ir.actions.act_window">
        <field name="name">Admin Tests</field>
        <field name="res_model">git_nostr_object.admin_test</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
    </record>

    <menuitem id="menu_admin_test" name="Admin Tests" parent="menu_git_nostr_object_root" action="action_admin_test" groups="base.group_system"/>
</odoo>
=== ./odoo_custom_addons/git_nostr_object/views/git_commit_wizard_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_commit_wizard_form" model="ir.ui.view">
        <field name="name">git.commit.wizard.form</field>
        <field name="model">git.commit.wizard</field>
        <field name="arch" type="xml">
            <form string="Create Commit">
                <group>
                    <field name="repository_id" invisible="1"/>
                    <field name="message"/>
                    <field name="file_name"/>
                    <field name="file_data"/>
                </group>
                <footer>
                    <button name="action_create_commit" string="Create Commit" type="object" class="btn-primary"/>
                    <button string="Cancel" class="btn-secondary" special="cancel"/>
                </footer>
            </form>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons/git_nostr_object/views/git_tree_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_tree_form" model="ir.ui.view">
        <field name="name">git.tree.form</field>
        <field name="model">git.tree</field>
        <field name="arch" type="xml">
            <form>
                <group>
                    <field name="sha"/>
                    <field name="data"/>
                </group>
            </form>
        </field>
    </record>

    <record id="view_git_tree_tree" model="ir.ui.view">
        <field name="name">git.tree.tree</field>
        <field name="model">git.tree</field>
        <field name="arch" type="xml">
            <tree>
                <field name="sha"/>
            </tree>
        </field>
    </record>

    <record id="action_git_tree" model="ir.actions.act_window">
        <field name="name">Git Trees</field>
        <field name="res_model">git.tree</field>
        <field name="view_mode">tree,form</field>
    </record>
</odoo>
=== ./odoo_custom_addons/git_nostr_object/views/nostr_event_object_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_nostr_event_object_form" model="ir.ui.view">
        <field name="name">nostr.event.object.form</field>
        <field name="model">nostr.event.object</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="action_publish" string="Publish Event" type="object" class="oe_highlight" attrs="{'invisible': [('published', '=', True)]}"/>
                </header>
                <sheet>
                    <group>
                        <field name="kind"/>
                        <field name="content"/>
                        <field name="tags"/>
                        <field name="created_at"/>
                        <field name="signature"/>
                        <field name="public_key"/>
                        <field name="published"/>
                    </group>
                    <notebook>
                        <page string="Logs">
                            <field name="logs" widget="text" readonly="1"/>
                        </page>
                    </notebook>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_nostr_event_object_tree" model="ir.ui.view">
        <field name="name">nostr.event.object.tree</field>
        <field name="model">nostr.event.object</field>
        <field name="arch" type="xml">
            <tree string="Nostr Event Objects">
                <field name="kind"/>
                <field name="content"/>
                <field name="tags"/>
                <field name="created_at"/>
                <field name="signature"/>
                <field name="public_key"/>
                <field name="published"/>
            </tree>
        </field>
    </record>

    <record id="action_nostr_event_object" model="ir.actions.act_window">
        <field name="name">Nostr Event Objects</field>
        <field name="res_model">nostr.event.object</field>
        <field name="view_mode">tree,form</field>
    </record>
</odoo>
=== ./odoo_custom_addons/git_nostr_object/views/git_repository_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_repository_form" model="ir.ui.view">
        <field name="name">git.repository.form</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="traverse_and_publish" string="Traverse and Publish" type="object" class="oe_highlight"/>
                </header>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="path" string="Local Path"/>
                    </group>
                    <notebook>
                        <page string="Logs">
                            <field name="logs" widget="text" readonly="1"/>
                        </page>
                    </notebook>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_git_repository_tree" model="ir.ui.view">
        <field name="name">git.repository.tree</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="path"/>
            </tree>
        </field>
    </record>

    <record id="action_git_repository" model="ir.actions.act_window">
        <field name="name">Git Repositories</field>
        <field name="res_model">git.repository</field>
        <field name="view_mode">tree,form</field>
    </record>
</odoo>
=== ./odoo_custom_addons/git_nostr_object/views/actions.xml ===
<!-- views/actions.xml -->
<odoo>
    <record id="action_git_nostr_event_object" model="ir.actions.act_window">
        <field name="name">Nostr Event Objects</field>
        <field name="res_model">nostr.event.object</field>
        <field name="view_mode">tree,form</field>
    </record>
</odoo>
=== ./odoo_custom_addons/git_nostr_object/controllers/git_controller.py ===
from odoo import http
from odoo.http import request
import logging

_logger = logging.getLogger(__name__)

class GitController(http.Controller):

    @http.route('/git_nostr_object/traverse_repo', type='json', auth='user')
    def traverse_repo(self, repo_id):
        try:
            repo = request.env['git.repository'].browse(repo_id)
            repo.traverse_and_publish()
            return {'status': 'success'}
        except Exception as e:
            _logger.exception("Error traversing repository")
            return {'status': 'error', 'message': str(e)}

    @http.route('/git_nostr_object/publish_event', type='json', auth='user')
    def publish_event(self, event_id):
        try:
            event = request.env['git_nostr.event.object'].browse(event_id)
            event.action_publish()
            return {'status': 'success'}
        except Exception as e:
            _logger.exception("Error publishing Nostr event")
            return {'status': 'error', 'message': str(e)}
=== ./odoo_custom_addons/custom_thunderbird_mail/models/custom_mail.py ===
import smtplib
from email.mime.text import MIMEText
from odoo import models, fields, api

class CustomMail(models.Model):
    _name = 'custom.mail'
    _description = 'Custom Mail Integration with Thunderbird Mail'

    @api.model
    def send_thunderbird_mail(self, recipient, subject, body):
        # Thunderbird SMTP server configuration
        smtp_server = 'test'
        smtp_port = 587
        smtp_user = 'g'
        smtp_password = 'your_thunderbird_password'  # Replace with the actual password

        # Create the email message
        msg = MIMEText(body)
        msg['Subject'] = subject
        msg['From'] = smtp_user
        msg['To'] = recipient

        # Send the email
        try:
            with smtplib.SMTP(smtp_server, smtp_port) as server:
                server.login(smtp_user, smtp_password)
                server.sendmail(smtp_user, [recipient], msg.as_string())
            return True
        except Exception as e:
            _logger.error('Failed to send email: %s', e)
            return False
=== ./odoo_custom_addons/custom_thunderbird_mail/__init__.py ===
from . import models
=== ./odoo_custom_addons/custom_thunderbird_mail/__manifest__.py ===
{
    'name': 'Custom Thunderbird Mail Integration',
    'version': '1.0',
    'category': 'Tools',
    'summary': 'Integrate Odoo with Thunderbird Mail',
    'description': 'A module to integrate Odoo with Thunderbird Mail for sending emails.',
    'depends': ['base'],
    'data': [],
    'installable': True,
    'application': True,
}
=== ./odoo_custom_addons/custom_thunderbird_mail/wizard/create_nostr_event_wizard.py ===
# wizard/create_nostr_event_wizard.py
from odoo import models, fields, api
import git
import json

class CreateNostrEventWizard(models.TransientModel):
    _name = 'create.nostr.event.wizard'
    _description = 'Create Nostr Event Wizard'

    repository_id = fields.Many2one('git.repository', string='Repository', required=True)
    event_type = fields.Selection([
        ('repo_anchor', 'Repository Anchor'),
        ('branch', 'Branch'),
        ('commit', 'Commit'),
        ('tree', 'Tree'),
        ('blob', 'Blob'),
    ], string='Event Type', required=True)
    commit_message = fields.Text(string='Commit Message')
    branch_name = fields.Char(string='Branch Name')
    file_content = fields.Text(string='File Content')
    file_name = fields.Char(string='File Name')

    def action_create_event(self):
        repo = git.Repo(self.repository_id.path)
        
        if self.event_type == 'commit':
            # Stage all changes
            repo.git.add(A=True)
            # Commit changes
            commit = repo.index.commit(self.commit_message)
            self.repository_id.last_commit = commit.hexsha
            content = json.dumps({
                'type': 'commit',
                'repository': self.repository_id.name,
                'commit_hash': commit.hexsha,
                'message': self.commit_message,
            })
        elif self.event_type == 'branch':
            repo.git.checkout('-b', self.branch_name)
            self.repository_id.branch = self.branch_name
            content = json.dumps({
                'type': 'branch',
                'repository': self.repository_id.name,
                'branch_name': self.branch_name,
            })
        elif self.event_type == 'blob':
            with open(os.path.join(self.repository_id.path, self.file_name), 'w') as f:
                f.write(self.file_content)
            repo.index.add([self.file_name])
            commit = repo.index.commit(f"Add file: {self.file_name}")
            self.repository_id.last_commit = commit.hexsha
            content = json.dumps({
                'type': 'blob',
                'repository': self.repository_id.name,
                'file_name': self.file_name,
                'commit_hash': commit.hexsha,
            })
        
        self.env['nostr.event'].create({
            'name': f"{self.event_type.capitalize()} - {self.repository_id.name}",
            'event_type': self.event_type,
            'content': content,
            'tags': json.dumps([['r', self.repository_id.remote_url]]),
        })

        return {'type': 'ir.actions.act_window_close'}
=== ./odoo_custom_addons/custom_thunderbird_mail/wizard/__init__.py ===
# wizard/__init__.py
from . import create_nostr_event_wizard
=== ./odoo_custom_addons/custom_thunderbird_mail/wizard/create_nostr_event_wizard_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_create_nostr_event_wizard_form" model="ir.ui.view">
        <field name="name">create.nostr.event.wizard.form</field>
        <field name="model">create.nostr.event.wizard</field>
        <field name="arch" type="xml">
            <form string="Create Nostr Event">
                <group>
                    <field name="repository_id"/>
                    <field name="event_type"/>
                    <field name="commit_message" attrs="{'invisible': [('event_type', '!=', 'commit')], 'required': [('event_type', '=', 'commit')]}"/>
                    <field name="branch_name" attrs="{'invisible': [('event_type', '!=', 'branch')], 'required': [('event_type', '=', 'branch')]}"/>
                    <field name="file_name" attrs="{'invisible': [('event_type', '!=', 'blob')], 'required': [('event_type', '=', 'blob')]}"/>
                    <field name="file_content" attrs="{'invisible': [('event_type', '!=', 'blob')], 'required': [('event_type', '=', 'blob')]}" widget="ace" options="{'mode': 'xml'}"/>
                </group>
                <footer>
                    <button name="action_create_event" string="Create Event" type="object" class="btn-primary"/>
                    <button string="Cancel" class="btn-secondary" special="cancel"/>
                </footer>
            </form>
        </field>
    </record>

    <record id="action_create_nostr_event_wizard" model="ir.actions.act_window">
        <field name="name">Create Nostr Event</field>
        <field name="res_model">create.nostr.event.wizard</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
    </record>
</odoo>
=== ./odoo_custom_addons/custom_thunderbird_mail/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_git_repository,access_git_repository,model_git_repository,base.group_user,1,1,1,1
access_nostr_event,access_nostr_event,model_nostr_event,base.group_user,1,1,1,1
access_create_nostr_event_wizard,access_create_nostr_event_wizard,model_create_nostr_event_wizard,base.group_user,1,1,1,0
=== ./odoo_custom_addons/custom_thunderbird_mail/views/res_users_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_users_form_inherit_git_nostr" model="ir.ui.view">
        <field name="name">res.users.form.inherit.git.nostr</field>
        <field name="model">res.users</field>
        <field name="inherit_id" ref="base.view_users_form"/>
        <field name="arch" type="xml">
            <notebook position="inside">
                <page string="Nostr Settings" name="nostr_settings">
                    <group>
                        <field name="nostr_private_key" password="True"/>
                        <field name="nostr_public_key"/>
                    </group>
                </page>
            </notebook>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons/custom_thunderbird_mail/views/res_config_settings_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="res_config_settings_view_form" model="ir.ui.view">
        <field name="name">res.config.settings.view.form.inherit.git_nostr_bridge</field>
        <field name="model">res.config.settings</field>
        <field name="inherit_id" ref="base.res_config_settings_view_form"/>
        <field name="arch" type="xml">
            <xpath expr="//div[hasclass('settings')]" position="inside">
                <div class="app_settings_block" data-string="Git-Nostr Bridge" string="Git-Nostr Bridge" data-key="git_nostr_bridge">
                    <h2>Nostr Settings</h2>
                    <div class="row mt16 o_settings_container">
                        <div class="col-12 col-lg-6 o_setting_box">
                            <div class="o_setting_left_pane"/>
                            <div class="o_setting_right_pane">
                                <span class="o_form_label">Nostr Relay URLs</span>
                                <div class="text-muted">
                                    Comma-separated list of Nostr relay URLs
                                </div>
                                <div class="content-group">
                                    <div class="mt16">
                                        <field name="git_nostr_relay_urls"/>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </xpath>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons/custom_thunderbird_mail/views/nostr_event_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_nostr_event_form" model="ir.ui.view">
        <field name="name">nostr.event.form</field>
        <field name="model">nostr.event</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="action_publish" string="Publish" type="object" class="oe_highlight" attrs="{'invisible': [('published', '=', True)]}"/>
                </header>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="event_type"/>
                        <field name="content"/>
                        <field name="tags"/>
                        <field name="published"/>
                        <field name="event_id"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_nostr_event_form_git_nostr" model="ir.ui.view">
        <field name="name">nostr.event.form.git.nostr</field>
        <field name="model">nostr.event</field>
        <field name="inherit_id" ref="integrated_ivcs.view_nostr_event_form"/>
        <field name="arch" type="xml">
            <xpath expr="//field[@name='event_type']" position="after">
                <field name="repository_id" attrs="{'invisible': [('event_type', 'not in', ['repo_anchor', 'branch', 'commit', 'tree', 'blob'])]}"/>
            </xpath>
        </field>
    </record>

    <record id="action_nostr_event" model="ir.actions.act_window">
        <field name="name">Nostr Events</field>
        <field name="res_model">nostr.event</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_nostr_event_git" name="Git Nostr Events" parent="menu_git_nostr_bridge" action="integrated_ivcs.action_nostr_event" sequence="20"/>
</odoo>
=== ./odoo_custom_addons/custom_thunderbird_mail/views/git_repository_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_repository_form" model="ir.ui.view">
        <field name="name">git.repository.form</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="action_pull" string="Pull" type="object" class="oe_highlight"/>
                    <button name="action_push" string="Push" type="object" class="oe_highlight"/>
                    <button name="action_commit" string="Commit" type="object" class="oe_highlight"/>
                </header>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="path"/>
                        <field name="remote_url"/>
                        <field name="branch"/>
                        <field name="last_commit"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="action_git_repository" model="ir.actions.act_window">
        <field name="name">Git Repositories</field>
        <field name="res_model">git.repository</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_git_nostr_bridge" name="Git-Nostr Bridge" sequence="10"/>
    <menuitem id="menu_git_repository" name="Git Repositories" parent="menu_git_nostr_bridge" action="action_git_repository" sequence="10"/>
</odoo>
=== ./odoo_custom_addons/git_nostr_bridge/models/git_repository.py ===
# models/git_repository.py
import os
import git
from odoo import models, fields, api, _
from odoo.exceptions import UserError

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Name', required=True)
    path = fields.Char(string='Local Path', required=True)
    remote_url = fields.Char(string='Remote URL')
    branch = fields.Char(string='Current Branch', default='main')
    last_commit = fields.Char(string='Last Commit', readonly=True)

    @api.model
    def create(self, vals):
        repo = super(GitRepository, self).create(vals)
        repo._initialize_repository()
        return repo

    def _initialize_repository(self):
        if not os.path.exists(self.path):
            os.makedirs(self.path)
            repo = git.Repo.init(self.path)
            if self.remote_url:
                repo.create_remote('origin', self.remote_url)
            open(os.path.join(self.path, 'README.md'), 'w').close()
            repo.index.add(['README.md'])
            repo.index.commit('Initial commit')
            self.last_commit = repo.head.commit.hexsha

    def action_pull(self):
        repo = git.Repo(self.path)
        origin = repo.remotes.origin
        origin.pull()
        self.last_commit = repo.head.commit.hexsha

    def action_push(self):
        repo = git.Repo(self.path)
        origin = repo.remotes.origin
        origin.push()

    def action_commit(self):
        return {
            'name': _('Create Commit'),
            'type': 'ir.actions.act_window',
            'res_model': 'create.nostr.event.wizard',
            'view_mode': 'form',
            'target': 'new',
            'context': {'default_repository_id': self.id, 'default_event_type': 'commit'},
        }
=== ./odoo_custom_addons/git_nostr_bridge/models/__init__.py ===
from . import git_repository
from . import nostr_event
from . import res_config_settings
=== ./odoo_custom_addons/git_nostr_bridge/models/res_users.py ===
from odoo import models, fields, api
from nostr.key import PrivateKey

class ResUsers(models.Model):
    _inherit = 'res.users'

    nostr_public_key = fields.Char(string="Nostr Public Key")
    nostr_private_key = fields.Char(string="Nostr Private Key")
    nostr_relay_url = fields.Char(string="Nostr Relay URL")

    @api.depends('nostr_private_key')
    def _compute_public_key(self):
        for user in self:
            if user.nostr_private_key:
                try:
                    private_key = PrivateKey.from_nsec(user.nostr_private_key)
                    user.nostr_public_key = private_key.public_key.hex()
                except Exception:
                    user.nostr_public_key = False
            else:
                user.nostr_public_key = False

    @api.model
    def create(self, vals):
        if 'nostr_private_key' not in vals or not vals['nostr_private_key']:
            private_key = PrivateKey()
            vals['nostr_private_key'] = private_key.bech32()
        return super(ResUsers, self).create(vals)
=== ./odoo_custom_addons/git_nostr_bridge/models/nostr_event.py ===
# File: /opt/odoo/custom_addons/git_nostr_bridge/models/nostr_event.py

import asyncio
import json
import logging
import websockets
from urllib.parse import urlparse
import time
import traceback

from odoo import models, fields, api, _
from odoo.exceptions import UserError
from nostr.event import Event as NostrLibEvent
from nostr.key import PrivateKey

_logger = logging.getLogger(__name__)

class NostrEvent(models.Model):
    _name = 'nostr.event'
    _description = 'Nostr Event'
    _inherit = 'nostr.event'

    name = fields.Char(string='Name', required=True)
    event_type = fields.Selection([
        ('repo_anchor', 'Repository Anchor'),
        ('branch', 'Branch'),
        ('commit', 'Commit'),
        ('tree', 'Tree'),
        ('blob', 'Blob'),
    ], string='Event Type', required=True)
    content = fields.Text(string='Content')
    tags = fields.Text(string='Tags')
    published = fields.Boolean(string='Published', default=False)
    event_id = fields.Char(string='Event ID', readonly=True)
    kind = fields.Integer(string='Nostr Event Kind', default=1)
    repository_id = fields.Many2one('git.repository', string='Related Repository')
    signature = fields.Char(string='Signature', readonly=True)
    public_key = fields.Char(string='Public Key', readonly=True)
    created_at = fields.Integer(string='Created At', readonly=True)

    @api.model
    def create(self, vals):
        record = super(NostrEvent, self).create(vals)
        record.generate_event_details()
        return record

    def generate_event_details(self):
        if not self.event_id or not self.signature:
            try:
                private_key = PrivateKey()
                public_key = private_key.public_key.hex()
                
                event = NostrLibEvent(
                    kind=self.kind,
                    content=self.content or '',
                    tags=json.loads(self.tags) if self.tags else [],
                    public_key=public_key,
                    created_at=int(time.time())
                )
                
                private_key.sign_event(event)
                
                self.write({
                    'event_id': event.id,
                    'signature': event.signature,
                    'public_key': public_key,
                    'created_at': event.created_at
                })
            except Exception as e:
                _logger.error(f"Error generating Nostr event details: {str(e)}")
                # Not raising UserError here to avoid disrupting the creation process

    @api.model
    def action_publish(self, event_id):
        event = self.browse(event_id)
        _logger.info(f"Starting publish action for event: {event.name}")
        start_time = time.time()

        try:
            if not self.env.user.nostr_private_key:
                raise UserError(_("Nostr private key is not set for the current user."))

            _logger.info("Generating private key")
            try:
                private_key = PrivateKey.from_nsec(self.env.user.nostr_private_key)
                _logger.info("Private key generated successfully")
            except Exception as e:
                _logger.error(f"Failed to generate private key: {str(e)}")
                _logger.error(traceback.format_exc())
                raise UserError(_("Invalid Nostr private key: %s") % str(e))

            public_key = private_key.public_key.hex()
            _logger.info(f"Public key: {public_key}")

            _logger.info("Parsing tags")
            try:
                tags = json.loads(event.tags) if event.tags else []
                _logger.info(f"Parsed tags: {tags}")
                if not isinstance(tags, list):
                    raise ValueError("Tags must be a list of lists")
                for tag in tags:
                    if not isinstance(tag, list):
                        raise ValueError("Each tag must be a list")
            except json.JSONDecodeError as e:
                _logger.error(f"JSON decode error: {str(e)}")
                _logger.error(traceback.format_exc())
                raise UserError(_("Invalid tags format. Please ensure tags are in valid JSON format."))
            except ValueError as e:
                _logger.error(f"Value error: {str(e)}")
                _logger.error(traceback.format_exc())
                raise UserError(_("Invalid tags format: %s") % str(e))

            _logger.info("Creating Nostr event")
            nostr_event = NostrLibEvent(
                kind=1,  # Assuming TEXT_NOTE, adjust if needed
                content=str(event.content),
                tags=tags,
                public_key=public_key  # Ensure public_key is provided
            )
            private_key.sign_event(nostr_event)
            _logger.info(f"Event created: {nostr_event.to_message()}")

            _logger.info("Fetching relay URLs")
            relay_urls = self.env['ir.config_parameter'].sudo().get_param('git_nostr_bridge.relay_urls', '').split(',')
            relay_urls = [url.strip() for url in relay_urls if url.strip()][:5]  # Limit to 5 relays
            _logger.info(f"Relay URLs: {relay_urls}")

            if not relay_urls:
                raise UserError(_("No Nostr relay URLs configured. Please set them in the settings."))

            _logger.info("Validating relay URLs")
            for url in relay_urls:
                parsed = urlparse(url)
                if parsed.scheme not in ('ws', 'wss'):
                    _logger.error(f"Invalid relay URL: {url}")
                    raise UserError(_("Invalid relay URL: %s. Must start with ws:// or wss://") % url)

            async def publish_to_relay(relay_url, nostr_event, retries=3):
                for attempt in range(retries):
                    try:
                        _logger.info(f"Attempting to connect to {relay_url} (attempt {attempt + 1})")
                        connection_start = time.time()
                        async with websockets.connect(relay_url, timeout=30) as websocket:
                            connection_end = time.time()
                            _logger.info(f"Connected to {relay_url} in {connection_end - connection_start:.2f} seconds")
                            
                            message = nostr_event.to_message()
                            _logger.debug(f"Raw event message: {message}")
                            
                            _logger.info(f"Sending Nostr event to {relay_url}: {message}")
                            
                            send_start = time.time()
                            await websocket.send(message)
                            send_end = time.time()
                            _logger.info(f"Sent message to {relay_url} in {send_end - send_start:.2f} seconds")
                            
                            _logger.info(f"Waiting for response from {relay_url}")
                            response_start = time.time()
                            response = await asyncio.wait_for(websocket.recv(), timeout=10.0)
                            response_end = time.time()
                            _logger.info(f"Received response from {relay_url} in {response_end - response_start:.2f} seconds: {response}")
                            
                            try:
                                return json.loads(response)
                            except json.JSONDecodeError as e:
                                _logger.error(f"Failed to parse response from {relay_url}: {str(e)}")
                                return f"Invalid response from {relay_url}: {response}"
                    except (websockets.exceptions.WebSocketException, asyncio.TimeoutError) as e:
                        _logger.error(f"Error publishing to {relay_url} (attempt {attempt + 1}): {str(e)}")
                        _logger.error(traceback.format_exc())
                        await asyncio.sleep(5 * (attempt + 1))  # Increased delay between attempts
                return f"Failed to publish to {relay_url} after {retries} attempts"

            async def publish_with_timeout():
                tasks = [publish_to_relay(url, nostr_event) for url in relay_urls]
                return await asyncio.gather(*tasks, return_exceptions=True)

            async def run_publication():
                _logger.info("Starting publication process")
                try:
                    results = await asyncio.wait_for(publish_with_timeout(), timeout=120)  # Increased overall timeout
                    _logger.info(f"Publication results: {results}")
                    return results
                except asyncio.TimeoutError:
                    _logger.error("Publication process timed out after 120 seconds")
                    raise UserError(_("Publishing timed out after 120 seconds"))

            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            try:
                results = loop.run_until_complete(run_publication())
            finally:
                loop.close()

            success = any(isinstance(result, list) and result[0] == "OK" for result in results)
            if success:
                event.write({
                    'published': True,
                    'event_id': nostr_event.id
                })
                _logger.info(f"Successfully published Nostr event: {nostr_event.id}")
                
                # Verify event publication
                self.verify_event_publication(nostr_event.id, relay_urls)
                
                end_time = time.time()
                _logger.info(f"Total publish action time: {end_time - start_time:.2f} seconds")
                
                return {
                    'type': 'ir.actions.client',
                    'tag': 'display_notification',
                    'params': {
                        'message': _("Nostr event successfully published to at least one relay."),
                        'type': 'success',
                        'sticky': False,
                    }
                }
            else:
                error_messages = [str(result) for result in results if isinstance(result, str)]
                _logger.error(f"Failed to publish Nostr event: {'; '.join(error_messages)}")
                raise UserError(_("Failed to publish Nostr event: %s") % "; ".join(error_messages))

        except Exception as e:
            _logger.error(f"Unexpected error in action_publish: {str(e)}")
            _logger.error(traceback.format_exc())
            raise UserError(_("An unexpected error occurred: %s") % str(e))

    @api.model
    def verify_event_publication(self, event_id, relay_urls, max_attempts=5, delay=2):
        _logger.info(f"Starting verification for event: {event_id}")
        for attempt in range(max_attempts):
            _logger.info(f"Verification attempt {attempt + 1}")
            for url in relay_urls:
                try:
                    loop = asyncio.new_event_loop()
                    asyncio.set_event_loop(loop)
                    result = loop.run_until_complete(self.query_event(url, event_id))
                    if result:
                        _logger.info(f"Event {event_id} found on relay {url}")
                        return True
                except Exception as e:
                    _logger.error(f"Error querying event from {url}: {str(e)}")
                    _logger.error(traceback.format_exc())
                finally:
                    loop.close()
            _logger.info(f"Waiting {delay} seconds before next attempt")
            time.sleep(delay)
        _logger.warning(f"Event {event_id} not found on any relay after {max_attempts} attempts")
        return False

    async def query_event(self, relay_url, event_id):
        _logger.info(f"Querying event {event_id} from {relay_url}")
        start_time = time.time()
        try:
            async with websockets.connect(relay_url, timeout=10) as websocket:
                request = json.dumps(["REQ", "query", {"ids": [event_id]}])
                _logger.info(f"Sending query to {relay_url}: {request}")
                await websocket.send(request)
                response = await asyncio.wait_for(websocket.recv(), timeout=5.0)
                _logger.info(f"Response from {relay_url}: {response}")
                end_time = time.time()
                _logger.info(f"Query to {relay_url} took {end_time - start_time:.2f} seconds")
                return json.loads(response)
        except Exception as e:
            _logger.error(f"Error querying {relay_url}: {str(e)}")
            _logger.error(traceback.format_exc())
            end_time = time.time()
            _logger.info(f"Failed query to {relay_url} took {end_time - start_time:.2f} seconds")
            return None
=== ./odoo_custom_addons/git_nostr_bridge/models/res_config_settings.py ===
import requests
import json
from odoo import fields, models, api
import logging

_logger = logging.getLogger(__name__)

class ResConfigSettings(models.TransientModel):
    _inherit = 'res.config.settings'

    git_nostr_relay_urls = fields.Char(
        string="Nostr Relay URLs", 
        config_parameter='git_nostr_bridge.relay_urls',
        default=lambda self: self._default_nostr_relays()
    )

    def _default_nostr_relays(self):
        return self._get_top_nostr_relays()

    @api.model
    def _get_top_nostr_relays(self, limit=108):
        url = "https://api.nostr.watch/v1/online"
        try:
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
            }
            response = requests.get(url, headers=headers, timeout=10)
            response.raise_for_status()
            _logger.info(f"Response status code: {response.status_code}")
            
            data = response.json()
            _logger.info(f"API response (first 108 items): {data[:108]}")
            
            relays = data[:108]
            _logger.info(f"Number of relay links found: {len(relays)}")
            _logger.info(f"Extracted relays (first 5): {relays[:5]}")
            
            relay_urls = ",".join(relays)
            return relay_urls
        except requests.RequestException as e:
            _logger.error(f"Error fetching Nostr relays: {e}")
            return "wss://nostr-relay.app,wss://nos.lol,wss://relay.snort.social,wss://relay.nostr.net"

    nostr_relay_urls = fields.Char(
        string="Nostr Relay URLs", 
        config_parameter='nostr_bridge.relay_urls',
        default=_default_nostr_relays
    )

    @api.model
    def get_values(self):
        res = super(ResConfigSettings, self).get_values()
        ICPSudo = self.env['ir.config_parameter'].sudo()
        
        relay_urls = ICPSudo.get_param('git_nostr_bridge.relay_urls')
        if not relay_urls:
            relay_urls = self._default_nostr_relays()
            ICPSudo.set_param('git_nostr_bridge.relay_urls', relay_urls)
            _logger.info(f"Set new relay URLs: {relay_urls[:100]}...")
        else:
            _logger.info(f"Using existing relay URLs: {relay_urls[:100]}...")
        
        res.update(git_nostr_relay_urls=relay_urls)
        return res

    def set_values(self):
        super(ResConfigSettings, self).set_values()
        ICPSudo = self.env['ir.config_parameter'].sudo()
        if self.git_nostr_relay_urls:
            ICPSudo.set_param('git_nostr_bridge.relay_urls', self.git_nostr_relay_urls)
            _logger.info(f"Updated relay URLs: {self.git_nostr_relay_urls[:100]}...")
        else:
            default_urls = self._default_nostr_relays()
            ICPSudo.set_param('git_nostr_bridge.relay_urls', default_urls)
            _logger.info(f"Set default relay URLs: {default_urls[:100]}...")
=== ./odoo_custom_addons/git_nostr_bridge/models/git_repository ===
# models/git_repository.py
import os
import git
from odoo import models, fields, api, _
from odoo.exceptions import UserError

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Name', required=True)
    path = fields.Char(string='Local Path', required=True)
    remote_url = fields.Char(string='Remote URL')
    branch = fields.Char(string='Current Branch', default='main')
    last_commit = fields.Char(string='Last Commit', readonly=True)

    @api.model
    def create(self, vals):
        repo = super(GitRepository, self).create(vals)
        repo._initialize_repository()
        return repo

    def _initialize_repository(self):
        if not os.path.exists(self.path):
            os.makedirs(self.path)
            repo = git.Repo.init(self.path)
            if self.remote_url:
                repo.create_remote('origin', self.remote_url)
            open(os.path.join(self.path, 'README.md'), 'w').close()
            repo.index.add(['README.md'])
            repo.index.commit('Initial commit')
            self.last_commit = repo.head.commit.hexsha

    def action_pull(self):
        repo = git.Repo(self.path)
        origin = repo.remotes.origin
        origin.pull()
        self.last_commit = repo.head.commit.hexsha

    def action_push(self):
        repo = git.Repo(self.path)
        origin = repo.remotes.origin
        origin.push()

    def action_commit(self):
        return {
            'name': _('Create Commit'),
            'type': 'ir.actions.act_window',
            'res_model': 'create.nostr.event.wizard',
            'view_mode': 'form',
            'target': 'new',
            'context': {'default_repository_id': self.id, 'default_event_type': 'commit'},
        }
=== ./odoo_custom_addons/git_nostr_bridge/__init__.py ===
from . import models
from . import wizard
=== ./odoo_custom_addons/git_nostr_bridge/__manifest__.py ===
{
    'name': 'Git-Nostr Bridge',
    'version': '1.0',
    'category': 'Tools',
    'summary': 'Integrates Git repositories with Nostr network',
    'author': 'Your Name',
    'website': 'https://www.example.com',
    'depends': ['base', 'mail', 'nostr_auth', 'nostr_bridge', 'integrated_ivcs'],
    'data': [
        'security/ir.model.access.csv',
        'views/git_repository_views.xml',
        'views/nostr_event_views.xml',
        'views/res_config_settings_views.xml',
        'views/res_users_views.xml',
        'wizard/create_nostr_event_wizard_views.xml',
    ],
    'installable': True,
    'application': True,
    'auto_install': False,
    'external_dependencies': {
        'python': ['git', 'nostr', 'websockets'],
    },
}
=== ./odoo_custom_addons/git_nostr_bridge/wizard/create_nostr_event_wizard.py ===
# wizard/create_nostr_event_wizard.py
from odoo import models, fields, api
import git
import json

class CreateNostrEventWizard(models.TransientModel):
    _name = 'create.nostr.event.wizard'
    _description = 'Create Nostr Event Wizard'

    repository_id = fields.Many2one('git.repository', string='Repository', required=True)
    event_type = fields.Selection([
        ('repo_anchor', 'Repository Anchor'),
        ('branch', 'Branch'),
        ('commit', 'Commit'),
        ('tree', 'Tree'),
        ('blob', 'Blob'),
    ], string='Event Type', required=True)
    commit_message = fields.Text(string='Commit Message')
    branch_name = fields.Char(string='Branch Name')
    file_content = fields.Text(string='File Content')
    file_name = fields.Char(string='File Name')

    def action_create_event(self):
        repo = git.Repo(self.repository_id.path)
        
        if self.event_type == 'commit':
            # Stage all changes
            repo.git.add(A=True)
            # Commit changes
            commit = repo.index.commit(self.commit_message)
            self.repository_id.last_commit = commit.hexsha
            content = json.dumps({
                'type': 'commit',
                'repository': self.repository_id.name,
                'commit_hash': commit.hexsha,
                'message': self.commit_message,
            })
        elif self.event_type == 'branch':
            repo.git.checkout('-b', self.branch_name)
            self.repository_id.branch = self.branch_name
            content = json.dumps({
                'type': 'branch',
                'repository': self.repository_id.name,
                'branch_name': self.branch_name,
            })
        elif self.event_type == 'blob':
            with open(os.path.join(self.repository_id.path, self.file_name), 'w') as f:
                f.write(self.file_content)
            repo.index.add([self.file_name])
            commit = repo.index.commit(f"Add file: {self.file_name}")
            self.repository_id.last_commit = commit.hexsha
            content = json.dumps({
                'type': 'blob',
                'repository': self.repository_id.name,
                'file_name': self.file_name,
                'commit_hash': commit.hexsha,
            })
        
        self.env['nostr.event'].create({
            'name': f"{self.event_type.capitalize()} - {self.repository_id.name}",
            'event_type': self.event_type,
            'content': content,
            'tags': json.dumps([['r', self.repository_id.remote_url]]),
        })

        return {'type': 'ir.actions.act_window_close'}
=== ./odoo_custom_addons/git_nostr_bridge/wizard/__init__.py ===
# wizard/__init__.py
from . import create_nostr_event_wizard
=== ./odoo_custom_addons/git_nostr_bridge/wizard/create_nostr_event_wizard_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_create_nostr_event_wizard_form" model="ir.ui.view">
        <field name="name">create.nostr.event.wizard.form</field>
        <field name="model">create.nostr.event.wizard</field>
        <field name="arch" type="xml">
            <form string="Create Nostr Event">
                <group>
                    <field name="repository_id"/>
                    <field name="event_type"/>
                    <field name="commit_message" attrs="{'invisible': [('event_type', '!=', 'commit')], 'required': [('event_type', '=', 'commit')]}"/>
                    <field name="branch_name" attrs="{'invisible': [('event_type', '!=', 'branch')], 'required': [('event_type', '=', 'branch')]}"/>
                    <field name="file_name" attrs="{'invisible': [('event_type', '!=', 'blob')], 'required': [('event_type', '=', 'blob')]}"/>
                    <field name="file_content" attrs="{'invisible': [('event_type', '!=', 'blob')], 'required': [('event_type', '=', 'blob')]}" widget="ace" options="{'mode': 'xml'}"/>
                </group>
                <footer>
                    <button name="action_create_event" string="Create Event" type="object" class="btn-primary"/>
                    <button string="Cancel" class="btn-secondary" special="cancel"/>
                </footer>
            </form>
        </field>
    </record>

    <record id="action_create_nostr_event_wizard" model="ir.actions.act_window">
        <field name="name">Create Nostr Event</field>
        <field name="res_model">create.nostr.event.wizard</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
    </record>
</odoo>
=== ./odoo_custom_addons/git_nostr_bridge/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_git_repository,access_git_repository,model_git_repository,base.group_user,1,1,1,1
access_nostr_event,access_nostr_event,model_nostr_event,base.group_user,1,1,1,1
access_create_nostr_event_wizard,access_create_nostr_event_wizard,model_create_nostr_event_wizard,base.group_user,1,1,1,0
=== ./odoo_custom_addons/git_nostr_bridge/views/res_users_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_users_form_inherit_git_nostr" model="ir.ui.view">
        <field name="name">res.users.form.inherit.git.nostr</field>
        <field name="model">res.users</field>
        <field name="inherit_id" ref="base.view_users_form"/>
        <field name="arch" type="xml">
            <notebook position="inside">
                <page string="Nostr Settings" name="nostr_settings">
                    <group>
                        <field name="nostr_private_key" password="True"/>
                        <field name="nostr_public_key"/>
                    </group>
                </page>
            </notebook>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons/git_nostr_bridge/views/res_config_settings_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="res_config_settings_view_form" model="ir.ui.view">
        <field name="name">res.config.settings.view.form.inherit.git_nostr_bridge</field>
        <field name="model">res.config.settings</field>
        <field name="inherit_id" ref="base.res_config_settings_view_form"/>
        <field name="arch" type="xml">
            <xpath expr="//div[hasclass('settings')]" position="inside">
                <div class="app_settings_block" data-string="Git-Nostr Bridge" string="Git-Nostr Bridge" data-key="git_nostr_bridge">
                    <h2>Nostr Settings</h2>
                    <div class="row mt16 o_settings_container">
                        <div class="col-12 col-lg-6 o_setting_box">
                            <div class="o_setting_left_pane"/>
                            <div class="o_setting_right_pane">
                                <span class="o_form_label">Nostr Relay URLs</span>
                                <div class="text-muted">
                                    Comma-separated list of Nostr relay URLs
                                </div>
                                <div class="content-group">
                                    <div class="mt16">
                                        <field name="git_nostr_relay_urls"/>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </xpath>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons/git_nostr_bridge/views/nostr_event_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_nostr_event_form" model="ir.ui.view">
        <field name="name">nostr.event.form</field>
        <field name="model">nostr.event</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="action_publish" string="Publish" type="object" class="oe_highlight" attrs="{'invisible': [('published', '=', True)]}"/>
                </header>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="event_type"/>
                        <field name="content"/>
                        <field name="tags"/>
                        <field name="published"/>
                        <field name="event_id"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_nostr_event_form_git_nostr" model="ir.ui.view">
        <field name="name">nostr.event.form.git.nostr</field>
        <field name="model">nostr.event</field>
        <field name="inherit_id" ref="integrated_ivcs.view_nostr_event_form"/>
        <field name="arch" type="xml">
            <xpath expr="//field[@name='event_type']" position="after">
                <field name="repository_id" attrs="{'invisible': [('event_type', 'not in', ['repo_anchor', 'branch', 'commit', 'tree', 'blob'])]}"/>
            </xpath>
        </field>
    </record>

    <record id="action_nostr_event" model="ir.actions.act_window">
        <field name="name">Nostr Events</field>
        <field name="res_model">nostr.event</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_nostr_event_git" name="Git Nostr Events" parent="menu_git_nostr_bridge" action="integrated_ivcs.action_nostr_event" sequence="20"/>
</odoo>
=== ./odoo_custom_addons/git_nostr_bridge/views/git_repository_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_repository_form" model="ir.ui.view">
        <field name="name">git.repository.form</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="action_pull" string="Pull" type="object" class="oe_highlight"/>
                    <button name="action_push" string="Push" type="object" class="oe_highlight"/>
                    <button name="action_commit" string="Commit" type="object" class="oe_highlight"/>
                </header>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="path"/>
                        <field name="remote_url"/>
                        <field name="branch"/>
                        <field name="last_commit"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="action_git_repository" model="ir.actions.act_window">
        <field name="name">Git Repositories</field>
        <field name="res_model">git.repository</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_git_nostr_bridge" name="Git-Nostr Bridge" sequence="10"/>
    <menuitem id="menu_git_repository" name="Git Repositories" parent="menu_git_nostr_bridge" action="action_git_repository" sequence="10"/>
</odoo>
=== ./odoo_custom_addons/custom_auth/models/res_users.py ===
from odoo import models, api
from odoo.exceptions import AccessDenied
import requests

class ResUsers(models.Model):
    _inherit = 'res.users'

    @classmethod
    def _login(cls, db, login, password):
        if not cls.validate_external_auth(login, password):
            raise AccessDenied()
        return super(ResUsers, cls)._login(db, login, password)

    @classmethod
    def validate_external_auth(cls, login, token):
        # Replace with your actual localhost API endpoint
        validation_url = 'http://localhost/validate_admin'
        response = requests.post(validation_url, json={'login': login, 'token': token})
        return response.status_code == 200 and response.json().get('is_admin', False)
=== ./odoo_custom_addons/custom_auth/__manifest__.py ===
{
    'name': 'Custom External Authentication',
    'version': '1.0',
    'category': 'Hidden',
    'summary': 'Custom authentication for external admin access',
    'depends': ['base'],
    'data': [],
    'installable': True,
}
=== ./odoo_custom_addons/opinion_reputation_nostr/models/__init__.py ===
from . import opinion_reputation
from . import nostr_event
=== ./odoo_custom_addons/opinion_reputation_nostr/models/nostr_event.py ===
from odoo import models, api, _
from odoo.exceptions import UserError
import json
import logging

_logger = logging.getLogger(__name__)

class NostrEvent(models.AbstractModel):
    _name = 'opinion.nostr.event'
    _description = 'Nostr Event for Opinion Reputation'

    @api.model
    def create_prediction_event(self, prediction):
        content = json.dumps({
            'question_id': prediction.question_id.id,
            'question_text': prediction.question_id.text,
            'answer': prediction.answer,
            'confidence': prediction.confidence
        })
        
        try:
            nostr_event = self.env['nostr.event']
            event = nostr_event.create_event(
                kind=1,  # You might want to use a custom event kind for predictions
                content=content,
                tags=[['p', prediction.user_id.nostr_public_key]],
                private_key=prediction.user_id.nostr_private_key
            )
            
            nostr_event.publish_event(event)
            _logger.info(f"Nostr event created and published for prediction {prediction.id}")
        except AttributeError:
            _logger.warning("Nostr bridge not available. Prediction event not published to Nostr.")
        except Exception as e:
            _logger.error(f"Error creating Nostr event: {str(e)}")
            raise UserError(_("Failed to create Nostr event: %s") % str(e))
=== ./odoo_custom_addons/opinion_reputation_nostr/models/opinion_reputation.py ===
from odoo import models, fields, api
from odoo.exceptions import UserError
import enum
import logging

_logger = logging.getLogger(__name__)

class AnswerChoice(enum.Enum):
    AGREE = "I Agree"
    DO_NOT_DISAGREE = "I do not disagree"
    DO_NOT_AGREE = "I do not agree"
    DISAGREE = "I Disagree"

class User(models.Model):
    _inherit = 'res.users'

    reputation = fields.Float(default=0)

class Question(models.Model):
    _name = 'opinion.question'
    _description = 'Opinion Question'

    text = fields.Text(required=True)
    explanation = fields.Text()
    created_by = fields.Many2one('res.users', string='Created By')
    created_at = fields.Datetime(default=fields.Datetime.now)
    is_settled = fields.Boolean(default=False)
    last_revisited = fields.Datetime()

class Prediction(models.Model):
    _name = 'opinion.prediction'
    _description = 'Opinion Prediction'

    user_id = fields.Many2one('res.users', required=True)
    question_id = fields.Many2one('opinion.question', required=True)
    answer = fields.Selection([
        ('AGREE', 'I Agree'),
        ('DO_NOT_DISAGREE', 'I do not disagree'),
        ('DO_NOT_AGREE', 'I do not agree'),
        ('DISAGREE', 'I Disagree')
    ], required=True)
    confidence = fields.Float(required=True)
    timestamp = fields.Datetime(default=fields.Datetime.now)
    is_correct = fields.Boolean()

    @api.model
    def create(self, vals):
        prediction = super(Prediction, self).create(vals)
        try:
            self.env['opinion.nostr.event'].create_prediction_event(prediction)
        except Exception as e:
            _logger.error(f"Failed to create Nostr event for prediction {prediction.id}: {str(e)}")
        self.update_reputation(prediction.user_id.id)
        return prediction

    def update_reputation(self, user_id):
        user = self.env['res.users'].browse(user_id)
        predictions = self.search([('user_id', '=', user_id)])
        correct_predictions = predictions.filtered(lambda p: p.is_correct)
        if predictions:
            user.reputation = (len(correct_predictions) / len(predictions)) * 100

class OpinionReputationSystem(models.AbstractModel):
    _name = 'opinion.reputation.system'
    _description = 'Opinion Reputation System'

    @api.model
    def revisit_question(self, question_id):
        question = self.env['opinion.question'].browse(question_id)
        if (fields.Datetime.now() - question.created_at).days >= 4*365:
            predictions = self.env['opinion.prediction'].search([('question_id', '=', question_id)])
            total_votes = len(predictions)
            if total_votes > 0:
                agreement_ratio = len(predictions.filtered(lambda p: p.answer in ['AGREE', 'DO_NOT_DISAGREE'])) / total_votes
                question.write({
                    'is_settled': agreement_ratio >= 0.8333334,
                    'last_revisited': fields.Datetime.now()
                })

    @api.model
    def explain_answer_choices(self):
        return """
        Answer choices explanation:
        1. I Agree: You fully support and believe in the statement.
        2. I do not disagree: You somewhat agree or have no strong objection to the statement.
        3. I do not agree: You somewhat disagree or have some reservations about the statement.
        4. I Disagree: You fully oppose or do not believe in the statement.
        """
=== ./odoo_custom_addons/opinion_reputation_nostr/__init__.py ===
from . import models
=== ./odoo_custom_addons/opinion_reputation_nostr/__manifest__.py ===
{
    'name': 'Opinion Reputation with Nostr',
    'version': '1.0',
    'category': 'Tools',
    'summary': 'Opinion Reputation System with optional Nostr integration',
    'depends': ['base'],
    'data': [
        'security/ir.model.access.csv',
        'views/opinion_reputation_views.xml',
        'data/default_questions.xml',
    ],
    'installable': True,
    'application': True,
}
=== ./odoo_custom_addons/opinion_reputation_nostr/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_opinion_question,access_opinion_question,model_opinion_question,base.group_user,1,1,1,1
access_opinion_prediction,access_opinion_prediction,model_opinion_prediction,base.group_user,1,1,1,1
access_opinion_nostr_event,access_opinion_nostr_event,model_opinion_nostr_event,base.group_user,1,1,1,1
=== ./odoo_custom_addons/opinion_reputation_nostr/data/default_questions.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <!-- Add your default questions here -->
        <record id="question_1" model="opinion.question">
            <field name="text">Do life's challenges sometimes lead to self-doubt?</field>
            <field name="explanation">Sometimes when things get tough, we might wonder if we're good enough or if we can handle it.</field>
        </record>
        <!-- Add more questions as needed -->
    </data>
</odoo>
=== ./odoo_custom_addons/opinion_reputation_nostr/views/opinion_reputation_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_question_form" model="ir.ui.view">
        <field name="name">opinion.question.form</field>
        <field name="model">opinion.question</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="text"/>
                        <field name="explanation"/>
                        <field name="created_by"/>
                        <field name="created_at"/>
                        <field name="is_settled"/>
                        <field name="last_revisited"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_prediction_form" model="ir.ui.view">
        <field name="name">opinion.prediction.form</field>
        <field name="model">opinion.prediction</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="user_id"/>
                        <field name="question_id"/>
                        <field name="answer"/>
                        <field name="confidence"/>
                        <field name="timestamp"/>
                        <field name="is_correct"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="action_questions" model="ir.actions.act_window">
        <field name="name">Questions</field>
        <field name="res_model">opinion.question</field>
        <field name="view_mode">tree,form</field>
    </record>

    <record id="action_predictions" model="ir.actions.act_window">
        <field name="name">Predictions</field>
        <field name="res_model">opinion.prediction</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_opinion_reputation" name="Opinion Reputation"/>
    <menuitem id="menu_questions" parent="menu_opinion_reputation" action="action_questions"/>
    <menuitem id="menu_predictions" parent="menu_opinion_reputation" action="action_predictions"/>
</odoo>
=== ./odoo_custom_addons/integrated_ivcs/models/git_repository.py ===
from odoo import models, fields, api
import git
import os

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Repository Name', required=True)
    path = fields.Char(string='Repository Path', required=True)
    
    @api.model
    def create(self, vals):
        repo = super(GitRepository, self).create(vals)
        if not os.path.exists(repo.path):
            os.makedirs(repo.path)
            git.Repo.init(repo.path)
        return repo

    def commit_changes(self, message):
        repo = git.Repo(self.path)
        repo.git.add(A=True)
        commit = repo.index.commit(message)
        
        self.env['nostr.event'].create_git_event(self.path, commit.hexsha)
        
        return commit.hexsha
=== ./odoo_custom_addons/integrated_ivcs/models/__init__.py ===
from . import ivcs_item
from . import ivcs_version
from . import ivcs_commit
from . import git_repository
from . import nostr_event
from . import branch_manager
from . import res_config_settings
from . import nostr_event
=== ./odoo_custom_addons/integrated_ivcs/models/nostr_events.py ===
# integrated_ivcs/models/nostr_events.py

import json
from odoo import models, fields, api
from odoo.exceptions import ValidationError
from datetime import datetime

class NostrEvent(models.AbstractModel):
    _name = 'nostr.event'
    _description = 'Base Nostr Event'

    id = fields.Char(string='Event ID', required=True, readonly=True)
    pubkey = fields.Char(string='Public Key', required=True)
    created_at = fields.Integer(string='Created At', required=True)
    kind = fields.Integer(string='Kind', required=True)
    tags = fields.Text(string='Tags')
    content = fields.Text(string='Content')
    sig = fields.Char(string='Signature', required=True)

    @api.model
    def create(self, vals):
        if 'created_at' not in vals:
            vals['created_at'] = int(datetime.now().timestamp())
        return super(NostrEvent, self).create(vals)

    def to_json(self):
        return json.dumps({
            "id": self.id,
            "pubkey": self.pubkey,
            "created_at": self.created_at,
            "kind": self.kind,
            "tags": json.loads(self.tags) if self.tags else [],
            "content": self.content,
            "sig": self.sig
        })

    @classmethod
    def from_json(cls, json_str):
        data = json.loads(json_str)
        return cls.create({
            "id": data["id"],
            "pubkey": data["pubkey"],
            "created_at": data["created_at"],
            "kind": data["kind"],
            "tags": json.dumps(data["tags"]),
            "content": data["content"],
            "sig": data["sig"]
        })

    @api.constrains('kind')
    def _check_kind(self):
        for record in self:
            if record.kind not in [31228, 31227, 3121, 3122, 3123]:
                raise ValidationError("Invalid event kind")

class NostrRepositoryAnchor(models.Model):
    _name = 'nostr.event.repository.anchor'
    _description = 'Nostr Repository Anchor Event'
    _inherit = 'nostr.event'

    kind = fields.Integer(default=31228, readonly=True)
    repo_name = fields.Char(string='Repository Name', required=True)
    description = fields.Text(string='Description')
    maintainers = fields.Many2many('res.users', string='Maintainers')

    @api.constrains('content')
    def _check_content(self):
        for record in self:
            try:
                content = json.loads(record.content)
                if 'action' not in content or content['action'] != 'create_repository':
                    raise ValidationError("Invalid content for Repository Anchor event")
            except json.JSONDecodeError:
                raise ValidationError("Invalid JSON in content field")

    def to_json(self):
        json_data = super(NostrRepositoryAnchor, self).to_json()
        data = json.loads(json_data)
        data['content'] = json.dumps({
            "action": "create_repository",
            "repo_name": self.repo_name,
            "description": self.description,
            "maintainers": self.maintainers.mapped('nostr_public_key')
        })
        return json.dumps(data)

    @classmethod
    def from_json(cls, json_str):
        data = json.loads(json_str)
        content = json.loads(data['content'])
        maintainer_ids = cls.env['res.users'].search([('nostr_public_key', 'in', content['maintainers'])]).ids
        return cls.create({
            "id": data["id"],
            "pubkey": data["pubkey"],
            "created_at": data["created_at"],
            "kind": data["kind"],
            "tags": json.dumps(data["tags"]),
            "content": data["content"],
            "sig": data["sig"],
            "repo_name": content["repo_name"],
            "description": content["description"],
            "maintainers": [(6, 0, maintainer_ids)]
        })

class NostrBranchEvent(models.Model):
    _name = 'nostr.event.branch'
    _description = 'Nostr Branch Event'
    _inherit = 'nostr.event'

    kind = fields.Integer(default=31227, readonly=True)
    branch_name = fields.Char(string='Branch Name', required=True)
    action = fields.Selection([('create', 'Create'), ('update', 'Update'), ('delete', 'Delete')], string='Action', required=True)

    @api.constrains('content')
    def _check_content(self):
        for record in self:
            try:
                content = json.loads(record.content)
                if 'action' not in content or content['action'] not in ['create_branch', 'update_branch', 'delete_branch']:
                    raise ValidationError("Invalid content for Branch event")
            except json.JSONDecodeError:
                raise ValidationError("Invalid JSON in content field")

    def to_json(self):
        json_data = super(NostrBranchEvent, self).to_json()
        data = json.loads(json_data)
        data['content'] = json.dumps({
            "action": f"{self.action}_branch",
            "branch_name": self.branch_name
        })
        return json.dumps(data)

    @classmethod
    def from_json(cls, json_str):
        data = json.loads(json_str)
        content = json.loads(data['content'])
        return cls.create({
            "id": data["id"],
            "pubkey": data["pubkey"],
            "created_at": data["created_at"],
            "kind": data["kind"],
            "tags": json.dumps(data["tags"]),
            "content": data["content"],
            "sig": data["sig"],
            "branch_name": content["branch_name"],
            "action": content["action"].replace("_branch", "")
        })

class NostrCommitEvent(models.Model):
    _name = 'nostr.event.commit'
    _description = 'Nostr Commit Event'
    _inherit = 'nostr.event'

    kind = fields.Integer(default=3121, readonly=True)
    commit_hash = fields.Char(string='Commit Hash', required=True)
    message = fields.Text(string='Commit Message', required=True)
    author = fields.Char(string='Author', required=True)
    timestamp = fields.Datetime(string='Timestamp', required=True)

    @api.constrains('content')
    def _check_content(self):
        for record in self:
            try:
                content = json.loads(record.content)
                required_fields = ['hash', 'message', 'author', 'date']
                if not all(field in content for field in required_fields):
                    raise ValidationError("Missing required fields in Commit event content")
            except json.JSONDecodeError:
                raise ValidationError("Invalid JSON in content field")

    def to_json(self):
        json_data = super(NostrCommitEvent, self).to_json()
        data = json.loads(json_data)
        data['content'] = json.dumps({
            "hash": self.commit_hash,
            "message": self.message,
            "author": self.author,
            "date": self.timestamp.isoformat()
        })
        return json.dumps(data)

    @classmethod
    def from_json(cls, json_str):
        data = json.loads(json_str)
        content = json.loads(data['content'])
        return cls.create({
            "id": data["id"],
            "pubkey": data["pubkey"],
            "created_at": data["created_at"],
            "kind": data["kind"],
            "tags": json.dumps(data["tags"]),
            "content": data["content"],
            "sig": data["sig"],
            "commit_hash": content["hash"],
            "message": content["message"],
            "author": content["author"],
            "timestamp": datetime.fromisoformat(content["date"])
        })

class NostrTreeEvent(models.Model):
    _name = 'nostr.event.tree'
    _description = 'Nostr Tree Event'
    _inherit = 'nostr.event'

    kind = fields.Integer(default=3122, readonly=True)
    tree_hash = fields.Char(string='Tree Hash', required=True)
    items = fields.Text(string='Tree Items', required=True)

    @api.constrains('content')
    def _check_content(self):
        for record in self:
            try:
                content = json.loads(record.content)
                if 'hash' not in content or 'items' not in content:
                    raise ValidationError("Missing required fields in Tree event content")
            except json.JSONDecodeError:
                raise ValidationError("Invalid JSON in content field")

    def to_json(self):
        json_data = super(NostrTreeEvent, self).to_json()
        data = json.loads(json_data)
        data['content'] = json.dumps({
            "hash": self.tree_hash,
            "items": json.loads(self.items)
        })
        return json.dumps(data)

    @classmethod
    def from_json(cls, json_str):
        data = json.loads(json_str)
        content = json.loads(data['content'])
        return cls.create({
            "id": data["id"],
            "pubkey": data["pubkey"],
            "created_at": data["created_at"],
            "kind": data["kind"],
            "tags": json.dumps(data["tags"]),
            "content": data["content"],
            "sig": data["sig"],
            "tree_hash": content["hash"],
            "items": json.dumps(content["items"])
        })

class NostrBlobEvent(models.Model):
    _name = 'nostr.event.blob'
    _description = 'Nostr Blob Event'
    _inherit = 'nostr.event'

    kind = fields.Integer(default=3123, readonly=True)
    blob_hash = fields.Char(string='Blob Hash', required=True)
    size = fields.Integer(string='Blob Size', required=True)
    data = fields.Text(string='Blob Data', required=True)

    @api.constrains('content')
    def _check_content(self):
        for record in self:
            try:
                content = json.loads(record.content)
                if 'hash' not in content or 'size' not in content or 'data' not in content:
                    raise ValidationError("Missing required fields in Blob event content")
            except json.JSONDecodeError:
                raise ValidationError("Invalid JSON in content field")

    def to_json(self):
        json_data = super(NostrBlobEvent, self).to_json()
        data = json.loads(json_data)
        data['content'] = json.dumps({
            "hash": self.blob_hash,
            "size": self.size,
            "data": self.data
        })
        return json.dumps(data)

    @classmethod
    def from_json(cls, json_str):
        data = json.loads(json_str)
        content = json.loads(data['content'])
        return cls.create({
            "id": data["id"],
            "pubkey": data["pubkey"],
            "created_at": data["created_at"],
            "kind": data["kind"],
            "tags": json.dumps(data["tags"]),
            "content": data["content"],
            "sig": data["sig"],
            "blob_hash": content["hash"],
            "size": content["size"],
            "data": content["data"]
        })
=== ./odoo_custom_addons/integrated_ivcs/models/ivcs_version.py ===
from odoo import models, fields, api

class IVCSVersion(models.Model):
    _name = 'ivcs.version'
    _description = 'IVCS Version'

    name = fields.Char(string='Version Name', required=True)
    description = fields.Text(string='Description')
    item_id = fields.Many2one('ivcs.item', string='IVCS Item', required=True, ondelete='cascade')
    commit_id = fields.Many2one('ivcs.commit', string='Associated Commit')
    create_date = fields.Datetime(string='Created On', readonly=True, default=fields.Datetime.now)

    @api.model
    def create(self, vals):
        version = super(IVCSVersion, self).create(vals)
        if not version.item_id.current_version_id:
            version.item_id.current_version_id = version.id
        return version

    def name_get(self):
        result = []
        for version in self:
            name = f"{version.item_id.name} - {version.name}"
            result.append((version.id, name))
        return result
=== ./odoo_custom_addons/integrated_ivcs/models/nostr_event.py ===
from odoo import models, fields, api, _
from odoo.exceptions import UserError
from nostr.event import Event
from nostr.key import PrivateKey
import json
import logging
import time
import git

_logger = logging.getLogger(__name__)

class NostrEvent(models.Model):
    _name = 'nostr.event'
    _description = 'Nostr Event'

    event_id = fields.Char(string='Event ID', required=True)
    kind = fields.Integer(string='Event Kind', required=True)
    content = fields.Text(string='Content', required=True)
    tags = fields.Text(string='Tags')
    public_key = fields.Char(string='Public Key')
    created_at = fields.Integer(string='Created At', required=True)
    signature = fields.Char(string='Signature', required=True)
    published = fields.Boolean(string='Published', default=False)
    name = fields.Char(string='Name')
    event_type = fields.Selection([
        ('repo_anchor', 'Repository Anchor'),
        ('branch', 'Branch'),
        ('commit', 'Commit'),
        ('tree', 'Tree'),
        ('blob', 'Blob'),
    ], string='Event Type')

    def create_and_publish(self, event):
        event_model = self._get_event_model(event.kind)
        if event_model:
            nostr_event = event_model.from_json(event.to_json())
            nostr_event.publish_event()
            return nostr_event
        else:
            return super(NostrEvent, self).create_and_publish(event)

    def _get_event_model(self, kind):
        if kind == 31228:
            return self.env['nostr.event.repository.anchor']
        elif kind == 31227:
            return self.env['nostr.event.branch']
        elif kind == 3121:
            return self.env['nostr.event.commit']
        elif kind == 3122:
            return self.env['nostr.event.tree']
        elif kind == 3123:
            return self.env['nostr.event.blob']
        else:
            return None

    def publish_event(self):
        self.ensure_one()
        relay_urls = self.env['ir.config_parameter'].sudo().get_param('integrated_ivcs.relay_urls', '').split(',')
        
        event_data = {
            'id': self.event_id,
            'kind': self.kind,
            'created_at': self.created_at,
            'tags': json.loads(self.tags),
            'content': self.content,
            'pubkey': self.public_key,
            'sig': self.signature,
        }

        for url in relay_urls:
            try:
                # Here you would typically use a Nostr client library to publish the event
                # For simplicity, we'll just log the action
                _logger.info(f"Publishing event {self.event_id} to relay: {url}")
                # Example: nostr_client.publish_event(url, event_data)
                self.published = True
            except Exception as e:
                _logger.error(f"Failed to publish event to {url}: {str(e)}")

    @api.model
    def create_git_event(self, repo_path, commit_hash):
        repo = git.Repo(repo_path)
        commit = repo.commit(commit_hash)
        
        commit_event = self.env['nostr.event.commit'].create({
            'id': commit_hash,  # Using commit hash as event ID
            'pubkey': self.env.user.nostr_public_key,
            'sig': 'placeholder',  # This should be properly signed
            'commit_hash': commit_hash,
            'message': commit.message,
            'author': f"{commit.author.name} <{commit.author.email}>",
            'timestamp': commit.committed_datetime.isoformat(),
            'content': json.dumps({
                'hash': commit_hash,
                'message': commit.message,
                'author': f"{commit.author.name} <{commit.author.email}>",
                'date': commit.committed_datetime.isoformat(),
            })
        })
        
        return commit_event

    @api.model
    def create_tree_event(self, repo_path, tree_hash):
        repo = git.Repo(repo_path)
        tree = repo.tree(tree_hash)
        
        content = json.dumps({
            "action": "tree",
            "hash": tree_hash,
            "items": [{"mode": item.mode, "type": item.type, "hash": item.hexsha, "path": item.path} for item in tree.traverse()],
        })
        
        event = Event(
            kind=3122,
            content=content,
            tags=[
                ["r", repo_path],
                ["h", tree_hash],
            ],
            public_key=self.env.user.nostr_public_key,
        )
        
        private_key = PrivateKey(bytes.fromhex(self.env.user.nostr_private_key))
        private_key.sign_event(event)
        
        return self.create_and_publish(event)

    @api.model
    def create_blob_event(self, repo_path, blob_hash):
        repo = git.Repo(repo_path)
        blob = repo.blob(blob_hash)
        
        content = json.dumps({
            "action": "blob",
            "hash": blob_hash,
            "size": blob.size,
            "data": blob.data_stream.read().decode('utf-8', errors='replace'),
        })
        
        event = Event(
            kind=3123,
            content=content,
            tags=[
                ["r", repo_path],
                ["h", blob_hash],
            ],
            public_key=self.env.user.nostr_public_key,
        )
        
        private_key = PrivateKey(bytes.fromhex(self.env.user.nostr_private_key))
        private_key.sign_event(event)
        
        return self.create_and_publish(event)

    @api.model
    def reconstruct_git_objects(self, repo_path):
        repo = git.Repo(repo_path)
        events = self.search([('tags', 'ilike', repo_path)])
        
        for event in events:
            content = json.loads(event.content)
            if event.kind == 3121:  # Commit
                self._reconstruct_commit(repo, content)
            elif event.kind == 3122:  # Tree
                self._reconstruct_tree(repo, content)
            elif event.kind == 3123:  # Blob
                self._reconstruct_blob(repo, content)

    def _reconstruct_commit(self, repo, content):
        commit_hash = content['hash']
        if commit_hash not in repo.objects:
            repo.create_commit(
                tree=repo.tree(content['tree_hash']),
                message=content['message'],
                author=git.Actor(content['author'], content['email']),
                committer=git.Actor(content['author'], content['email']),
                parent_commits=[repo.commit(p) for p in content['parent_hashes']],
                commit_timestamp=int(content['date']),
                ref=f'refs/heads/{content["branch"]}' if 'branch' in content else None
            )

    def _reconstruct_tree(self, repo, content):
        tree_hash = content['hash']
        if tree_hash not in repo.objects:
            tree_items = []
            for item in content['items']:
                if item['type'] == 'blob':
                    tree_items.append((item['mode'], 'blob', item['hash'], item['path']))
                elif item['type'] == 'tree':
                    tree_items.append((item['mode'], 'tree', item['hash'], item['path']))
            repo.create_tree(tree_items)

    def _reconstruct_blob(self, repo, content):
        blob_hash = content['hash']
        if blob_hash not in repo.objects:
            repo.create_blob(content['data'].encode('utf-8'))

    def sync_git_nostr(self, repo_path):
        repo = git.Repo(repo_path)
        for obj in repo.objects:
            if isinstance(obj, git.Commit):
                self.create_git_event(repo_path, obj.hexsha)
            elif isinstance(obj, git.Tree):
                self.create_tree_event(repo_path, obj.hexsha)
            elif isinstance(obj, git.Blob):
                self.create_blob_event(repo_path, obj.hexsha)

        self.reconstruct_git_objects(repo_path)
=== ./odoo_custom_addons/integrated_ivcs/models/res_config_settings.py ===
from odoo import fields, models

class ResConfigSettings(models.TransientModel):
    _inherit = 'res.config.settings'

    integrated_ivcs_relay_urls = fields.Char(string="Nostr Relay URLs", config_parameter='integrated_ivcs.relay_urls')
=== ./odoo_custom_addons/integrated_ivcs/models/ivcs_commit.py ===
from odoo import models, fields, api
import json
from nostr.event import Event
from nostr.key import PrivateKey
import logging

_logger = logging.getLogger(__name__)

class IVCSCommit(models.Model):
    _name = 'ivcs.commit'
    _description = 'IVCS Commit'

    hash = fields.Char(string='Commit Hash', required=True)
    message = fields.Text(string='Commit Message', required=True)
    author = fields.Char(string='Author', required=True, default=lambda self: self.env.user.name)
    date = fields.Datetime(string='Commit Date', required=True, default=fields.Datetime.now)
    item_id = fields.Many2one('ivcs.item', string='IVCS Item', required=True, ondelete='cascade')
    version_id = fields.Many2one('ivcs.version', string='Associated Version')

    @api.model
    def create(self, vals):
        commit = super(IVCSCommit, self).create(vals)
        try:
            commit._create_nostr_commit_event()
        except Exception as e:
            _logger.error(f"Failed to create Nostr commit event: {str(e)}")
        return commit

    def _create_nostr_commit_event(self):
        if not self.item_id.nostr_private_key:
            _logger.warning(f"No Nostr private key set for IVCS Item {self.item_id.name}")
            return

        try:
            private_key = PrivateKey.from_nsec(self.item_id.nostr_private_key)
        except Exception as e:
            _logger.error(f"Invalid Nostr private key for IVCS Item {self.item_id.name}: {str(e)}")
            return

        event = Event(
            kind=3121,
            content=json.dumps({
                "hash": self.hash,
                "message": self.message,
                "author": self.author,
                "date": self.date.isoformat(),
            }),
            tags=[['r', self.item_id.repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)
        
        try:
            self.env['nostr.event'].create_and_publish(event)
            _logger.info(f"Nostr commit event created and published for commit {self.hash}")
        except Exception as e:
            _logger.error(f"Failed to create and publish Nostr event for commit {self.hash}: {str(e)}")
=== ./odoo_custom_addons/integrated_ivcs/models/ivcs_item.py ===
from odoo import models, fields, api, _
from odoo.exceptions import UserError
import git
import json
from nostr.event import Event
from nostr.key import PrivateKey
import os
import logging

_logger = logging.getLogger(__name__)

class IVCSItem(models.Model):
    _name = 'ivcs.item'
    _description = 'IVCS Item'

    name = fields.Char(string='Name', required=True)
    description = fields.Text('Description')
    current_version_id = fields.Many2one('ivcs.version', string='Current Version', compute='_compute_current_version', store=True)
    version_ids = fields.One2many('ivcs.version', 'item_id', string='Versions')
    repo_path = fields.Char('Repository Path', compute='_compute_repo_path', store=True)
    current_branch = fields.Char('Current Branch', default='main')
    commit_ids = fields.One2many('ivcs.commit', 'item_id', string='Commits')
    nostr_private_key = fields.Char(string="Nostr Private Key")
    branch_manager_id = fields.Many2one('ivcs.branch.manager', string='Branch Manager')

    @api.depends('name')
    def _compute_repo_path(self):
        for item in self:
            item.repo_path = f"/opt/ivcs_repos/item_{item.id}"

    @api.depends('version_ids')
    def _compute_current_version(self):
        for item in self:
            if item.version_ids:
                item.current_version_id = item.version_ids.sorted(lambda v: v.create_date, reverse=True)[0]
            else:
                item.current_version_id = False

    @api.model
    def create(self, vals):
        if 'nostr_private_key' in vals and vals['nostr_private_key']:
            try:
                # Validate and format the private key
                private_key = PrivateKey.from_nsec(vals['nostr_private_key'])
                vals['nostr_private_key'] = private_key.hex()  # Store the private key as a hex string
            except Exception as e:
                raise UserError(_("Invalid Nostr private key: %s") % str(e))
        return super(IVCSItem, self).create(vals)

    def write(self, vals):
        if 'nostr_private_key' in vals and vals['nostr_private_key']:
            try:
                # Validate and format the private key
                private_key = PrivateKey.from_nsec(vals['nostr_private_key'])
                vals['nostr_private_key'] = private_key.hex()  # Store the private key as a hex string
            except Exception as e:
                raise UserError(_("Invalid Nostr private key: %s") % str(e))
        return super(IVCSItem, self).write(vals)

    def _initialize_repository(self):
        self.ensure_one()
        if not os.path.exists(self.repo_path):
            os.makedirs(self.repo_path)
            repo = git.Repo.init(self.repo_path)
            readme_path = os.path.join(self.repo_path, 'README.md')
            with open(readme_path, 'w') as f:
                f.write(f"# {self.name}\n\n{self.description}")
            repo.index.add(['README.md'])
            commit = repo.index.commit("Initial commit")
            self._create_initial_version(commit.hexsha)
            self._create_nostr_repo_event()

    def _create_initial_version(self, commit_hash):
        version = self.env['ivcs.version'].create({
            'name': 'v1.0',
            'description': 'Initial version',
            'item_id': self.id,
        })
        self.env['ivcs.commit'].create({
            'hash': commit_hash,
            'message': "Initial commit",
            'item_id': self.id,
            'version_id': version.id,
        })

    def _create_nostr_repo_event(self):
        if not self.nostr_private_key:
            raise UserError(_("Nostr private key is not set for this item."))
    
        private_key = PrivateKey(bytes.fromhex(self.nostr_private_key))
        event = Event(
            kind=31228,
            content=json.dumps({
                "action": "create_repository",
                "repo_name": self.name,
                "description": self.description
            }),
            tags=[['r', self.repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)
        
        self.env['nostr.event'].create_and_publish(event)

    def create_branch(self, branch_name):
        self.ensure_one()
        repo = git.Repo(self.repo_path)
        if not self.branch_manager_id:
            self.branch_manager_id = self.env['ivcs.branch.manager'].create({
                'name': f"Branch Manager for {self.name}",
                'item_id': self.id,
            })
        if branch_name not in repo.heads:
            repo.create_head(branch_name)
            self.current_branch = branch_name
            self._create_nostr_branch_event(branch_name)
            if self.branch_manager_id:
                self.branch_manager_id.create_branch(branch_name)
            return self._return_success('Branch Created', f'Branch {branch_name} has been created.')
        else:
            return self._return_warning('Branch Exists', f'Branch {branch_name} already exists.')

    def _create_nostr_branch_event(self, branch_name):
        if not self.nostr_private_key:
            raise UserError(_("Nostr private key is not set for this item."))
        
        private_key = PrivateKey(bytes.fromhex(self.nostr_private_key))
        event = Event(
            kind=31227,
            content=json.dumps({
                "action": "create_branch",
                "branch_name": branch_name,
                "repo_name": self.name
            }),
            tags=[['r', self.repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)
        
        self.env['nostr.event'].create_and_publish(event)

    def _return_success(self, title, message):
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _(title),
                'message': _(message),
                'type': 'success',
            }
        }

    def _return_warning(self, title, message):
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _(title),
                'message': _(message),
                'type': 'warning',
            }
        }

    def delete_branch(self, branch_name):
        self.ensure_one()
        if self.branch_manager_id.delete_branch(branch_name):
            return self._return_success('Branch Deleted', f'Branch {branch_name} has been deleted.')
        else:
            return self._return_warning('Branch Not Found', f'Branch {branch_name} does not exist.')

    def merge_branches(self, source_branch, target_branch):
        self.ensure_one()
        if self.branch_manager_id.merge_branches(source_branch, target_branch):
            return self._return_success('Branches Merged', f'Branch {source_branch} has been merged into {target_branch}.')
        else:
            return self._return_warning('Merge Failed', f'Failed to merge {source_branch} into {target_branch}.')

    def reconstruct_branches(self):
        self.ensure_one()
        branches = self.branch_manager_id.reconstruct_branches_from_events()
        return self._return_success('Branches Reconstructed', f'Reconstructed {len(branches)} branches from Nostr events.')

    # Add other methods as needed (e.g., commit, push, pull, etc.)
=== ./odoo_custom_addons/integrated_ivcs/models/branch_manager.py ===
from odoo import models, fields, api
from git import Repo, GitCommandError
import json
from nostr.event import Event
from nostr.key import PrivateKey
import logging

_logger = logging.getLogger(__name__)

class BranchManager(models.Model):
    _name = 'ivcs.branch.manager'
    _description = 'IVCS Branch Manager'

    name = fields.Char(string='Name', required=True)
    item_id = fields.Many2one('ivcs.item', string='IVCS Item', required=True)

    def create_branch(self, branch_name):
        self.ensure_one()
        repo = Repo(self.item_id.repo_path)
        if branch_name not in repo.heads:
            repo.create_head(branch_name)
            self._create_branch_event(branch_name, 'create')
            return True
        return False

    def delete_branch(self, branch_name):
        self.ensure_one()
        repo = Repo(self.item_id.repo_path)
        if branch_name in repo.heads:
            repo.delete_head(branch_name, force=True)
            self._create_branch_event(branch_name, 'delete')
            return True
        return False

    def update_branch(self, branch_name, new_commit):
        self.ensure_one()
        repo = Repo(self.item_id.repo_path)
        if branch_name in repo.heads:
            branch = repo.heads[branch_name]
            branch.set_commit(new_commit)
            self._create_branch_event(branch_name, 'update', new_commit)
            return True
        return False

    def merge_branches(self, source_branch, target_branch):
        self.ensure_one()
        repo = Repo(self.item_id.repo_path)
        if source_branch in repo.heads and target_branch in repo.heads:
            try:
                repo.git.checkout(target_branch)
                repo.git.merge(source_branch)
                self._create_branch_event(target_branch, 'merge', source_branch)
                return True
            except GitCommandError as e:
                _logger.error(f"Merge conflict: {str(e)}")
                repo.git.merge('--abort')
                return False
        return False

    def _create_branch_event(self, branch_name, action, additional_info=None):
        if not self.item_id.nostr_private_key:
            _logger.warning(f"No Nostr private key for item {self.item_id.name}")
            return

        private_key = PrivateKey(bytes.fromhex(self.item_id.nostr_private_key))
        content = {
            "action": action,
            "branch_name": branch_name,
            "repo_name": self.item_id.name
        }
        if additional_info:
            content["additional_info"] = additional_info

        event = Event(
            kind=31227,
            content=json.dumps(content),
            tags=[['r', self.item_id.repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)
        
        self.env['nostr.event'].create_and_publish(event)

    def list_branches(self):
        self.ensure_one()
        repo = Repo(self.item_id.repo_path)
        return [head.name for head in repo.heads]

    def reconstruct_branches_from_events(self):
        self.ensure_one()
        events = self.env['nostr.event'].search([
            ('kind', '=', 31227),
            ('tags', 'ilike', self.item_id.repo_path)
        ], order='created_at asc')

        branches = {}
        for event in events:
            content = json.loads(event.content)
            action = content.get('action')
            branch_name = content.get('branch_name')

            if action == 'create':
                branches[branch_name] = {'created_at': event.created_at}
            elif action == 'delete':
                branches.pop(branch_name, None)
            elif action == 'update':
                if branch_name in branches:
                    branches[branch_name]['last_updated'] = event.created_at
            elif action == 'merge':
                if branch_name in branches:
                    branches[branch_name]['last_merged'] = event.created_at
                    branches[branch_name]['merged_from'] = content.get('additional_info')

        return branches
=== ./odoo_custom_addons/integrated_ivcs/__init__.py ===
from . import models
from . import wizards
=== ./odoo_custom_addons/integrated_ivcs/wizards/create_commit_wizard_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_create_commit_wizard_form" model="ir.ui.view">
        <field name="name">create.commit.wizard.form</field>
        <field name="model">create.commit.wizard</field>
        <field name="arch" type="xml">
            <form string="Create Commit">
                <group>
                    <field name="item_id"/>
                    <field name="message"/>
                </group>
                <footer>
                    <button name="action_create_commit" string="Create Commit" type="object" class="btn-primary"/>
                    <button string="Cancel" class="btn-secondary" special="cancel"/>
                </footer>
            </form>
        </field>
    </record>

    <record id="action_create_commit_wizard" model="ir.actions.act_window">
        <field name="name">Create Commit</field>
        <field name="res_model">create.commit.wizard</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
    </record>
</odoo>
=== ./odoo_custom_addons/integrated_ivcs/wizards/__init__.py ===
from . import create_branch_wizard
from . import create_commit_wizard
=== ./odoo_custom_addons/integrated_ivcs/wizards/create_commit_wizard.py ===
from odoo import models, fields, api

class CreateCommitWizard(models.TransientModel):
    _name = 'create.commit.wizard'
    _description = 'Create Commit Wizard'

    item_id = fields.Many2one('ivcs.item', string='IVCS Item', required=True)
    message = fields.Text(string='Commit Message', required=True)

    def action_create_commit(self):
        self.ensure_one()
        repo = self.env['git.repository'].search([('path', '=', self.item_id.repo_path)])
        commit_hash = repo.commit_changes(self.message)
        self.env['ivcs.commit'].create({
            'hash': commit_hash,
            'message': self.message,
            'author': self.env.user.name,
            'date': fields.Datetime.now(),
            'item_id': self.item_id.id,
        })
        return {'type': 'ir.actions.act_window_close'}
=== ./odoo_custom_addons/integrated_ivcs/wizards/create_branch_wizard.py ===
from odoo import models, fields, api

class CreateBranchWizard(models.TransientModel):
    _name = 'create.branch.wizard'
    _description = 'Create Branch Wizard'

    item_id = fields.Many2one('ivcs.item', string='IVCS Item', required=True)
    branch_name = fields.Char(string='Branch Name', required=True)

    def action_create_branch(self):
        self.ensure_one()
        return self.item_id.create_branch(self.branch_name)
=== ./odoo_custom_addons/integrated_ivcs/wizards/create_branch_wizard_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_create_branch_wizard_form" model="ir.ui.view">
        <field name="name">create.branch.wizard.form</field>
        <field name="model">create.branch.wizard</field>
        <field name="arch" type="xml">
            <form string="Create Branch">
                <group>
                    <field name="item_id"/>
                    <field name="branch_name"/>
                </group>
                <footer>
                    <button name="action_create_branch" string="Create Branch" type="object" class="btn-primary"/>
                    <button string="Cancel" class="btn-secondary" special="cancel"/>
                </footer>
            </form>
        </field>
    </record>

    <record id="action_create_branch_wizard" model="ir.actions.act_window">
        <field name="name">Create Branch</field>
        <field name="res_model">create.branch.wizard</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
    </record>
</odoo>
=== ./odoo_custom_addons/integrated_ivcs/cli.py ===
import argparse
import os
import git
from nostr.event import Event
from nostr.key import PrivateKey
import json
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class GitNostrCLI:
    def __init__(self, repo_path):
        self.repo_path = repo_path
        self.repo = git.Repo(repo_path)
        self.private_key = PrivateKey()

    def create_branch(self, branch_name):
        logger.info(f"Creating branch: {branch_name}")
        self.repo.create_head(branch_name)
        self._create_branch_event(branch_name, 'create')
        logger.info(f"Branch {branch_name} created successfully")

    def delete_branch(self, branch_name):
        logger.info(f"Deleting branch: {branch_name}")
        self.repo.delete_head(branch_name, force=True)
        self._create_branch_event(branch_name, 'delete')
        logger.info(f"Branch {branch_name} deleted successfully")

    def merge_branches(self, source_branch, target_branch):
        logger.info(f"Merging {source_branch} into {target_branch}")
        self.repo.git.checkout(target_branch)
        try:
            self.repo.git.merge(source_branch)
            self._create_branch_event(target_branch, 'merge', source_branch)
            logger.info(f"Merged {source_branch} into {target_branch} successfully")
        except git.GitCommandError as e:
            logger.error(f"Merge conflict: {str(e)}")
            self.repo.git.merge('--abort')
            logger.info("Merge aborted due to conflicts")

    def commit_changes(self, message):
        logger.info(f"Committing changes with message: {message}")
        self.repo.git.add(A=True)
        commit = self.repo.index.commit(message)
        self._create_commit_event(commit)
        logger.info(f"Changes committed successfully. Commit hash: {commit.hexsha}")

    def _create_branch_event(self, branch_name, action, additional_info=None):
        logger.info(f"Creating Nostr event for branch action: {action}")
        content = {
            "action": action,
            "branch_name": branch_name,
            "repo_name": os.path.basename(self.repo_path)
        }
        if additional_info:
            content["additional_info"] = additional_info

        event = Event(
            kind=31227,
            content=json.dumps(content),
            tags=[['r', self.repo_path]],
            public_key=self.private_key.public_key.hex()
        )
        self.private_key.sign_event(event)
        logger.info(f"Nostr event created: {event.id}")
        # Here you would typically publish the event to Nostr relays

    def _create_commit_event(self, commit):
        logger.info(f"Creating Nostr event for commit: {commit.hexsha}")
        content = json.dumps({
            "action": "commit",
            "message": commit.message,
            "author": commit.author.name,
            "email": commit.author.email,
            "date": commit.authored_datetime.isoformat(),
            "hash": commit.hexsha,
            "parent_hashes": [c.hexsha for c in commit.parents],
            "tree_hash": commit.tree.hexsha,
        })
        
        event = Event(
            kind=3121,
            content=content,
            tags=[
                ["r", self.repo_path],
                ["h", commit.hexsha],
            ],
            public_key=self.private_key.public_key.hex()
        )
        self.private_key.sign_event(event)
        logger.info(f"Nostr event created: {event.id}")
        # Here you would typically publish the event to Nostr relays

def main():
    parser = argparse.ArgumentParser(description="Git-Nostr CLI")
    parser.add_argument('repo_path', help="Path to the Git repository")
    parser.add_argument('action', choices=['create-branch', 'delete-branch', 'merge-branches', 'commit'])
    parser.add_argument('--branch-name', help="Name of the branch (for create-branch and delete-branch)")
    parser.add_argument('--source-branch', help="Source branch for merge")
    parser.add_argument('--target-branch', help="Target branch for merge")
    parser.add_argument('--commit-message', help="Commit message")

    args = parser.parse_args()

    cli = GitNostrCLI(args.repo_path)

    if args.action == 'create-branch':
        cli.create_branch(args.branch_name)
    elif args.action == 'delete-branch':
        cli.delete_branch(args.branch_name)
    elif args.action == 'merge-branches':
        cli.merge_branches(args.source_branch, args.target_branch)
    elif args.action == 'commit':
        cli.commit_changes(args.commit_message)

if __name__ == "__main__":
    main()
=== ./odoo_custom_addons/integrated_ivcs/__manifest__.py ===
{
    'name': 'Integrated IVCS',
    'version': '1.0',
    'category': 'Development',
    'summary': 'Integrated Version Control System with Git and Nostr',
    'author': 'Your Name',
    'website': 'https://www.example.com',
    'depends': ['base', 'mail'],
    'data': [
        'security/ir.model.access.csv',
        'views/ivcs_item_views.xml',
        'views/ivcs_version_views.xml',
        'views/ivcs_commit_views.xml',
        'views/git_repository_views.xml',
        'views/nostr_event_views.xml',
        'views/res_config_settings_views.xml',
        'wizards/create_branch_wizard_views.xml',
        'wizards/create_commit_wizard_views.xml',
    ],
    'demo': [],
    'external_dependencies': {
        'python': ['git', 'nostr'],
    },
    'installable': True,
    'application': True,
    'auto_install': False,
    'post_init_hook': 'post_init_hook',
    'uninstall_hook': 'uninstall_hook',
}
=== ./odoo_custom_addons/integrated_ivcs/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_ivcs_item_user,ivcs.item user,model_ivcs_item,base.group_user,1,1,1,1
access_ivcs_version_user,ivcs.version user,model_ivcs_version,base.group_user,1,1,1,1
access_ivcs_commit_user,ivcs.commit user,model_ivcs_commit,base.group_user,1,1,1,1
access_git_repository_user,git.repository user,model_git_repository,base.group_user,1,1,1,1
access_nostr_event_user,nostr.event user,model_nostr_event,base.group_user,1,1,1,1
access_ivcs_branch_manager_user,ivcs.branch.manager user,model_ivcs_branch_manager,base.group_user,1,1,1,1
access_create_branch_wizard_user,create.branch.wizard user,model_create_branch_wizard,base.group_user,1,1,1,0
access_create_commit_wizard_user,create.commit.wizard user,model_create_commit_wizard,base.group_user,1,1,1,0
access_nostr_event_branch_user,nostr.event.branch user,model_nostr_event_branch,base.group_user,1,1,1,1
access_nostr_event_commit_user,nostr.event.commit user,model_nostr_event_commit,base.group_user,1,1,1,1
access_nostr_event_tree_user,nostr.event.tree user,model_nostr_event_tree,base.group_user,1,1,1,1
access_nostr_event_blob_user,nostr.event.blob user,model_nostr_event_blob,base.group_user,1,1,1,1
access_nostr_event_user,nostr.event user,model_nostr_event,base.group_user,1,1,1,1
access_nostr_event_repository_anchor_user,nostr.event.repository.anchor user,model_nostr_event_repository_anchor,base.group_user,1,1,1,1
=== ./odoo_custom_addons/integrated_ivcs/tests/test_nostr_events.py ===
# integrated_ivcs/tests/test_nostr_events.py

from odoo.tests.common import TransactionCase
from odoo.exceptions import ValidationError
import json

class TestNostrEvents(TransactionCase):

    def setUp(self):
        super(TestNostrEvents, self).setUp()
        self.RepositoryAnchor = self.env['nostr.event.repository.anchor']
        self.BranchEvent = self.env['nostr.event.branch']
        self.CommitEvent = self.env['nostr.event.commit']
        self.TreeEvent = self.env['nostr.event.tree']
        self.BlobEvent = self.env['nostr.event.blob']

    def test_repository_anchor_event(self):
        event = self.RepositoryAnchor.create({
            'id': 'test_id',
            'pubkey': 'test_pubkey',
            'sig': 'test_sig',
            'repo_name': 'test_repo',
            'description': 'Test repository',
            'content': json.dumps({
                'action': 'create_repository',
                'repo_name': 'test_repo',
                'description': 'Test repository'
            })
        })
        self.assertEqual(event.kind, 31228)
        
        json_str = event.to_json()
        new_event = self.RepositoryAnchor.from_json(json_str)
        self.assertEqual(new_event.repo_name, 'test_repo')
        
        with self.assertRaises(ValidationError):
            self.RepositoryAnchor.create({
                'id': 'test_id',
                'pubkey': 'test_pubkey',
                'sig': 'test_sig',
                'repo_name': 'test_repo',
                'description': 'Test repository',
                'content': json.dumps({
                    'action': 'invalid_action',
                    'repo_name': 'test_repo',
                    'description': 'Test repository'
                })
            })

    def test_branch_event(self):
        event = self.BranchEvent.create({
            'id': 'test_id',
            'pubkey': 'test_pubkey',
            'sig': 'test_sig',
            'branch_name': 'test_branch',
            'action': 'create',
            'content': json.dumps({
                'action': 'create_branch',
                'branch_name': 'test_branch'
            })
        })
        self.assertEqual(event.kind, 31227)
        
        json_str = event.to_json()
        new_event = self.BranchEvent.from_json(json_str)
        self.assertEqual(new_event.branch_name, 'test_branch')
        self.assertEqual(new_event.action, 'create')
        
        with self.assertRaises(ValidationError):
            self.BranchEvent.create({
                'id': 'test_id',
                'pubkey': 'test_pubkey',
                'sig': 'test_sig',
                'branch_name': 'test_branch',
                'action': 'create',
                'content': json.dumps({
                    'action': 'invalid_action',
                    'branch_name': 'test_branch'
                })
            })

    def test_commit_event(self):
        event = self.CommitEvent.create({
            'id': 'test_id',
            'pubkey': 'test_pubkey',
            'sig': 'test_sig',
            'commit_hash': 'test_hash',
            'message': 'Test commit',
            'author': 'Test Author',
            'timestamp': '2023-06-01 12:00:00',
            'content': json.dumps({
                'hash': 'test_hash',
                'message': 'Test commit',
                'author': 'Test Author',
                'date': '2023-06-01T12:00:00'
            })
        })
        self.assertEqual(event.kind, 3121)
        
        json_str = event.to_json()
        new_event = self.CommitEvent.from_json(json_str)
        self.assertEqual(new_event.commit_hash, 'test_hash')
        self.assertEqual(new_event.message, 'Test commit')
        
        with self.assertRaises(ValidationError):
            self.CommitEvent.create({
                'id': 'test_id',
                'pubkey': 'test_pubkey',
                'sig': 'test_sig',
                'commit_hash': 'test_hash',
                'message': 'Test commit',
                'author': 'Test Author',
                'timestamp': '2023-06-01 12:00:00',
                'content': json.dumps({
                    'hash': 'test_hash',
                    'message': 'Test commit'
                    # Missing 'author' and 'date' fields
                })
            })

    def test_tree_event(self):
        event = self.TreeEvent.create({
            'id': 'test_id',
            'pubkey': 'test_pubkey',
            'sig': 'test_sig',
            'tree_hash': 'test_hash',
            'items': json.dumps([{'path': 'file1', 'mode': '100644', 'type': 'blob', 'sha': 'file1_hash'}]),
            'content': json.dumps({
                'hash': 'test_hash',
                'items': [{'path': 'file1', 'mode': '100644', 'type': 'blob', 'sha': 'file1_hash'}]
            })
        })
        self.assertEqual(event.kind, 3122)
        
        json_str = event.to_json()
        new_event = self.TreeEvent.from_json(json_str)
        self.assertEqual(new_event.tree_hash, 'test_hash')
        self.assertIn('file1', new_event.items)
        
        with self.assertRaises(ValidationError):
            self.TreeEvent.create({
                'id': 'test_id',
                'pubkey': 'test_pubkey',
                'sig': 'test_sig',
                'tree_hash': 'test_hash',
                'items': json.dumps([{'path': 'file1', 'mode': '100644', 'type': 'blob', 'sha': 'file1_hash'}]),
                'content': json.dumps({
                    'hash': 'test_hash'
                    # Missing 'items' field
                })
            })

    def test_blob_event(self):
        event = self.BlobEvent.create({
            'id': 'test_id',
            'pubkey': 'test_pubkey',
            'sig': 'test_sig',
            'blob_hash': 'test_hash',
            'size': 100,
            'data': 'Test blob data',
            'content': json.dumps({
                'hash': 'test_hash',
                'size': 100,
                'data': 'Test blob data'
            })
        })
        self.assertEqual(event.kind, 3123)
        
        json_str = event.to_json()
        new_event = self.BlobEvent.from_json(json_str)
        self.assertEqual(new_event.blob_hash, 'test_hash')
        self.assertEqual(new_event.size, 100)
        self.assertEqual(new_event.data, 'Test blob data')
        
        with self.assertRaises(ValidationError):
            self.BlobEvent.create({
                'id': 'test_id',
                'pubkey': 'test_pubkey',
                'sig': 'test_sig',
                'blob_hash': 'test_hash',
                'size': 100,
                'data': 'Test blob data',
                'content': json.dumps({
                    'hash': 'test_hash',
                    'size': 100
                    # Missing 'data' field
                })
            })
=== ./odoo_custom_addons/integrated_ivcs/tests/test_git_nostr_integration.py ===
import unittest
import tempfile
import os
import git
import json
from nostr.event import Event
from nostr.key import PrivateKey
from odoo.tests.common import TransactionCase
from odoo.exceptions import UserError

class TestGitNostrIntegration(TransactionCase):

    def setUp(self):
        super(TestGitNostrIntegration, self).setUp()
        self.IVCSItem = self.env['ivcs.item']
        self.NostrEvent = self.env['nostr.event']
        self.temp_dir = tempfile.mkdtemp()
        self.repo_path = os.path.join(self.temp_dir, 'test_repo')

    def tearDown(self):
        super(TestGitNostrIntegration, self).tearDown()
        if os.path.exists(self.temp_dir):
            import shutil
            shutil.rmtree(self.temp_dir)

    def test_create_repository(self):
        item = self.IVCSItem.create({
            'name': 'Test Repo',
            'description': 'Test repository',
            'repo_path': self.repo_path,
        })
        self.assertTrue(os.path.exists(self.repo_path))
        self.assertTrue(os.path.exists(os.path.join(self.repo_path, '.git')))
        self.assertTrue(os.path.exists(os.path.join(self.repo_path, 'README.md')))

    def test_create_branch(self):
        item = self.IVCSItem.create({
            'name': 'Test Repo',
            'description': 'Test repository',
            'repo_path': self.repo_path,
        })
        result = item.create_branch('test-branch')
        self.assertEqual(result['type'], 'ir.actions.client')
        self.assertEqual(result['params']['type'], 'success')
        repo = git.Repo(self.repo_path)
        self.assertIn('test-branch', repo.heads)

    def test_merge_branches(self):
        item = self.IVCSItem.create({
            'name': 'Test Repo',
            'description': 'Test repository',
            'repo_path': self.repo_path,
        })
        item.create_branch('branch1')
        item.create_branch('branch2')
        repo = git.Repo(self.repo_path)
        repo.heads.branch1.checkout()
        with open(os.path.join(self.repo_path, 'file1.txt'), 'w') as f:
            f.write('Content in branch1')
        repo.index.add(['file1.txt'])
        repo.index.commit('Commit in branch1')
        
        result = item.merge_branches('branch1', 'branch2')
        self.assertEqual(result['type'], 'ir.actions.client')
        self.assertEqual(result['params']['type'], 'success')
        
        repo.heads.branch2.checkout()
        self.assertTrue(os.path.exists(os.path.join(self.repo_path, 'file1.txt')))

    def test_create_nostr_events(self):
        item = self.IVCSItem.create({
            'name': 'Test Repo',
            'description': 'Test repository',
            'repo_path': self.repo_path,
        })
        repo = git.Repo(self.repo_path)
        with open(os.path.join(self.repo_path, 'test.txt'), 'w') as f:
            f.write('Test content')
        repo.index.add(['test.txt'])
        commit = repo.index.commit('Test commit')
        
        event = self.NostrEvent.create_git_event(self.repo_path, commit.hexsha)
        self.assertEqual(event.kind, 3121)
        self.assertIn(commit.hexsha, event.content)

    def test_reconstruct_git_objects(self):
        item = self.IVCSItem.create({
            'name': 'Test Repo',
            'description': 'Test repository',
            'repo_path': self.repo_path,
        })
        repo = git.Repo(self.repo_path)
        with open(os.path.join(self.repo_path, 'test.txt'), 'w') as f:
            f.write('Test content')
        repo.index.add(['test.txt'])
        commit = repo.index.commit('Test commit')
        
        self.NostrEvent.create_git_event(self.repo_path, commit.hexsha)
        
        # Delete the .git directory to simulate a fresh repository
        import shutil
        shutil.rmtree(os.path.join(self.repo_path, '.git'))
        
        # Reconstruct the repository from Nostr events
        self.NostrEvent.reconstruct_git_objects(self.repo_path)
        
        reconstructed_repo = git.Repo(self.repo_path)
        self.assertIn(commit.hexsha, reconstructed_repo.heads.master.commit.hexsha)
        self.assertTrue(os.path.exists(os.path.join(self.repo_path, 'test.txt')))

if __name__ == '__main__':
    unittest.main()
=== ./odoo_custom_addons/integrated_ivcs/views/res_config_settings_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="res_config_settings_view_form" model="ir.ui.view">
        <field name="name">res.config.settings.view.form.inherit.integrated_ivcs</field>
        <field name="model">res.config.settings</field>
        <field name="inherit_id" ref="base.res_config_settings_view_form"/>
        <field name="arch" type="xml">
            <xpath expr="//div[hasclass('settings')]" position="inside">
                <div class="app_settings_block" data-string="Integrated IVCS" string="Integrated IVCS" data-key="integrated_ivcs">
                    <h2>Nostr Settings</h2>
                    <div class="row mt16 o_settings_container">
                        <div class="col-12 col-lg-6 o_setting_box">
                            <div class="o_setting_left_pane"/>
                            <div class="o_setting_right_pane">
                                <span class="o_form_label">Nostr Relay URLs</span>
                                <div class="text-muted">
                                    Comma-separated list of Nostr relay URLs
                                </div>
                                <div class="content-group">
                                    <field name="integrated_ivcs_relay_urls"/>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </xpath>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons/integrated_ivcs/views/ivcs_version_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_ivcs_version_form" model="ir.ui.view">
        <field name="name">ivcs.version.form</field>
        <field name="model">ivcs.version</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="description"/>
                        <field name="item_id"/>
                        <field name="commit_id"/>
                        <field name="create_date"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_ivcs_version_tree" model="ir.ui.view">
        <field name="name">ivcs.version.tree</field>
        <field name="model">ivcs.version</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="item_id"/>
                <field name="create_date"/>
            </tree>
        </field>
    </record>

    <record id="action_ivcs_version" model="ir.actions.act_window">
        <field name="name">IVCS Versions</field>
        <field name="res_model">ivcs.version</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_ivcs_version" name="Versions" parent="menu_ivcs_root" action="action_ivcs_version"/>
</odoo>
=== ./odoo_custom_addons/integrated_ivcs/views/nostr_event_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_nostr_event_form" model="ir.ui.view">
        <field name="name">nostr.event.form</field>
        <field name="model">nostr.event</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="event_id"/>
                        <field name="kind"/>
                        <field name="event_type"/>
                        <field name="content"/>
                        <field name="tags"/>
                        <field name="public_key"/>
                        <field name="created_at"/>
                        <field name="signature"/>
                        <field name="published"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_nostr_event_tree" model="ir.ui.view">
        <field name="name">nostr.event.tree</field>
        <field name="model">nostr.event</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="event_id"/>
                <field name="kind"/>
                <field name="event_type"/>
                <field name="public_key"/>
                <field name="created_at"/>
                <field name="published"/>
            </tree>
        </field>
    </record>

    <record id="action_nostr_event" model="ir.actions.act_window">
        <field name="name">Nostr Events</field>
        <field name="res_model">nostr.event</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_nostr_event" name="Nostr Events" parent="menu_ivcs_root" action="action_nostr_event"/>
</odoo>
=== ./odoo_custom_addons/integrated_ivcs/views/ivcs_item_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_ivcs_item_form" model="ir.ui.view">
        <field name="name">ivcs.item.form</field>
        <field name="model">ivcs.item</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="description"/>
                        <field name="repo_path"/>
                        <field name="current_branch"/>
                        <field name="current_version_id"/>
                        <field name="nostr_private_key" password="True"/>
                    </group>
                    <notebook>
                        <page string="Versions">
                            <field name="version_ids"/>
                        </page>
                        <page string="Commits">
                            <field name="commit_ids"/>
                        </page>
                    </notebook>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_ivcs_item_tree" model="ir.ui.view">
        <field name="name">ivcs.item.tree</field>
        <field name="model">ivcs.item</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="repo_path"/>
                <field name="current_branch"/>
                <field name="current_version_id"/>
            </tree>
        </field>
    </record>

    <record id="action_ivcs_item" model="ir.actions.act_window">
        <field name="name">IVCS Items</field>
        <field name="res_model">ivcs.item</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_ivcs_root" name="Integrated IVCS"/>
    <menuitem id="menu_ivcs_item" name="IVCS Items" parent="menu_ivcs_root" action="action_ivcs_item"/>
</odoo>
=== ./odoo_custom_addons/integrated_ivcs/views/git_repository_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_repository_form" model="ir.ui.view">
        <field name="name">git.repository.form</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="path"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_git_repository_tree" model="ir.ui.view">
        <field name="name">git.repository.tree</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="path"/>
            </tree>
        </field>
    </record>

    <record id="action_git_repository" model="ir.actions.act_window">
        <field name="name">Git Repositories</field>
        <field name="res_model">git.repository</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_git_repository" name="Git Repositories" parent="menu_ivcs_root" action="action_git_repository"/>
</odoo>
=== ./odoo_custom_addons/integrated_ivcs/views/ivcs_commit_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_ivcs_commit_form" model="ir.ui.view">
        <field name="name">ivcs.commit.form</field>
        <field name="model">ivcs.commit</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="hash"/>
                        <field name="message"/>
                        <field name="author"/>
                        <field name="date"/>
                        <field name="item_id"/>
                        <field name="version_id"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_ivcs_commit_tree" model="ir.ui.view">
        <field name="name">ivcs.commit.tree</field>
        <field name="model">ivcs.commit</field>
        <field name="arch" type="xml">
            <tree>
                <field name="hash"/>
                <field name="message"/>
                <field name="author"/>
                <field name="date"/>
                <field name="item_id"/>
            </tree>
        </field>
    </record>

    <record id="action_ivcs_commit" model="ir.actions.act_window">
        <field name="name">IVCS Commits</field>
        <field name="res_model">ivcs.commit</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_ivcs_commit" name="Commits" parent="menu_ivcs_root" action="action_ivcs_commit"/>
</odoo>
=== ./erm.txt ===
=== ./nostr_auth.py ===
#!/usr/bin/env python3
import sys
import os

# Add Odoo to Python path
odoo_path = '/opt/odoo/odoo'
sys.path.append(odoo_path)

import odoo
from odoo.tools import config
# from nostr_auth import authenticate_user

def authenticate_user(public_key, private_key):
    # Generate a random challenge
    challenge = os.urandom(32).hex()
    
    # Sign the challenge with the private key
    private_key_int = int(private_key, 16)
    private_key_obj = ec.derive_private_key(private_key_int, ec.SECP256K1())
    signature = private_key_obj.sign(challenge.encode('utf-8'), ec.ECDSA(hashes.SHA256()))
    
    # Verify the signature
    if verify_nostr_signature(public_key, challenge, signature.hex()):
        # Check if user exists in Odoo database
        conn = psycopg2.connect(
            dbname="odoodb",
            user="odoo",
            password="your_secure_password",
            host="localhost",
            port="5432"
        )
        cur = conn.cursor()
        cur.execute("SELECT id FROM res_users WHERE login = %s", (public_key,))
        user = cur.fetchone()
        
        if user:
            return user[0]  # Return user ID if exists
        else:
            # Create new user
            cur.execute("INSERT INTO res_users (login, password) VALUES (%s, %s) RETURNING id", (public_key, hashlib.sha256(private_key.encode()).hexdigest()))
            new_user_id = cur.fetchone()[0]
            conn.commit()
            return new_user_id
    else:
        return None

if __name__ == "__main__":
    config.parse_config(sys.argv[1:])
    
    if config.get('auth_method') == 'nostr':
        def check_security(method, *args, **kwargs):
            # Get Nostr public and private keys from request
            public_key = odoo.http.request.params.get('public_key')
            private_key = odoo.http.request.params.get('private_key')
            
            if not public_key or not private_key:
                raise odoo.exceptions.AccessDenied()
            
            user_id = authenticate_user(public_key, private_key)
            if user_id:
                odoo.http.request.uid = user_id
            else:
                raise odoo.exceptions.AccessDenied()
        
        odoo.http.root.check_security = check_security
    
    odoo.cli.main()
=== ./docker-compose.yml ===
version: '3'
services:
  postgres:
    image: postgres:14
    environment:
      - POSTGRES_DB=odoodb
      - POSTGRES_PASSWORD=your_secure_password
      - POSTGRES_USER=odoo
    networks:
      - odoo_network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U odoo"]
      interval: 10s
      timeout: 5s
      retries: 5

  odoo:
    build: .
    command: ["/opt/odoo/odoo/odoo-bin", "-c", "/etc/odoo/odoo.conf", "-d", "odoodb", "-i", "base,nostr_bridge,ivcs_git"]
    depends_on:
      postgres:
        condition: service_healthy
    ports:
      - "8069:8069"
      - "8072:8072"
    volumes:
      - ./odoo.conf:/etc/odoo/odoo.conf
      - ./odoo_custom_addons:/opt/odoo/custom_addons
      - ivcs_repos:/opt/ivcs_repos
    environment:
      - HOST=postgres
      - USER=odoo
      - PASSWORD=your_secure_password
    networks:
      - odoo_network
    extra_hosts:
      - "host.docker.internal:host-gateway"

networks:
  odoo_network:
    driver: bridge

volumes:
  ivcs_repos:
=== ./odoo.conf ===
[options]
addons_path = /opt/odoo/odoo/addons,/opt/odoo/odoo/odoo/addons,/opt/odoo/custom_addons
admin_passwd = your_secure_admin_password
db_host = postgres
db_port = 5432
db_user = odoo
db_password = your_secure_password
db_name = odoodb
http_port = 8069
xmlrpc_port = 8069
gevent_port = 8072
longpolling_port = 8072
proxy_mode = True
workers = 2
max_cron_threads = 1
limit_time_cpu = 600
limit_time_real = 1200
log_level = debug
log_handler = [':DEBUG']
logfile = /var/log/odoo/odoo-server.log
=== ./podman-compose.yml ===
version: '3'
services:
  postgres:
    image: postgres:14
    environment:
      - POSTGRES_DB=odoodb
      - POSTGRES_PASSWORD=your_secure_password
      - POSTGRES_USER=odoo
    networks:
      - odoo_network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U odoo"]
      interval: 10s
      timeout: 5s
      retries: 5

  odoo:
    build: .
    command: ["/opt/odoo/odoo/odoo-bin", "-c", "/etc/odoo/odoo.conf", "-d", "odoodb", "-i", "base,nostr_bridge,ivcs_git"]
    depends_on:
      postgres:
        condition: service_healthy
    ports:
      - "8069:8069"
      - "8072:8072"
    volumes:
      - ./odoo.conf:/etc/odoo/odoo.conf:Z
      - ./odoo_custom_addons:/opt/odoo/custom_addons:Z
      - ivcs_repos:/opt/ivcs_repos:Z
    environment:
      - HOST=postgres
      - USER=odoo
      - PASSWORD=your_secure_password
    networks:
      - odoo_network

networks:
  odoo_network:
    driver: bridge

volumes:
  ivcs_repos:
=== ./patch_openssl.py ===

=== ./git_repository_anchor.txt ===
Certainly! I'll refine and merge the code into a single Odoo module as requested. Here's the structure and content for the `git_repository_anchor` Odoo module:



First, let's create the module structure:

```bash
git_repository_anchor/
├── __init__.py
├── __manifest__.py
├── models/
│   ├── __init__.py
│   ├── repository_anchor.py
│   ├── branch_manager.py
│   └── odoo_models.py
├── controllers/
│   ├── __init__.py
│   └── main.py
└── tests/
    ├── __init__.py
    └── test_repository_anchor.py

```

Now, let's implement each component:

1. Module Manifest (__manifest__.py):

```python
{
    'name': 'Git Repository Anchor',
    'version': '1.0',
    'category': 'Development',
    'summary': 'Manage Git repositories using Nostr events',
    'author': 'Your Name',
    'website': 'https://www.example.com',
    'depends': ['base'],
    'data': [
        'security/ir.model.access.csv',
        'views/repository_views.xml',
    ],
    'installable': True,
    'application': True,
    'auto_install': False,
}

```

2. Models (models/repository_anchor.py):

```python
import logging
import time
from functools import wraps
from odoo import models, fields, api
from nostr.key import PrivateKey

def log_execution_time(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        logging.debug(f"{func.__name__} executed in {end_time - start_time:.2f} seconds")
        return result
    return wrapper

class RepositoryAnchor(models.AbstractModel):
    _name = 'git.repository.anchor'
    _description = 'Git Repository Anchor'

    @api.model
    def _get_private_key(self):
        # In practice, you'd retrieve this securely
        return PrivateKey()

    @log_execution_time
    def create_repository(self, name, description, maintainers):
        private_key = self._get_private_key()
        # Implement repository creation logic here
        logging.info(f"Creating repository: {name}")
        # Return the created repository as an Odoo recordset

    @log_execution_time
    def update_repository(self, repo, description=None, maintainers=None):
        # Implement repository update logic here
        logging.info(f"Updating repository: {repo.name}")
        # Return the updated repository

    # Implement other methods (fork_repository, list_maintainers, etc.)

```

3. Models (models/odoo_models.py):

```python
from odoo import models, fields, api

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Repository Name', required=True)
    description = fields.Text(string='Description')
    maintainer_ids = fields.Many2many('res.users', string='Maintainers')
    created_at = fields.Datetime(string='Created At', default=fields.Datetime.now)
    last_updated = fields.Datetime(string='Last Updated', default=fields.Datetime.now)

class GitBranch(models.Model):
    _name = 'git.branch'
    _description = 'Git Branch'

    name = fields.Char(string='Branch Name', required=True)
    repository_id = fields.Many2one('git.repository', string='Repository', required=True)
    head = fields.Char(string='Head Commit', required=True)

class GitEvent(models.Model):
    _name = 'git.event'
    _description = 'Git Event'

    event_type = fields.Selection([
        ('create_repository', 'Create Repository'),
        ('update_repository', 'Update Repository'),
        ('fork_repository', 'Fork Repository'),
        ('create_branch', 'Create Branch'),
        ('update_branch', 'Update Branch'),
        ('delete_branch', 'Delete Branch')
    ], string='Event Type')
    content = fields.Text(string='Event Content')
    created_at = fields.Datetime(string='Created At', default=fields.Datetime.now)

class GitRepositoryManager(models.Model):
    _name = 'git.repository.manager'
    _description = 'Git Repository Manager'

    @api.model
    def create_repository(self, name, description, maintainer_ids):
        anchor = self.env['git.repository.anchor']
        repo = anchor.create_repository(name, description, maintainer_ids)
        return repo.id

    # Implement other management methods

```

4. Controllers (controllers/main.py):

```python
from odoo import http
from odoo.http import request

class GitRepositoryController(http.Controller):
    @http.route('/git/repository/create', type='json', auth='user')
    def create_repository(self, name, description, maintainer_ids):
        repo_manager = request.env['git.repository.manager'].sudo()
        repo_id = repo_manager.create_repository(name, description, maintainer_ids)
        return {'success': True, 'repository_id': repo_id}

    # Implement other routes (update_repository, fork_repository, etc.)

```

5. Tests (tests/test_repository_anchor.py):

```python
from odoo.tests.common import TransactionCase

class TestRepositoryAnchor(TransactionCase):

    def setUp(self):
        super(TestRepositoryAnchor, self).setUp()
        self.repo_manager = self.env['git.repository.manager'].sudo()

    def test_create_repository(self):
        repo_id = self.repo_manager.create_repository(
            "test-repo", "Test repository", [self.env.user.id]
        )
        repo = self.env['git.repository'].browse(repo_id)
        self.assertEqual(repo.name, "test-repo")
        self.assertEqual(repo.description, "Test repository")
        self.assertIn(self.env.user, repo.maintainer_ids)

    # Implement other test methods

    def test_fork_repository(self):
        original_repo_id = self.repo_manager.create_repository(
            "original-repo", "Original repository", [self.env.user.id]
        )
        forked_repo_id = self.repo_manager.fork_repository(
            original_repo_id, "forked-repo", self.env.user.id
        )
        forked_repo = self.env['git.repository'].browse(forked_repo_id)
        self.assertEqual(forked_repo.name, "forked-repo")
        self.assertIn(self.env.user, forked_repo.maintainer_ids)

```

6. CLI Script (outside the module):

```python
import argparse
import logging
from odoo import api, registry, SUPERUSER_ID

def setup_logging():
    logging.basicConfig(level=logging.INFO,
                        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

def main(args):
    with api.Environment.manage():
        with registry('your_database_name').cursor() as cr:
            env = api.Environment(cr, SUPERUSER_ID, {})
            repo_manager = env['git.repository.manager'].sudo()

            if args.action == 'create':
                repo_id = repo_manager.create_repository(args.name, args.description, args.maintainers)
                print(f"Repository created with ID: {repo_id}")
            elif args.action == 'update':
                repo_manager.update_repository(args.repo_id, args.description, args.maintainers)
                print(f"Repository updated: {args.repo_id}")
            # Implement other actions

if __name__ == '__main__':
    setup_logging()
    parser = argparse.ArgumentParser(description="Git Repository Anchor CLI")
    parser.add_argument("action", choices=['create', 'update', 'fork', 'list'])
    parser.add_argument("--name", help="Repository name")
    parser.add_argument("--description", help="Repository description")
    parser.add_argument("--maintainers", nargs='+', type=int, help="Maintainer user IDs")
    parser.add_argument("--repo-id", type=int, help="Repository ID for updates")
    args = parser.parse_args()
    main(args)

```

This refined and merged code creates a complete Odoo module for managing Git repositories using Nostr events. It includes:

1. A proper Odoo module structure
2. Odoo models for repositories, branches, and events
3. A repository manager that uses the RepositoryAnchor functionality
4. Odoo controllers for web interactions
5. Unit tests integrated with Odoo's testing framework
6. Enhanced logging throughout the module
7. A CLI script for standalone usage

To use this module:
1. Place the `git_repository_anchor` directory in your Odoo addons path.
2. Update your Odoo apps list and install the "Git Repository Anchor" module.
3. Use the Odoo interface or the provided CLI script to manage repositories.

Remember to add necessary security rules and views (not shown here for brevity) to make the module fully functional within Odoo.
=== ./ivcs_version.py ===
from odoo import models, fields, api

class IVCSVersion(models.Model):
    _name = 'ivcs.version'
    _description = 'IVCS Version'

    name = fields.Char(string='Version Name', required=True)
    description = fields.Text(string='Description')
    state = fields.Selection([
        ('draft', 'Draft'),
        ('confirmed', 'Confirmed'),
        ('done', 'Done')
    ], string='State', default='draft')
    item_id = fields.Many2one('ivcs.item', string='IVCS Item', required=True)
    create_date = fields.Datetime(string='Created On', readonly=True, default=fields.Datetime.now)

    @api.model
    def create(self, vals):
        version = super(IVCSVersion, self).create(vals)
        if version.item_id and not version.item_id.current_version_id:
            version.item_id.current_version_id = version.id
        return version

    def name_get(self):
        result = []
        for version in self:
            name = f"{version.item_id.name} - {version.name}"
            result.append((version.id, name))
        return result
=== ./podman_commands.txt ===
/home/impromise/.local/bin/podman-compose

sudo /home/impromise/.local/bin/podman-compose down
sudo /home/impromise/.local/bin/podman-compose build
sudo /home/impromise/.local/bin/podman-compose up -d
ping google.com -c 10 # wait 10 seconds
sudo podman ps
sudo podman logs odoo-nostr-project-odoo-1
ping google.com -c 10 # wait 10 seconds
sudo podman exec -it odoo-nostr-project-odoo-1 /opt/odoo/odoo/odoo-bin -c /etc/odoo/odoo.conf -d odoodb -u nostr_bridge
sudo podman exec -it odoo-nostr-project-odoo-1 /opt/odoo/odoo/odoo-bin -c /etc/odoo/odoo.conf -d odoodb -u nostr_auth
sudo podman exec -it odoo-nostr-project-odoo-1 /opt/odoo/odoo/odoo-bin -c /etc/odoo/odoo.conf -d odoodb -u ivcs_git
sudo podman exec -it odoo-nostr-project-odoo-1 /opt/odoo/odoo/odoo-bin -c /etc/odoo/odoo.conf -d odoodb -u nostr_identity
sudo podman exec -it odoo-nostr-project-odoo-1 /opt/odoo/odoo/odoo-bin -c /etc/odoo/odoo.conf -d odoodb -u decentralized_sync
sudo podman exec -it odoo-nostr-project-odoo-1 /opt/odoo/odoo/odoo-bin -c /etc/odoo/odoo.conf -d odoodb -u git_nostr_bridge
ping google.com -c 10 # wait 10 seconds
sudo podman logs odoo-nostr-project-odoo-1


podman-compose down
podman-compose build
podman-compose up -d
ping google.com -c 10 # wait 10 seconds
podman ps
podman logs odoo-nostr-project-odoo-1
ping google.com -c 10 # wait 10 seconds
podman exec -it odoo-nostr-project-odoo-1 /opt/odoo/odoo/odoo-bin -c /etc/odoo/odoo.conf -d odoodb -u nostr_bridge
podman exec -it odoo-nostr-project-odoo-1 /opt/odoo/odoo/odoo-bin -c /etc/odoo/odoo.conf -d odoodb -u nostr_auth
podman exec -it odoo-nostr-project-odoo-1 /opt/odoo/odoo/odoo-bin -c /etc/odoo/odoo.conf -d odoodb -u ivcs_git
podman exec -it odoo-nostr-project-odoo-1 /opt/odoo/odoo/odoo-bin -c /etc/odoo/odoo.conf -d odoodb -u nostr_identity
podman exec -it odoo-nostr-project-odoo-1 /opt/odoo/odoo/odoo-bin -c /etc/odoo/odoo.conf -d odoodb -u decentralized_sync
podman exec -it odoo-nostr-project-odoo-1 /opt/odoo/odoo/odoo-bin -c /etc/odoo/odoo.conf -d odoodb -u git_nostr_bridge
ping google.com -c 10 # wait 10 seconds
podman logs odoo-nostr-project-odoo-1





podman run -d --name postgres -e POSTGRES_DB=odoodb -e POSTGRES_PASSWORD=your_secure_password -e POSTGRES_USER=odoo postgres:14

podman build -t odoo-custom .

podman run -d --name odoo -p 8069:8069 -p 8072:8072 --pod-id-file /tmp/postgres-pod-id -e HOST=postgres -e USER=odoo -e PASSWORD=your_secure_password -v ./odoo.conf:/etc/odoo/odoo.conf:Z -v ./odoo_custom_addons:/opt/odoo/custom_addons:Z odoo-custom



# Remove any existing containers and pods
podman pod rm -f odoo-pod
podman rm -f postgres odoo

# Create the pod
podman pod create --name odoo-pod -p 8069:8069 -p 8072:8072

# Run PostgreSQL in the pod
podman run -d --pod odoo-pod --name postgres -e POSTGRES_DB=odoodb -e POSTGRES_PASSWORD=your_secure_password -e POSTGRES_USER=odoo postgres:14

# Run Odoo in the pod
podman run -d --pod odoo-pod --name odoo -e HOST=postgres -e USER=odoo -e PASSWORD=your_secure_password -v ./odoo.conf:/etc/odoo/odoo.conf:Z -v ./odoo_custom_addons:/opt/odoo/custom_addons:Z localhost/odoo-custom:latest /bin/bash -c "while ! pg_isready -h postgres -p 5432 -U odoo; do sleep 1; done; /opt/odoo/check_nostr_bridge.sh && python3 /opt/odoo/odoo/odoo-bin -c /etc/odoo/odoo.conf -d odoodb -i base && python3 /opt/odoo/custom_odoo_server.py -c /etc/odoo/odoo.conf"



podman stop $(sudo podman ps -aq)
podman rm $(sudo podman ps -aq)
podman system prune -a --volumes -f
podman-compose down
podman-compose build
podman-compose up -d
ping google.com -c 10 # wait 10 seconds
podman ps
podman logs odoo-nostr-project-odoo-1
ping google.com -c 10 # wait 10 seconds
podman exec -it odoo-nostr-project-odoo-1 /opt/odoo/odoo/odoo-bin -c /etc/odoo/odoo.conf -d odoodb -u nostr_bridge
podman exec -it odoo-nostr-project-odoo-1 /opt/odoo/odoo/odoo-bin -c /etc/odoo/odoo.conf -d odoodb -u nostr_auth
podman exec -it odoo-nostr-project-odoo-1 /opt/odoo/odoo/odoo-bin -c /etc/odoo/odoo.conf -d odoodb -u ivcs_git
podman exec -it odoo-nostr-project-odoo-1 /opt/odoo/odoo/odoo-bin -c /etc/odoo/odoo.conf -d odoodb -u nostr_identity
podman exec -it odoo-nostr-project-odoo-1 /opt/odoo/odoo/odoo-bin -c /etc/odoo/odoo.conf -d odoodb -u decentralized_sync
podman exec -it odoo-nostr-project-odoo-1 /opt/odoo/odoo/odoo-bin -c /etc/odoo/odoo.conf -d odoodb -u git_nostr_bridge
=== ./test.txt ===

=== ./start.sh ===
#!/bin/bash

docker-compose up -d
echo "Odoo is starting up. You can access it at http://localhost:8080"
echo "It may take a few moments for the service to be fully available."
=== ./odoo_custom_addons (copy)/git_repository_anchor/models/git_repository.py ===
from odoo import models, fields, api, _
from odoo.exceptions import UserError
import git
import os
import logging

_logger = logging.getLogger(__name__)

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'
    _inherit = ['mail.thread', 'mail.activity.mixin']

    name = fields.Char(string='Repository Name', required=True)
    path = fields.Char(string='Repository Path', required=True)
    description = fields.Text(string='Description', tracking=True)
    maintainer_ids = fields.Many2many('res.users', string='Maintainers')
    anchor_event_id = fields.Many2one('nostr.event', string='Anchor Event')
    #company_id = fields.Many2one('res.company', string='Company', required=True, default=lambda self: self.env.company)

    @api.model
    def create(self, vals):
        repo = super(GitRepository, self).create(vals)
        repo._initialize_repository()
        return repo

    def _initialize_repository(self):
        if not os.path.exists(self.path):
            os.makedirs(self.path)
            git.Repo.init(self.path)
            readme_path = os.path.join(self.path, 'README.md')
            with open(readme_path, 'w') as f:
                f.write(f"# {self.name}\n\n{self.description or ''}")
            repo = git.Repo(self.path)
            repo.index.add(['README.md'])
            repo.index.commit("Initial commit")

    def _create_anchor_event(self):
        anchor = self.env['git.repository.anchor']
        event = anchor.create_anchor_event(self.path, self.maintainer_ids.mapped('nostr_public_key'))
        self.env['nostr.event'].create_and_publish(event)
        self.anchor_event_id = self.env['nostr.event'].search([('event_id', '=', event.id)], limit=1).id

    def update_maintainers(self):
        anchor = self.env['git.repository.anchor']
        event = anchor.update_anchor(self.path, self.maintainer_ids.mapped('nostr_public_key'))
        self.env['nostr.event'].create_and_publish(event)
        self.anchor_event_id = self.env['nostr.event'].search([('event_id', '=', event.id)], limit=1).id

    def fork_repository(self, new_name, new_path, new_maintainer_ids):
        anchor = self.env['git.repository.anchor']
        new_maintainers = self.env['res.users'].browse(new_maintainer_ids).mapped('nostr_public_key')
        event = anchor.fork_repository(self.path, new_path, new_maintainers)
        self.env['nostr.event'].create_and_publish(event)
        
        new_repo = self.create({
            'name': new_name,
            'path': new_path,
            'maintainer_ids': [(6, 0, new_maintainer_ids)],
        })
        new_repo.anchor_event_id = self.env['nostr.event'].search([('event_id', '=', event.id)], limit=1).id
        
        # Clone the repository
        git.Repo.clone_from(self.path, new_path)
        
        return new_repo

    def check_permission(self, user_id):
        user = self.env['res.users'].browse(user_id)
        anchor = self.env['git.repository.anchor']
        return anchor.check_permission(self.anchor_event_id, user.nostr_public_key)
=== ./odoo_custom_addons (copy)/git_repository_anchor/models/__init__.py ===
from . import repository_anchor
from . import branch_manager
from . import odoo_models
from . import git_repository
from . import nostr_event
=== ./odoo_custom_addons (copy)/git_repository_anchor/models/repository_anchor.py ===
from odoo import models, fields, api, _
from odoo.exceptions import UserError
from nostr.event import Event
from nostr.key import PrivateKey
import json
import os
import logging
import time
from functools import wraps  # Add this import

_logger = logging.getLogger(__name__)

def log_execution_time(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        _logger.info(f"{func.__name__} executed in {end_time - start_time:.2f} seconds")
        return result
    return wrapper

class RepositoryAnchor(models.AbstractModel):
    _name = 'git.repository.anchor'
    _description = 'Git Repository Anchor'

    @api.model
    def _get_private_key(self):
        # In practice, you'd retrieve this securely
        return PrivateKey()

    @log_execution_time
    def create_anchor_event(self, repo_path, maintainers):
        _logger.info(f"Creating anchor event for repository: {repo_path}")
        start_time = time.time()

        private_key = self._get_private_key()
        content = json.dumps({
            "action": "create_repository",
            "repo_name": os.path.basename(repo_path),
            "maintainers": maintainers
        })
        event = Event(
            kind=31228,
            content=content,
            tags=[['r', repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)

        end_time = time.time()
        _logger.info(f"Anchor event created in {end_time - start_time:.2f} seconds")
        return event

    def update_anchor(self, repo_path, maintainers):
        _logger.info(f"Updating anchor for repository: {repo_path}")
        start_time = time.time()

        private_key = self._get_private_key()
        content = json.dumps({
            "action": "update_repository",
            "repo_name": os.path.basename(repo_path),
            "maintainers": maintainers
        })
        event = Event(
            kind=31228,
            content=content,
            tags=[['r', repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)

        end_time = time.time()
        _logger.info(f"Anchor updated in {end_time - start_time:.2f} seconds")
        return event

    def resolve_repository_state(self, anchor_event):
        _logger.info("Resolving repository state from anchor event")
        start_time = time.time()

        try:
            content = json.loads(anchor_event.content)
            state = {
                "repo_name": content["repo_name"],
                "maintainers": content["maintainers"]
            }
        except json.JSONDecodeError as e:
            _logger.error(f"Error decoding anchor event content: {str(e)}")
            raise UserError(_("Invalid anchor event content"))
        except KeyError as e:
            _logger.error(f"Missing key in anchor event content: {str(e)}")
            raise UserError(_("Incomplete anchor event content"))

        end_time = time.time()
        _logger.info(f"Repository state resolved in {end_time - start_time:.2f} seconds")
        return state

    def list_maintainers(self, anchor_event):
        _logger.info("Listing maintainers from anchor event")
        start_time = time.time()

        try:
            content = json.loads(anchor_event.content)
            maintainers = content["maintainers"]
        except json.JSONDecodeError as e:
            _logger.error(f"Error decoding anchor event content: {str(e)}")
            raise UserError(_("Invalid anchor event content"))
        except KeyError:
            _logger.error("Maintainers key not found in anchor event content")
            raise UserError(_("Incomplete anchor event content"))

        end_time = time.time()
        _logger.info(f"Maintainers listed in {end_time - start_time:.2f} seconds")
        return maintainers

    def check_permission(self, anchor_event, public_key):
        _logger.info(f"Checking permission for public key: {public_key}")
        start_time = time.time()

        maintainers = self.list_maintainers(anchor_event)
        has_permission = public_key in maintainers

        end_time = time.time()
        _logger.info(f"Permission check completed in {end_time - start_time:.2f} seconds")
        return has_permission

    def fork_repository(self, original_repo_path, new_repo_path, new_maintainers):
        _logger.info(f"Forking repository from {original_repo_path} to {new_repo_path}")
        start_time = time.time()

        private_key = self._get_private_key()
        content = json.dumps({
            "action": "fork_repository",
            "original_repo": original_repo_path,
            "new_repo": new_repo_path,
            "maintainers": new_maintainers
        })
        event = Event(
            kind=31228,
            content=content,
            tags=[['r', new_repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)

        end_time = time.time()
        _logger.info(f"Repository forked in {end_time - start_time:.2f} seconds")
        return event
=== ./odoo_custom_addons (copy)/git_repository_anchor/models/nostr_event.py ===
# File: /opt/odoo/custom_addons/git_repository_anchor/models/nostr_event.py

from odoo import models, fields, api, _
from odoo.exceptions import UserError
from nostr.event import Event as NostrLibEvent
from nostr.key import PrivateKey
import json
import time
import logging

_logger = logging.getLogger(__name__)

class NostrEvent(models.Model):
    _name = 'nostr.event'
    _description = 'Nostr Event'

    name = fields.Char(string='Name', required=True)
    event_id = fields.Char(string='Event ID', readonly=True)
    kind = fields.Integer(string='Event Kind', required=True)
    content = fields.Text(string='Content')
    tags = fields.Text(string='Tags')
    public_key = fields.Char(string='Public Key', readonly=True)
    created_at = fields.Integer(string='Created At', readonly=True)
    signature = fields.Char(string='Signature', readonly=True)
    published = fields.Boolean(string='Published', default=False)
    event_type = fields.Selection([
        ('commit', 'Commit'),
        ('branch', 'Branch'),
        ('tree', 'Tree'),
        ('blob', 'Blob'),
    ], string='Event Type')
    repository_id = fields.Many2one('git.repository', string='Related Repository')

    @api.model
    def create(self, vals):
        try:
            # Generate a new private key for this event
            private_key = PrivateKey()
            public_key = private_key.public_key.hex()
            
            created_at = int(time.time())
            tags = json.loads(vals.get('tags', '[]'))
            
            event = NostrLibEvent(
                kind=vals['kind'],
                content=vals.get('content', ''),
                tags=tags,
                pub_key=public_key,
                created_at=created_at
            )
            
            # Sign the event
            private_key.sign_event(event)
            
            # Update vals with generated data
            vals.update({
                'event_id': event.id,
                'public_key': public_key,
                'created_at': created_at,
                'signature': event.sig
            })
            
            _logger.info(f"Created Nostr event: {event.id}")
        except Exception as e:
            _logger.error(f"Error creating Nostr event: {str(e)}")
            raise UserError(_("Failed to create Nostr event: %s") % str(e))
        
        return super(NostrEvent, self).create(vals)

    @api.model
    def create_and_publish(self, event):
        vals = {
            'name': f"Event {event.id[:8]}",  # Use first 8 characters of event ID as name
            'event_id': event.id,
            'kind': event.kind,
            'content': event.content,
            'tags': json.dumps(event.tags),
            'public_key': event.public_key,
            'created_at': event.created_at,
            'signature': event.sig,
        }
        nostr_event = self.create(vals)
        # Here you would typically publish the event to Nostr relays
        # For demonstration purposes, we'll just log it
        _logger.info(f"Published Nostr event: {event.to_message()}")
        return nostr_event
=== ./odoo_custom_addons (copy)/git_repository_anchor/models/odoo_models.py ===
from odoo import models, fields, api
import logging

_logger = logging.getLogger(__name__)

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Repository Name', required=True)
    path = fields.Char(string='Repository Path', required=True)
    description = fields.Text(string='Description')
    maintainer_ids = fields.Many2many('res.users', string='Maintainers')
    created_at = fields.Datetime(string='Created At', default=fields.Datetime.now)
    last_updated = fields.Datetime(string='Last Updated', default=fields.Datetime.now)
    branch_ids = fields.One2many('git.branch', 'repository_id', string='Branches')

    @api.model
    def fields_get(self, allfields=None, attributes=None):
        res = super(GitRepository, self).fields_get(allfields, attributes)
        _logger.info(f"Fields in GitRepository model: {res.keys()}")
        return res

    @api.model
    def search_read(self, domain=None, fields=None, offset=0, limit=None, order=None):
        _logger.info(f"Search_read called with fields: {fields}")
        return super(GitRepository, self).search_read(domain=domain, fields=fields, offset=offset, limit=limit, order=order)

    def read(self, fields=None, load='_classic_read'):
        _logger.info(f"Read called with fields: {fields}")
        return super(GitRepository, self).read(fields=fields, load=load)

    @api.model
    def create(self, vals):
        repo = super(GitRepository, self).create(vals)
        repo._create_default_branch()
        return repo

    def _create_default_branch(self):
        self.env['git.branch'].create({
            'name': 'main',
            'repository_id': self.id,
            'head': 'initial commit',
        })

class GitBranch(models.Model):
    _name = 'git.branch'
    _description = 'Git Branch'

    name = fields.Char(string='Branch Name', required=True)
    repository_id = fields.Many2one('git.repository', string='Repository', required=True)
    head = fields.Char(string='Head Commit', required=True)

class GitEvent(models.Model):
    _name = 'git.event'
    _description = 'Git Event'

    event_type = fields.Selection([
        ('create_repository', 'Create Repository'),
        ('update_repository', 'Update Repository'),
        ('fork_repository', 'Fork Repository'),
        ('create_branch', 'Create Branch'),
        ('update_branch', 'Update Branch'),
        ('delete_branch', 'Delete Branch')
    ], string='Event Type')
    content = fields.Text(string='Event Content')
    created_at = fields.Datetime(string='Created At', default=fields.Datetime.now)

class GitRepositoryManager(models.Model):
    _name = 'git.repository.manager'
    _description = 'Git Repository Manager'

    @api.model
    def create_repository(self, name, path, description, maintainer_ids):
        anchor = self.env['git.repository.anchor']
        repo = anchor.create_repository(name, path, description, maintainer_ids)
        return repo.id

    @api.model
    def update_repository(self, repo_id, description=None, maintainer_ids=None):
        anchor = self.env['git.repository.anchor']
        repo = self.env['git.repository'].browse(repo_id)
        updated_repo = anchor.update_repository(repo, description, maintainer_ids)
        return updated_repo.id

    @api.model
    def fork_repository(self, original_repo_id, new_name, new_maintainer_id):
        anchor = self.env['git.repository.anchor']
        original_repo = self.env['git.repository'].browse(original_repo_id)
        forked_repo = anchor.fork_repository(original_repo, new_name, new_maintainer_id)
        return forked_repo.id

    @api.model
    def list_maintainers(self, repo_id):
        anchor = self.env['git.repository.anchor']
        repo = self.env['git.repository'].browse(repo_id)
        maintainers = anchor.list_maintainers(repo)
        return maintainers.ids
=== ./odoo_custom_addons (copy)/git_repository_anchor/models/branch_manager.py ===
from odoo import models, fields, api
from .repository_anchor import log_execution_time
from git import Repo, GitCommandError
import json
from nostr.event import Event
from nostr.key import PrivateKey
import logging

_logger = logging.getLogger(__name__)

class BranchManager(models.AbstractModel):
    _name = 'ivcs.branch.manager'
    _description = 'IVCS Branch Manager'

    name = fields.Char(string='Name', required=True)
    item_id = fields.Many2one('ivcs.item', string='IVCS Item', required=True)

    @api.model
    @log_execution_time
    def create_branch(self, repository_id, name, head):
        repo = self.env['git.repository'].browse(repository_id)
        branch = self.env['git.branch'].create({
            'name': name,
            'repository_id': repository_id,
            'head': head,
        })
        self._create_event('create_branch', branch)
        return branch.id

    @api.model
    @log_execution_time
    def update_branch(self, branch_id, new_head):
        branch = self.env['git.branch'].browse(branch_id)
        branch.write({'head': new_head})
        self._create_event('update_branch', branch)
        return branch.id

    @api.model
    @log_execution_time
    def delete_branch(self, branch_id):
        branch = self.env['git.branch'].browse(branch_id)
        self._create_event('delete_branch', branch)
        branch.unlink()
        return True

    @api.model
    def _create_event(self, event_type, branch):
        self.env['git.event'].create({
            'event_type': event_type,
            'content': f"{event_type}: {branch.name} in {branch.repository_id.name}",
        })
=== ./odoo_custom_addons (copy)/git_repository_anchor/__init__.py ===
from . import models
from . import controllers
=== ./odoo_custom_addons (copy)/git_repository_anchor/__manifest__.py ===
{
    'name': 'Git Repository Anchor',
    'version': '1.0',
    'category': 'Development',
    'summary': 'Manage Git repositories using Nostr events',
    'author': 'Your Name',
    'website': 'https://www.example.com',
    'depends': ['base', 'mail'],
    'data': [
        'security/git_repository_security.xml',
        'security/ir.model.access.csv',
        'views/git_repository_views.xml',
        'views/nostr_event_views.xml',
    ],
    'installable': True,
    'application': True,
    'auto_install': False,
    'external_dependencies': {
        'python': ['git', 'nostr'],
    },
}
=== ./odoo_custom_addons (copy)/git_repository_anchor/security/git_repository_security.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="module_category_git_repository" model="ir.module.category">
        <field name="name">Git Repository</field>
        <field name="description">Manage Git repositories</field>
        <field name="sequence">20</field>
    </record>

    <record id="group_git_repository_user" model="res.groups">
        <field name="name">User</field>
        <field name="category_id" ref="module_category_git_repository"/>
    </record>

    <record id="group_git_repository_manager" model="res.groups">
        <field name="name">Manager</field>
        <field name="category_id" ref="module_category_git_repository"/>
        <field name="implied_ids" eval="[(4, ref('group_git_repository_user'))]"/>
        <field name="users" eval="[(4, ref('base.user_root')), (4, ref('base.user_admin'))]"/>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/git_repository_anchor/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_git_repository_user,git.repository user,model_git_repository,group_git_repository_user,1,0,0,0
access_git_repository_manager,git.repository manager,model_git_repository,group_git_repository_manager,1,1,1,1
access_git_branch_user,git.branch user,model_git_branch,group_git_repository_user,1,1,1,0
access_git_branch_manager,git.branch manager,model_git_branch,group_git_repository_manager,1,1,1,1
access_git_event_user,git.event user,model_git_event,group_git_repository_user,1,0,0,0
access_git_event_manager,git.event manager,model_git_event,group_git_repository_manager,1,1,1,1
access_git_repository_manager_user,git.repository.manager user,model_git_repository_manager,group_git_repository_user,1,1,1,0
access_git_repository_manager_manager,git.repository.manager manager,model_git_repository_manager,group_git_repository_manager,1,1,1,1
access_nostr_event_user,nostr.event user,model_nostr_event,group_git_repository_user,1,0,0,0
access_nostr_event_manager,nostr.event manager,model_nostr_event,group_git_repository_manager,1,1,1,1
access_git_repository_user,git.repository user,model_git_repository,base.group_user,1,1,1,0
access_git_repository_manager,git.repository manager,model_git_repository,base.group_system,1,1,1,1
access_nostr_event_user,nostr.event user,model_nostr_event,base.group_user,1,0,0,0
access_nostr_event_manager,nostr.event manager,model_nostr_event,base.group_system,1,1,1,1
=== ./odoo_custom_addons (copy)/git_repository_anchor/security/oldgit_repository_security.xml.txt ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="module_category_git_repository" model="ir.module.category">
        <field name="name">Git Repository</field>
        <field name="description">Manage Git repositories</field>
        <field name="sequence">20</field>
    </record>

    <record id="group_git_repository_user" model="res.groups">
        <field name="name">User</field>
        <field name="category_id" ref="module_category_git_repository"/>
    </record>

    <record id="group_git_repository_manager" model="res.groups">
        <field name="name">Manager</field>
        <field name="category_id" ref="module_category_git_repository"/>
        <field name="implied_ids" eval="[(4, ref('group_git_repository_user'))]"/>
        <field name="users" eval="[(4, ref('base.user_root')), (4, ref('base.user_admin'))]"/>
    </record>

    <record id="git_repository_comp_rule" model="ir.rule">
        <field name="name">Git Repository multi-company</field>
        <field name="model_id" ref="model_git_repository"/>
        <field name="global" eval="True"/>
        <field name="domain_force">['|', ('company_id', '=', False), ('company_id', 'in', company_ids)]</field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/git_repository_anchor/tests/test_repository_anchor.py ===
from odoo.tests.common import TransactionCase
from odoo.exceptions import AccessError

class TestRepositoryAnchor(TransactionCase):

    def setUp(self):
        super(TestRepositoryAnchor, self).setUp()
        self.repo_manager = self.env['git.repository.manager'].sudo()
        self.user_admin = self.env.ref('base.user_admin')
        self.user_demo = self.env.ref('base.user_demo')

    def test_create_repository(self):
        repo_id = self.repo_manager.create_repository(
            "test-repo", "/path/to/test-repo", "Test repository", [self.user_admin.id]
        )
        repo = self.env['git.repository'].browse(repo_id)
        self.assertEqual(repo.name, "test-repo")
        self.assertEqual(repo.path, "/path/to/test-repo")
        self.assertEqual(repo.description, "Test repository")
        self.assertIn(self.user_admin, repo.maintainer_ids)
        self.assertEqual(len(repo.branch_ids), 1)
        self.assertEqual(repo.branch_ids[0].name, 'main')

    def test_update_repository(self):
        repo_id = self.repo_manager.create_repository(
            "test-repo", "Test repository", [self.user_admin.id]
        )
        updated_repo_id = self.repo_manager.update_repository(
            repo_id, "Updated description", [self.user_admin.id, self.user_demo.id]
        )
        repo = self.env['git.repository'].browse(updated_repo_id)
        self.assertEqual(repo.description, "Updated description")
        self.assertIn(self.user_demo, repo.maintainer_ids)

    def test_fork_repository(self):
        original_repo_id = self.repo_manager.create_repository(
            "original-repo", "Original repository", [self.user_admin.id]
        )
        forked_repo_id = self.repo_manager.fork_repository(
            original_repo_id, "forked-repo", self.user_demo.id
        )
        forked_repo = self.env['git.repository'].browse(forked_repo_id)
        self.assertEqual(forked_repo.name, "forked-repo")
        self.assertIn(self.user_demo, forked_repo.maintainer_ids)
        self.assertEqual(len(forked_repo.branch_ids), 1)
        self.assertEqual(forked_repo.branch_ids[0].name, 'main')

    def test_list_maintainers(self):
        repo_id = self.repo_manager.create_repository(
            "test-repo", "Test repository", [self.user_admin.id, self.user_demo.id]
        )
        maintainer_ids = self.repo_manager.list_maintainers(repo_id)
        self.assertIn(self.user_admin.id, maintainer_ids)
        self.assertIn(self.user_demo.id, maintainer_ids)

    def test_access_rights(self):
        repo_id = self.repo_manager.create_repository(
            "test-repo", "Test repository", [self.user_admin.id]
        )
        
        # Test that non-maintainer can't update the repository
        with self.assertRaises(AccessError):
            self.repo_manager.with_user(self.user_demo).update_repository(
                repo_id, "Unauthorized update"
            )

        # Test that maintainer can update the repository
        self.repo_manager.with_user(self.user_admin).update_repository(
            repo_id, "Authorized update"
        )
        repo = self.env['git.repository'].browse(repo_id)
        self.assertEqual(repo.description, "Authorized update")
=== ./odoo_custom_addons (copy)/git_repository_anchor/tests/__init__.py ===
from . import test_repository_anchor
=== ./odoo_custom_addons (copy)/git_repository_anchor/data/README.md ===
# Git Repository Anchor

This Odoo module provides a system for managing Git repositories using Nostr events. It allows users to create, update, and fork repositories, as well as manage branches and maintainers.

## Features

- Create, update, and fork Git repositories
- Manage repository maintainers
- Create and manage branches
- Log all actions as Nostr events
- Odoo views for easy management through the UI
- CLI for standalone usage

## Installation

1. Place the `git_repository_anchor` directory in your Odoo addons path.
2. Update your Odoo apps list.
3. Install the "Git Repository Anchor" module from the Odoo Apps menu.

## Usage

### Through Odoo Interface

1. Navigate to the "Git Repositories" menu item.
2. Use the provided views to manage repositories, branches, and maintainers.

### Using CLI

A CLI script is provided for standalone usage. Example usage:

```bash
python cli_script.py create --name "New Repo" --description "A new repository" --maintainers 1 2
python cli_script.py update --repo-id 1 --description "Updated description"
python cli_script.py fork --original-repo-id 1 --new-name "Forked Repo"
=== ./odoo_custom_addons (copy)/git_repository_anchor/data/git_repository_data.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <!-- Example repository data -->
        <record id="git_repository_example" model="git.repository">
            <field name="name">Example Repository</field>
            <field name="path">/path/to/example-repo</field>
            <field name="description">This is an example repository created during module installation.</field>
            <field name="maintainer_ids" eval="[(4, ref('base.user_admin'))]"/>
        </record>
    </data>
</odoo>
=== ./odoo_custom_addons (copy)/git_repository_anchor/views/nostr_event_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_nostr_event_form" model="ir.ui.view">
        <field name="name">nostr.event.form</field>
        <field name="model">nostr.event</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="event_id" readonly="1"/>
                        <field name="kind"/>
                        <field name="content"/>
                        <field name="tags"/>
                        <field name="public_key" readonly="1"/>
                        <field name="created_at" readonly="1"/>
                        <field name="signature" readonly="1"/>
                        <field name="published"/>
                        <field name="event_type"/>
                        <field name="repository_id"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_nostr_event_tree" model="ir.ui.view">
        <field name="name">nostr.event.tree</field>
        <field name="model">nostr.event</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="event_id"/>
                <field name="kind"/>
                <field name="event_type"/>
                <field name="repository_id"/>
                <field name="public_key"/>
                <field name="created_at"/>
                <field name="published"/>
            </tree>
        </field>
    </record>

    <record id="action_nostr_event" model="ir.actions.act_window">
        <field name="name">Nostr Events</field>
        <field name="res_model">nostr.event</field>
        <field name="view_mode">tree,form</field>
    </record>

    <!-- Menu item for Nostr Events -->
    <menuitem id="menu_nostr_event"
              name="Nostr Events"
              parent="menu_git_nostr_bridge_root"
              action="action_nostr_event"
              sequence="20"/>
</odoo>
=== ./odoo_custom_addons (copy)/git_repository_anchor/views/git_repository_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_repository_form" model="ir.ui.view">
        <field name="name">git.repository.form</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="path"/>
                        <field name="description"/>
                    </group>
                </sheet>
                <div class="oe_chatter">
                    <field name="message_follower_ids" widget="mail_followers"/>
                    <field name="message_ids" widget="mail_thread"/>
                </div>
            </form>
        </field>
    </record>

    <record id="view_git_repository_tree" model="ir.ui.view">
        <field name="name">git.repository.tree</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="path"/>
            </tree>
        </field>
    </record>

    <record id="action_git_repository" model="ir.actions.act_window">
        <field name="name">Git Repositories</field>
        <field name="res_model">git.repository</field>
        <field name="view_mode">tree,form</field>
    </record>

    <!-- Root menu for the module -->
    <menuitem id="menu_git_nostr_bridge_root"
              name="Git Repository Anchor"
              sequence="10"/>

    <!-- Submenu for Git Repositories -->
    <menuitem id="menu_git_repository"
              name="Git Repositories"
              parent="menu_git_nostr_bridge_root"
              action="action_git_repository"
              sequence="10"/>
</odoo>
=== ./odoo_custom_addons (copy)/git_repository_anchor/views/repository_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data>
        <!-- Repository Form View -->
        <record id="view_git_repository_form" model="ir.ui.view">
            <field name="name">git.repository.form</field>
            <field name="model">git.repository</field>
            <field name="arch" type="xml">
                <form string="Git Repository">
                    <sheet>
                        <group>
                            <field name="name"/>
                            <field name="path"/>
                            <field name="description"/>
                            <field name="maintainer_ids" widget="many2many_tags"/>
                            <field name="created_at"/>
                            <field name="last_updated"/>
                        </group>
                        <notebook>
                            <page string="Branches">
                                <field name="branch_ids">
                                    <tree editable="bottom">
                                        <field name="name"/>
                                        <field name="head"/>
                                    </tree>
                                </field>
                            </page>
                        </notebook>
                    </sheet>
                </form>
            </field>
        </record>

        <!-- Repository Tree View -->
        <record id="view_git_repository_tree" model="ir.ui.view">
            <field name="name">git.repository.tree</field>
            <field name="model">git.repository</field>
            <field name="arch" type="xml">
                <tree string="Git Repositories">
                    <field name="name"/>
                    <field name="path"/>
                    <field name="description"/>
                    <field name="created_at"/>
                    <field name="last_updated"/>
                </tree>
            </field>
        </record>

        <!-- Repository Search View -->
        <record id="view_git_repository_search" model="ir.ui.view">
            <field name="name">git.repository.search</field>
            <field name="model">git.repository</field>
            <field name="arch" type="xml">
                <search string="Search Repositories">
                    <field name="name"/>
                    <field name="path"/>
                    <field name="description"/>
                    <field name="maintainer_ids"/>
                    <filter string="My Repositories" name="my_repositories" domain="[('maintainer_ids', 'in', uid)]"/>
                    <group expand="0" string="Group By">
                        <filter string="Created Date" name="group_by_created_at" context="{'group_by': 'created_at:month'}"/>
                    </group>
                </search>
            </field>
        </record>

        <!-- Repository Action -->
        <record id="action_git_repository" model="ir.actions.act_window">
            <field name="name">Git Repositories</field>
            <field name="res_model">git.repository</field>
            <field name="view_mode">tree,form</field>
            <field name="search_view_id" ref="view_git_repository_search"/>
        </record>

        <!-- Menu Items -->
        <menuitem id="menu_git_repository_root" name="Git Repositories" sequence="10"/>
        <menuitem id="menu_git_repository" parent="menu_git_repository_root" action="action_git_repository" sequence="10"/>
    </data>
</odoo>
=== ./odoo_custom_addons (copy)/git_repository_anchor/controllers/__init__.py ===
from . import main
=== ./odoo_custom_addons (copy)/git_repository_anchor/controllers/main.py ===
from odoo import http
from odoo.http import request

class GitRepositoryController(http.Controller):
    @http.route('/git/repository/create', type='json', auth='user')
    def create_repository(self, name, path, description, maintainer_ids):
        repo_manager = request.env['git.repository.manager'].sudo()
        repo_id = repo_manager.create_repository(name, path, description, maintainer_ids)
        return {'success': True, 'repository_id': repo_id}

    @http.route('/git/repository/update', type='json', auth='user')
    def update_repository(self, repo_id, description=None, maintainer_ids=None):
        repo_manager = request.env['git.repository.manager'].sudo()
        updated_repo_id = repo_manager.update_repository(repo_id, description, maintainer_ids)
        return {'success': True, 'repository_id': updated_repo_id}

    @http.route('/git/repository/fork', type='json', auth='user')
    def fork_repository(self, original_repo_id, new_name):
        repo_manager = request.env['git.repository.manager'].sudo()
        forked_repo_id = repo_manager.fork_repository(original_repo_id, new_name, request.env.user.id)
        return {'success': True, 'repository_id': forked_repo_id}

    @http.route('/git/repository/list_maintainers', type='json', auth='user')
    def list_maintainers(self, repo_id):
        repo_manager = request.env['git.repository.manager'].sudo()
        maintainer_ids = repo_manager.list_maintainers(repo_id)
        return {'success': True, 'maintainer_ids': maintainer_ids}
=== ./odoo_custom_addons (copy)/git_branch_manager/git-branch-manager-module.py ===
# Directory structure:
# git_branch_manager/
# ├── __init__.py
# ├── __manifest__.py
# ├── models/
# │   ├── __init__.py
# │   ├── branch.py
# │   ├── event.py
# │   └── branch_manager.py
# ├── controllers/
# │   ├── __init__.py
# │   └── main.py
# ├── security/
# │   └── ir.model.access.csv
# └── views/
#     ├── branch_views.xml
#     └── event_views.xml

# __init__.py
from . import models
from . import controllers

# __manifest__.py
{
    'name': 'Git Branch Manager',
    'version': '1.0',
    'summary': 'Manage Git branches using Nostr events',
    'description': """
    This module allows you to manage Git branches using Nostr events.
    It integrates with the Nostr-Odoo application to handle branch operations.
    """,
    'author': 'Your Name',
    'depends': ['base'],
    'data': [
        'security/ir.model.access.csv',
        'views/branch_views.xml',
        'views/event_views.xml',
    ],
    'installable': True,
    'application': True,
}

# models/__init__.py
from . import branch
from . import event
from . import branch_manager

# models/branch.py
from odoo import models, fields

class GitBranch(models.Model):
    _name = 'git.branch'
    _description = 'Git Branch'

    name = fields.Char(string='Branch Name', required=True)
    head = fields.Char(string='Head Commit', required=True)
    created_at = fields.Datetime(string='Created At')
    last_updated = fields.Datetime(string='Last Updated')

# models/event.py
from odoo import models, fields

class GitEvent(models.Model):
    _name = 'git.event'
    _description = 'Git Event'

    event_type = fields.Selection([('create', 'Create'), ('update', 'Update'), ('delete', 'Delete')], string='Event Type')
    content = fields.Text(string='Event Content')
    created_at = fields.Datetime(string='Created At', default=fields.Datetime.now)

# models/branch_manager.py
from odoo import models, api
from nostr.event import Event
from nostr.key import PrivateKey
import json
import logging
import time

_logger = logging.getLogger(__name__)

class GitBranchManager(models.AbstractModel):
    _name = 'git.branch.manager'
    _description = 'Git Branch Manager'

    @api.model
    def create_branch(self, name, head):
        _logger.info(f"Creating branch: {name} with head: {head}")
        start_time = time.time()

        try:
            if self.env['git.branch'].search([('name', '=', name)]):
                raise ValueError(f"Branch {name} already exists")

            branch = self.env['git.branch'].create({
                'name': name,
                'head': head,
                'created_at': fields.Datetime.now(),
                'last_updated': fields.Datetime.now(),
            })

            event = self._create_branch_event(branch, 'create')
            self._publish_event(event)

            end_time = time.time()
            _logger.info(f"Branch {name} created in {end_time - start_time:.2f} seconds")
            return True
        except Exception as e:
            _logger.exception(f"Error creating branch: {str(e)}")
            raise

    @api.model
    def update_branch(self, name, new_head):
        _logger.info(f"Updating branch: {name} to new head: {new_head}")
        start_time = time.time()

        try:
            branch = self.env['git.branch'].search([('name', '=', name)])
            if not branch:
                raise ValueError(f"Branch {name} does not exist")

            branch.write({
                'head': new_head,
                'last_updated': fields.Datetime.now(),
            })

            event = self._create_branch_event(branch, 'update')
            self._publish_event(event)

            end_time = time.time()
            _logger.info(f"Branch {name} updated in {end_time - start_time:.2f} seconds")
            return True
        except Exception as e:
            _logger.exception(f"Error updating branch: {str(e)}")
            raise

    @api.model
    def delete_branch(self, name):
        _logger.info(f"Deleting branch: {name}")
        start_time = time.time()

        try:
            branch = self.env['git.branch'].search([('name', '=', name)])
            if not branch:
                raise ValueError(f"Branch {name} does not exist")

            event = self._create_branch_event(branch, 'delete')
            branch.unlink()
            self._publish_event(event)

            end_time = time.time()
            _logger.info(f"Branch {name} deleted in {end_time - start_time:.2f} seconds")
            return True
        except Exception as e:
            _logger.exception(f"Error deleting branch: {str(e)}")
            raise

    def _create_branch_event(self, branch, operation):
        event = Event()
        event.kind = 31227  # Custom event kind for git branch operations
        event.content = json.dumps({
            'operation': operation,
            'name': branch.name,
            'head': branch.head,
            'timestamp': fields.Datetime.now().isoformat(),
        })
        event.tags = [['e', 'git_branch']]

        private_key = PrivateKey()  # In practice, securely store and retrieve this
        event.sign(private_key.hex())

        return event

    def _publish_event(self, event):
        self.env['git.event'].create({
            'event_type': json.loads(event.content)['operation'],
            'content': event.to_message(),
        })
        # Here you would also publish the event to the Nostr network
        # This part depends on how you've implemented your Nostr client in Odoo

# controllers/__init__.py
from . import main

# controllers/main.py
from odoo import http
from odoo.http import request

class GitBranchController(http.Controller):

    @http.route('/git/branch/create', type='json', auth='user')
    def create_branch(self, name, head):
        branch_manager = request.env['git.branch.manager'].sudo()
        result = branch_manager.create_branch(name, head)
        return {'success': result}

    @http.route('/git/branch/update', type='json', auth='user')
    def update_branch(self, name, new_head):
        branch_manager = request.env['git.branch.manager'].sudo()
        result = branch_manager.update_branch(name, new_head)
        return {'success': result}

    @http.route('/git/branch/delete', type='json', auth='user')
    def delete_branch(self, name):
        branch_manager = request.env['git.branch.manager'].sudo()
        result = branch_manager.delete_branch(name)
        return {'success': result}

# security/ir.model.access.csv
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_git_branch_user,access_git_branch_user,model_git_branch,,1,1,1,1
access_git_event_user,access_git_event_user,model_git_event,,1,1,1,1

# views/branch_views.xml
<?xml version="1.0" encoding="UTF-8"?>
<odoo>
    <record id="view_git_branch_form" model="ir.ui.view">
        <field name="name">git.branch.form</field>
        <field name="model">git.branch</field>
        <field name="arch" type="xml">
            <form string="Git Branch">
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="head"/>
                        <field name="created_at"/>
                        <field name="last_updated"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_git_branch_tree" model="ir.ui.view">
        <field name="name">git.branch.tree</field>
        <field name="model">git.branch</field>
        <field name="arch" type="xml">
            <tree string="Git Branches">
                <field name="name"/>
                <field name="head"/>
                <field name="created_at"/>
                <field name="last_updated"/>
            </tree>
        </field>
    </record>

    <record id="action_git_branch" model="ir.actions.act_window">
        <field name="name">Branches</field>
        <field name="res_model">git.branch</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_git_branch_root" name="Git Branches" sequence="10"/>
    <menuitem id="menu_git_branch" parent="menu_git_branch_root"
              action="action_git_branch" sequence="10"/>
</odoo>

# views/event_views.xml
<?xml version="1.0" encoding="UTF-8"?>
<odoo>
    <record id="view_git_event_form" model="ir.ui.view">
        <field name="name">git.event.form</field>
        <field name="model">git.event</field>
        <field name="arch" type="xml">
            <form string="Git Event">
                <sheet>
                    <group>
                        <field name="event_type"/>
                        <field name="content"/>
                        <field name="created_at"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_git_event_tree" model="ir.ui.view">
        <field name="name">git.event.tree</field>
        <field name="model">git.event</field>
        <field name="arch" type="xml">
            <tree string="Git Events">
                <field name="event_type"/>
                <field name="content"/>
                <field name="created_at"/>
            </tree>
        </field>
    </record>

    <record id="action_git_event" model="ir.actions.act_window">
        <field name="name">Events</field>
        <field name="res_model">git.event</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_git_events" parent="menu_git_branch_root"
              action="action_git_event" sequence="20"/>
</odoo>
=== ./odoo_custom_addons (copy)/nostr_auth/models/__init__.py ===
# File: odoo_custom_addons/nostr_auth/models/__init__.py
from . import res_users
from . import nostr_auth_module
=== ./odoo_custom_addons (copy)/nostr_auth/models/res_users.py ===
# File: odoo_custom_addons/nostr_auth/models/res_users.py

from odoo import models, fields, api
from odoo.exceptions import ValidationError
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import hashes
import base64

class ResUsers(models.Model):
    _inherit = 'res.users'

    nostr_public_key = fields.Char(string='Nostr Public Key')
    nostr_private_key = fields.Char(string='Nostr Private Key')
    nostr_relay_url = fields.Char(string='Nostr Relay URL')

    @api.model_create_multi
    def create(self, vals_list):
        nostr_auth = self.env['nostr.auth.module']
        for vals in vals_list:
            if not vals.get('nostr_private_key'):
                keys = nostr_auth.generate_keypair()
                vals['nostr_private_key'] = keys['private_key']
                vals['nostr_public_key'] = keys['public_key']
        return super(ResUsers, self).create(vals_list)

    @api.constrains('nostr_public_key')
    def _check_nostr_public_key(self):
        for user in self:
            if user.nostr_public_key:
                if not user.nostr_public_key.startswith('npub1'):
                    raise ValidationError("Invalid Nostr public key format. It should start with 'npub1'.")

    @api.model
    def authenticate_nostr(self, public_key, signature, message):
        user = self.search([('nostr_public_key', '=', public_key)], limit=1)
        if user:
            nostr_auth = self.env['nostr.auth.module']
            if nostr_auth.verify_signature(public_key, message, signature):
                return user.id
        return False
=== ./odoo_custom_addons (copy)/nostr_auth/models/nostr_auth_module.py ===
# File: odoo_custom_addons/nostr_auth/models/nostr_auth_module.py

from odoo import models, api
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.serialization import Encoding, PublicFormat, PrivateFormat, NoEncryption
import base64
from bech32 import bech32_encode, bech32_decode, convertbits

class NostrAuthModule(models.AbstractModel):
    _name = 'nostr.auth.module'
    _description = 'Nostr Authentication Module'

    @api.model
    def generate_keypair(self):
        private_key = ec.generate_private_key(ec.SECP256K1())
        public_key = private_key.public_key()
        
        private_bytes = private_key.private_numbers().private_value.to_bytes(32, 'big')
        public_bytes = public_key.public_bytes(
            encoding=Encoding.X962,
            format=PublicFormat.UncompressedPoint
        )[1:]
        
        return {
            'private_key': self.bytes_to_nsec(private_bytes),
            'public_key': self.bytes_to_npub(public_bytes)
        }

    @api.model
    def verify_signature(self, public_key, message, signature):
        try:
            public_key_bytes = self.npub_to_bytes(public_key)
            public_key_obj = ec.EllipticCurvePublicKey.from_encoded_point(ec.SECP256K1(), b'\x04' + public_key_bytes)
            signature_bytes = base64.b64decode(signature)
            public_key_obj.verify(
                signature_bytes,
                message.encode('utf-8'),
                ec.ECDSA(hashes.SHA256())
            )
            return True
        except:
            return False

    @api.model
    def bytes_to_npub(self, key_bytes):
        data = convertbits(key_bytes[:32], 8, 5)
        return bech32_encode('npub', data)

    @api.model
    def bytes_to_nsec(self, key_bytes):
        data = convertbits(key_bytes[:32], 8, 5)
        return bech32_encode('nsec', data)
        
    @api.model
    def npub_to_bytes(self, npub):
        hrp, data = bech32_decode(npub)
        return bytes(convertbits(data, 5, 8, False))

    @api.model
    def nsec_to_bytes(self, nsec):
        hrp, data = bech32_decode(nsec)
        return bytes(convertbits(data, 5, 8, False))
=== ./odoo_custom_addons (copy)/nostr_auth/__init__.py ===
from . import models
=== ./odoo_custom_addons (copy)/nostr_auth/__manifest__.py ===
# File: odoo_custom_addons/nostr_auth/__manifest__.py
{
    'name': 'Nostr Authentication',
    'version': '1.0',
    'category': 'Authentication',
    'summary': 'Extends user model with Nostr fields and authentication',
    'depends': ['base', 'auth_signup'],
    'data': [
        'views/res_users_views.xml',
    ],
    'installable': True,
    'application': False,
    'auto_install': False,
    'external_dependencies': {
        'python': ['cryptography', 'bech32'],
    },
}
=== ./odoo_custom_addons (copy)/nostr_auth/views/res_users_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_users_form_nostr" model="ir.ui.view">
        <field name="name">res.users.form.nostr</field>
        <field name="model">res.users</field>
        <field name="inherit_id" ref="base.view_users_form"/>
        <field name="arch" type="xml">
            <xpath expr="//page[@name='access_rights']" position="after">
                <page string="Nostr Authentication" name="nostr_auth">
                    <group>
                        <field name="nostr_public_key"/>
                        <field name="nostr_relay_url"/>
                    </group>
                </page>
            </xpath>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/nostr_auth/controllers/__init__.py ===
from . import main
=== ./odoo_custom_addons (copy)/nostr_auth/controllers/main.py ===
# controllers/main.py
from odoo import http
from odoo.http import request
import json

class NostrAuthController(http.Controller):
    @http.route('/web/nostr/authenticate', type='json', auth='none')
    def authenticate(self, public_key, signature, message):
        uid = request.env['res.users'].sudo().authenticate_nostr(public_key, signature, message)
        if uid:
            request.session.authenticate(request.session.db, uid, public_key)
            return {'success': True, 'uid': uid}
        return {'success': False, 'error': 'Authentication failed'}
=== ./odoo_custom_addons (copy)/nostr_identity/models/__init__.py ===
# models/__init__.py
from . import nostr_identity
from . import nostr_identity_verifier
from . import nostr_message
=== ./odoo_custom_addons (copy)/nostr_identity/models/nostr_identity_verifier.py ===
from odoo import models, fields, api, _
from odoo.exceptions import UserError
import logging
import json
import websocket
import threading
import ssl
import time
from odoo.tools import config

_logger = logging.getLogger(__name__)

class NostrIdentityVerifier(models.Model):
    _name = 'nostr.identity.verifier'
    _description = 'Nostr Identity Verifier'

    name = fields.Char(string='Name', required=True)
    active = fields.Boolean(default=True)
    relay_url = fields.Char(string='Relay URL', required=True)
    websocket_state = fields.Selection([
        ('disconnected', 'Disconnected'),
        ('connecting', 'Connecting'),
        ('connected', 'Connected')
    ], default='disconnected', string='WebSocket State', readonly=True)
    last_error = fields.Text(string='Last Error', readonly=True)

    def _get_ws_connection(self):
        return self.env.context.get('ws_connection')

    def _set_ws_connection(self, ws):
        self = self.with_context(ws_connection=ws)

    def connect_to_relay(self):
        self.ensure_one()
        if self.websocket_state == 'connected':
            return True

        self.websocket_state = 'connecting'
        self.last_error = False

        try:
            ws = self._create_websocket(self.relay_url)
            self._set_ws_connection(ws)
            
            # Wait for connection to establish or fail
            for _ in range(20):  # Wait up to 10 seconds
                if self.websocket_state == 'connected':
                    return True
                elif self.websocket_state == 'disconnected':
                    raise UserError(self.last_error or _("Connection failed"))
                time.sleep(0.5)

            raise UserError(_("Connection timeout"))
        except Exception as e:
            self.websocket_state = 'disconnected'
            self.last_error = str(e)
            _logger.error(f"Failed to connect to {self.relay_url}: {str(e)}")
            return False

    def _create_websocket(self, relay_url):
        def on_message(ws, message):
            with self.pool.cursor() as new_cr:
                self.with_env(self.env(cr=new_cr))._handle_message(message)

        def on_error(ws, error):
            with self.pool.cursor() as new_cr:
                self.with_env(self.env(cr=new_cr))._handle_error(error)

        def on_close(ws, close_status_code, close_msg):
            with self.pool.cursor() as new_cr:
                self.with_env(self.env(cr=new_cr))._handle_close()

        def on_open(ws):
            with self.pool.cursor() as new_cr:
                self.with_env(self.env(cr=new_cr))._handle_open()

        ws = websocket.WebSocketApp(relay_url,
                                    on_message=on_message,
                                    on_error=on_error,
                                    on_close=on_close,
                                    on_open=on_open)

        wst = threading.Thread(target=lambda: ws.run_forever(sslopt={"cert_reqs": ssl.CERT_NONE}))
        wst.daemon = True
        wst.start()

        return ws

    def _handle_message(self, message):
        _logger.info(f"Received message from {self.relay_url}: {message}")
        self.env['nostr.message'].create({
            'verifier_id': self.id,
            'content': message
        })

    def _handle_error(self, error):
        _logger.error(f"WebSocket error for {self.relay_url}: {error}")
        self.write({'last_error': str(error), 'websocket_state': 'disconnected'})

    def _handle_close(self):
        _logger.info(f"WebSocket connection closed for {self.relay_url}")
        self.write({'websocket_state': 'disconnected'})

    def _handle_open(self):
        _logger.info(f"WebSocket connection opened for {self.relay_url}")
        self.write({'websocket_state': 'connected'})

    def publish_event(self, event):
        self.ensure_one()
        if self.websocket_state != 'connected':
            if not self.connect_to_relay():
                raise UserError(_("Failed to connect to relay"))

        try:
            message = json.dumps(["EVENT", event])
            ws = self._get_ws_connection()
            if ws:
                ws.send(message)
                _logger.info(f"Published event to {self.relay_url}")
                return True
            else:
                raise UserError(_("WebSocket connection is not available"))
        except Exception as e:
            _logger.error(f"Failed to publish event to {self.relay_url}: {str(e)}")
            raise UserError(_("Failed to publish event: %s") % str(e))

    @api.model
    def process_messages(self):
        messages = self.env['nostr.message'].search([('processed', '=', False)])
        for message in messages:
            try:
                # Process the message here
                _logger.info(f"Processing message: {message.content}")
                # Add your message processing logic here
                message.write({'processed': True})
            except Exception as e:
                _logger.error(f"Error processing message {message.id}: {str(e)}")

    def close_connection(self):
        self.ensure_one()
        ws = self._get_ws_connection()
        if ws:
            try:
                ws.close()
            except Exception as e:
                _logger.error(f"Error closing WebSocket for {self.relay_url}: {str(e)}")
        self._set_ws_connection(None)
        self.write({'websocket_state': 'disconnected'})
=== ./odoo_custom_addons (copy)/nostr_identity/models/nostr_identity.py ===
from odoo import models, fields, api, _
from odoo.exceptions import UserError, ValidationError
import base64
from cryptography.fernet import Fernet
import logging
import secrets
from nostr.key import PrivateKey
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import serialization
import bech32

_logger = logging.getLogger(__name__)

def hex_to_nostr_key(hex_key, prefix):
    # Convert hex to bytes
    data = bytes.fromhex(hex_key)
    
    # Convert to 5-bit words
    words = bech32.convertbits(data, 8, 5)
    
    # Encode with bech32
    encoded = bech32.bech32_encode(prefix, words)
    
    return encoded

class NostrIdentity(models.Model):
    _name = 'nostr.identity'
    _description = 'Nostr Identity'

    name = fields.Char(string='Name', required=True)
    public_key = fields.Char(string='Public Key (hex)', readonly=True)
    private_key = fields.Char(string='Private Key (hex)', readonly=True)
    public_key_bech32 = fields.Char(string='Public Key (npub)', readonly=True, compute='_compute_bech32_keys')
    private_key_bech32 = fields.Char(string='Private Key (nsec)', readonly=True, compute='_compute_bech32_keys')
    relay_urls = fields.Text(string='Relay URLs')
    profile_data = fields.Text(string='Profile Data')

    @api.model
    def create(self, vals):
        if 'public_key' not in vals or 'private_key' not in vals:
            try:
                private_key = PrivateKey()
                public_key = private_key.public_key
                vals['private_key'] = private_key.hex()
                vals['public_key'] = public_key.hex()
            except Exception as e:
                _logger.error(f"Failed to generate Nostr keys: {str(e)}")
                raise UserError(_("Failed to generate Nostr keys: %s") % str(e))
        return super(NostrIdentity, self).create(vals)

    @api.depends('public_key', 'private_key')
    def _compute_bech32_keys(self):
        for record in self:
            if record.public_key:
                record.public_key_bech32 = hex_to_nostr_key(record.public_key, "npub")
            else:
                record.public_key_bech32 = False
            
            if record.private_key:
                record.private_key_bech32 = hex_to_nostr_key(record.private_key, "nsec")
            else:
                record.private_key_bech32 = False

    def get_private_key(self):
        self.ensure_one()
        try:
            encryption_key = self.env['ir.config_parameter'].sudo().get_param('nostr.encryption_key')
            if not encryption_key:
                raise UserError(_("Encryption key not found. Unable to decrypt private key."))
            
            fernet = Fernet(encryption_key.encode())
            decrypted_private_key = fernet.decrypt(base64.b64decode(self.encrypted_private_key))
            return PrivateKey(bytes.fromhex(decrypted_private_key.decode()))
        except Exception as e:
            _logger.error(f"Failed to decrypt private key: {str(e)}")
            raise UserError(_("Failed to decrypt private key: %s") % str(e))

    def get_public_key_bech32(self):
        return self.public_key_bech32
=== ./odoo_custom_addons (copy)/nostr_identity/models/nostr_message.py ===
# models/nostr_message.py

from odoo import models, fields

class NostrMessage(models.Model):
    _name = 'nostr.message'
    _description = 'Nostr Message'

    verifier_id = fields.Many2one('nostr.identity.verifier', string='Verifier', required=True, ondelete='cascade')
    content = fields.Text(string='Message Content', required=True)
    processed = fields.Boolean(string='Processed', default=False)
=== ./odoo_custom_addons (copy)/nostr_identity/__init__.py ===
# nostr_identity/__init__.py

from . import models
from . import nostr_cleanup

def post_init_hook(cr, registry):
    from odoo import api, SUPERUSER_ID
    env = api.Environment(cr, SUPERUSER_ID, {})
    
    # Generate encryption key if it doesn't exist
    if not env['ir.config_parameter'].get_param('nostr.encryption_key'):
        from cryptography.fernet import Fernet
        encryption_key = Fernet.generate_key()
        env['ir.config_parameter'].set_param('nostr.encryption_key', encryption_key.decode())

def uninstall_hook(cr, registry):
    from odoo import api, SUPERUSER_ID
    env = api.Environment(cr, SUPERUSER_ID, {})
    
    # Remove the encryption key
    env['ir.config_parameter'].set_param('nostr.encryption_key', False)
    
    # Close all active WebSocket connections
    verifiers = env['nostr.identity.verifier'].search([])
    for verifier in verifiers:
        verifier.close_connection()
=== ./odoo_custom_addons (copy)/nostr_identity/__manifest__.py ===
# __manifest__.py
{
    'name': 'Nostr Identity Verifier',
    'version': '1.0',
    'category': 'Tools',
    'summary': 'Integrate Nostr identity verification into Odoo',
    'author': 'Your Name',
    'website': 'https://www.example.com',
    'license': 'LGPL-3',
    'depends': ['base', 'mail'],
    'data': [
        'security/nostr_security.xml',
        'security/ir.model.access.csv',
        'views/nostr_identity_views.xml',
        'data/ir_cron_data.xml',
    ],
    'demo': [],
    'external_dependencies': {
        'python': ['websocket-client', 'nostr'],
    },
    'installable': True,
    'application': False,
    'auto_install': False,
    'post_init_hook': 'post_init_hook',
    'uninstall_hook': 'uninstall_hook',
}
=== ./odoo_custom_addons (copy)/nostr_identity/nostr_cleanup.py ===
# nostr_identity/nostr_cleanup.py

import atexit
from odoo import api, SUPERUSER_ID

def cleanup_connections():
    try:
        with api.Environment.manage():
            env = api.Environment(odoo.registry(odoo.tools.config['db_name']).cursor(), SUPERUSER_ID, {})
            verifiers = env['nostr.identity.verifier'].search([])
            for verifier in verifiers:
                verifier.close_connection()
            env.cr.commit()
    except Exception as e:
        # Log the error, but don't raise it to avoid interfering with Odoo's shutdown process
        _logger.error(f"Error during Nostr connection cleanup: {e}")
    finally:
        if env and env.cr:
            env.cr.close()

atexit.register(cleanup_connections)
=== ./odoo_custom_addons (copy)/nostr_identity/security/nostr_security.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <!-- Rule: Users can only see their own Nostr Identity records -->
        <record id="rule_nostr_identity_users" model="ir.rule">
            <field name="name">Users can only see their own Nostr Identity</field>
            <field name="model_id" ref="model_nostr_identity"/>
            <field name="domain_force">[('create_uid', '=', user.id)]</field>
            <field name="groups" eval="[(4, ref('base.group_user'))]"/>
            <field name="perm_read" eval="True"/>
            <field name="perm_write" eval="False"/>
            <field name="perm_create" eval="False"/>
            <field name="perm_unlink" eval="False"/>
        </record>

        <!-- Rule: Managers can see all Nostr Identity records -->
        <record id="rule_nostr_identity_managers" model="ir.rule">
            <field name="name">Managers can see all Nostr Identity records</field>
            <field name="model_id" ref="model_nostr_identity"/>
            <field name="domain_force">[(1, '=', 1)]</field>
            <field name="groups" eval="[(4, ref('base.group_system'))]"/>
            <field name="perm_read" eval="True"/>
            <field name="perm_write" eval="True"/>
            <field name="perm_create" eval="True"/>
            <field name="perm_unlink" eval="True"/>
        </record>
    </data>
</odoo>
=== ./odoo_custom_addons (copy)/nostr_identity/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_nostr_identity_user,nostr.identity user,model_nostr_identity,base.group_user,1,1,1,0
access_nostr_identity_manager,nostr.identity manager,model_nostr_identity,base.group_system,1,1,1,1
access_nostr_identity_verifier_user,nostr.identity.verifier user,model_nostr_identity_verifier,base.group_user,1,0,0,0
access_nostr_identity_verifier_manager,nostr.identity.verifier manager,model_nostr_identity_verifier,base.group_system,1,1,1,1
access_nostr_message_user,nostr.message user,model_nostr_message,base.group_user,1,0,0,0
access_nostr_message_manager,nostr.message manager,model_nostr_message,base.group_system,1,1,1,1
=== ./odoo_custom_addons (copy)/nostr_identity/data/ir_cron_data.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <record id="ir_cron_nostr_process_messages" model="ir.cron">
            <field name="name">Nostr: Process Messages</field>
            <field name="model_id" ref="model_nostr_identity_verifier"/>
            <field name="state">code</field>
            <field name="code">model.process_messages()</field>
            <field name="interval_number">5</field>
            <field name="interval_type">minutes</field>
            <field name="numbercall">-1</field>
            <field name="doall" eval="False"/>
            <field name="active" eval="True"/>
        </record>
    </data>
</odoo>
=== ./odoo_custom_addons (copy)/nostr_identity/views/nostr_identity_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <!-- Nostr Identity Views -->
    <record id="view_nostr_identity_tree" model="ir.ui.view">
        <field name="name">nostr.identity.tree</field>
        <field name="model">nostr.identity</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="public_key"/>
                <field name="public_key_bech32"/>
            </tree>
        </field>
    </record>

    <record id="view_nostr_identity_form" model="ir.ui.view">
        <field name="name">nostr.identity.form</field>
        <field name="model">nostr.identity</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="public_key"/>
                        <field name="public_key_bech32"/>
                        <field name="relay_urls"/>
                        <field name="profile_data"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <!-- The rest of the XML remains unchanged -->
    <!-- Nostr Identity Verifier Views -->
    <record id="view_nostr_identity_verifier_tree" model="ir.ui.view">
        <field name="name">nostr.identity.verifier.tree</field>
        <field name="model">nostr.identity.verifier</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="relay_url"/>
                <field name="websocket_state"/>
            </tree>
        </field>
    </record>

    <record id="view_nostr_identity_verifier_form" model="ir.ui.view">
        <field name="name">nostr.identity.verifier.form</field>
        <field name="model">nostr.identity.verifier</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="connect_to_relay" string="Connect" type="object" class="oe_highlight" attrs="{'invisible': [('websocket_state', '=', 'connected')]}"/>
                    <button name="close_connection" string="Disconnect" type="object" attrs="{'invisible': [('websocket_state', '!=', 'connected')]}"/>
                </header>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="relay_url"/>
                        <field name="active"/>
                        <field name="websocket_state"/>
                        <field name="last_error"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <!-- Action Windows -->
    <record id="action_nostr_identity" model="ir.actions.act_window">
        <field name="name">Nostr Identities</field>
        <field name="res_model">nostr.identity</field>
        <field name="view_mode">tree,form</field>
    </record>

    <record id="action_nostr_identity_verifier" model="ir.actions.act_window">
        <field name="name">Nostr Identity Verifiers</field>
        <field name="res_model">nostr.identity.verifier</field>
        <field name="view_mode">tree,form</field>
    </record>

    <!-- Menu Items -->
    <menuitem id="menu_nostr_root" name="Nostr" sequence="10"/>
    <menuitem id="menu_nostr_identity" name="Identities" parent="menu_nostr_root" action="action_nostr_identity" sequence="10"/>
    <menuitem id="menu_nostr_identity_verifier" name="Verifiers" parent="menu_nostr_root" action="action_nostr_identity_verifier" sequence="20"/>
</odoo>
=== ./odoo_custom_addons (copy)/nostr_bridge/models/git_repository.py ===
# File: odoo_custom_addons/nostr_bridge/models/git_repository.py

from odoo import models, fields, api
import git
import os

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Repository Name', required=True)
    path = fields.Char(string='Repository Path', required=True)
    
    @api.model
    def create(self, vals):
        repo = super(GitRepository, self).create(vals)
        if not os.path.exists(repo.path):
            os.makedirs(repo.path)
            git.Repo.init(repo.path)
        return repo

    def commit_changes(self, message):
        repo = git.Repo(self.path)
        repo.git.add(A=True)
        commit = repo.index.commit(message)
        
        event_manager = self.env['nostr.event.manager']
        event = event_manager.create_git_event(self.path, commit.hexsha)
        event_manager.publish_event(event)
        
        return commit.hexsha
=== ./odoo_custom_addons (copy)/nostr_bridge/models/__init__.py ===
# File: odoo_custom_addons/nostr_bridge/models/__init__.py

from . import res_users
from . import mail_message
from . import nostr_adapter
from . import res_config_settings
from . import res_partner
from . import nostr_event_manager
from . import git_repository
=== ./odoo_custom_addons (copy)/nostr_bridge/models/res_users.py ===
"""from odoo import models, fields, api
from nostr.key import PrivateKey

class ResUsers(models.Model):
    _inherit = 'res.users'

    #nostr_private_key = fields.Char(string="Nostr Private Key")
    #nostr_public_key = fields.Char(string="Nostr Public Key", compute='_compute_public_key')
    #nostr_relay_url = fields.Char(string="Nostr Relay URL")

    nostr_public_key = fields.Char(string="Nostr Public Key")
    nostr_private_key = fields.Char(string="Nostr Private Key")
    nostr_relay_url = fields.Char(string="Nostr Relay URL")

    @api.model
    def create(self, vals):
        if not vals.get('nostr_private_key'):
            private_key = PrivateKey()
            vals['nostr_private_key'] = private_key.bech32()
        return super(ResUsers, self).create(vals)

    def write(self, vals):
        # Here you might want to handle updates to Nostr fields
        return super(ResUsers, self).write(vals)

    @api.depends('nostr_private_key')
    def _compute_public_key(self):
        for user in self:
            if user.nostr_private_key:
                private_key = PrivateKey.from_nsec(user.nostr_private_key)
                user.nostr_public_key = private_key.public_key.bech32()
            else:
                user.nostr_public_key = False
"""

"""from odoo import models, fields, api

class ResUsers(models.Model):
    _inherit = 'res.users'

    nostr_public_key = fields.Char(string="Nostr Public Key")
    nostr_private_key = fields.Char(string="Nostr Private Key")
    nostr_relay_url = fields.Char(string="Nostr Relay URL")

    @api.model
    def create(self, vals):
        # Here you might want to generate Nostr keys if they're not provided
        return super(ResUsers, self).create(vals)

    def write(self, vals):
        # Here you might want to handle updates to Nostr fields
        return super(ResUsers, self).write(vals)"""
        
        
from odoo import models, fields

class ResUsers(models.Model):
    _inherit = 'res.users'

    nostr_public_key = fields.Char(string="Nostr Public Key")
    nostr_private_key = fields.Char(string="Nostr Private Key")
    nostr_relay_url = fields.Char(string="Nostr Relay URL")
=== ./odoo_custom_addons (copy)/nostr_bridge/models/nostr_adapter.py ===
import requests
import websocket
from odoo import models, api
from websocket._exceptions import WebSocketConnectionClosedException
from odoo.exceptions import UserError
from nostr.event import Event
from nostr.key import PrivateKey
from nostr.relay_manager import RelayManager
import logging
import time

_logger = logging.getLogger(__name__)

class NostrAdapter(models.AbstractModel):
    _name = 'nostr.adapter'
    _description = 'Nostr Adapter'

    @api.model
    def get_relay_manager(self):
        ICPSudo = self.env['ir.config_parameter'].sudo()
        relay_urls = ICPSudo.get_param('nostr_bridge.relay_urls', '').split(',')
        if not relay_urls:
            raise UserError("Nostr relay URL is not configured. Please set it in the settings.")
        _logger.info(f"Nostr relay URLs: {relay_urls}")

        relay_manager = RelayManager()
        for url in relay_urls:
            url = url.strip()
            if url:  # Only add non-empty URLs
                _logger.info(f"Adding relay: {url}")
                relay_manager.add_relay(url)
        return relay_manager

    @api.model
    def publish_event(self, event_data, max_retries=3, retry_delay=1):
        for attempt in range(max_retries):
            try:
                private_key = PrivateKey.from_nsec(self.env.user.nostr_private_key)
                public_key = private_key.public_key.hex()
                
                event = Event(
                    kind=event_data['kind'],
                    content=event_data['content'],
                    tags=event_data.get('tags', []),
                    public_key=public_key
                )
                private_key.sign_event(event)
                
                relay_manager = self.get_relay_manager()
                relay_manager.open_connections({"write": True})
                time.sleep(1)  # Give some time for connections to establish
                
                publish_result = relay_manager.publish_event(event)
                _logger.info(f"Relay publish response: {publish_result}")
    
                relay_manager.close_connections()
                return True
            except Exception as e:
                _logger.exception(f"Error publishing event to Nostr: {str(e)}")
                time.sleep(retry_delay)
        
        _logger.error("Failed to publish event after multiple attempts")
        return False
=== ./odoo_custom_addons (copy)/nostr_bridge/models/mail_message.py ===
from odoo import models, api
import logging

_logger = logging.getLogger(__name__)

class MailMessage(models.Model):
    _inherit = 'mail.message'

    @api.model_create_multi
    def create(self, vals_list):
        _logger.info("Creating new mail messages")
        messages = super(MailMessage, self).create(vals_list)
        for message in messages:
            self._publish_to_nostr(message)
        return messages

    def _publish_to_nostr(self, message):
        try:
            nostr_adapter = self.env['nostr.adapter'].sudo()
            event_data = {
                'kind': 1,  # Text note
                'content': message.body,
                'tags': [
                    ['e', str(message.parent_id.id)] if message.parent_id else [],
                    ['p', message.author_id.nostr_public_key] if message.author_id and message.author_id.nostr_public_key else [],
                    ['client', 'Odoo Nostr Bridge'],
                ],
            }
            result = nostr_adapter.publish_event(event_data)
            if result:
                _logger.info(f"Successfully published message {message.id} to Nostr")
            else:
                _logger.warning(f"Failed to publish message {message.id} to Nostr")
        except Exception as e:
            _logger.exception(f"Error publishing message {message.id} to Nostr: {str(e)}")
=== ./odoo_custom_addons (copy)/nostr_bridge/models/nostr_event_handler.py ===
import json
from odoo import api, models

class NostrEventHandler(models.AbstractModel):
    _name = 'nostr.event.handler'
    _description = 'Nostr Event Handler'

    @api.model
    def handle_event(self, event):
        content = json.loads(event.content)
        if event.kind == 1:  # Text note
            self._handle_message(content)
        elif event.kind == 7:  # Reaction
            self._handle_reaction(content)

    def _handle_message(self, content):
        self.env['mail.message'].create({
            'body': content['body'],
            'author_id': self._get_author_id(content['author']),
            'model': content['channel'],
            'res_id': content['res_id'],
        })

    def _handle_reaction(self, content):
        # Implement reaction handling (e.g., likes, emojis)
        pass

    def _get_author_id(self, author_name):
        partner = self.env['res.partner'].search([('name', '=', author_name)], limit=1)
        if not partner:
            partner = self.env['res.partner'].create({'name': author_name})
        return partner.id
=== ./odoo_custom_addons (copy)/nostr_bridge/models/res_config_settings.py ===
import requests
import json
from odoo import fields, models, api
import logging

_logger = logging.getLogger(__name__)

class ResConfigSettings(models.TransientModel):
    _inherit = 'res.config.settings'

    def _default_nostr_relays(self):
        return self._get_top_nostr_relays()

    @api.model
    def _get_top_nostr_relays(self, limit=108):
        url = "https://api.nostr.watch/v1/online"
        try:
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
            }
            response = requests.get(url, headers=headers, timeout=10)
            response.raise_for_status()
            _logger.info(f"Response status code: {response.status_code}")
            
            data = response.json()
            #_logger.info(f"API response (first 108 items): {json.dumps(data)[:1000]}")
            _logger.info(f"API response (first 108 items): {data[:108]}")
            
            relays = data[:108]
            _logger.info(f"Number of relay links found: {len(relays)}")
            _logger.info(f"Extracted relays (first 5): {relays[:5]}")
            
            relay_urls = ",".join(relays)
            return relay_urls
        except requests.RequestException as e:
            _logger.error(f"Error fetching Nostr relays: {e}")
            return "wss://nostr-relay.app,wss://nos.lol,wss://relay.snort.social,wss://relay.nostr.net"

    nostr_relay_urls = fields.Char(
        string="Nostr Relay URLs", 
        config_parameter='nostr_bridge.relay_urls',
        default=_default_nostr_relays
    )

    @api.model
    def get_values(self):
        res = super(ResConfigSettings, self).get_values()
        ICPSudo = self.env['ir.config_parameter'].sudo()
        
        relay_urls = ICPSudo.get_param('nostr_bridge.relay_urls')
        if not relay_urls:
            relay_urls = self._get_top_nostr_relays()
            ICPSudo.set_param('nostr_bridge.relay_urls', relay_urls)
            _logger.info(f"Set new relay URLs: {relay_urls[:100]}...")  # Log first 100 characters
        else:
            _logger.info(f"Using existing relay URLs: {relay_urls[:100]}...")  # Log first 100 characters
        
        res.update(nostr_relay_urls=relay_urls)
        return res

    def set_values(self):
        super(ResConfigSettings, self).set_values()
        ICPSudo = self.env['ir.config_parameter'].sudo()
        if self.nostr_relay_urls:
            ICPSudo.set_param('nostr_bridge.relay_urls', self.nostr_relay_urls)
            _logger.info(f"Updated relay URLs: {self.nostr_relay_urls[:100]}...")  # Log first 100 characters
        else:
            default_urls = self._get_top_nostr_relays()
            ICPSudo.set_param('nostr_bridge.relay_urls', default_urls)
            _logger.info(f"Set default relay URLs: {default_urls[:100]}...")  # Log first 100 characters
=== ./odoo_custom_addons (copy)/nostr_bridge/models/res_partner.py ===
from odoo import models, fields

class ResPartner(models.Model):
    _inherit = 'res.partner'

    nostr_public_key = fields.Char(string="Nostr Public Key")
=== ./odoo_custom_addons (copy)/nostr_bridge/models/nostr_event_manager.py ===
from odoo import models, fields, api
import json
import time
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.serialization import Encoding, PublicFormat
import logging

_logger = logging.getLogger(__name__)

class NostrEventManager(models.AbstractModel):
    _name = 'nostr.event.manager'
    _description = 'Nostr Event Manager'

    @api.model
    def create_event(self, content, tags, private_key):
        private_key_obj = PrivateKey.from_nsec(private_key)
        event = Event(kind=1, content=content, tags=tags)
        private_key_obj.sign_event(event)
        return event.to_json()

    @api.model
    def get_public_key(self, private_key):
        private_key_obj = ec.derive_private_key(int(private_key, 16), ec.SECP256K1())
        public_key = private_key_obj.public_key()
        return public_key.public_bytes(
            encoding=Encoding.X962,
            format=PublicFormat.UncompressedPoint
        )[1:].hex()

    @api.model
    def calculate_event_id(self, event_data):
        serialized = json.dumps([
            0,
            event_data['pubkey'],
            event_data['created_at'],
            event_data['kind'],
            event_data['tags'],
            event_data['content']
        ], separators=(',', ':'))
        return self.sha256(serialized)

    @api.model
    def sign_event(self, event_data, private_key):
        private_key_obj = ec.derive_private_key(int(private_key, 16), ec.SECP256K1())
        signature = private_key_obj.sign(
            bytes.fromhex(event_data['id']),
            ec.ECDSA(hashes.SHA256())
        )
        return signature.hex()

    @api.model
    def sha256(self, data):
        digest = hashes.Hash(hashes.SHA256())
        digest.update(data.encode())
        return digest.finalize().hex()

    @api.model
    def create_git_event(self, repo_path, commit_hash):
        repo = git.Repo(repo_path)
        commit = repo.commit(commit_hash)
        
        content = json.dumps({
            "action": "commit",
            "message": commit.message,
            "author": commit.author.name,
            "email": commit.author.email,
            "date": commit.authored_datetime.isoformat()
        })
        
        tags = [
            ["t", "commit"],
            ["h", commit_hash],
            ["n", repo.active_branch.name],
            ["m", commit.author.name],
            ["v", "1.0"],
            ["r", repo.remotes.origin.url if repo.remotes else ""],
            ["p", self.env.user.nostr_public_key],
            ["d", commit.message],
            ["s", "success"]
        ]
        
        event = self.create_event(content, tags, self.env.user.nostr_private_key)
        self.publish_event(event)
        return event

    def sync_with_decentralized_manager(self, event):
        sync_managers = self.env['decentralized.sync.manager'].search([])
        for manager in sync_managers:
            program = self.env['decentralized.sync.program'].search([
                ('manager_id', '=', manager.id),
                ('content', '=', event['content'])
            ], limit=1)

            if not program:
                program = self.env['decentralized.sync.program'].create({
                    'manager_id': manager.id,
                    'creator_id': self.env['decentralized.sync.creator'].search([], limit=1).id,
                    'content': event['content'],
                    'version': 1,
                    'size': 0.5  # Arbitrary size
                })

            manager.propagate_update(program)

    @api.model
    def publish_event(self, event):
        sync_managers = self.env['decentralized.sync.manager'].search([])
        for manager in sync_managers:
            manager.publish_event(event['content'], event['tags'])
        return True

    @api.model
    def get_events(self, filters=None):
        nostr_adapter = self.env['nostr.adapter']
        return nostr_adapter.get_events(filters)
=== ./odoo_custom_addons (copy)/nostr_bridge/models/ivcs_item.py ===
# File: odoo_custom_addons/nostr_bridge/models/ivcs_item.py

from odoo import models, fields, api, _
from odoo.exceptions import UserError
import git
import os
import logging
from nostr.key import PrivateKey

_logger = logging.getLogger(__name__)

class IVCSItem(models.Model):
    _inherit = 'ivcs.item'

    nostr_private_key = fields.Char(string="Nostr Private Key")

    def _create_nostr_event_and_publish(self, commit):
        if not self.nostr_private_key:
            self.nostr_private_key = PrivateKey().hex()
            self.sudo().write({'nostr_private_key': self.nostr_private_key})

        private_key = PrivateKey(bytes.fromhex(self.nostr_private_key))
        nostr_manager = self.env['nostr.event.manager']
        event = nostr_manager.create_git_event(commit, private_key)

        relay_urls = self.env['ir.config_parameter'].sudo().get_param('nostr_bridge.relay_urls', '').split(',')
        for relay_url in relay_urls:
            if relay_url.strip():
                success = nostr_manager.publish_event_sync(event, relay_url.strip())
                if success:
                    _logger.info(f"Successfully published event to {relay_url}")
                else:
                    _logger.warning(f"Failed to publish event to {relay_url}")

    def sync_repository(self):
        result = super(IVCSItem, self).sync_repository()
        if result.get('type') == 'ir.actions.client' and result['params']['type'] == 'success':
            repo = git.Repo(self.repo_path)
            latest_commit = repo.head.commit
            self._create_nostr_event_and_publish(latest_commit)
        return result

    def create_file(self, filename, content):
        result = super(IVCSItem, self).create_file(filename, content)
        if result.get('type') == 'ir.actions.client' and result['params']['type'] == 'success':
            repo = git.Repo(self.repo_path)
            latest_commit = repo.head.commit
            self._create_nostr_event_and_publish(latest_commit)
        return result

    @api.model
    def create(self, vals):
        item = super(IVCSItem, self).create(vals)
        repo = git.Repo(item.repo_path)
        initial_commit = repo.head.commit
        item._create_nostr_event_and_publish(initial_commit)
        return item
=== ./odoo_custom_addons (copy)/nostr_bridge/__init__.py ===
from . import models
from . import controllers
=== ./odoo_custom_addons (copy)/nostr_bridge/__manifest__.py ===
# File: odoo_custom_addons/nostr_bridge/__manifest__.py

{
    'name': 'Nostr Bridge',
    'version': '1.0',
    'category': 'Social',
    'summary': 'Bridge between Odoo messages, Git, and Nostr network',
    'depends': ['base', 'mail', 'web'],
    'data': [
        'views/res_config_settings_views.xml',
        'views/res_users_views.xml',
        'views/res_partner_views.xml',
        'views/git_repository_views.xml',
        'security/ir.model.access.csv',
    ],
    'installable': True,
    'application': False,
    'auto_install': False,
    'license': 'LGPL-3',
    'external_dependencies': {
        'python': ['cryptography', 'gitpython', 'nostr'],
    },
}
=== ./odoo_custom_addons (copy)/nostr_bridge/static/src/js/nostr_client.js ===
odoo.define('nostr_bridge.NostrClient', function (require) {
    "use strict";

    var Class = require('web.Class');

    var NostrClient = Class.extend({
        init: function (relayUrls) {
            this.relayUrls = relayUrls;
            this.relayPool = new NostrTools.RelayPool(this.relayUrls);
        },

        subscribe: function (filters, callback) {
            this.relayPool.subscribe(filters, callback);
        },

        publish: function (event) {
            this.relayPool.publish(event);
        }
    });

    return NostrClient;
});
=== ./odoo_custom_addons (copy)/nostr_bridge/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_git_repository_user,git.repository.user,model_git_repository,base.group_user,1,1,1,1
=== ./odoo_custom_addons (copy)/nostr_bridge/data/ir_cron_data.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <record id="ir_cron_migrate_messages_to_nostr" model="ir.cron">
            <field name="name">Migrate Messages to Nostr</field>
            <field name="model_id" ref="model_mail_message"/>
            <field name="state">code</field>
            <field name="code">model.migrate_messages_to_nostr()</field>
            <field name="interval_number">1</field>
            <field name="interval_type">days</field>
            <field name="numbercall">1</field>
            <field name="doall" eval="False"/>
        </record>
    </data>
</odoo>
=== ./odoo_custom_addons (copy)/nostr_bridge/views/res_users_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_users_form_nostr" model="ir.ui.view">
        <field name="name">res.users.form.nostr</field>
        <field name="model">res.users</field>
        <field name="inherit_id" ref="base.view_users_form"/>
        <field name="arch" type="xml">
            <xpath expr="//notebook" position="inside">
                <page string="Nostr Settings" name="nostr_settings">
                    <group>
                        <field name="nostr_public_key"/>
                        <field name="nostr_private_key" password="True"/>
                        <field name="nostr_relay_url"/>
                    </group>
                </page>
            </xpath>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/nostr_bridge/views/res_partner_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_partner_form_nostr" model="ir.ui.view">
        <field name="name">res.partner.form.nostr</field>
        <field name="model">res.partner</field>
        <field name="inherit_id" ref="base.view_partner_form"/>
        <field name="arch" type="xml">
            <xpath expr="//notebook" position="inside">
                <page string="Nostr Settings" name="nostr_settings">
                    <group>
                        <field name="nostr_public_key"/>
                    </group>
                </page>
            </xpath>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/nostr_bridge/views/res_config_settings_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="res_config_settings_view_form_nostr" model="ir.ui.view">
        <field name="name">res.config.settings.view.form.inherit.nostr</field>
        <field name="model">res.config.settings</field>
        <field name="inherit_id" ref="base.res_config_settings_view_form"/>
        <field name="arch" type="xml">
            <xpath expr="//div[hasclass('settings')]" position="inside">
                <div class="app_settings_block" data-string="Nostr Bridge" string="Nostr Bridge" data-key="nostr_bridge">
                    <h2>Nostr Settings</h2>
                    <div class="row mt16 o_settings_container">
                        <div class="col-12 col-lg-6 o_setting_box">
                            <div class="o_setting_left_pane"/>
                            <div class="o_setting_right_pane">
                                <span class="o_form_label">Nostr Relay URLs</span>
                                <div class="text-muted">
                                    Comma-separated list of Nostr relay URLs
                                </div>
                                <div class="content-group">
                                    <div class="mt16">
                                        <field name="nostr_relay_urls" class="o_light_label"/>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </xpath>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/nostr_bridge/views/templates.xml ===
<odoo>
    <template id="assets_backend" name="nostr_bridge assets" inherit_id="web.assets_backend">
        <xpath expr="." position="inside">
            <script type="text/javascript" src="/nostr_bridge/static/src/js/nostr_client.js"/>
        </xpath>
    </template>
</odoo>
=== ./odoo_custom_addons (copy)/nostr_bridge/views/git_repository_views.xml ===
<!-- File: odoo_custom_addons/nostr_bridge/views/git_repository_views.xml -->

<odoo>
    <record id="view_git_repository_form" model="ir.ui.view">
        <field name="name">git.repository.form</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="path"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="action_git_repository" model="ir.actions.act_window">
        <field name="name">Git Repositories</field>
        <field name="res_model">git.repository</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_git_repository" name="Git Repositories" action="action_git_repository" parent="base.menu_custom"/>
</odoo>
=== ./odoo_custom_addons (copy)/nostr_bridge/controllers/__init__.py ===
from . import main
=== ./odoo_custom_addons (copy)/nostr_bridge/controllers/main.py ===
from odoo import http
from odoo.http import request
import json
from nostr.event import Event
from nostr.key import PrivateKey

class NostrController(http.Controller):

    @http.route('/nostr/authenticate', type='json', auth='public')
    def authenticate(self, public_key, signature, message):
        User = request.env['res.users'].sudo()
        user_id = User.authenticate_nostr(public_key, signature, message)
        if user_id:
            request.session.authenticate(request.db, user_id, public_key)
            return {'success': True, 'uid': user_id}
        return {'success': False, 'error': 'Authentication failed'}

    @http.route('/nostr/publish', type='json', auth='user')
    def publish_event(self, event_data):
        nostr_adapter = request.env['nostr.adapter'].sudo().get_adapter()
        try:
            nostr_adapter.publish_event(event_data)
            return {'success': True}
        except Exception as e:
            return {'success': False, 'error': str(e)}

    @http.route('/nostr/subscribe', type='json', auth='user')
    def subscribe_to_events(self, filters):
        nostr_adapter = request.env['nostr.adapter'].sudo().get_adapter()
        try:
            def callback(event):
                # Process the event, e.g., create a message in Odoo
                request.env['nostr.event.handler'].sudo().handle_event(event)

            nostr_adapter.subscribe_to_events(filters, callback)
            return {'success': True}
        except Exception as e:
            return {'success': False, 'error': str(e)}

    @http.route('/nostr/get_public_key', type='json', auth='user')
    def get_public_key(self):
        user = request.env.user
        return {'public_key': user.nostr_public_key}

    @http.route('/nostr/create_event', type='json', auth='user')
    def create_event(self, kind, content, tags=None):
        user = request.env.user
        private_key = PrivateKey.from_nsec(user.nostr_private_key)
        event = Event(kind=kind, content=json.dumps(content), tags=tags or [])
        event.sign(private_key.hex())
        return {
            'id': event.id,
            'pubkey': event.public_key,
            'created_at': event.created_at,
            'kind': event.kind,
            'tags': event.tags,
            'content': event.content,
            'sig': event.signature,
        }
=== ./odoo_custom_addons (copy)/decentralized_sync/models/supporting_models.py ===
from odoo import models, fields, api

class DAO(models.Model):
    _name = 'decentralized.sync.dao'
    _description = 'DAO'

    manager_id = fields.Many2one('decentralized.sync.manager', string='Sync Manager')
    tier = fields.Selection([('primary', 'Primary'), ('secondary', 'Secondary'), ('tertiary', 'Tertiary')], string='Tier')
    location_lat = fields.Float(string='Latitude')
    location_lon = fields.Float(string='Longitude')
    storage_capacity = fields.Float(string='Storage Capacity')
    network_speed = fields.Float(string='Network Speed')
    local_state = fields.Text(string='Local State')

class Creator(models.Model):
    _name = 'decentralized.sync.creator'
    _description = 'Creator'

    manager_id = fields.Many2one('decentralized.sync.manager', string='Sync Manager')
    location_lat = fields.Float(string='Latitude')
    location_lon = fields.Float(string='Longitude')
    productivity = fields.Float(string='Productivity')
    dao_id = fields.Many2one('decentralized.sync.dao', string='Associated DAO')

class Program(models.Model):
    _name = 'decentralized.sync.program'
    _description = 'Program'

    manager_id = fields.Many2one('decentralized.sync.manager', string='Sync Manager')
    creator_id = fields.Many2one('decentralized.sync.creator', string='Creator')
    size = fields.Float(string='Size')
    version = fields.Integer(string='Version')
    content = fields.Text(string='Content')
    host_ids = fields.Many2many('decentralized.sync.dao', string='Hosts')

class Event(models.Model):
    _name = 'decentralized.sync.event'
    _description = 'Sync Event'

    manager_id = fields.Many2one('decentralized.sync.manager', string='Sync Manager')
    description = fields.Text(string='Event Description')
    timestamp = fields.Datetime(string='Timestamp', default=fields.Datetime.now)

class Connection(models.Model):
    _name = 'decentralized.sync.connection'
    _description = 'Connection between Creator and DAO'

    manager_id = fields.Many2one('decentralized.sync.manager', string='Sync Manager')
    creator_id = fields.Many2one('decentralized.sync.creator', string='Creator')
    dao_id = fields.Many2one('decentralized.sync.dao', string='DAO')
=== ./odoo_custom_addons (copy)/decentralized_sync/models/sync_manager.py ===
from odoo import models, fields, api
import logging
from nostr.key import PrivateKey
from nostr.event import Event
from nostr.relay_manager import RelayManager
import git
import os

_logger = logging.getLogger(__name__)

class DecentralizedNostrSyncManager(models.Model):
    _name = 'decentralized.sync.manager'
    _description = 'Decentralized Nostr Sync Manager'

    name = fields.Char(string='Name', required=True)
    relay_urls = fields.Text(string='Relay URLs', required=True)
    private_key = fields.Char(string='Private Key')
    public_key = fields.Char(string='Public Key', compute='_compute_public_key')

    @api.depends('private_key')
    def _compute_public_key(self):
        for record in self:
            if record.private_key:
                private_key = PrivateKey.from_nsec(record.private_key)
                record.public_key = private_key.public_key.bech32()
            else:
                record.public_key = False

    def initialize_nostr(self):
        if not self.private_key:
            private_key = PrivateKey()
            self.private_key = private_key.bech32()
        
        self.relay_manager = RelayManager()
        for url in self.relay_urls.split(','):
            self.relay_manager.add_relay(url.strip())
        self.relay_manager.open_connections()

    def publish_event(self, content, tags=None):
        if not hasattr(self, 'relay_manager'):
            self.initialize_nostr()

        private_key = PrivateKey.from_nsec(self.private_key)
        event = Event(content=content, tags=tags or [])
        private_key.sign_event(event)
        
        self.relay_manager.publish_event(event)
        return event

    def sync_git_repository(self, repo_path):
        repo = git.Repo(repo_path)
        if not repo.remotes:
            raise ValueError('No remote repository configured')

        origin = repo.remotes.origin
        origin.fetch()
        
        current_branch = repo.active_branch
        if f'origin/{current_branch.name}' not in repo.refs:
            origin.push(current_branch)
        else:
            origin.pull(current_branch)

        for commit in repo.iter_commits(f'{current_branch.name}@{{u}}..{current_branch.name}'):
            self.publish_event(
                content=f"New commit: {commit.hexsha}",
                tags=[['c', commit.hexsha], ['t', 'git_commit']]
            )

    @api.model
    def create(self, vals):
        manager = super(DecentralizedNostrSyncManager, self).create(vals)
        manager.initialize_nostr()
        return manager

    def write(self, vals):
        result = super(DecentralizedNostrSyncManager, self).write(vals)
        if 'relay_urls' in vals:
            self.initialize_nostr()
        return result
=== ./odoo_custom_addons (copy)/decentralized_sync/__init__.py ===
from . import models
from . import controllers
=== ./odoo_custom_addons (copy)/decentralized_sync/__manifest__.py ===
{
    'name': 'Decentralized Nostr Sync Manager',
    'version': '1.0',
    'category': 'Tools',
    'summary': 'Manage decentralized synchronization with Nostr and Git',
    'depends': ['base', 'ivcs_git', 'nostr_bridge'],
    'data': [
        'security/ir.model.access.csv',
        'views/sync_manager_views.xml',
        'views/dao_views.xml',
        'views/creator_views.xml',
        'views/program_views.xml',
        'views/event_views.xml',
        'views/menu_items.xml',
    ],
    'installable': True,
    'application': False,
    'auto_install': False,
}
=== ./odoo_custom_addons (copy)/decentralized_sync/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_decentralized_sync_manager_user,decentralized.sync.manager user,model_decentralized_sync_manager,base.group_user,1,1,1,1
access_decentralized_sync_dao_user,decentralized.sync.dao user,model_decentralized_sync_dao,base.group_user,1,1,1,1
access_decentralized_sync_creator_user,decentralized.sync.creator user,model_decentralized_sync_creator,base.group_user,1,1,1,1
access_decentralized_sync_program_user,decentralized.sync.program user,model_decentralized_sync_program,base.group_user,1,1,1,1
access_decentralized_sync_event_user,decentralized.sync.event user,model_decentralized_sync_event,base.group_user,1,1,1,1
access_decentralized_sync_connection_user,decentralized.sync.connection user,model_decentralized_sync_connection,base.group_user,1,1,1,1
=== ./odoo_custom_addons (copy)/decentralized_sync/controllers/main.py ===
from odoo import http
from odoo.http import request
from nostr.event import Event
import json

class DecentralizedSyncController(http.Controller):

    @http.route('/api/decentralized_sync/publish', type='json', auth='user')
    def publish_event(self, manager_id, content, tags=None):
        manager = request.env['decentralized.sync.manager'].browse(int(manager_id))
        event = manager.publish_event(content, tags)
        return {'status': 'success', 'event_id': event.id}

    @http.route('/api/decentralized_sync/sync_repo', type='json', auth='user')
    def sync_repository(self, manager_id, repo_path):
        manager = request.env['decentralized.sync.manager'].browse(int(manager_id))
        manager.sync_git_repository(repo_path)
        return {'status': 'success', 'message': 'Repository synced and events published'}

    @http.route('/api/decentralized_sync/events', type='json', auth='user')
    def get_events(self, manager_id):
        manager = request.env['decentralized.sync.manager'].browse(int(manager_id))
        # This would typically fetch events from Nostr relays
        # For now, we'll return an empty list
        return {'events': []}
=== ./odoo_custom_addons (copy)/nostr_auth_test/nostr_auth_module.py ===
import os
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import hashes
from odoo import models, fields, api
from odoo.exceptions import ValidationError
import base64

class NostrAuthModule(models.AbstractModel):
    _name = 'nostr.auth'
    _description = 'Nostr Authentication Module'

    @api.model
    def generate_keypair(self):
        """
        Generate a new Nostr keypair.
        This represents the 'Cause' in our 'Causal Relationship'.
        """
        private_key = ec.generate_private_key(ec.SECP256K1())
        public_key = private_key.public_key()
        
        private_bytes = private_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=serialization.NoEncryption()
        )
        public_bytes = public_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        )
        
        return {
            'private_key': base64.b64encode(private_bytes).decode('utf-8'),
            'public_key': base64.b64encode(public_bytes).decode('utf-8')
        }

    @api.model
    def store_keys(self, user_id, public_key, private_key):
        """
        Store the Nostr keys for a user.
        This action creates an 'Effect' in our 'Causal Relationship'.
        """
        user = self.env['res.users'].browse(user_id)
        if not user.exists():
            raise ValidationError("User does not exist")
        
        user.write({
            'nostr_public_key': public_key,
            'nostr_private_key': private_key  # In a real-world scenario, encrypt this before storage
        })

    @api.model
    def verify_signature(self, public_key, message, signature):
        """
        Verify a Nostr signature.
        This verification process is another 'Effect' in our 'Causal Relationship'.
        """
        try:
            public_key_obj = serialization.load_pem_public_key(base64.b64decode(public_key))
            signature_bytes = base64.b64decode(signature)
            public_key_obj.verify(
                signature_bytes,
                message.encode('utf-8'),
                ec.ECDSA(hashes.SHA256())
            )
            return True
        except:
            return False

    @api.model
    def authenticate_nostr(self, public_key, signature, message):
        """
        Authenticate a user using Nostr.
        This method embodies the complete 'Causal Relationship':
        The provided credentials (Cause) lead to authentication success or failure (Effect).
        """
        user = self.env['res.users'].search([('nostr_public_key', '=', public_key)], limit=1)
        if user and self.verify_signature(user.nostr_public_key, message, signature):
            return user.id
        return False

# For console testing
if __name__ == "__main__":
    # Simulate Odoo environment
    class MockEnv:
        def __init__(self):
            self.users = {}
        
        def __getitem__(self, key):
            return self
        
        def search(self, domain, limit=None):
            for user_id, user in self.users.items():
                if user['nostr_public_key'] == domain[0][2]:
                    return [MockUser(user_id, user)]
            return []
    
    class MockUser:
        def __init__(self, id, data):
            self.id = id
            self.__dict__.update(data)
        
        def exists(self):
            return True
        
        def write(self, vals):
            self.__dict__.update(vals)

    mock_env = MockEnv()
    
    # Create an instance of NostrAuthModule
    nostr_auth = NostrAuthModule()
    nostr_auth.env = mock_env

    # Test key generation
    print("Generating keypair...")
    keys = nostr_auth.generate_keypair()
    print(f"Public Key: {keys['public_key'][:32]}...")
    print(f"Private Key: {keys['private_key'][:32]}...")

    # Test key storage
    print("\nStoring keys...")
    mock_env.users[1] = {'name': 'Test User'}
    try:
        nostr_auth.store_keys(1, keys['public_key'], keys['private_key'])
        print("Keys stored successfully")
    except Exception as e:
        print(f"Error storing keys: {str(e)}")

    # Test signature verification
    print("\nTesting signature verification...")
    message = "Test message"
    private_key = serialization.load_pem_private_key(base64.b64decode(keys['private_key']), password=None)
    signature = base64.b64encode(private_key.sign(
        message.encode('utf-8'),
        ec.ECDSA(hashes.SHA256())
    )).decode('utf-8')
    
    is_valid = nostr_auth.verify_signature(keys['public_key'], message, signature)
    print(f"Signature valid: {is_valid}")

    # Test authentication
    print("\nTesting authentication...")
    user_id = nostr_auth.authenticate_nostr(keys['public_key'], signature, message)
    print(f"Authenticated user ID: {user_id}")

    print("\nAll tests completed.")
=== ./odoo_custom_addons (copy)/allfiles.txt ===
Home dir: ~/oldhome/home/impromise/Downloads/Telegram Desktop/nostr-w-relay-main (2)/nostr-w-relay-main (1)/src/views/components/login/odoo-nostr-project/odoo_custom_addons/

=== ./git_repository_anchor/models/git_repository.py ===
from odoo import models, fields, api, _
from odoo.exceptions import UserError
import git
import os
import logging

_logger = logging.getLogger(__name__)

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'
    _inherit = ['mail.thread', 'mail.activity.mixin']

    name = fields.Char(string='Repository Name', required=True)
    path = fields.Char(string='Repository Path', required=True)
    description = fields.Text(string='Description', tracking=True)
    maintainer_ids = fields.Many2many('res.users', string='Maintainers')
    anchor_event_id = fields.Many2one('nostr.event', string='Anchor Event')
    #company_id = fields.Many2one('res.company', string='Company', required=True, default=lambda self: self.env.company)

    @api.model
    def create(self, vals):
        repo = super(GitRepository, self).create(vals)
        repo._initialize_repository()
        return repo

    def _initialize_repository(self):
        if not os.path.exists(self.path):
            os.makedirs(self.path)
            git.Repo.init(self.path)
            readme_path = os.path.join(self.path, 'README.md')
            with open(readme_path, 'w') as f:
                f.write(f"# {self.name}\n\n{self.description or ''}")
            repo = git.Repo(self.path)
            repo.index.add(['README.md'])
            repo.index.commit("Initial commit")

    def _create_anchor_event(self):
        anchor = self.env['git.repository.anchor']
        event = anchor.create_anchor_event(self.path, self.maintainer_ids.mapped('nostr_public_key'))
        self.env['nostr.event'].create_and_publish(event)
        self.anchor_event_id = self.env['nostr.event'].search([('event_id', '=', event.id)], limit=1).id

    def update_maintainers(self):
        anchor = self.env['git.repository.anchor']
        event = anchor.update_anchor(self.path, self.maintainer_ids.mapped('nostr_public_key'))
        self.env['nostr.event'].create_and_publish(event)
        self.anchor_event_id = self.env['nostr.event'].search([('event_id', '=', event.id)], limit=1).id

    def fork_repository(self, new_name, new_path, new_maintainer_ids):
        anchor = self.env['git.repository.anchor']
        new_maintainers = self.env['res.users'].browse(new_maintainer_ids).mapped('nostr_public_key')
        event = anchor.fork_repository(self.path, new_path, new_maintainers)
        self.env['nostr.event'].create_and_publish(event)
        
        new_repo = self.create({
            'name': new_name,
            'path': new_path,
            'maintainer_ids': [(6, 0, new_maintainer_ids)],
        })
        new_repo.anchor_event_id = self.env['nostr.event'].search([('event_id', '=', event.id)], limit=1).id
        
        # Clone the repository
        git.Repo.clone_from(self.path, new_path)
        
        return new_repo

    def check_permission(self, user_id):
        user = self.env['res.users'].browse(user_id)
        anchor = self.env['git.repository.anchor']
        return anchor.check_permission(self.anchor_event_id, user.nostr_public_key)
=== ./git_repository_anchor/models/__init__.py ===
from . import repository_anchor
from . import branch_manager
from . import odoo_models
from . import git_repository
from . import nostr_event
=== ./git_repository_anchor/models/repository_anchor.py ===
from odoo import models, fields, api, _
from odoo.exceptions import UserError
from nostr.event import Event
from nostr.key import PrivateKey
import json
import os
import logging
import time
from functools import wraps  # Add this import

_logger = logging.getLogger(__name__)

def log_execution_time(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        _logger.info(f"{func.__name__} executed in {end_time - start_time:.2f} seconds")
        return result
    return wrapper

class RepositoryAnchor(models.AbstractModel):
    _name = 'git.repository.anchor'
    _description = 'Git Repository Anchor'

    @api.model
    def _get_private_key(self):
        # In practice, you'd retrieve this securely
        return PrivateKey()

    @log_execution_time
    def create_anchor_event(self, repo_path, maintainers):
        _logger.info(f"Creating anchor event for repository: {repo_path}")
        start_time = time.time()

        private_key = self._get_private_key()
        content = json.dumps({
            "action": "create_repository",
            "repo_name": os.path.basename(repo_path),
            "maintainers": maintainers
        })
        event = Event(
            kind=31228,
            content=content,
            tags=[['r', repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)

        end_time = time.time()
        _logger.info(f"Anchor event created in {end_time - start_time:.2f} seconds")
        return event

    def update_anchor(self, repo_path, maintainers):
        _logger.info(f"Updating anchor for repository: {repo_path}")
        start_time = time.time()

        private_key = self._get_private_key()
        content = json.dumps({
            "action": "update_repository",
            "repo_name": os.path.basename(repo_path),
            "maintainers": maintainers
        })
        event = Event(
            kind=31228,
            content=content,
            tags=[['r', repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)

        end_time = time.time()
        _logger.info(f"Anchor updated in {end_time - start_time:.2f} seconds")
        return event

    def resolve_repository_state(self, anchor_event):
        _logger.info("Resolving repository state from anchor event")
        start_time = time.time()

        try:
            content = json.loads(anchor_event.content)
            state = {
                "repo_name": content["repo_name"],
                "maintainers": content["maintainers"]
            }
        except json.JSONDecodeError as e:
            _logger.error(f"Error decoding anchor event content: {str(e)}")
            raise UserError(_("Invalid anchor event content"))
        except KeyError as e:
            _logger.error(f"Missing key in anchor event content: {str(e)}")
            raise UserError(_("Incomplete anchor event content"))

        end_time = time.time()
        _logger.info(f"Repository state resolved in {end_time - start_time:.2f} seconds")
        return state

    def list_maintainers(self, anchor_event):
        _logger.info("Listing maintainers from anchor event")
        start_time = time.time()

        try:
            content = json.loads(anchor_event.content)
            maintainers = content["maintainers"]
        except json.JSONDecodeError as e:
            _logger.error(f"Error decoding anchor event content: {str(e)}")
            raise UserError(_("Invalid anchor event content"))
        except KeyError:
            _logger.error("Maintainers key not found in anchor event content")
            raise UserError(_("Incomplete anchor event content"))

        end_time = time.time()
        _logger.info(f"Maintainers listed in {end_time - start_time:.2f} seconds")
        return maintainers

    def check_permission(self, anchor_event, public_key):
        _logger.info(f"Checking permission for public key: {public_key}")
        start_time = time.time()

        maintainers = self.list_maintainers(anchor_event)
        has_permission = public_key in maintainers

        end_time = time.time()
        _logger.info(f"Permission check completed in {end_time - start_time:.2f} seconds")
        return has_permission

    def fork_repository(self, original_repo_path, new_repo_path, new_maintainers):
        _logger.info(f"Forking repository from {original_repo_path} to {new_repo_path}")
        start_time = time.time()

        private_key = self._get_private_key()
        content = json.dumps({
            "action": "fork_repository",
            "original_repo": original_repo_path,
            "new_repo": new_repo_path,
            "maintainers": new_maintainers
        })
        event = Event(
            kind=31228,
            content=content,
            tags=[['r', new_repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)

        end_time = time.time()
        _logger.info(f"Repository forked in {end_time - start_time:.2f} seconds")
        return event
=== ./git_repository_anchor/models/nostr_event.py ===
# File: /opt/odoo/custom_addons/git_repository_anchor/models/nostr_event.py

from odoo import models, fields, api, _
from odoo.exceptions import UserError
from nostr.event import Event as NostrLibEvent
from nostr.key import PrivateKey
import json
import time
import logging

_logger = logging.getLogger(__name__)

class NostrEvent(models.Model):
    _name = 'nostr.event'
    _description = 'Nostr Event'

    name = fields.Char(string='Name', required=True)
    event_id = fields.Char(string='Event ID', readonly=True)
    kind = fields.Integer(string='Event Kind', required=True)
    content = fields.Text(string='Content')
    tags = fields.Text(string='Tags')
    public_key = fields.Char(string='Public Key', readonly=True)
    created_at = fields.Integer(string='Created At', readonly=True)
    signature = fields.Char(string='Signature', readonly=True)
    published = fields.Boolean(string='Published', default=False)
    event_type = fields.Selection([
        ('commit', 'Commit'),
        ('branch', 'Branch'),
        ('tree', 'Tree'),
        ('blob', 'Blob'),
    ], string='Event Type')
    repository_id = fields.Many2one('git.repository', string='Related Repository')

    @api.model
    def create(self, vals):
        try:
            # Generate a new private key for this event
            private_key = PrivateKey()
            public_key = private_key.public_key.hex()
            
            created_at = int(time.time())
            tags = json.loads(vals.get('tags', '[]'))
            
            event = NostrLibEvent(
                kind=vals['kind'],
                content=vals.get('content', ''),
                tags=tags,
                pub_key=public_key,
                created_at=created_at
            )
            
            # Sign the event
            private_key.sign_event(event)
            
            # Update vals with generated data
            vals.update({
                'event_id': event.id,
                'public_key': public_key,
                'created_at': created_at,
                'signature': event.sig
            })
            
            _logger.info(f"Created Nostr event: {event.id}")
        except Exception as e:
            _logger.error(f"Error creating Nostr event: {str(e)}")
            raise UserError(_("Failed to create Nostr event: %s") % str(e))
        
        return super(NostrEvent, self).create(vals)

    @api.model
    def create_and_publish(self, event):
        vals = {
            'name': f"Event {event.id[:8]}",  # Use first 8 characters of event ID as name
            'event_id': event.id,
            'kind': event.kind,
            'content': event.content,
            'tags': json.dumps(event.tags),
            'public_key': event.public_key,
            'created_at': event.created_at,
            'signature': event.sig,
        }
        nostr_event = self.create(vals)
        # Here you would typically publish the event to Nostr relays
        # For demonstration purposes, we'll just log it
        _logger.info(f"Published Nostr event: {event.to_message()}")
        return nostr_event
=== ./git_repository_anchor/models/odoo_models.py ===
from odoo import models, fields, api
import logging

_logger = logging.getLogger(__name__)

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Repository Name', required=True)
    path = fields.Char(string='Repository Path', required=True)
    description = fields.Text(string='Description')
    maintainer_ids = fields.Many2many('res.users', string='Maintainers')
    created_at = fields.Datetime(string='Created At', default=fields.Datetime.now)
    last_updated = fields.Datetime(string='Last Updated', default=fields.Datetime.now)
    branch_ids = fields.One2many('git.branch', 'repository_id', string='Branches')

    @api.model
    def fields_get(self, allfields=None, attributes=None):
        res = super(GitRepository, self).fields_get(allfields, attributes)
        _logger.info(f"Fields in GitRepository model: {res.keys()}")
        return res

    @api.model
    def search_read(self, domain=None, fields=None, offset=0, limit=None, order=None):
        _logger.info(f"Search_read called with fields: {fields}")
        return super(GitRepository, self).search_read(domain=domain, fields=fields, offset=offset, limit=limit, order=order)

    def read(self, fields=None, load='_classic_read'):
        _logger.info(f"Read called with fields: {fields}")
        return super(GitRepository, self).read(fields=fields, load=load)

    @api.model
    def create(self, vals):
        repo = super(GitRepository, self).create(vals)
        repo._create_default_branch()
        return repo

    def _create_default_branch(self):
        self.env['git.branch'].create({
            'name': 'main',
            'repository_id': self.id,
            'head': 'initial commit',
        })

class GitBranch(models.Model):
    _name = 'git.branch'
    _description = 'Git Branch'

    name = fields.Char(string='Branch Name', required=True)
    repository_id = fields.Many2one('git.repository', string='Repository', required=True)
    head = fields.Char(string='Head Commit', required=True)

class GitEvent(models.Model):
    _name = 'git.event'
    _description = 'Git Event'

    event_type = fields.Selection([
        ('create_repository', 'Create Repository'),
        ('update_repository', 'Update Repository'),
        ('fork_repository', 'Fork Repository'),
        ('create_branch', 'Create Branch'),
        ('update_branch', 'Update Branch'),
        ('delete_branch', 'Delete Branch')
    ], string='Event Type')
    content = fields.Text(string='Event Content')
    created_at = fields.Datetime(string='Created At', default=fields.Datetime.now)

class GitRepositoryManager(models.Model):
    _name = 'git.repository.manager'
    _description = 'Git Repository Manager'

    @api.model
    def create_repository(self, name, path, description, maintainer_ids):
        anchor = self.env['git.repository.anchor']
        repo = anchor.create_repository(name, path, description, maintainer_ids)
        return repo.id

    @api.model
    def update_repository(self, repo_id, description=None, maintainer_ids=None):
        anchor = self.env['git.repository.anchor']
        repo = self.env['git.repository'].browse(repo_id)
        updated_repo = anchor.update_repository(repo, description, maintainer_ids)
        return updated_repo.id

    @api.model
    def fork_repository(self, original_repo_id, new_name, new_maintainer_id):
        anchor = self.env['git.repository.anchor']
        original_repo = self.env['git.repository'].browse(original_repo_id)
        forked_repo = anchor.fork_repository(original_repo, new_name, new_maintainer_id)
        return forked_repo.id

    @api.model
    def list_maintainers(self, repo_id):
        anchor = self.env['git.repository.anchor']
        repo = self.env['git.repository'].browse(repo_id)
        maintainers = anchor.list_maintainers(repo)
        return maintainers.ids
=== ./git_repository_anchor/models/branch_manager.py ===
from odoo import models, fields, api
from .repository_anchor import log_execution_time
from git import Repo, GitCommandError
import json
from nostr.event import Event
from nostr.key import PrivateKey
import logging

_logger = logging.getLogger(__name__)

class BranchManager(models.AbstractModel):
    _name = 'ivcs.branch.manager'
    _description = 'IVCS Branch Manager'

    name = fields.Char(string='Name', required=True)
    item_id = fields.Many2one('ivcs.item', string='IVCS Item', required=True)

    @api.model
    @log_execution_time
    def create_branch(self, repository_id, name, head):
        repo = self.env['git.repository'].browse(repository_id)
        branch = self.env['git.branch'].create({
            'name': name,
            'repository_id': repository_id,
            'head': head,
        })
        self._create_event('create_branch', branch)
        return branch.id

    @api.model
    @log_execution_time
    def update_branch(self, branch_id, new_head):
        branch = self.env['git.branch'].browse(branch_id)
        branch.write({'head': new_head})
        self._create_event('update_branch', branch)
        return branch.id

    @api.model
    @log_execution_time
    def delete_branch(self, branch_id):
        branch = self.env['git.branch'].browse(branch_id)
        self._create_event('delete_branch', branch)
        branch.unlink()
        return True

    @api.model
    def _create_event(self, event_type, branch):
        self.env['git.event'].create({
            'event_type': event_type,
            'content': f"{event_type}: {branch.name} in {branch.repository_id.name}",
        })
=== ./git_repository_anchor/__init__.py ===
from . import models
from . import controllers
=== ./git_repository_anchor/__manifest__.py ===
{
    'name': 'Git Repository Anchor',
    'version': '1.0',
    'category': 'Development',
    'summary': 'Manage Git repositories using Nostr events',
    'author': 'Your Name',
    'website': 'https://www.example.com',
    'depends': ['base', 'mail'],
    'data': [
        'security/git_repository_security.xml',
        'security/ir.model.access.csv',
        'views/git_repository_views.xml',
        'views/nostr_event_views.xml',
    ],
    'installable': True,
    'application': True,
    'auto_install': False,
    'external_dependencies': {
        'python': ['git', 'nostr'],
    },
}
=== ./git_repository_anchor/security/git_repository_security.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="module_category_git_repository" model="ir.module.category">
        <field name="name">Git Repository</field>
        <field name="description">Manage Git repositories</field>
        <field name="sequence">20</field>
    </record>

    <record id="group_git_repository_user" model="res.groups">
        <field name="name">User</field>
        <field name="category_id" ref="module_category_git_repository"/>
    </record>

    <record id="group_git_repository_manager" model="res.groups">
        <field name="name">Manager</field>
        <field name="category_id" ref="module_category_git_repository"/>
        <field name="implied_ids" eval="[(4, ref('group_git_repository_user'))]"/>
        <field name="users" eval="[(4, ref('base.user_root')), (4, ref('base.user_admin'))]"/>
    </record>
</odoo>
=== ./git_repository_anchor/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_git_repository_user,git.repository user,model_git_repository,group_git_repository_user,1,0,0,0
access_git_repository_manager,git.repository manager,model_git_repository,group_git_repository_manager,1,1,1,1
access_git_branch_user,git.branch user,model_git_branch,group_git_repository_user,1,1,1,0
access_git_branch_manager,git.branch manager,model_git_branch,group_git_repository_manager,1,1,1,1
access_git_event_user,git.event user,model_git_event,group_git_repository_user,1,0,0,0
access_git_event_manager,git.event manager,model_git_event,group_git_repository_manager,1,1,1,1
access_git_repository_manager_user,git.repository.manager user,model_git_repository_manager,group_git_repository_user,1,1,1,0
access_git_repository_manager_manager,git.repository.manager manager,model_git_repository_manager,group_git_repository_manager,1,1,1,1
access_nostr_event_user,nostr.event user,model_nostr_event,group_git_repository_user,1,0,0,0
access_nostr_event_manager,nostr.event manager,model_nostr_event,group_git_repository_manager,1,1,1,1
access_git_repository_user,git.repository user,model_git_repository,base.group_user,1,1,1,0
access_git_repository_manager,git.repository manager,model_git_repository,base.group_system,1,1,1,1
access_nostr_event_user,nostr.event user,model_nostr_event,base.group_user,1,0,0,0
access_nostr_event_manager,nostr.event manager,model_nostr_event,base.group_system,1,1,1,1
=== ./git_repository_anchor/security/oldgit_repository_security.xml.txt ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="module_category_git_repository" model="ir.module.category">
        <field name="name">Git Repository</field>
        <field name="description">Manage Git repositories</field>
        <field name="sequence">20</field>
    </record>

    <record id="group_git_repository_user" model="res.groups">
        <field name="name">User</field>
        <field name="category_id" ref="module_category_git_repository"/>
    </record>

    <record id="group_git_repository_manager" model="res.groups">
        <field name="name">Manager</field>
        <field name="category_id" ref="module_category_git_repository"/>
        <field name="implied_ids" eval="[(4, ref('group_git_repository_user'))]"/>
        <field name="users" eval="[(4, ref('base.user_root')), (4, ref('base.user_admin'))]"/>
    </record>

    <record id="git_repository_comp_rule" model="ir.rule">
        <field name="name">Git Repository multi-company</field>
        <field name="model_id" ref="model_git_repository"/>
        <field name="global" eval="True"/>
        <field name="domain_force">['|', ('company_id', '=', False), ('company_id', 'in', company_ids)]</field>
    </record>
</odoo>
=== ./git_repository_anchor/tests/test_repository_anchor.py ===
from odoo.tests.common import TransactionCase
from odoo.exceptions import AccessError

class TestRepositoryAnchor(TransactionCase):

    def setUp(self):
        super(TestRepositoryAnchor, self).setUp()
        self.repo_manager = self.env['git.repository.manager'].sudo()
        self.user_admin = self.env.ref('base.user_admin')
        self.user_demo = self.env.ref('base.user_demo')

    def test_create_repository(self):
        repo_id = self.repo_manager.create_repository(
            "test-repo", "/path/to/test-repo", "Test repository", [self.user_admin.id]
        )
        repo = self.env['git.repository'].browse(repo_id)
        self.assertEqual(repo.name, "test-repo")
        self.assertEqual(repo.path, "/path/to/test-repo")
        self.assertEqual(repo.description, "Test repository")
        self.assertIn(self.user_admin, repo.maintainer_ids)
        self.assertEqual(len(repo.branch_ids), 1)
        self.assertEqual(repo.branch_ids[0].name, 'main')

    def test_update_repository(self):
        repo_id = self.repo_manager.create_repository(
            "test-repo", "Test repository", [self.user_admin.id]
        )
        updated_repo_id = self.repo_manager.update_repository(
            repo_id, "Updated description", [self.user_admin.id, self.user_demo.id]
        )
        repo = self.env['git.repository'].browse(updated_repo_id)
        self.assertEqual(repo.description, "Updated description")
        self.assertIn(self.user_demo, repo.maintainer_ids)

    def test_fork_repository(self):
        original_repo_id = self.repo_manager.create_repository(
            "original-repo", "Original repository", [self.user_admin.id]
        )
        forked_repo_id = self.repo_manager.fork_repository(
            original_repo_id, "forked-repo", self.user_demo.id
        )
        forked_repo = self.env['git.repository'].browse(forked_repo_id)
        self.assertEqual(forked_repo.name, "forked-repo")
        self.assertIn(self.user_demo, forked_repo.maintainer_ids)
        self.assertEqual(len(forked_repo.branch_ids), 1)
        self.assertEqual(forked_repo.branch_ids[0].name, 'main')

    def test_list_maintainers(self):
        repo_id = self.repo_manager.create_repository(
            "test-repo", "Test repository", [self.user_admin.id, self.user_demo.id]
        )
        maintainer_ids = self.repo_manager.list_maintainers(repo_id)
        self.assertIn(self.user_admin.id, maintainer_ids)
        self.assertIn(self.user_demo.id, maintainer_ids)

    def test_access_rights(self):
        repo_id = self.repo_manager.create_repository(
            "test-repo", "Test repository", [self.user_admin.id]
        )
        
        # Test that non-maintainer can't update the repository
        with self.assertRaises(AccessError):
            self.repo_manager.with_user(self.user_demo).update_repository(
                repo_id, "Unauthorized update"
            )

        # Test that maintainer can update the repository
        self.repo_manager.with_user(self.user_admin).update_repository(
            repo_id, "Authorized update"
        )
        repo = self.env['git.repository'].browse(repo_id)
        self.assertEqual(repo.description, "Authorized update")
=== ./git_repository_anchor/tests/__init__.py ===
from . import test_repository_anchor
=== ./git_repository_anchor/data/README.md ===
# Git Repository Anchor

This Odoo module provides a system for managing Git repositories using Nostr events. It allows users to create, update, and fork repositories, as well as manage branches and maintainers.

## Features

- Create, update, and fork Git repositories
- Manage repository maintainers
- Create and manage branches
- Log all actions as Nostr events
- Odoo views for easy management through the UI
- CLI for standalone usage

## Installation

1. Place the `git_repository_anchor` directory in your Odoo addons path.
2. Update your Odoo apps list.
3. Install the "Git Repository Anchor" module from the Odoo Apps menu.

## Usage

### Through Odoo Interface

1. Navigate to the "Git Repositories" menu item.
2. Use the provided views to manage repositories, branches, and maintainers.

### Using CLI

A CLI script is provided for standalone usage. Example usage:

```bash
python cli_script.py create --name "New Repo" --description "A new repository" --maintainers 1 2
python cli_script.py update --repo-id 1 --description "Updated description"
python cli_script.py fork --original-repo-id 1 --new-name "Forked Repo"
=== ./git_repository_anchor/data/git_repository_data.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <!-- Example repository data -->
        <record id="git_repository_example" model="git.repository">
            <field name="name">Example Repository</field>
            <field name="path">/path/to/example-repo</field>
            <field name="description">This is an example repository created during module installation.</field>
            <field name="maintainer_ids" eval="[(4, ref('base.user_admin'))]"/>
        </record>
    </data>
</odoo>
=== ./git_repository_anchor/views/nostr_event_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_nostr_event_form" model="ir.ui.view">
        <field name="name">nostr.event.form</field>
        <field name="model">nostr.event</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="event_id" readonly="1"/>
                        <field name="kind"/>
                        <field name="content"/>
                        <field name="tags"/>
                        <field name="public_key" readonly="1"/>
                        <field name="created_at" readonly="1"/>
                        <field name="signature" readonly="1"/>
                        <field name="published"/>
                        <field name="event_type"/>
                        <field name="repository_id"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_nostr_event_tree" model="ir.ui.view">
        <field name="name">nostr.event.tree</field>
        <field name="model">nostr.event</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="event_id"/>
                <field name="kind"/>
                <field name="event_type"/>
                <field name="repository_id"/>
                <field name="public_key"/>
                <field name="created_at"/>
                <field name="published"/>
            </tree>
        </field>
    </record>

    <record id="action_nostr_event" model="ir.actions.act_window">
        <field name="name">Nostr Events</field>
        <field name="res_model">nostr.event</field>
        <field name="view_mode">tree,form</field>
    </record>

    <!-- Menu item for Nostr Events -->
    <menuitem id="menu_nostr_event"
              name="Nostr Events"
              parent="menu_git_nostr_bridge_root"
              action="action_nostr_event"
              sequence="20"/>
</odoo>
=== ./git_repository_anchor/views/git_repository_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_repository_form" model="ir.ui.view">
        <field name="name">git.repository.form</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="path"/>
                        <field name="description"/>
                    </group>
                </sheet>
                <div class="oe_chatter">
                    <field name="message_follower_ids" widget="mail_followers"/>
                    <field name="message_ids" widget="mail_thread"/>
                </div>
            </form>
        </field>
    </record>

    <record id="view_git_repository_tree" model="ir.ui.view">
        <field name="name">git.repository.tree</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="path"/>
            </tree>
        </field>
    </record>

    <record id="action_git_repository" model="ir.actions.act_window">
        <field name="name">Git Repositories</field>
        <field name="res_model">git.repository</field>
        <field name="view_mode">tree,form</field>
    </record>

    <!-- Root menu for the module -->
    <menuitem id="menu_git_nostr_bridge_root"
              name="Git Repository Anchor"
              sequence="10"/>

    <!-- Submenu for Git Repositories -->
    <menuitem id="menu_git_repository"
              name="Git Repositories"
              parent="menu_git_nostr_bridge_root"
              action="action_git_repository"
              sequence="10"/>
</odoo>
=== ./git_repository_anchor/views/repository_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data>
        <!-- Repository Form View -->
        <record id="view_git_repository_form" model="ir.ui.view">
            <field name="name">git.repository.form</field>
            <field name="model">git.repository</field>
            <field name="arch" type="xml">
                <form string="Git Repository">
                    <sheet>
                        <group>
                            <field name="name"/>
                            <field name="path"/>
                            <field name="description"/>
                            <field name="maintainer_ids" widget="many2many_tags"/>
                            <field name="created_at"/>
                            <field name="last_updated"/>
                        </group>
                        <notebook>
                            <page string="Branches">
                                <field name="branch_ids">
                                    <tree editable="bottom">
                                        <field name="name"/>
                                        <field name="head"/>
                                    </tree>
                                </field>
                            </page>
                        </notebook>
                    </sheet>
                </form>
            </field>
        </record>

        <!-- Repository Tree View -->
        <record id="view_git_repository_tree" model="ir.ui.view">
            <field name="name">git.repository.tree</field>
            <field name="model">git.repository</field>
            <field name="arch" type="xml">
                <tree string="Git Repositories">
                    <field name="name"/>
                    <field name="path"/>
                    <field name="description"/>
                    <field name="created_at"/>
                    <field name="last_updated"/>
                </tree>
            </field>
        </record>

        <!-- Repository Search View -->
        <record id="view_git_repository_search" model="ir.ui.view">
            <field name="name">git.repository.search</field>
            <field name="model">git.repository</field>
            <field name="arch" type="xml">
                <search string="Search Repositories">
                    <field name="name"/>
                    <field name="path"/>
                    <field name="description"/>
                    <field name="maintainer_ids"/>
                    <filter string="My Repositories" name="my_repositories" domain="[('maintainer_ids', 'in', uid)]"/>
                    <group expand="0" string="Group By">
                        <filter string="Created Date" name="group_by_created_at" context="{'group_by': 'created_at:month'}"/>
                    </group>
                </search>
            </field>
        </record>

        <!-- Repository Action -->
        <record id="action_git_repository" model="ir.actions.act_window">
            <field name="name">Git Repositories</field>
            <field name="res_model">git.repository</field>
            <field name="view_mode">tree,form</field>
            <field name="search_view_id" ref="view_git_repository_search"/>
        </record>

        <!-- Menu Items -->
        <menuitem id="menu_git_repository_root" name="Git Repositories" sequence="10"/>
        <menuitem id="menu_git_repository" parent="menu_git_repository_root" action="action_git_repository" sequence="10"/>
    </data>
</odoo>
=== ./git_repository_anchor/controllers/__init__.py ===
from . import main
=== ./git_repository_anchor/controllers/main.py ===
from odoo import http
from odoo.http import request

class GitRepositoryController(http.Controller):
    @http.route('/git/repository/create', type='json', auth='user')
    def create_repository(self, name, path, description, maintainer_ids):
        repo_manager = request.env['git.repository.manager'].sudo()
        repo_id = repo_manager.create_repository(name, path, description, maintainer_ids)
        return {'success': True, 'repository_id': repo_id}

    @http.route('/git/repository/update', type='json', auth='user')
    def update_repository(self, repo_id, description=None, maintainer_ids=None):
        repo_manager = request.env['git.repository.manager'].sudo()
        updated_repo_id = repo_manager.update_repository(repo_id, description, maintainer_ids)
        return {'success': True, 'repository_id': updated_repo_id}

    @http.route('/git/repository/fork', type='json', auth='user')
    def fork_repository(self, original_repo_id, new_name):
        repo_manager = request.env['git.repository.manager'].sudo()
        forked_repo_id = repo_manager.fork_repository(original_repo_id, new_name, request.env.user.id)
        return {'success': True, 'repository_id': forked_repo_id}

    @http.route('/git/repository/list_maintainers', type='json', auth='user')
    def list_maintainers(self, repo_id):
        repo_manager = request.env['git.repository.manager'].sudo()
        maintainer_ids = repo_manager.list_maintainers(repo_id)
        return {'success': True, 'maintainer_ids': maintainer_ids}
=== ./git_branch_manager/git-branch-manager-module.py ===
# Directory structure:
# git_branch_manager/
# ├── __init__.py
# ├── __manifest__.py
# ├── models/
# │   ├── __init__.py
# │   ├── branch.py
# │   ├── event.py
# │   └── branch_manager.py
# ├── controllers/
# │   ├── __init__.py
# │   └── main.py
# ├── security/
# │   └── ir.model.access.csv
# └── views/
#     ├── branch_views.xml
#     └── event_views.xml

# __init__.py
from . import models
from . import controllers

# __manifest__.py
{
    'name': 'Git Branch Manager',
    'version': '1.0',
    'summary': 'Manage Git branches using Nostr events',
    'description': """
    This module allows you to manage Git branches using Nostr events.
    It integrates with the Nostr-Odoo application to handle branch operations.
    """,
    'author': 'Your Name',
    'depends': ['base'],
    'data': [
        'security/ir.model.access.csv',
        'views/branch_views.xml',
        'views/event_views.xml',
    ],
    'installable': True,
    'application': True,
}

# models/__init__.py
from . import branch
from . import event
from . import branch_manager

# models/branch.py
from odoo import models, fields

class GitBranch(models.Model):
    _name = 'git.branch'
    _description = 'Git Branch'

    name = fields.Char(string='Branch Name', required=True)
    head = fields.Char(string='Head Commit', required=True)
    created_at = fields.Datetime(string='Created At')
    last_updated = fields.Datetime(string='Last Updated')

# models/event.py
from odoo import models, fields

class GitEvent(models.Model):
    _name = 'git.event'
    _description = 'Git Event'

    event_type = fields.Selection([('create', 'Create'), ('update', 'Update'), ('delete', 'Delete')], string='Event Type')
    content = fields.Text(string='Event Content')
    created_at = fields.Datetime(string='Created At', default=fields.Datetime.now)

# models/branch_manager.py
from odoo import models, api
from nostr.event import Event
from nostr.key import PrivateKey
import json
import logging
import time

_logger = logging.getLogger(__name__)

class GitBranchManager(models.AbstractModel):
    _name = 'git.branch.manager'
    _description = 'Git Branch Manager'

    @api.model
    def create_branch(self, name, head):
        _logger.info(f"Creating branch: {name} with head: {head}")
        start_time = time.time()

        try:
            if self.env['git.branch'].search([('name', '=', name)]):
                raise ValueError(f"Branch {name} already exists")

            branch = self.env['git.branch'].create({
                'name': name,
                'head': head,
                'created_at': fields.Datetime.now(),
                'last_updated': fields.Datetime.now(),
            })

            event = self._create_branch_event(branch, 'create')
            self._publish_event(event)

            end_time = time.time()
            _logger.info(f"Branch {name} created in {end_time - start_time:.2f} seconds")
            return True
        except Exception as e:
            _logger.exception(f"Error creating branch: {str(e)}")
            raise

    @api.model
    def update_branch(self, name, new_head):
        _logger.info(f"Updating branch: {name} to new head: {new_head}")
        start_time = time.time()

        try:
            branch = self.env['git.branch'].search([('name', '=', name)])
            if not branch:
                raise ValueError(f"Branch {name} does not exist")

            branch.write({
                'head': new_head,
                'last_updated': fields.Datetime.now(),
            })

            event = self._create_branch_event(branch, 'update')
            self._publish_event(event)

            end_time = time.time()
            _logger.info(f"Branch {name} updated in {end_time - start_time:.2f} seconds")
            return True
        except Exception as e:
            _logger.exception(f"Error updating branch: {str(e)}")
            raise

    @api.model
    def delete_branch(self, name):
        _logger.info(f"Deleting branch: {name}")
        start_time = time.time()

        try:
            branch = self.env['git.branch'].search([('name', '=', name)])
            if not branch:
                raise ValueError(f"Branch {name} does not exist")

            event = self._create_branch_event(branch, 'delete')
            branch.unlink()
            self._publish_event(event)

            end_time = time.time()
            _logger.info(f"Branch {name} deleted in {end_time - start_time:.2f} seconds")
            return True
        except Exception as e:
            _logger.exception(f"Error deleting branch: {str(e)}")
            raise

    def _create_branch_event(self, branch, operation):
        event = Event()
        event.kind = 31227  # Custom event kind for git branch operations
        event.content = json.dumps({
            'operation': operation,
            'name': branch.name,
            'head': branch.head,
            'timestamp': fields.Datetime.now().isoformat(),
        })
        event.tags = [['e', 'git_branch']]

        private_key = PrivateKey()  # In practice, securely store and retrieve this
        event.sign(private_key.hex())

        return event

    def _publish_event(self, event):
        self.env['git.event'].create({
            'event_type': json.loads(event.content)['operation'],
            'content': event.to_message(),
        })
        # Here you would also publish the event to the Nostr network
        # This part depends on how you've implemented your Nostr client in Odoo

# controllers/__init__.py
from . import main

# controllers/main.py
from odoo import http
from odoo.http import request

class GitBranchController(http.Controller):

    @http.route('/git/branch/create', type='json', auth='user')
    def create_branch(self, name, head):
        branch_manager = request.env['git.branch.manager'].sudo()
        result = branch_manager.create_branch(name, head)
        return {'success': result}

    @http.route('/git/branch/update', type='json', auth='user')
    def update_branch(self, name, new_head):
        branch_manager = request.env['git.branch.manager'].sudo()
        result = branch_manager.update_branch(name, new_head)
        return {'success': result}

    @http.route('/git/branch/delete', type='json', auth='user')
    def delete_branch(self, name):
        branch_manager = request.env['git.branch.manager'].sudo()
        result = branch_manager.delete_branch(name)
        return {'success': result}

# security/ir.model.access.csv
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_git_branch_user,access_git_branch_user,model_git_branch,,1,1,1,1
access_git_event_user,access_git_event_user,model_git_event,,1,1,1,1

# views/branch_views.xml
<?xml version="1.0" encoding="UTF-8"?>
<odoo>
    <record id="view_git_branch_form" model="ir.ui.view">
        <field name="name">git.branch.form</field>
        <field name="model">git.branch</field>
        <field name="arch" type="xml">
            <form string="Git Branch">
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="head"/>
                        <field name="created_at"/>
                        <field name="last_updated"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_git_branch_tree" model="ir.ui.view">
        <field name="name">git.branch.tree</field>
        <field name="model">git.branch</field>
        <field name="arch" type="xml">
            <tree string="Git Branches">
                <field name="name"/>
                <field name="head"/>
                <field name="created_at"/>
                <field name="last_updated"/>
            </tree>
        </field>
    </record>

    <record id="action_git_branch" model="ir.actions.act_window">
        <field name="name">Branches</field>
        <field name="res_model">git.branch</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_git_branch_root" name="Git Branches" sequence="10"/>
    <menuitem id="menu_git_branch" parent="menu_git_branch_root"
              action="action_git_branch" sequence="10"/>
</odoo>

# views/event_views.xml
<?xml version="1.0" encoding="UTF-8"?>
<odoo>
    <record id="view_git_event_form" model="ir.ui.view">
        <field name="name">git.event.form</field>
        <field name="model">git.event</field>
        <field name="arch" type="xml">
            <form string="Git Event">
                <sheet>
                    <group>
                        <field name="event_type"/>
                        <field name="content"/>
                        <field name="created_at"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_git_event_tree" model="ir.ui.view">
        <field name="name">git.event.tree</field>
        <field name="model">git.event</field>
        <field name="arch" type="xml">
            <tree string="Git Events">
                <field name="event_type"/>
                <field name="content"/>
                <field name="created_at"/>
            </tree>
        </field>
    </record>

    <record id="action_git_event" model="ir.actions.act_window">
        <field name="name">Events</field>
        <field name="res_model">git.event</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_git_events" parent="menu_git_branch_root"
              action="action_git_event" sequence="20"/>
</odoo>
=== ./nostr_auth/models/__init__.py ===
# File: odoo_custom_addons/nostr_auth/models/__init__.py
from . import res_users
from . import nostr_auth_module
=== ./nostr_auth/models/res_users.py ===
# File: odoo_custom_addons/nostr_auth/models/res_users.py

from odoo import models, fields, api
from odoo.exceptions import ValidationError
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import hashes
import base64

class ResUsers(models.Model):
    _inherit = 'res.users'

    nostr_public_key = fields.Char(string='Nostr Public Key')
    nostr_private_key = fields.Char(string='Nostr Private Key')
    nostr_relay_url = fields.Char(string='Nostr Relay URL')

    @api.model_create_multi
    def create(self, vals_list):
        nostr_auth = self.env['nostr.auth.module']
        for vals in vals_list:
            if not vals.get('nostr_private_key'):
                keys = nostr_auth.generate_keypair()
                vals['nostr_private_key'] = keys['private_key']
                vals['nostr_public_key'] = keys['public_key']
        return super(ResUsers, self).create(vals_list)

    @api.constrains('nostr_public_key')
    def _check_nostr_public_key(self):
        for user in self:
            if user.nostr_public_key:
                if not user.nostr_public_key.startswith('npub1'):
                    raise ValidationError("Invalid Nostr public key format. It should start with 'npub1'.")

    @api.model
    def authenticate_nostr(self, public_key, signature, message):
        user = self.search([('nostr_public_key', '=', public_key)], limit=1)
        if user:
            nostr_auth = self.env['nostr.auth.module']
            if nostr_auth.verify_signature(public_key, message, signature):
                return user.id
        return False
=== ./nostr_auth/models/nostr_auth_module.py ===
# File: odoo_custom_addons/nostr_auth/models/nostr_auth_module.py

from odoo import models, api
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.serialization import Encoding, PublicFormat, PrivateFormat, NoEncryption
import base64
from bech32 import bech32_encode, bech32_decode, convertbits

class NostrAuthModule(models.AbstractModel):
    _name = 'nostr.auth.module'
    _description = 'Nostr Authentication Module'

    @api.model
    def generate_keypair(self):
        private_key = ec.generate_private_key(ec.SECP256K1())
        public_key = private_key.public_key()
        
        private_bytes = private_key.private_numbers().private_value.to_bytes(32, 'big')
        public_bytes = public_key.public_bytes(
            encoding=Encoding.X962,
            format=PublicFormat.UncompressedPoint
        )[1:]
        
        return {
            'private_key': self.bytes_to_nsec(private_bytes),
            'public_key': self.bytes_to_npub(public_bytes)
        }

    @api.model
    def verify_signature(self, public_key, message, signature):
        try:
            public_key_bytes = self.npub_to_bytes(public_key)
            public_key_obj = ec.EllipticCurvePublicKey.from_encoded_point(ec.SECP256K1(), b'\x04' + public_key_bytes)
            signature_bytes = base64.b64decode(signature)
            public_key_obj.verify(
                signature_bytes,
                message.encode('utf-8'),
                ec.ECDSA(hashes.SHA256())
            )
            return True
        except:
            return False

    @api.model
    def bytes_to_npub(self, key_bytes):
        data = convertbits(key_bytes[:32], 8, 5)
        return bech32_encode('npub', data)

    @api.model
    def bytes_to_nsec(self, key_bytes):
        data = convertbits(key_bytes[:32], 8, 5)
        return bech32_encode('nsec', data)
        
    @api.model
    def npub_to_bytes(self, npub):
        hrp, data = bech32_decode(npub)
        return bytes(convertbits(data, 5, 8, False))

    @api.model
    def nsec_to_bytes(self, nsec):
        hrp, data = bech32_decode(nsec)
        return bytes(convertbits(data, 5, 8, False))
=== ./nostr_auth/__init__.py ===
from . import models
=== ./nostr_auth/__manifest__.py ===
# File: odoo_custom_addons/nostr_auth/__manifest__.py
{
    'name': 'Nostr Authentication',
    'version': '1.0',
    'category': 'Authentication',
    'summary': 'Extends user model with Nostr fields and authentication',
    'depends': ['base', 'auth_signup'],
    'data': [
        'views/res_users_views.xml',
    ],
    'installable': True,
    'application': False,
    'auto_install': False,
    'external_dependencies': {
        'python': ['cryptography', 'bech32'],
    },
}
=== ./nostr_auth/views/res_users_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_users_form_nostr" model="ir.ui.view">
        <field name="name">res.users.form.nostr</field>
        <field name="model">res.users</field>
        <field name="inherit_id" ref="base.view_users_form"/>
        <field name="arch" type="xml">
            <xpath expr="//page[@name='access_rights']" position="after">
                <page string="Nostr Authentication" name="nostr_auth">
                    <group>
                        <field name="nostr_public_key"/>
                        <field name="nostr_relay_url"/>
                    </group>
                </page>
            </xpath>
        </field>
    </record>
</odoo>
=== ./nostr_auth/controllers/__init__.py ===
from . import main
=== ./nostr_auth/controllers/main.py ===
# controllers/main.py
from odoo import http
from odoo.http import request
import json

class NostrAuthController(http.Controller):
    @http.route('/web/nostr/authenticate', type='json', auth='none')
    def authenticate(self, public_key, signature, message):
        uid = request.env['res.users'].sudo().authenticate_nostr(public_key, signature, message)
        if uid:
            request.session.authenticate(request.session.db, uid, public_key)
            return {'success': True, 'uid': uid}
        return {'success': False, 'error': 'Authentication failed'}
=== ./nostr_identity/models/__init__.py ===
# models/__init__.py
from . import nostr_identity
from . import nostr_identity_verifier
from . import nostr_message
=== ./nostr_identity/models/nostr_identity_verifier.py ===
from odoo import models, fields, api, _
from odoo.exceptions import UserError
import logging
import json
import websocket
import threading
import ssl
import time
from odoo.tools import config

_logger = logging.getLogger(__name__)

class NostrIdentityVerifier(models.Model):
    _name = 'nostr.identity.verifier'
    _description = 'Nostr Identity Verifier'

    name = fields.Char(string='Name', required=True)
    active = fields.Boolean(default=True)
    relay_url = fields.Char(string='Relay URL', required=True)
    websocket_state = fields.Selection([
        ('disconnected', 'Disconnected'),
        ('connecting', 'Connecting'),
        ('connected', 'Connected')
    ], default='disconnected', string='WebSocket State', readonly=True)
    last_error = fields.Text(string='Last Error', readonly=True)

    def _get_ws_connection(self):
        return self.env.context.get('ws_connection')

    def _set_ws_connection(self, ws):
        self = self.with_context(ws_connection=ws)

    def connect_to_relay(self):
        self.ensure_one()
        if self.websocket_state == 'connected':
            return True

        self.websocket_state = 'connecting'
        self.last_error = False

        try:
            ws = self._create_websocket(self.relay_url)
            self._set_ws_connection(ws)
            
            # Wait for connection to establish or fail
            for _ in range(20):  # Wait up to 10 seconds
                if self.websocket_state == 'connected':
                    return True
                elif self.websocket_state == 'disconnected':
                    raise UserError(self.last_error or _("Connection failed"))
                time.sleep(0.5)

            raise UserError(_("Connection timeout"))
        except Exception as e:
            self.websocket_state = 'disconnected'
            self.last_error = str(e)
            _logger.error(f"Failed to connect to {self.relay_url}: {str(e)}")
            return False

    def _create_websocket(self, relay_url):
        def on_message(ws, message):
            with self.pool.cursor() as new_cr:
                self.with_env(self.env(cr=new_cr))._handle_message(message)

        def on_error(ws, error):
            with self.pool.cursor() as new_cr:
                self.with_env(self.env(cr=new_cr))._handle_error(error)

        def on_close(ws, close_status_code, close_msg):
            with self.pool.cursor() as new_cr:
                self.with_env(self.env(cr=new_cr))._handle_close()

        def on_open(ws):
            with self.pool.cursor() as new_cr:
                self.with_env(self.env(cr=new_cr))._handle_open()

        ws = websocket.WebSocketApp(relay_url,
                                    on_message=on_message,
                                    on_error=on_error,
                                    on_close=on_close,
                                    on_open=on_open)

        wst = threading.Thread(target=lambda: ws.run_forever(sslopt={"cert_reqs": ssl.CERT_NONE}))
        wst.daemon = True
        wst.start()

        return ws

    def _handle_message(self, message):
        _logger.info(f"Received message from {self.relay_url}: {message}")
        self.env['nostr.message'].create({
            'verifier_id': self.id,
            'content': message
        })

    def _handle_error(self, error):
        _logger.error(f"WebSocket error for {self.relay_url}: {error}")
        self.write({'last_error': str(error), 'websocket_state': 'disconnected'})

    def _handle_close(self):
        _logger.info(f"WebSocket connection closed for {self.relay_url}")
        self.write({'websocket_state': 'disconnected'})

    def _handle_open(self):
        _logger.info(f"WebSocket connection opened for {self.relay_url}")
        self.write({'websocket_state': 'connected'})

    def publish_event(self, event):
        self.ensure_one()
        if self.websocket_state != 'connected':
            if not self.connect_to_relay():
                raise UserError(_("Failed to connect to relay"))

        try:
            message = json.dumps(["EVENT", event])
            ws = self._get_ws_connection()
            if ws:
                ws.send(message)
                _logger.info(f"Published event to {self.relay_url}")
                return True
            else:
                raise UserError(_("WebSocket connection is not available"))
        except Exception as e:
            _logger.error(f"Failed to publish event to {self.relay_url}: {str(e)}")
            raise UserError(_("Failed to publish event: %s") % str(e))

    @api.model
    def process_messages(self):
        messages = self.env['nostr.message'].search([('processed', '=', False)])
        for message in messages:
            try:
                # Process the message here
                _logger.info(f"Processing message: {message.content}")
                # Add your message processing logic here
                message.write({'processed': True})
            except Exception as e:
                _logger.error(f"Error processing message {message.id}: {str(e)}")

    def close_connection(self):
        self.ensure_one()
        ws = self._get_ws_connection()
        if ws:
            try:
                ws.close()
            except Exception as e:
                _logger.error(f"Error closing WebSocket for {self.relay_url}: {str(e)}")
        self._set_ws_connection(None)
        self.write({'websocket_state': 'disconnected'})
=== ./nostr_identity/models/nostr_identity.py ===
from odoo import models, fields, api, _
from odoo.exceptions import UserError, ValidationError
import base64
from cryptography.fernet import Fernet
import logging
import secrets
from nostr.key import PrivateKey
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import serialization
import bech32

_logger = logging.getLogger(__name__)

def hex_to_nostr_key(hex_key, prefix):
    # Convert hex to bytes
    data = bytes.fromhex(hex_key)
    
    # Convert to 5-bit words
    words = bech32.convertbits(data, 8, 5)
    
    # Encode with bech32
    encoded = bech32.bech32_encode(prefix, words)
    
    return encoded

class NostrIdentity(models.Model):
    _name = 'nostr.identity'
    _description = 'Nostr Identity'

    name = fields.Char(string='Name', required=True)
    public_key = fields.Char(string='Public Key (hex)', readonly=True)
    private_key = fields.Char(string='Private Key (hex)', readonly=True)
    public_key_bech32 = fields.Char(string='Public Key (npub)', readonly=True, compute='_compute_bech32_keys')
    private_key_bech32 = fields.Char(string='Private Key (nsec)', readonly=True, compute='_compute_bech32_keys')
    relay_urls = fields.Text(string='Relay URLs')
    profile_data = fields.Text(string='Profile Data')

    @api.model
    def create(self, vals):
        if 'public_key' not in vals or 'private_key' not in vals:
            try:
                private_key = PrivateKey()
                public_key = private_key.public_key
                vals['private_key'] = private_key.hex()
                vals['public_key'] = public_key.hex()
            except Exception as e:
                _logger.error(f"Failed to generate Nostr keys: {str(e)}")
                raise UserError(_("Failed to generate Nostr keys: %s") % str(e))
        return super(NostrIdentity, self).create(vals)

    @api.depends('public_key', 'private_key')
    def _compute_bech32_keys(self):
        for record in self:
            if record.public_key:
                record.public_key_bech32 = hex_to_nostr_key(record.public_key, "npub")
            else:
                record.public_key_bech32 = False
            
            if record.private_key:
                record.private_key_bech32 = hex_to_nostr_key(record.private_key, "nsec")
            else:
                record.private_key_bech32 = False

    def get_private_key(self):
        self.ensure_one()
        try:
            encryption_key = self.env['ir.config_parameter'].sudo().get_param('nostr.encryption_key')
            if not encryption_key:
                raise UserError(_("Encryption key not found. Unable to decrypt private key."))
            
            fernet = Fernet(encryption_key.encode())
            decrypted_private_key = fernet.decrypt(base64.b64decode(self.encrypted_private_key))
            return PrivateKey(bytes.fromhex(decrypted_private_key.decode()))
        except Exception as e:
            _logger.error(f"Failed to decrypt private key: {str(e)}")
            raise UserError(_("Failed to decrypt private key: %s") % str(e))

    def get_public_key_bech32(self):
        return self.public_key_bech32
=== ./nostr_identity/models/nostr_message.py ===
# models/nostr_message.py

from odoo import models, fields

class NostrMessage(models.Model):
    _name = 'nostr.message'
    _description = 'Nostr Message'

    verifier_id = fields.Many2one('nostr.identity.verifier', string='Verifier', required=True, ondelete='cascade')
    content = fields.Text(string='Message Content', required=True)
    processed = fields.Boolean(string='Processed', default=False)
=== ./nostr_identity/__init__.py ===
# nostr_identity/__init__.py

from . import models
from . import nostr_cleanup

def post_init_hook(cr, registry):
    from odoo import api, SUPERUSER_ID
    env = api.Environment(cr, SUPERUSER_ID, {})
    
    # Generate encryption key if it doesn't exist
    if not env['ir.config_parameter'].get_param('nostr.encryption_key'):
        from cryptography.fernet import Fernet
        encryption_key = Fernet.generate_key()
        env['ir.config_parameter'].set_param('nostr.encryption_key', encryption_key.decode())

def uninstall_hook(cr, registry):
    from odoo import api, SUPERUSER_ID
    env = api.Environment(cr, SUPERUSER_ID, {})
    
    # Remove the encryption key
    env['ir.config_parameter'].set_param('nostr.encryption_key', False)
    
    # Close all active WebSocket connections
    verifiers = env['nostr.identity.verifier'].search([])
    for verifier in verifiers:
        verifier.close_connection()
=== ./nostr_identity/__manifest__.py ===
# __manifest__.py
{
    'name': 'Nostr Identity Verifier',
    'version': '1.0',
    'category': 'Tools',
    'summary': 'Integrate Nostr identity verification into Odoo',
    'author': 'Your Name',
    'website': 'https://www.example.com',
    'license': 'LGPL-3',
    'depends': ['base', 'mail'],
    'data': [
        'security/nostr_security.xml',
        'security/ir.model.access.csv',
        'views/nostr_identity_views.xml',
        'data/ir_cron_data.xml',
    ],
    'demo': [],
    'external_dependencies': {
        'python': ['websocket-client', 'nostr'],
    },
    'installable': True,
    'application': False,
    'auto_install': False,
    'post_init_hook': 'post_init_hook',
    'uninstall_hook': 'uninstall_hook',
}
=== ./nostr_identity/nostr_cleanup.py ===
# nostr_identity/nostr_cleanup.py

import atexit
from odoo import api, SUPERUSER_ID

def cleanup_connections():
    try:
        with api.Environment.manage():
            env = api.Environment(odoo.registry(odoo.tools.config['db_name']).cursor(), SUPERUSER_ID, {})
            verifiers = env['nostr.identity.verifier'].search([])
            for verifier in verifiers:
                verifier.close_connection()
            env.cr.commit()
    except Exception as e:
        # Log the error, but don't raise it to avoid interfering with Odoo's shutdown process
        _logger.error(f"Error during Nostr connection cleanup: {e}")
    finally:
        if env and env.cr:
            env.cr.close()

atexit.register(cleanup_connections)
=== ./nostr_identity/security/nostr_security.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <!-- Rule: Users can only see their own Nostr Identity records -->
        <record id="rule_nostr_identity_users" model="ir.rule">
            <field name="name">Users can only see their own Nostr Identity</field>
            <field name="model_id" ref="model_nostr_identity"/>
            <field name="domain_force">[('create_uid', '=', user.id)]</field>
            <field name="groups" eval="[(4, ref('base.group_user'))]"/>
            <field name="perm_read" eval="True"/>
            <field name="perm_write" eval="False"/>
            <field name="perm_create" eval="False"/>
            <field name="perm_unlink" eval="False"/>
        </record>

        <!-- Rule: Managers can see all Nostr Identity records -->
        <record id="rule_nostr_identity_managers" model="ir.rule">
            <field name="name">Managers can see all Nostr Identity records</field>
            <field name="model_id" ref="model_nostr_identity"/>
            <field name="domain_force">[(1, '=', 1)]</field>
            <field name="groups" eval="[(4, ref('base.group_system'))]"/>
            <field name="perm_read" eval="True"/>
            <field name="perm_write" eval="True"/>
            <field name="perm_create" eval="True"/>
            <field name="perm_unlink" eval="True"/>
        </record>
    </data>
</odoo>
=== ./nostr_identity/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_nostr_identity_user,nostr.identity user,model_nostr_identity,base.group_user,1,1,1,0
access_nostr_identity_manager,nostr.identity manager,model_nostr_identity,base.group_system,1,1,1,1
access_nostr_identity_verifier_user,nostr.identity.verifier user,model_nostr_identity_verifier,base.group_user,1,0,0,0
access_nostr_identity_verifier_manager,nostr.identity.verifier manager,model_nostr_identity_verifier,base.group_system,1,1,1,1
access_nostr_message_user,nostr.message user,model_nostr_message,base.group_user,1,0,0,0
access_nostr_message_manager,nostr.message manager,model_nostr_message,base.group_system,1,1,1,1
=== ./nostr_identity/data/ir_cron_data.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <record id="ir_cron_nostr_process_messages" model="ir.cron">
            <field name="name">Nostr: Process Messages</field>
            <field name="model_id" ref="model_nostr_identity_verifier"/>
            <field name="state">code</field>
            <field name="code">model.process_messages()</field>
            <field name="interval_number">5</field>
            <field name="interval_type">minutes</field>
            <field name="numbercall">-1</field>
            <field name="doall" eval="False"/>
            <field name="active" eval="True"/>
        </record>
    </data>
</odoo>
=== ./nostr_identity/views/nostr_identity_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <!-- Nostr Identity Views -->
    <record id="view_nostr_identity_tree" model="ir.ui.view">
        <field name="name">nostr.identity.tree</field>
        <field name="model">nostr.identity</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="public_key"/>
                <field name="public_key_bech32"/>
            </tree>
        </field>
    </record>

    <record id="view_nostr_identity_form" model="ir.ui.view">
        <field name="name">nostr.identity.form</field>
        <field name="model">nostr.identity</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="public_key"/>
                        <field name="public_key_bech32"/>
                        <field name="relay_urls"/>
                        <field name="profile_data"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <!-- The rest of the XML remains unchanged -->
    <!-- Nostr Identity Verifier Views -->
    <record id="view_nostr_identity_verifier_tree" model="ir.ui.view">
        <field name="name">nostr.identity.verifier.tree</field>
        <field name="model">nostr.identity.verifier</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="relay_url"/>
                <field name="websocket_state"/>
            </tree>
        </field>
    </record>

    <record id="view_nostr_identity_verifier_form" model="ir.ui.view">
        <field name="name">nostr.identity.verifier.form</field>
        <field name="model">nostr.identity.verifier</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="connect_to_relay" string="Connect" type="object" class="oe_highlight" attrs="{'invisible': [('websocket_state', '=', 'connected')]}"/>
                    <button name="close_connection" string="Disconnect" type="object" attrs="{'invisible': [('websocket_state', '!=', 'connected')]}"/>
                </header>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="relay_url"/>
                        <field name="active"/>
                        <field name="websocket_state"/>
                        <field name="last_error"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <!-- Action Windows -->
    <record id="action_nostr_identity" model="ir.actions.act_window">
        <field name="name">Nostr Identities</field>
        <field name="res_model">nostr.identity</field>
        <field name="view_mode">tree,form</field>
    </record>

    <record id="action_nostr_identity_verifier" model="ir.actions.act_window">
        <field name="name">Nostr Identity Verifiers</field>
        <field name="res_model">nostr.identity.verifier</field>
        <field name="view_mode">tree,form</field>
    </record>

    <!-- Menu Items -->
    <menuitem id="menu_nostr_root" name="Nostr" sequence="10"/>
    <menuitem id="menu_nostr_identity" name="Identities" parent="menu_nostr_root" action="action_nostr_identity" sequence="10"/>
    <menuitem id="menu_nostr_identity_verifier" name="Verifiers" parent="menu_nostr_root" action="action_nostr_identity_verifier" sequence="20"/>
</odoo>
=== ./nostr_bridge/models/git_repository.py ===
# File: odoo_custom_addons/nostr_bridge/models/git_repository.py

from odoo import models, fields, api
import git
import os

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Repository Name', required=True)
    path = fields.Char(string='Repository Path', required=True)
    
    @api.model
    def create(self, vals):
        repo = super(GitRepository, self).create(vals)
        if not os.path.exists(repo.path):
            os.makedirs(repo.path)
            git.Repo.init(repo.path)
        return repo

    def commit_changes(self, message):
        repo = git.Repo(self.path)
        repo.git.add(A=True)
        commit = repo.index.commit(message)
        
        event_manager = self.env['nostr.event.manager']
        event = event_manager.create_git_event(self.path, commit.hexsha)
        event_manager.publish_event(event)
        
        return commit.hexsha
=== ./nostr_bridge/models/__init__.py ===
# File: odoo_custom_addons/nostr_bridge/models/__init__.py

from . import res_users
from . import mail_message
from . import nostr_adapter
from . import res_config_settings
from . import res_partner
from . import nostr_event_manager
from . import git_repository
=== ./nostr_bridge/models/res_users.py ===
"""from odoo import models, fields, api
from nostr.key import PrivateKey

class ResUsers(models.Model):
    _inherit = 'res.users'

    #nostr_private_key = fields.Char(string="Nostr Private Key")
    #nostr_public_key = fields.Char(string="Nostr Public Key", compute='_compute_public_key')
    #nostr_relay_url = fields.Char(string="Nostr Relay URL")

    nostr_public_key = fields.Char(string="Nostr Public Key")
    nostr_private_key = fields.Char(string="Nostr Private Key")
    nostr_relay_url = fields.Char(string="Nostr Relay URL")

    @api.model
    def create(self, vals):
        if not vals.get('nostr_private_key'):
            private_key = PrivateKey()
            vals['nostr_private_key'] = private_key.bech32()
        return super(ResUsers, self).create(vals)

    def write(self, vals):
        # Here you might want to handle updates to Nostr fields
        return super(ResUsers, self).write(vals)

    @api.depends('nostr_private_key')
    def _compute_public_key(self):
        for user in self:
            if user.nostr_private_key:
                private_key = PrivateKey.from_nsec(user.nostr_private_key)
                user.nostr_public_key = private_key.public_key.bech32()
            else:
                user.nostr_public_key = False
"""

"""from odoo import models, fields, api

class ResUsers(models.Model):
    _inherit = 'res.users'

    nostr_public_key = fields.Char(string="Nostr Public Key")
    nostr_private_key = fields.Char(string="Nostr Private Key")
    nostr_relay_url = fields.Char(string="Nostr Relay URL")

    @api.model
    def create(self, vals):
        # Here you might want to generate Nostr keys if they're not provided
        return super(ResUsers, self).create(vals)

    def write(self, vals):
        # Here you might want to handle updates to Nostr fields
        return super(ResUsers, self).write(vals)"""
        
        
from odoo import models, fields

class ResUsers(models.Model):
    _inherit = 'res.users'

    nostr_public_key = fields.Char(string="Nostr Public Key")
    nostr_private_key = fields.Char(string="Nostr Private Key")
    nostr_relay_url = fields.Char(string="Nostr Relay URL")
=== ./nostr_bridge/models/nostr_adapter.py ===
import requests
import websocket
from odoo import models, api
from websocket._exceptions import WebSocketConnectionClosedException
from odoo.exceptions import UserError
from nostr.event import Event
from nostr.key import PrivateKey
from nostr.relay_manager import RelayManager
import logging
import time

_logger = logging.getLogger(__name__)

class NostrAdapter(models.AbstractModel):
    _name = 'nostr.adapter'
    _description = 'Nostr Adapter'

    @api.model
    def get_relay_manager(self):
        ICPSudo = self.env['ir.config_parameter'].sudo()
        relay_urls = ICPSudo.get_param('nostr_bridge.relay_urls', '').split(',')
        if not relay_urls:
            raise UserError("Nostr relay URL is not configured. Please set it in the settings.")
        _logger.info(f"Nostr relay URLs: {relay_urls}")

        relay_manager = RelayManager()
        for url in relay_urls:
            url = url.strip()
            if url:  # Only add non-empty URLs
                _logger.info(f"Adding relay: {url}")
                relay_manager.add_relay(url)
        return relay_manager

    @api.model
    def publish_event(self, event_data, max_retries=3, retry_delay=1):
        for attempt in range(max_retries):
            try:
                private_key = PrivateKey.from_nsec(self.env.user.nostr_private_key)
                public_key = private_key.public_key.hex()
                
                event = Event(
                    kind=event_data['kind'],
                    content=event_data['content'],
                    tags=event_data.get('tags', []),
                    public_key=public_key
                )
                private_key.sign_event(event)
                
                relay_manager = self.get_relay_manager()
                relay_manager.open_connections({"write": True})
                time.sleep(1)  # Give some time for connections to establish
                
                publish_result = relay_manager.publish_event(event)
                _logger.info(f"Relay publish response: {publish_result}")
    
                relay_manager.close_connections()
                return True
            except Exception as e:
                _logger.exception(f"Error publishing event to Nostr: {str(e)}")
                time.sleep(retry_delay)
        
        _logger.error("Failed to publish event after multiple attempts")
        return False
=== ./nostr_bridge/models/mail_message.py ===
from odoo import models, api
import logging

_logger = logging.getLogger(__name__)

class MailMessage(models.Model):
    _inherit = 'mail.message'

    @api.model_create_multi
    def create(self, vals_list):
        _logger.info("Creating new mail messages")
        messages = super(MailMessage, self).create(vals_list)
        for message in messages:
            self._publish_to_nostr(message)
        return messages

    def _publish_to_nostr(self, message):
        try:
            nostr_adapter = self.env['nostr.adapter'].sudo()
            event_data = {
                'kind': 1,  # Text note
                'content': message.body,
                'tags': [
                    ['e', str(message.parent_id.id)] if message.parent_id else [],
                    ['p', message.author_id.nostr_public_key] if message.author_id and message.author_id.nostr_public_key else [],
                    ['client', 'Odoo Nostr Bridge'],
                ],
            }
            result = nostr_adapter.publish_event(event_data)
            if result:
                _logger.info(f"Successfully published message {message.id} to Nostr")
            else:
                _logger.warning(f"Failed to publish message {message.id} to Nostr")
        except Exception as e:
            _logger.exception(f"Error publishing message {message.id} to Nostr: {str(e)}")
=== ./nostr_bridge/models/nostr_event_handler.py ===
import json
from odoo import api, models

class NostrEventHandler(models.AbstractModel):
    _name = 'nostr.event.handler'
    _description = 'Nostr Event Handler'

    @api.model
    def handle_event(self, event):
        content = json.loads(event.content)
        if event.kind == 1:  # Text note
            self._handle_message(content)
        elif event.kind == 7:  # Reaction
            self._handle_reaction(content)

    def _handle_message(self, content):
        self.env['mail.message'].create({
            'body': content['body'],
            'author_id': self._get_author_id(content['author']),
            'model': content['channel'],
            'res_id': content['res_id'],
        })

    def _handle_reaction(self, content):
        # Implement reaction handling (e.g., likes, emojis)
        pass

    def _get_author_id(self, author_name):
        partner = self.env['res.partner'].search([('name', '=', author_name)], limit=1)
        if not partner:
            partner = self.env['res.partner'].create({'name': author_name})
        return partner.id
=== ./nostr_bridge/models/res_config_settings.py ===
import requests
import json
from odoo import fields, models, api
import logging

_logger = logging.getLogger(__name__)

class ResConfigSettings(models.TransientModel):
    _inherit = 'res.config.settings'

    def _default_nostr_relays(self):
        return self._get_top_nostr_relays()

    @api.model
    def _get_top_nostr_relays(self, limit=108):
        url = "https://api.nostr.watch/v1/online"
        try:
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
            }
            response = requests.get(url, headers=headers, timeout=10)
            response.raise_for_status()
            _logger.info(f"Response status code: {response.status_code}")
            
            data = response.json()
            #_logger.info(f"API response (first 108 items): {json.dumps(data)[:1000]}")
            _logger.info(f"API response (first 108 items): {data[:108]}")
            
            relays = data[:108]
            _logger.info(f"Number of relay links found: {len(relays)}")
            _logger.info(f"Extracted relays (first 5): {relays[:5]}")
            
            relay_urls = ",".join(relays)
            return relay_urls
        except requests.RequestException as e:
            _logger.error(f"Error fetching Nostr relays: {e}")
            return "wss://nostr-relay.app,wss://nos.lol,wss://relay.snort.social,wss://relay.nostr.net"

    nostr_relay_urls = fields.Char(
        string="Nostr Relay URLs", 
        config_parameter='nostr_bridge.relay_urls',
        default=_default_nostr_relays
    )

    @api.model
    def get_values(self):
        res = super(ResConfigSettings, self).get_values()
        ICPSudo = self.env['ir.config_parameter'].sudo()
        
        relay_urls = ICPSudo.get_param('nostr_bridge.relay_urls')
        if not relay_urls:
            relay_urls = self._get_top_nostr_relays()
            ICPSudo.set_param('nostr_bridge.relay_urls', relay_urls)
            _logger.info(f"Set new relay URLs: {relay_urls[:100]}...")  # Log first 100 characters
        else:
            _logger.info(f"Using existing relay URLs: {relay_urls[:100]}...")  # Log first 100 characters
        
        res.update(nostr_relay_urls=relay_urls)
        return res

    def set_values(self):
        super(ResConfigSettings, self).set_values()
        ICPSudo = self.env['ir.config_parameter'].sudo()
        if self.nostr_relay_urls:
            ICPSudo.set_param('nostr_bridge.relay_urls', self.nostr_relay_urls)
            _logger.info(f"Updated relay URLs: {self.nostr_relay_urls[:100]}...")  # Log first 100 characters
        else:
            default_urls = self._get_top_nostr_relays()
            ICPSudo.set_param('nostr_bridge.relay_urls', default_urls)
            _logger.info(f"Set default relay URLs: {default_urls[:100]}...")  # Log first 100 characters
=== ./nostr_bridge/models/res_partner.py ===
from odoo import models, fields

class ResPartner(models.Model):
    _inherit = 'res.partner'

    nostr_public_key = fields.Char(string="Nostr Public Key")
=== ./nostr_bridge/models/nostr_event_manager.py ===
from odoo import models, fields, api
import json
import time
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.serialization import Encoding, PublicFormat
import logging

_logger = logging.getLogger(__name__)

class NostrEventManager(models.AbstractModel):
    _name = 'nostr.event.manager'
    _description = 'Nostr Event Manager'

    @api.model
    def create_event(self, content, tags, private_key):
        private_key_obj = PrivateKey.from_nsec(private_key)
        event = Event(kind=1, content=content, tags=tags)
        private_key_obj.sign_event(event)
        return event.to_json()

    @api.model
    def get_public_key(self, private_key):
        private_key_obj = ec.derive_private_key(int(private_key, 16), ec.SECP256K1())
        public_key = private_key_obj.public_key()
        return public_key.public_bytes(
            encoding=Encoding.X962,
            format=PublicFormat.UncompressedPoint
        )[1:].hex()

    @api.model
    def calculate_event_id(self, event_data):
        serialized = json.dumps([
            0,
            event_data['pubkey'],
            event_data['created_at'],
            event_data['kind'],
            event_data['tags'],
            event_data['content']
        ], separators=(',', ':'))
        return self.sha256(serialized)

    @api.model
    def sign_event(self, event_data, private_key):
        private_key_obj = ec.derive_private_key(int(private_key, 16), ec.SECP256K1())
        signature = private_key_obj.sign(
            bytes.fromhex(event_data['id']),
            ec.ECDSA(hashes.SHA256())
        )
        return signature.hex()

    @api.model
    def sha256(self, data):
        digest = hashes.Hash(hashes.SHA256())
        digest.update(data.encode())
        return digest.finalize().hex()

    @api.model
    def create_git_event(self, repo_path, commit_hash):
        repo = git.Repo(repo_path)
        commit = repo.commit(commit_hash)
        
        content = json.dumps({
            "action": "commit",
            "message": commit.message,
            "author": commit.author.name,
            "email": commit.author.email,
            "date": commit.authored_datetime.isoformat()
        })
        
        tags = [
            ["t", "commit"],
            ["h", commit_hash],
            ["n", repo.active_branch.name],
            ["m", commit.author.name],
            ["v", "1.0"],
            ["r", repo.remotes.origin.url if repo.remotes else ""],
            ["p", self.env.user.nostr_public_key],
            ["d", commit.message],
            ["s", "success"]
        ]
        
        event = self.create_event(content, tags, self.env.user.nostr_private_key)
        self.publish_event(event)
        return event

    def sync_with_decentralized_manager(self, event):
        sync_managers = self.env['decentralized.sync.manager'].search([])
        for manager in sync_managers:
            program = self.env['decentralized.sync.program'].search([
                ('manager_id', '=', manager.id),
                ('content', '=', event['content'])
            ], limit=1)

            if not program:
                program = self.env['decentralized.sync.program'].create({
                    'manager_id': manager.id,
                    'creator_id': self.env['decentralized.sync.creator'].search([], limit=1).id,
                    'content': event['content'],
                    'version': 1,
                    'size': 0.5  # Arbitrary size
                })

            manager.propagate_update(program)

    @api.model
    def publish_event(self, event):
        sync_managers = self.env['decentralized.sync.manager'].search([])
        for manager in sync_managers:
            manager.publish_event(event['content'], event['tags'])
        return True

    @api.model
    def get_events(self, filters=None):
        nostr_adapter = self.env['nostr.adapter']
        return nostr_adapter.get_events(filters)
=== ./nostr_bridge/models/ivcs_item.py ===
# File: odoo_custom_addons/nostr_bridge/models/ivcs_item.py

from odoo import models, fields, api, _
from odoo.exceptions import UserError
import git
import os
import logging
from nostr.key import PrivateKey

_logger = logging.getLogger(__name__)

class IVCSItem(models.Model):
    _inherit = 'ivcs.item'

    nostr_private_key = fields.Char(string="Nostr Private Key")

    def _create_nostr_event_and_publish(self, commit):
        if not self.nostr_private_key:
            self.nostr_private_key = PrivateKey().hex()
            self.sudo().write({'nostr_private_key': self.nostr_private_key})

        private_key = PrivateKey(bytes.fromhex(self.nostr_private_key))
        nostr_manager = self.env['nostr.event.manager']
        event = nostr_manager.create_git_event(commit, private_key)

        relay_urls = self.env['ir.config_parameter'].sudo().get_param('nostr_bridge.relay_urls', '').split(',')
        for relay_url in relay_urls:
            if relay_url.strip():
                success = nostr_manager.publish_event_sync(event, relay_url.strip())
                if success:
                    _logger.info(f"Successfully published event to {relay_url}")
                else:
                    _logger.warning(f"Failed to publish event to {relay_url}")

    def sync_repository(self):
        result = super(IVCSItem, self).sync_repository()
        if result.get('type') == 'ir.actions.client' and result['params']['type'] == 'success':
            repo = git.Repo(self.repo_path)
            latest_commit = repo.head.commit
            self._create_nostr_event_and_publish(latest_commit)
        return result

    def create_file(self, filename, content):
        result = super(IVCSItem, self).create_file(filename, content)
        if result.get('type') == 'ir.actions.client' and result['params']['type'] == 'success':
            repo = git.Repo(self.repo_path)
            latest_commit = repo.head.commit
            self._create_nostr_event_and_publish(latest_commit)
        return result

    @api.model
    def create(self, vals):
        item = super(IVCSItem, self).create(vals)
        repo = git.Repo(item.repo_path)
        initial_commit = repo.head.commit
        item._create_nostr_event_and_publish(initial_commit)
        return item
=== ./nostr_bridge/__init__.py ===
from . import models
from . import controllers
=== ./nostr_bridge/__manifest__.py ===
# File: odoo_custom_addons/nostr_bridge/__manifest__.py

{
    'name': 'Nostr Bridge',
    'version': '1.0',
    'category': 'Social',
    'summary': 'Bridge between Odoo messages, Git, and Nostr network',
    'depends': ['base', 'mail', 'web'],
    'data': [
        'views/res_config_settings_views.xml',
        'views/res_users_views.xml',
        'views/res_partner_views.xml',
        'views/git_repository_views.xml',
        'security/ir.model.access.csv',
    ],
    'installable': True,
    'application': False,
    'auto_install': False,
    'license': 'LGPL-3',
    'external_dependencies': {
        'python': ['cryptography', 'gitpython', 'nostr'],
    },
}
=== ./nostr_bridge/static/src/js/nostr_client.js ===
odoo.define('nostr_bridge.NostrClient', function (require) {
    "use strict";

    var Class = require('web.Class');

    var NostrClient = Class.extend({
        init: function (relayUrls) {
            this.relayUrls = relayUrls;
            this.relayPool = new NostrTools.RelayPool(this.relayUrls);
        },

        subscribe: function (filters, callback) {
            this.relayPool.subscribe(filters, callback);
        },

        publish: function (event) {
            this.relayPool.publish(event);
        }
    });

    return NostrClient;
});
=== ./nostr_bridge/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_git_repository_user,git.repository.user,model_git_repository,base.group_user,1,1,1,1
=== ./nostr_bridge/data/ir_cron_data.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <record id="ir_cron_migrate_messages_to_nostr" model="ir.cron">
            <field name="name">Migrate Messages to Nostr</field>
            <field name="model_id" ref="model_mail_message"/>
            <field name="state">code</field>
            <field name="code">model.migrate_messages_to_nostr()</field>
            <field name="interval_number">1</field>
            <field name="interval_type">days</field>
            <field name="numbercall">1</field>
            <field name="doall" eval="False"/>
        </record>
    </data>
</odoo>
=== ./nostr_bridge/views/res_users_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_users_form_nostr" model="ir.ui.view">
        <field name="name">res.users.form.nostr</field>
        <field name="model">res.users</field>
        <field name="inherit_id" ref="base.view_users_form"/>
        <field name="arch" type="xml">
            <xpath expr="//notebook" position="inside">
                <page string="Nostr Settings" name="nostr_settings">
                    <group>
                        <field name="nostr_public_key"/>
                        <field name="nostr_private_key" password="True"/>
                        <field name="nostr_relay_url"/>
                    </group>
                </page>
            </xpath>
        </field>
    </record>
</odoo>
=== ./nostr_bridge/views/res_partner_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_partner_form_nostr" model="ir.ui.view">
        <field name="name">res.partner.form.nostr</field>
        <field name="model">res.partner</field>
        <field name="inherit_id" ref="base.view_partner_form"/>
        <field name="arch" type="xml">
            <xpath expr="//notebook" position="inside">
                <page string="Nostr Settings" name="nostr_settings">
                    <group>
                        <field name="nostr_public_key"/>
                    </group>
                </page>
            </xpath>
        </field>
    </record>
</odoo>
=== ./nostr_bridge/views/res_config_settings_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="res_config_settings_view_form_nostr" model="ir.ui.view">
        <field name="name">res.config.settings.view.form.inherit.nostr</field>
        <field name="model">res.config.settings</field>
        <field name="inherit_id" ref="base.res_config_settings_view_form"/>
        <field name="arch" type="xml">
            <xpath expr="//div[hasclass('settings')]" position="inside">
                <div class="app_settings_block" data-string="Nostr Bridge" string="Nostr Bridge" data-key="nostr_bridge">
                    <h2>Nostr Settings</h2>
                    <div class="row mt16 o_settings_container">
                        <div class="col-12 col-lg-6 o_setting_box">
                            <div class="o_setting_left_pane"/>
                            <div class="o_setting_right_pane">
                                <span class="o_form_label">Nostr Relay URLs</span>
                                <div class="text-muted">
                                    Comma-separated list of Nostr relay URLs
                                </div>
                                <div class="content-group">
                                    <div class="mt16">
                                        <field name="nostr_relay_urls" class="o_light_label"/>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </xpath>
        </field>
    </record>
</odoo>
=== ./nostr_bridge/views/templates.xml ===
<odoo>
    <template id="assets_backend" name="nostr_bridge assets" inherit_id="web.assets_backend">
        <xpath expr="." position="inside">
            <script type="text/javascript" src="/nostr_bridge/static/src/js/nostr_client.js"/>
        </xpath>
    </template>
</odoo>
=== ./nostr_bridge/views/git_repository_views.xml ===
<!-- File: odoo_custom_addons/nostr_bridge/views/git_repository_views.xml -->

<odoo>
    <record id="view_git_repository_form" model="ir.ui.view">
        <field name="name">git.repository.form</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="path"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="action_git_repository" model="ir.actions.act_window">
        <field name="name">Git Repositories</field>
        <field name="res_model">git.repository</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_git_repository" name="Git Repositories" action="action_git_repository" parent="base.menu_custom"/>
</odoo>
=== ./nostr_bridge/controllers/__init__.py ===
from . import main
=== ./nostr_bridge/controllers/main.py ===
from odoo import http
from odoo.http import request
import json
from nostr.event import Event
from nostr.key import PrivateKey

class NostrController(http.Controller):

    @http.route('/nostr/authenticate', type='json', auth='public')
    def authenticate(self, public_key, signature, message):
        User = request.env['res.users'].sudo()
        user_id = User.authenticate_nostr(public_key, signature, message)
        if user_id:
            request.session.authenticate(request.db, user_id, public_key)
            return {'success': True, 'uid': user_id}
        return {'success': False, 'error': 'Authentication failed'}

    @http.route('/nostr/publish', type='json', auth='user')
    def publish_event(self, event_data):
        nostr_adapter = request.env['nostr.adapter'].sudo().get_adapter()
        try:
            nostr_adapter.publish_event(event_data)
            return {'success': True}
        except Exception as e:
            return {'success': False, 'error': str(e)}

    @http.route('/nostr/subscribe', type='json', auth='user')
    def subscribe_to_events(self, filters):
        nostr_adapter = request.env['nostr.adapter'].sudo().get_adapter()
        try:
            def callback(event):
                # Process the event, e.g., create a message in Odoo
                request.env['nostr.event.handler'].sudo().handle_event(event)

            nostr_adapter.subscribe_to_events(filters, callback)
            return {'success': True}
        except Exception as e:
            return {'success': False, 'error': str(e)}

    @http.route('/nostr/get_public_key', type='json', auth='user')
    def get_public_key(self):
        user = request.env.user
        return {'public_key': user.nostr_public_key}

    @http.route('/nostr/create_event', type='json', auth='user')
    def create_event(self, kind, content, tags=None):
        user = request.env.user
        private_key = PrivateKey.from_nsec(user.nostr_private_key)
        event = Event(kind=kind, content=json.dumps(content), tags=tags or [])
        event.sign(private_key.hex())
        return {
            'id': event.id,
            'pubkey': event.public_key,
            'created_at': event.created_at,
            'kind': event.kind,
            'tags': event.tags,
            'content': event.content,
            'sig': event.signature,
        }
=== ./decentralized_sync/models/supporting_models.py ===
from odoo import models, fields, api

class DAO(models.Model):
    _name = 'decentralized.sync.dao'
    _description = 'DAO'

    manager_id = fields.Many2one('decentralized.sync.manager', string='Sync Manager')
    tier = fields.Selection([('primary', 'Primary'), ('secondary', 'Secondary'), ('tertiary', 'Tertiary')], string='Tier')
    location_lat = fields.Float(string='Latitude')
    location_lon = fields.Float(string='Longitude')
    storage_capacity = fields.Float(string='Storage Capacity')
    network_speed = fields.Float(string='Network Speed')
    local_state = fields.Text(string='Local State')

class Creator(models.Model):
    _name = 'decentralized.sync.creator'
    _description = 'Creator'

    manager_id = fields.Many2one('decentralized.sync.manager', string='Sync Manager')
    location_lat = fields.Float(string='Latitude')
    location_lon = fields.Float(string='Longitude')
    productivity = fields.Float(string='Productivity')
    dao_id = fields.Many2one('decentralized.sync.dao', string='Associated DAO')

class Program(models.Model):
    _name = 'decentralized.sync.program'
    _description = 'Program'

    manager_id = fields.Many2one('decentralized.sync.manager', string='Sync Manager')
    creator_id = fields.Many2one('decentralized.sync.creator', string='Creator')
    size = fields.Float(string='Size')
    version = fields.Integer(string='Version')
    content = fields.Text(string='Content')
    host_ids = fields.Many2many('decentralized.sync.dao', string='Hosts')

class Event(models.Model):
    _name = 'decentralized.sync.event'
    _description = 'Sync Event'

    manager_id = fields.Many2one('decentralized.sync.manager', string='Sync Manager')
    description = fields.Text(string='Event Description')
    timestamp = fields.Datetime(string='Timestamp', default=fields.Datetime.now)

class Connection(models.Model):
    _name = 'decentralized.sync.connection'
    _description = 'Connection between Creator and DAO'

    manager_id = fields.Many2one('decentralized.sync.manager', string='Sync Manager')
    creator_id = fields.Many2one('decentralized.sync.creator', string='Creator')
    dao_id = fields.Many2one('decentralized.sync.dao', string='DAO')
=== ./decentralized_sync/models/sync_manager.py ===
from odoo import models, fields, api
import logging
from nostr.key import PrivateKey
from nostr.event import Event
from nostr.relay_manager import RelayManager
import git
import os

_logger = logging.getLogger(__name__)

class DecentralizedNostrSyncManager(models.Model):
    _name = 'decentralized.sync.manager'
    _description = 'Decentralized Nostr Sync Manager'

    name = fields.Char(string='Name', required=True)
    relay_urls = fields.Text(string='Relay URLs', required=True)
    private_key = fields.Char(string='Private Key')
    public_key = fields.Char(string='Public Key', compute='_compute_public_key')

    @api.depends('private_key')
    def _compute_public_key(self):
        for record in self:
            if record.private_key:
                private_key = PrivateKey.from_nsec(record.private_key)
                record.public_key = private_key.public_key.bech32()
            else:
                record.public_key = False

    def initialize_nostr(self):
        if not self.private_key:
            private_key = PrivateKey()
            self.private_key = private_key.bech32()
        
        self.relay_manager = RelayManager()
        for url in self.relay_urls.split(','):
            self.relay_manager.add_relay(url.strip())
        self.relay_manager.open_connections()

    def publish_event(self, content, tags=None):
        if not hasattr(self, 'relay_manager'):
            self.initialize_nostr()

        private_key = PrivateKey.from_nsec(self.private_key)
        event = Event(content=content, tags=tags or [])
        private_key.sign_event(event)
        
        self.relay_manager.publish_event(event)
        return event

    def sync_git_repository(self, repo_path):
        repo = git.Repo(repo_path)
        if not repo.remotes:
            raise ValueError('No remote repository configured')

        origin = repo.remotes.origin
        origin.fetch()
        
        current_branch = repo.active_branch
        if f'origin/{current_branch.name}' not in repo.refs:
            origin.push(current_branch)
        else:
            origin.pull(current_branch)

        for commit in repo.iter_commits(f'{current_branch.name}@{{u}}..{current_branch.name}'):
            self.publish_event(
                content=f"New commit: {commit.hexsha}",
                tags=[['c', commit.hexsha], ['t', 'git_commit']]
            )

    @api.model
    def create(self, vals):
        manager = super(DecentralizedNostrSyncManager, self).create(vals)
        manager.initialize_nostr()
        return manager

    def write(self, vals):
        result = super(DecentralizedNostrSyncManager, self).write(vals)
        if 'relay_urls' in vals:
            self.initialize_nostr()
        return result
=== ./decentralized_sync/__init__.py ===
from . import models
from . import controllers
=== ./decentralized_sync/__manifest__.py ===
{
    'name': 'Decentralized Nostr Sync Manager',
    'version': '1.0',
    'category': 'Tools',
    'summary': 'Manage decentralized synchronization with Nostr and Git',
    'depends': ['base', 'ivcs_git', 'nostr_bridge'],
    'data': [
        'security/ir.model.access.csv',
        'views/sync_manager_views.xml',
        'views/dao_views.xml',
        'views/creator_views.xml',
        'views/program_views.xml',
        'views/event_views.xml',
        'views/menu_items.xml',
    ],
    'installable': True,
    'application': False,
    'auto_install': False,
}
=== ./decentralized_sync/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_decentralized_sync_manager_user,decentralized.sync.manager user,model_decentralized_sync_manager,base.group_user,1,1,1,1
access_decentralized_sync_dao_user,decentralized.sync.dao user,model_decentralized_sync_dao,base.group_user,1,1,1,1
access_decentralized_sync_creator_user,decentralized.sync.creator user,model_decentralized_sync_creator,base.group_user,1,1,1,1
access_decentralized_sync_program_user,decentralized.sync.program user,model_decentralized_sync_program,base.group_user,1,1,1,1
access_decentralized_sync_event_user,decentralized.sync.event user,model_decentralized_sync_event,base.group_user,1,1,1,1
access_decentralized_sync_connection_user,decentralized.sync.connection user,model_decentralized_sync_connection,base.group_user,1,1,1,1
=== ./decentralized_sync/controllers/main.py ===
from odoo import http
from odoo.http import request
from nostr.event import Event
import json

class DecentralizedSyncController(http.Controller):

    @http.route('/api/decentralized_sync/publish', type='json', auth='user')
    def publish_event(self, manager_id, content, tags=None):
        manager = request.env['decentralized.sync.manager'].browse(int(manager_id))
        event = manager.publish_event(content, tags)
        return {'status': 'success', 'event_id': event.id}

    @http.route('/api/decentralized_sync/sync_repo', type='json', auth='user')
    def sync_repository(self, manager_id, repo_path):
        manager = request.env['decentralized.sync.manager'].browse(int(manager_id))
        manager.sync_git_repository(repo_path)
        return {'status': 'success', 'message': 'Repository synced and events published'}

    @http.route('/api/decentralized_sync/events', type='json', auth='user')
    def get_events(self, manager_id):
        manager = request.env['decentralized.sync.manager'].browse(int(manager_id))
        # This would typically fetch events from Nostr relays
        # For now, we'll return an empty list
        return {'events': []}
=== ./nostr_auth_test/nostr_auth_module.py ===
import os
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import hashes
from odoo import models, fields, api
from odoo.exceptions import ValidationError
import base64

class NostrAuthModule(models.AbstractModel):
    _name = 'nostr.auth'
    _description = 'Nostr Authentication Module'

    @api.model
    def generate_keypair(self):
        """
        Generate a new Nostr keypair.
        This represents the 'Cause' in our 'Causal Relationship'.
        """
        private_key = ec.generate_private_key(ec.SECP256K1())
        public_key = private_key.public_key()
        
        private_bytes = private_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=serialization.NoEncryption()
        )
        public_bytes = public_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        )
        
        return {
            'private_key': base64.b64encode(private_bytes).decode('utf-8'),
            'public_key': base64.b64encode(public_bytes).decode('utf-8')
        }

    @api.model
    def store_keys(self, user_id, public_key, private_key):
        """
        Store the Nostr keys for a user.
        This action creates an 'Effect' in our 'Causal Relationship'.
        """
        user = self.env['res.users'].browse(user_id)
        if not user.exists():
            raise ValidationError("User does not exist")
        
        user.write({
            'nostr_public_key': public_key,
            'nostr_private_key': private_key  # In a real-world scenario, encrypt this before storage
        })

    @api.model
    def verify_signature(self, public_key, message, signature):
        """
        Verify a Nostr signature.
        This verification process is another 'Effect' in our 'Causal Relationship'.
        """
        try:
            public_key_obj = serialization.load_pem_public_key(base64.b64decode(public_key))
            signature_bytes = base64.b64decode(signature)
            public_key_obj.verify(
                signature_bytes,
                message.encode('utf-8'),
                ec.ECDSA(hashes.SHA256())
            )
            return True
        except:
            return False

    @api.model
    def authenticate_nostr(self, public_key, signature, message):
        """
        Authenticate a user using Nostr.
        This method embodies the complete 'Causal Relationship':
        The provided credentials (Cause) lead to authentication success or failure (Effect).
        """
        user = self.env['res.users'].search([('nostr_public_key', '=', public_key)], limit=1)
        if user and self.verify_signature(user.nostr_public_key, message, signature):
            return user.id
        return False

# For console testing
if __name__ == "__main__":
    # Simulate Odoo environment
    class MockEnv:
        def __init__(self):
            self.users = {}
        
        def __getitem__(self, key):
            return self
        
        def search(self, domain, limit=None):
            for user_id, user in self.users.items():
                if user['nostr_public_key'] == domain[0][2]:
                    return [MockUser(user_id, user)]
            return []
    
    class MockUser:
        def __init__(self, id, data):
            self.id = id
            self.__dict__.update(data)
        
        def exists(self):
            return True
        
        def write(self, vals):
            self.__dict__.update(vals)

    mock_env = MockEnv()
    
    # Create an instance of NostrAuthModule
    nostr_auth = NostrAuthModule()
    nostr_auth.env = mock_env

    # Test key generation
    print("Generating keypair...")
    keys = nostr_auth.generate_keypair()
    print(f"Public Key: {keys['public_key'][:32]}...")
    print(f"Private Key: {keys['private_key'][:32]}...")

    # Test key storage
    print("\nStoring keys...")
    mock_env.users[1] = {'name': 'Test User'}
    try:
        nostr_auth.store_keys(1, keys['public_key'], keys['private_key'])
        print("Keys stored successfully")
    except Exception as e:
        print(f"Error storing keys: {str(e)}")

    # Test signature verification
    print("\nTesting signature verification...")
    message = "Test message"
    private_key = serialization.load_pem_private_key(base64.b64decode(keys['private_key']), password=None)
    signature = base64.b64encode(private_key.sign(
        message.encode('utf-8'),
        ec.ECDSA(hashes.SHA256())
    )).decode('utf-8')
    
    is_valid = nostr_auth.verify_signature(keys['public_key'], message, signature)
    print(f"Signature valid: {is_valid}")

    # Test authentication
    print("\nTesting authentication...")
    user_id = nostr_auth.authenticate_nostr(keys['public_key'], signature, message)
    print(f"Authenticated user ID: {user_id}")

    print("\nAll tests completed.")
=== ./allfiles.txt ===
=== ./git_nostr_object/models/git_repository.py ===
# models/git_repository.py
from odoo import models, fields, api
import git
import json

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Name', required=True)
    path = fields.Char(string='Path', required=True)
    logs = fields.Text(string='Logs')

    def traverse_and_publish(self):
        self.ensure_one()
        logs = []
        try:
            git_repo = git.Repo(self.path)
            for commit in git_repo.iter_commits():
                nostr_event = self.env['nostr.event.object'].create({
                    'kind': 1,
                    'content': commit.message,
                    'tags': json.dumps([['commit', commit.hexsha]]),
                    'created_at': commit.committed_date,
                })
                nostr_event.action_publish()
                logs.append(f"Published commit {commit.hexsha}")

            self.write({'logs': '\n'.join(logs)})
            self.env['bus.bus']._sendone(self.env.user.partner_id, 'simple_notification', {
                'title': _("Git Repository Traversed"),
                'message': _("All commits published to Nostr network"),
            })
        except Exception as e:
            error_msg = f"Error traversing repository: {e}"
            logs.append(error_msg)
            self.write({'logs': '\n'.join(logs)})
            raise UserError(_(error_msg))

        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _("Git Repository"),
                'message': _("Repository traversed and commits published. Check logs for details."),
                'sticky': False,
                'type': 'success',
            }
        }
=== ./git_nostr_object/models/git_commit.py ===
from odoo import models, fields, api
from .git_object import GitObject

class GitCommit(models.Model):
    _name = 'git.commit'
    _inherit = 'git.object'
    _description = 'Git Commit'

    message = fields.Text(string='Commit Message')
    author = fields.Char(string='Author')
    timestamp = fields.Datetime(string='Timestamp')

    def to_nostr_event(self):
        return self.env['nostr.event.object'].create({
            'kind': 3121,
            'content': self.data,
            'tags': [['sha', self.sha]],
        })

    @api.model
    def create_from_nostr_event(self, event):
        git_commit = GitObject.from_nostr_event(event)
        return self.create({
            'sha': git_commit.sha,
            'data': git_commit.data.decode('utf-8', errors='replace'),
            'message': git_commit.message,
            'author': git_commit.author,
            'timestamp': git_commit.timestamp,
        })
    @api.model
    def create_from_git_commit(self, commit):
        return self.create({
            'sha': commit.hexsha,
            'message': commit.message,
            'author': f"{commit.author.name} <{commit.author.email}>",
            'timestamp': commit.committed_datetime,
            'data': commit.tree.data_stream.read().decode('utf-8', errors='replace'),
        })
=== ./git_nostr_object/models/nostr_websocket_client.py ===
import websocket
import json
import logging
import time

_logger = logging.getLogger(__name__)

class NostrWebSocketClient:
    def __init__(self, relay_urls):
        self.relay_urls = relay_urls

    def connect_and_publish(self, event_data):
        responses = []
        for url in self.relay_urls:
            try:
                _logger.info(f"Attempting to connect to {url}")
                start_time = time.time()
                ws = websocket.create_connection(url, timeout=10)
                _logger.info(f"Connected to {url} in {time.time() - start_time:.2f} seconds")

                # Construct the message correctly
                message = ["EVENT", event_data]
                _logger.debug(f"Raw event message: {message}")

                ws.send(json.dumps(message))
                _logger.info(f"Sent message to {url} in {time.time() - start_time:.2f} seconds")

                _logger.info(f"Waiting for response from {url}")
                response = ws.recv()
                _logger.info(f"Received response from {url} in {time.time() - start_time:.2f} seconds: {response}")

                responses.append(json.loads(response))
                ws.close()
            except Exception as e:
                _logger.error(f"Error publishing to {url}: {str(e)}")
                responses.append(["ERROR", str(e)])
        return responses
=== ./git_nostr_object/models/__init__.py ===
# __init__.py
from . import git_object
from . import git_commit
from . import git_tree
from . import git_blob
from . import git_repository
from . import nostr_event
from . import admin_test
from . import git_commit_wizard
=== ./git_nostr_object/models/git_object.py ===
from odoo import models, fields, api

class GitObject(models.AbstractModel):
    _name = 'git.object'
    _description = 'Git Object'

    sha = fields.Char(string='SHA', required=True)
    data = fields.Text(string='Data', required=True)

    def to_nostr_event(self):
        raise NotImplementedError("This method should be implemented by subclasses")

    @api.model
    def create_from_nostr_event(self, event):
        raise NotImplementedError("This method should be implemented by subclasses")
=== ./git_nostr_object/models/git_nostr_object.py ===
# models/git_nostr_event.py
from odoo import models, fields, api
from utils.nostr_websocket_client import NostrWebSocketClient
from nostr.event import Event as NostrEvent
import logging
import time
import json

_logger = logging.getLogger(__name__)

class GitNostrEventObject(models.Model):
    _name = 'git_nostr.event.object'
    _description = 'Git Nostr Event Object'

    kind = fields.Integer(string='Event Kind', required=True)
    content = fields.Text(string='Content', required=True)
    tags = fields.Text(string='Tags')
    created_at = fields.Integer(string='Created At', required=True)
    signature = fields.Char(string='Signature', required=True)
    public_key = fields.Char(string='Public Key', required=True)
    published = fields.Boolean(string='Published', default=False)

    def action_publish(self):
        """
        Publish the Nostr event to the configured relays.
        """
        relay_urls = [
            'wss://relay.damus.io',
            'wss://nostr-pub.wellorder.net',
            'wss://nostr.mom',
            'wss://nostr.slothy.win',
            'wss://relay.stoner.com'
        ]

        event_data = {
            'kind': self.kind,
            'content': self.content,
            'tags': self.tags,
            'created_at': self.created_at,
            'pubkey': self.public_key,
            'sig': self.signature,
        }

        websocket_client = NostrWebSocketClient(relay_urls)

        try:
            responses = websocket_client.connect_and_publish(event_data)
            if all(response[0] == 'OK' and response[2] for response in responses):
                self.write({'published': True})
                _logger.info(f"Nostr event successfully published: {self.id}")
            else:
                self.write({'published': False})
                _logger.error(f"Error publishing Nostr event {self.id}: {responses}")
        except Exception as e:
            self.write({'published': False})
            _logger.error(f"Error publishing Nostr event {self.id}: {e}")

    def to_nostr_event(self):
        try:
            tags = json.loads(self.tags) if self.tags else []
        except json.JSONDecodeError:
            _logger.warning(f"Invalid JSON in tags for event {self.id}. Using empty tags list.")
            tags = []

        return NostrEvent(
            kind=self.kind,
            content=self.content,
            tags=tags,
            public_key=self.public_key,
            created_at=self.created_at,
            sig=self.signature
        )
=== ./git_nostr_object/models/git_blob.py ===
from odoo import models, fields, api
from .git_object import GitObject

class GitBlob(models.Model):
    _name = 'git.blob'
    _inherit = 'git.object'
    _description = 'Git Blob'

    def to_nostr_event(self):
        return self.env['nostr.event.object'].create({
            'kind': 3123,
            'content': self.data,
            'tags': [['sha', self.sha]],
        })

    @api.model
    def create_from_nostr_event(self, event):
        git_blob = GitObject.from_nostr_event(event)
        return self.create({
            'sha': git_blob.sha,
            'data': git_blob.data.hex(),
        })
=== ./git_nostr_object/models/git_tree.py ===
from odoo import models, fields, api
from .git_object import GitObject

class GitTree(models.Model):
    _name = 'git.tree'
    _inherit = 'git.object'
    _description = 'Git Tree'

    def to_nostr_event(self):
        return self.env['nostr.event.object'].create({
            'kind': 3122,
            'content': self.data,
            'tags': [['sha', self.sha]],
        })

    @api.model
    def create_from_nostr_event(self, event):
        git_tree = GitObject.from_nostr_event(event)
        return self.create({
            'sha': git_tree.sha,
            'data': git_tree.data.decode('utf-8', errors='replace'),
        })
=== ./git_nostr_object/models/nostr_event.py ===
# models/nostr_event.py
from odoo import models, fields, api, _
from odoo.exceptions import UserError
from ..utils.nostr_websocket_client import NostrWebSocketClient
from nostr.event import Event as NostrEvent
from nostr.key import PrivateKey
import logging
import json
import time

_logger = logging.getLogger(__name__)

class NostrEventObject(models.Model):
    _name = 'nostr.event.object'
    _description = 'Nostr Event Object'

    kind = fields.Integer(string='Event Kind', required=True)
    content = fields.Text(string='Content', required=True)
    tags = fields.Text(string='Tags')
    created_at = fields.Integer(string='Created At', required=True)
    signature = fields.Char(string='Signature')
    public_key = fields.Char(string='Public Key', required=True)
    published = fields.Boolean(string='Published', default=False)
    logs = fields.Text(string='Logs')

    def action_publish(self):
        self.ensure_one()
        if self.published:
            raise UserError(_("This event has already been published."))

        start_time = time.time()
        logs = []

        # Get the user's private key
        user = self.env.user
        private_key_nsec = user.nostr_private_key
        if not private_key_nsec:
            raise UserError(_("Nostr private key is not set for the current user."))

        try:
            private_key = PrivateKey.from_nsec(private_key_nsec)
        except Exception as e:
            raise UserError(_("Invalid Nostr private key: %s") % str(e))

        logs.append(f"Key preparation took {time.time() - start_time:.4f} seconds")

        # Create and sign the Nostr event
        event_creation_start = time.time()
        event = NostrEvent(
            kind=self.kind,
            content=self.content,
            tags=json.loads(self.tags) if self.tags else [],
            public_key=private_key.public_key.hex(),
            created_at=int(time.time())
        )
        private_key.sign_event(event)
        logs.append(f"Event creation and signing took {time.time() - event_creation_start:.4f} seconds")

        # Update the record
        self.write({
            'signature': event.signature,
            'public_key': event.public_key,
            'created_at': event.created_at
        })

        relay_urls = [
            'wss://relay.damus.io',
            'wss://nostr-pub.wellorder.net',
            'wss://nostr.mom',
            'wss://nostr.slothy.win',
            'wss://relay.stoner.com'
        ]

        event_data = json.loads(event.to_message())[1]
        websocket_client = NostrWebSocketClient(relay_urls)

        publish_start = time.time()
        try:
            responses, ws_logs = websocket_client.connect_and_publish(event_data)
            logs.extend(ws_logs)
            if any(response[0] == 'OK' for response in responses):
                self.write({'published': True})
                logs.append(f"Nostr event successfully published: {self.id}")
                self.env['bus.bus']._sendone(self.env.user.partner_id, 'simple_notification', {
                    'title': _("Nostr Event Published"),
                    'message': _("Event successfully published to Nostr network"),
                })
            else:
                error_msg = f"Error publishing Nostr event {self.id}: {responses}"
                logs.append(error_msg)
                raise UserError(_(error_msg))
        except Exception as e:
            error_msg = f"Error publishing Nostr event {self.id}: {e}"
            logs.append(error_msg)
            raise UserError(_(error_msg))
        finally:
            logs.append(f"Publishing process took {time.time() - publish_start:.4f} seconds")

        logs.append(f"Total publish action took {time.time() - start_time:.4f} seconds")
        self.write({'logs': '\n'.join(logs)})

        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _("Nostr Event"),
                'message': _("Event published successfully. Check logs for details."),
                'sticky': False,
                'type': 'success',
            }
        }
=== ./git_nostr_object/models/git_commit_wizard.py ===
from odoo import models, fields, api

class GitCommitWizard(models.TransientModel):
    _name = 'git.commit.wizard'
    _description = 'Git Commit Wizard'

    repository_id = fields.Many2one('git.repository', string='Repository', required=True)
    message = fields.Text(string='Commit Message', required=True)
    file_data = fields.Text(string='File Content')
    file_name = fields.Char(string='File Name')

    def action_create_commit(self):
        repo = self.repository_id
        with open(f"{repo.path}/{self.file_name}", 'w') as f:
            f.write(self.file_data)
        commit = repo.create_commit(self.message, [self.file_name])
        return {'type': 'ir.actions.act_window_close'}
=== ./git_nostr_object/models/admin_test.py ===
# /opt/odoo/custom_addons/git_nostr_object/models/admin_test.py
from odoo import models, api
from ..tests.test_git_nostr_object import test_git_nostr_object, test_nostr_auth

class AdminTest(models.TransientModel):
    _name = 'git_nostr_object.admin_test'
    _description = 'Admin Test for Git-Nostr Object'

    def run_tests(self):
        test_git_nostr_object()
        test_nostr_auth()
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': 'Test Results',
                'message': 'Tests completed. Check the logs for details.',
                'sticky': False,
            }
        }
=== ./git_nostr_object/__init__.py ===
from . import models
from . import controllers
=== ./git_nostr_object/utils/nostr_websocket_client.py ===
# utils/nostr_websocket_client.py
import logging
import time
import websocket
import json

_logger = logging.getLogger(__name__)

class NostrWebSocketClient:
    def __init__(self, relay_urls):
        self.relay_urls = relay_urls

    def connect_and_publish(self, event_data):
        responses = []
        logs = []
        for url in self.relay_urls:
            try:
                response, log = self._connect_and_publish_to_relay(url, event_data)
                responses.append(response)
                logs.extend(log)
            except Exception as e:
                error_message = f"Error publishing event to relay {url}: {e}"
                _logger.error(error_message)
                logs.append(error_message)
        return responses, logs

    def _connect_and_publish_to_relay(self, relay_url, event_data):
        log = []
        log.append(f"Attempting to connect to {relay_url}")
        start_time = time.time()

        ws = websocket.create_connection(relay_url)
        log.append(f"Connected to {relay_url} in {time.time() - start_time:.2f} seconds")

        event_message = json.dumps(["EVENT", event_data])
        log.append(f"Sending Nostr event to {relay_url}")
        ws.send(event_message)
        log.append(f"Sent message to {relay_url} in {time.time() - start_time:.2f} seconds")

        log.append(f"Waiting for response from {relay_url}")
        response = ws.recv()
        log.append(f"Received response from {relay_url} in {time.time() - start_time:.2f} seconds: {response}")
        ws.close()
        return json.loads(response), log
=== ./git_nostr_object/__manifest__.py ===
{
    'name': 'git_nostr_object',
    'version': '1.0',
    'depends': ['base', 'bus'],
    'data': [
        'security/ir.model.access.csv',
        'views/git_repository_views.xml',
        'views/git_commit_views.xml',
        'views/git_tree_views.xml',
        'views/git_blob_views.xml',
        'views/git_object_views.xml',
        'views/nostr_event_object_views.xml',
        'views/actions.xml',
        'views/menus.xml',
        'views/admin_test_views.xml',
        'views/git_commit_wizard_views.xml'
    ],
    'assets': {
        'web.assets_backend': [
            'git_nostr_object/static/src/js/git_nostr_notifications.js',
        ],
    },
    'installable': True,
    'application': True,
    'auto_install': False,
}
=== ./git_nostr_object/static/src/js/git_nostr_notifications.js ===
// static/src/js/git_nostr_notifications.js
odoo.define('git_nostr_object.notifications', function (require) {
    "use strict";

    var core = require('web.core');
    var session = require('web.session');
    var BusService = require('bus.BusService');

    BusService.include({
        _onNotification: function (notifications) {
            var self = this;
            _.each(notifications, function (notification) {
                if (notification[0][1] === 'simple_notification') {
                    self.displayNotification({
                        title: notification[1].title,
                        message: notification[1].message,
                        type: 'info',
                    });
                }
            });
            this._super.apply(this, arguments);
        },
    });
});
=== ./git_nostr_object/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_git_commit,access_git_commit,model_git_commit,base.group_user,1,1,1,1
access_git_tree,access_git_tree,model_git_tree,base.group_user,1,1,1,1
access_git_blob,access_git_blob,model_git_blob,base.group_user,1,1,1,1
access_git_repository,access_git_repository,model_git_repository,base.group_user,1,1,1,1
access_nostr_event_object,access_nostr_event_object,model_nostr_event_object,base.group_user,1,1,1,1
=== ./git_nostr_object/tests/__init__.py ===
# /opt/odoo/custom_addons/git_nostr_object/tests/__init__.py
from . import test_git_nostr_object
=== ./git_nostr_object/tests/test_git_nostr_object.py ===
from odoo.tests.common import TransactionCase
from datetime import datetime
import random
import string
import logging
import os

_logger = logging.getLogger(__name__)

def random_string(length=10):
    return ''.join(random.choices(string.ascii_letters + string.digits, k=length))

def generate_sha():
    """Generate a random 40-character SHA hash"""
    return ''.join(random.choices('0123456789abcdef', k=40))

def get_current_timestamp():
    """Return the current timestamp"""
    return int(datetime.now().timestamp())

def get_author(env):
    """Return the logged-in user's name as the author"""
    return env.user.name

def get_local_path():
    """Return the Odoo installation path as the local path"""
    return '/opt/odoo'

def generate_nostr_keys():
    """Generate random 64-character Nostr public and private keys for the logged-in user"""
    public_key = random_string(64)
    private_key = random_string(64)
    return public_key, private_key

def get_event_type(content):
    """Extract the event type from the first line of the content"""
    return int(content.split('\n')[0].strip('# '))

def get_event_name(content):
    """Extract the event name from the first line of the content"""
    return content.split('\n', 1)[0]

def check_method_existence(env, methods):
    """Check if the required methods exist in the corresponding models"""
    for model, method_name in methods.items():
        model_obj = env[model]
        if not hasattr(model_obj, method_name):
            return False, f"Method '{method_name}' not found in model '{model}'"
    return True, "All required methods found"

class TestGitNostrObject(TransactionCase):

    def setUp(self):
        super(TestGitNostrObject, self).setUp()
        self.GitRepository = self.env['git.repository']
        self.GitCommit = self.env['git.commit']
        self.GitTree = self.env['git.tree']
        self.GitBlob = self.env['git.blob']
        self.GitNostrEventObject = self.env['git_nostr.event.object']
        self.NostrKey = self.env['nostr.key']
        self.NostrRelay = self.env['nostr.relay']
        self.NostrProfile = self.env['nostr.profile']

        # Check if required methods exist in the corresponding models
        required_methods = {
            'git.repository': 'traverse_and_publish',
            'nostr.event.object': 'action_publish',
            'nostr.key': 'generate_key_pair',
            'nostr.key': 'sign_event'
        }
        success, message = check_method_existence(self.env, required_methods)
        if not success:
            self.fail(message)

    def test_git_nostr_object(self):
        _logger.info("Testing Git-Nostr Object module...")

        # Test Git Repository
        repo_name = f'Test Repo {random_string()}'
        repo_path = f'{get_local_path()}/custom_addons/git_nostr_object/tests/test_repo_{random_string()}'
        repo = self.GitRepository.create({
            'name': repo_name,
            'path': repo_path
        })
        _logger.info(f"Created Git Repository with ID: {repo.id}")

        # Test traverse_and_publish
        try:
            repo.traverse_and_publish()
            _logger.info("traverse_and_publish executed successfully")
        except Exception as e:
            _logger.error(f"Error in traverse_and_publish: {e}")

        # Test Git Commit
        commit_sha = generate_sha()
        commit_author = get_author(self.env)
        commit_timestamp = get_current_timestamp()
        commit_data = 'Test commit data'
        commit = self.GitCommit.create({
            'sha': commit_sha,
            'message': 'Test commit message',
            'author': commit_author,
            'timestamp': commit_timestamp,
            'data': commit_data
        })
        _logger.info(f"Created Git Commit with ID: {commit.id}")

        # Test Git Tree
        tree_sha = generate_sha()
        tree_data = 'Test tree data'
        tree = self.GitTree.create({
            'sha': tree_sha,
            'data': tree_data
        })
        _logger.info(f"Created Git Tree with ID: {tree.id}")

        # Test Git Blob
        blob_sha = generate_sha()
        blob_data = 'Test blob data'
        blob = self.GitBlob.create({
            'sha': blob_sha,
            'data': blob_data
        })
        _logger.info(f"Created Git Blob with ID: {blob.id}")

        # Test Nostr Event Object
        event_content = '# 1\nTest Nostr event content'
        event_type = get_event_type(event_content)
        event_tags = '[]'
        event_created_at = get_current_timestamp()
        event_signature = random_string(64)
        event_name = get_event_name(event_content)
        event = self.GitNostrEventObject.create({
            'kind': event_type,
            'content': event_content,
            'tags': event_tags,
            'created_at': event_created_at,
            'signature': event_signature,
            'name': event_name
        })
        _logger.info(f"Created Nostr Event Object with ID: {event.id}")

        # Test action_publish
        try:
            event.action_publish()
            _logger.info("action_publish executed successfully")
        except Exception as e:
            _logger.error(f"Error in action_publish: {e}")

    def test_nostr_auth(self):
        _logger.info("Testing Nostr Authentication module...")

        # Test Nostr Key
        public_key, private_key = generate_nostr_keys()
        key = self.NostrKey.create({
            'public_key': public_key,
            'private_key': private_key,
            'user_id': self.env.user.id
        })
        _logger.info(f"Created Nostr Key with ID: {key.id}")

        # Test Nostr Relay
        relay_url = f'wss://relay{random_string()}.com'
        relay = self.NostrRelay.create({
            'url': relay_url,
            'is_active': True
        })
        _logger.info(f"Created Nostr Relay with ID: {relay.id}")

        # Test Nostr Profile
        profile_name = f'Test Profile {random_string()}'
        profile_about = 'Test profile description'
        profile_picture = 'http://example.com/pic.jpg'
        profile = self.NostrProfile.create({
            'name': profile_name,
            'about': profile_about,
            'picture': profile_picture,
            'user_id': self.env.user.id
        })
        _logger.info(f"Created Nostr Profile with ID: {profile.id}")

        # Test generate_key_pair method
        try:
            result = self.NostrKey.generate_key_pair()
            _logger.info(f"Generated key pair: {result}")
        except Exception as e:
            _logger.error(f"Error in generate_key_pair: {e}")

        # Test sign_event method (assuming it exists)
        try:
            event_data = {
                'kind': 1,
                'content': 'Test content',
                'created_at': get_current_timestamp(),
                'tags': []
            }
            result = key.sign_event(event_data)
            _logger.info(f"Signed event: {result}")
        except Exception as e:
            _logger.error(f"Error in sign_event: {e}")

def test_git_nostr_object():
    test_case = TestGitNostrObject.create({})
    test_case.test_git_nostr_object()

def test_nostr_auth():
    test_case = TestGitNostrObject.create({})
    test_case.test_nostr_auth()

# This allows running the test from the Odoo shell
if __name__ == '__main__':
    test_git_nostr_object()
    test_nostr_auth()
=== ./git_nostr_object/views/git_blob_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_blob_form" model="ir.ui.view">
        <field name="name">git.blob.form</field>
        <field name="model">git.blob</field>
        <field name="arch" type="xml">
            <form>
                <group>
                    <field name="sha"/>
                    <field name="data"/>
                </group>
            </form>
        </field>
    </record>

    <record id="view_git_blob_tree" model="ir.ui.view">
        <field name="name">git.blob.tree</field>
        <field name="model">git.blob</field>
        <field name="arch" type="xml">
            <tree>
                <field name="sha"/>
            </tree>
        </field>
    </record>

    <record id="action_git_blob" model="ir.actions.act_window">
        <field name="name">Git Blobs</field>
        <field name="res_model">git.blob</field>
        <field name="view_mode">tree,form</field>
    </record>
</odoo>
=== ./git_nostr_object/views/menus.xml ===
<!-- views/menus.xml -->
<odoo>
    <menuitem id="menu_git_nostr_object_root" name="Git-Nostr Object">
        <menuitem id="menu_git_repository" name="Repositories" action="action_git_repository"/>
        <menuitem id="menu_git_commit" name="Commits" action="action_git_commit"/>
        <menuitem id="menu_git_tree" name="Trees" action="action_git_tree"/>
        <menuitem id="menu_git_blob" name="Blobs" action="action_git_blob"/>
        <menuitem id="menu_git_nostr_event_object" name="Nostr Event Objects" action="action_git_nostr_event_object"/>
    </menuitem>
</odoo>
=== ./git_nostr_object/views/git_commit_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_commit_form" model="ir.ui.view">
        <field name="name">git.commit.form</field>
        <field name="model">git.commit</field>
        <field name="arch" type="xml">
            <form>
                <group>
                    <field name="sha"/>
                    <field name="message"/>
                    <field name="author"/>
                    <field name="timestamp"/>
                    <field name="data"/>
                </group>
            </form>
        </field>
    </record>

    <record id="view_git_commit_tree" model="ir.ui.view">
        <field name="name">git.commit.tree</field>
        <field name="model">git.commit</field>
        <field name="arch" type="xml">
            <tree>
                <field name="sha"/>
                <field name="message"/>
                <field name="author"/>
                <field name="timestamp"/>
            </tree>
        </field>
    </record>

    <record id="action_git_commit" model="ir.actions.act_window">
        <field name="name">Git Commits</field>
        <field name="res_model">git.commit</field>
        <field name="view_mode">tree,form</field>
    </record>
</odoo>
=== ./git_nostr_object/views/git_object_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_object_form" model="ir.ui.view">
        <field name="name">git.object.form</field>
        <field name="model">git.object</field>
        <field name="arch" type="xml">
            <form>
                <group>
                    <field name="sha"/>
                    <field name="data"/>
                </group>
            </form>
        </field>
    </record>

    <record id="view_git_object_tree" model="ir.ui.view">
        <field name="name">git.object.tree</field>
        <field name="model">git.object</field>
        <field name="arch" type="xml">
            <tree>
                <field name="sha"/>
            </tree>
        </field>
    </record>
</odoo>
=== ./git_nostr_object/views/admin_test_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_admin_test_form" model="ir.ui.view">
        <field name="name">git_nostr_object.admin_test.form</field>
        <field name="model">git_nostr_object.admin_test</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="run_tests" string="Run Tests" type="object" class="oe_highlight"/>
                </header>
                <div>
                    <p>Click the button to run the Git-Nostr Object tests.</p>
                </div>
            </form>
        </field>
    </record>

    <record id="action_admin_test" model="ir.actions.act_window">
        <field name="name">Admin Tests</field>
        <field name="res_model">git_nostr_object.admin_test</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
    </record>

    <menuitem id="menu_admin_test" name="Admin Tests" parent="menu_git_nostr_object_root" action="action_admin_test" groups="base.group_system"/>
</odoo>
=== ./git_nostr_object/views/git_commit_wizard_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_commit_wizard_form" model="ir.ui.view">
        <field name="name">git.commit.wizard.form</field>
        <field name="model">git.commit.wizard</field>
        <field name="arch" type="xml">
            <form string="Create Commit">
                <group>
                    <field name="repository_id" invisible="1"/>
                    <field name="message"/>
                    <field name="file_name"/>
                    <field name="file_data"/>
                </group>
                <footer>
                    <button name="action_create_commit" string="Create Commit" type="object" class="btn-primary"/>
                    <button string="Cancel" class="btn-secondary" special="cancel"/>
                </footer>
            </form>
        </field>
    </record>
</odoo>
=== ./git_nostr_object/views/git_tree_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_tree_form" model="ir.ui.view">
        <field name="name">git.tree.form</field>
        <field name="model">git.tree</field>
        <field name="arch" type="xml">
            <form>
                <group>
                    <field name="sha"/>
                    <field name="data"/>
                </group>
            </form>
        </field>
    </record>

    <record id="view_git_tree_tree" model="ir.ui.view">
        <field name="name">git.tree.tree</field>
        <field name="model">git.tree</field>
        <field name="arch" type="xml">
            <tree>
                <field name="sha"/>
            </tree>
        </field>
    </record>

    <record id="action_git_tree" model="ir.actions.act_window">
        <field name="name">Git Trees</field>
        <field name="res_model">git.tree</field>
        <field name="view_mode">tree,form</field>
    </record>
</odoo>
=== ./git_nostr_object/views/nostr_event_object_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_nostr_event_object_form" model="ir.ui.view">
        <field name="name">nostr.event.object.form</field>
        <field name="model">nostr.event.object</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="action_publish" string="Publish Event" type="object" class="oe_highlight" attrs="{'invisible': [('published', '=', True)]}"/>
                </header>
                <sheet>
                    <group>
                        <field name="kind"/>
                        <field name="content"/>
                        <field name="tags"/>
                        <field name="created_at"/>
                        <field name="signature"/>
                        <field name="public_key"/>
                        <field name="published"/>
                    </group>
                    <notebook>
                        <page string="Logs">
                            <field name="logs" widget="text" readonly="1"/>
                        </page>
                    </notebook>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_nostr_event_object_tree" model="ir.ui.view">
        <field name="name">nostr.event.object.tree</field>
        <field name="model">nostr.event.object</field>
        <field name="arch" type="xml">
            <tree string="Nostr Event Objects">
                <field name="kind"/>
                <field name="content"/>
                <field name="tags"/>
                <field name="created_at"/>
                <field name="signature"/>
                <field name="public_key"/>
                <field name="published"/>
            </tree>
        </field>
    </record>

    <record id="action_nostr_event_object" model="ir.actions.act_window">
        <field name="name">Nostr Event Objects</field>
        <field name="res_model">nostr.event.object</field>
        <field name="view_mode">tree,form</field>
    </record>
</odoo>
=== ./git_nostr_object/views/git_repository_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_repository_form" model="ir.ui.view">
        <field name="name">git.repository.form</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="traverse_and_publish" string="Traverse and Publish" type="object" class="oe_highlight"/>
                </header>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="path" string="Local Path"/>
                    </group>
                    <notebook>
                        <page string="Logs">
                            <field name="logs" widget="text" readonly="1"/>
                        </page>
                    </notebook>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_git_repository_tree" model="ir.ui.view">
        <field name="name">git.repository.tree</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="path"/>
            </tree>
        </field>
    </record>

    <record id="action_git_repository" model="ir.actions.act_window">
        <field name="name">Git Repositories</field>
        <field name="res_model">git.repository</field>
        <field name="view_mode">tree,form</field>
    </record>
</odoo>
=== ./git_nostr_object/views/actions.xml ===
<!-- views/actions.xml -->
<odoo>
    <record id="action_git_nostr_event_object" model="ir.actions.act_window">
        <field name="name">Nostr Event Objects</field>
        <field name="res_model">nostr.event.object</field>
        <field name="view_mode">tree,form</field>
    </record>
</odoo>
=== ./git_nostr_object/controllers/git_controller.py ===
from odoo import http
from odoo.http import request
import logging

_logger = logging.getLogger(__name__)

class GitController(http.Controller):

    @http.route('/git_nostr_object/traverse_repo', type='json', auth='user')
    def traverse_repo(self, repo_id):
        try:
            repo = request.env['git.repository'].browse(repo_id)
            repo.traverse_and_publish()
            return {'status': 'success'}
        except Exception as e:
            _logger.exception("Error traversing repository")
            return {'status': 'error', 'message': str(e)}

    @http.route('/git_nostr_object/publish_event', type='json', auth='user')
    def publish_event(self, event_id):
        try:
            event = request.env['git_nostr.event.object'].browse(event_id)
            event.action_publish()
            return {'status': 'success'}
        except Exception as e:
            _logger.exception("Error publishing Nostr event")
            return {'status': 'error', 'message': str(e)}
=== ./custom_thunderbird_mail/models/custom_mail.py ===
import smtplib
from email.mime.text import MIMEText
from odoo import models, fields, api

class CustomMail(models.Model):
    _name = 'custom.mail'
    _description = 'Custom Mail Integration with Thunderbird Mail'

    @api.model
    def send_thunderbird_mail(self, recipient, subject, body):
        # Thunderbird SMTP server configuration
        smtp_server = 'test'
        smtp_port = 587
        smtp_user = 'g'
        smtp_password = 'your_thunderbird_password'  # Replace with the actual password

        # Create the email message
        msg = MIMEText(body)
        msg['Subject'] = subject
        msg['From'] = smtp_user
        msg['To'] = recipient

        # Send the email
        try:
            with smtplib.SMTP(smtp_server, smtp_port) as server:
                server.login(smtp_user, smtp_password)
                server.sendmail(smtp_user, [recipient], msg.as_string())
            return True
        except Exception as e:
            _logger.error('Failed to send email: %s', e)
            return False
=== ./custom_thunderbird_mail/__init__.py ===
from . import models
=== ./custom_thunderbird_mail/__manifest__.py ===
{
    'name': 'Custom Thunderbird Mail Integration',
    'version': '1.0',
    'category': 'Tools',
    'summary': 'Integrate Odoo with Thunderbird Mail',
    'description': 'A module to integrate Odoo with Thunderbird Mail for sending emails.',
    'depends': ['base'],
    'data': [],
    'installable': True,
    'application': True,
}
=== ./custom_thunderbird_mail/wizard/create_nostr_event_wizard.py ===
# wizard/create_nostr_event_wizard.py
from odoo import models, fields, api
import git
import json

class CreateNostrEventWizard(models.TransientModel):
    _name = 'create.nostr.event.wizard'
    _description = 'Create Nostr Event Wizard'

    repository_id = fields.Many2one('git.repository', string='Repository', required=True)
    event_type = fields.Selection([
        ('repo_anchor', 'Repository Anchor'),
        ('branch', 'Branch'),
        ('commit', 'Commit'),
        ('tree', 'Tree'),
        ('blob', 'Blob'),
    ], string='Event Type', required=True)
    commit_message = fields.Text(string='Commit Message')
    branch_name = fields.Char(string='Branch Name')
    file_content = fields.Text(string='File Content')
    file_name = fields.Char(string='File Name')

    def action_create_event(self):
        repo = git.Repo(self.repository_id.path)
        
        if self.event_type == 'commit':
            # Stage all changes
            repo.git.add(A=True)
            # Commit changes
            commit = repo.index.commit(self.commit_message)
            self.repository_id.last_commit = commit.hexsha
            content = json.dumps({
                'type': 'commit',
                'repository': self.repository_id.name,
                'commit_hash': commit.hexsha,
                'message': self.commit_message,
            })
        elif self.event_type == 'branch':
            repo.git.checkout('-b', self.branch_name)
            self.repository_id.branch = self.branch_name
            content = json.dumps({
                'type': 'branch',
                'repository': self.repository_id.name,
                'branch_name': self.branch_name,
            })
        elif self.event_type == 'blob':
            with open(os.path.join(self.repository_id.path, self.file_name), 'w') as f:
                f.write(self.file_content)
            repo.index.add([self.file_name])
            commit = repo.index.commit(f"Add file: {self.file_name}")
            self.repository_id.last_commit = commit.hexsha
            content = json.dumps({
                'type': 'blob',
                'repository': self.repository_id.name,
                'file_name': self.file_name,
                'commit_hash': commit.hexsha,
            })
        
        self.env['nostr.event'].create({
            'name': f"{self.event_type.capitalize()} - {self.repository_id.name}",
            'event_type': self.event_type,
            'content': content,
            'tags': json.dumps([['r', self.repository_id.remote_url]]),
        })

        return {'type': 'ir.actions.act_window_close'}
=== ./custom_thunderbird_mail/wizard/__init__.py ===
# wizard/__init__.py
from . import create_nostr_event_wizard
=== ./custom_thunderbird_mail/wizard/create_nostr_event_wizard_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_create_nostr_event_wizard_form" model="ir.ui.view">
        <field name="name">create.nostr.event.wizard.form</field>
        <field name="model">create.nostr.event.wizard</field>
        <field name="arch" type="xml">
            <form string="Create Nostr Event">
                <group>
                    <field name="repository_id"/>
                    <field name="event_type"/>
                    <field name="commit_message" attrs="{'invisible': [('event_type', '!=', 'commit')], 'required': [('event_type', '=', 'commit')]}"/>
                    <field name="branch_name" attrs="{'invisible': [('event_type', '!=', 'branch')], 'required': [('event_type', '=', 'branch')]}"/>
                    <field name="file_name" attrs="{'invisible': [('event_type', '!=', 'blob')], 'required': [('event_type', '=', 'blob')]}"/>
                    <field name="file_content" attrs="{'invisible': [('event_type', '!=', 'blob')], 'required': [('event_type', '=', 'blob')]}" widget="ace" options="{'mode': 'xml'}"/>
                </group>
                <footer>
                    <button name="action_create_event" string="Create Event" type="object" class="btn-primary"/>
                    <button string="Cancel" class="btn-secondary" special="cancel"/>
                </footer>
            </form>
        </field>
    </record>

    <record id="action_create_nostr_event_wizard" model="ir.actions.act_window">
        <field name="name">Create Nostr Event</field>
        <field name="res_model">create.nostr.event.wizard</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
    </record>
</odoo>
=== ./custom_thunderbird_mail/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_git_repository,access_git_repository,model_git_repository,base.group_user,1,1,1,1
access_nostr_event,access_nostr_event,model_nostr_event,base.group_user,1,1,1,1
access_create_nostr_event_wizard,access_create_nostr_event_wizard,model_create_nostr_event_wizard,base.group_user,1,1,1,0
=== ./custom_thunderbird_mail/views/res_users_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_users_form_inherit_git_nostr" model="ir.ui.view">
        <field name="name">res.users.form.inherit.git.nostr</field>
        <field name="model">res.users</field>
        <field name="inherit_id" ref="base.view_users_form"/>
        <field name="arch" type="xml">
            <notebook position="inside">
                <page string="Nostr Settings" name="nostr_settings">
                    <group>
                        <field name="nostr_private_key" password="True"/>
                        <field name="nostr_public_key"/>
                    </group>
                </page>
            </notebook>
        </field>
    </record>
</odoo>
=== ./custom_thunderbird_mail/views/res_config_settings_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="res_config_settings_view_form" model="ir.ui.view">
        <field name="name">res.config.settings.view.form.inherit.git_nostr_bridge</field>
        <field name="model">res.config.settings</field>
        <field name="inherit_id" ref="base.res_config_settings_view_form"/>
        <field name="arch" type="xml">
            <xpath expr="//div[hasclass('settings')]" position="inside">
                <div class="app_settings_block" data-string="Git-Nostr Bridge" string="Git-Nostr Bridge" data-key="git_nostr_bridge">
                    <h2>Nostr Settings</h2>
                    <div class="row mt16 o_settings_container">
                        <div class="col-12 col-lg-6 o_setting_box">
                            <div class="o_setting_left_pane"/>
                            <div class="o_setting_right_pane">
                                <span class="o_form_label">Nostr Relay URLs</span>
                                <div class="text-muted">
                                    Comma-separated list of Nostr relay URLs
                                </div>
                                <div class="content-group">
                                    <div class="mt16">
                                        <field name="git_nostr_relay_urls"/>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </xpath>
        </field>
    </record>
</odoo>
=== ./custom_thunderbird_mail/views/nostr_event_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_nostr_event_form" model="ir.ui.view">
        <field name="name">nostr.event.form</field>
        <field name="model">nostr.event</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="action_publish" string="Publish" type="object" class="oe_highlight" attrs="{'invisible': [('published', '=', True)]}"/>
                </header>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="event_type"/>
                        <field name="content"/>
                        <field name="tags"/>
                        <field name="published"/>
                        <field name="event_id"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_nostr_event_form_git_nostr" model="ir.ui.view">
        <field name="name">nostr.event.form.git.nostr</field>
        <field name="model">nostr.event</field>
        <field name="inherit_id" ref="integrated_ivcs.view_nostr_event_form"/>
        <field name="arch" type="xml">
            <xpath expr="//field[@name='event_type']" position="after">
                <field name="repository_id" attrs="{'invisible': [('event_type', 'not in', ['repo_anchor', 'branch', 'commit', 'tree', 'blob'])]}"/>
            </xpath>
        </field>
    </record>

    <record id="action_nostr_event" model="ir.actions.act_window">
        <field name="name">Nostr Events</field>
        <field name="res_model">nostr.event</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_nostr_event_git" name="Git Nostr Events" parent="menu_git_nostr_bridge" action="integrated_ivcs.action_nostr_event" sequence="20"/>
</odoo>
=== ./custom_thunderbird_mail/views/git_repository_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_repository_form" model="ir.ui.view">
        <field name="name">git.repository.form</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="action_pull" string="Pull" type="object" class="oe_highlight"/>
                    <button name="action_push" string="Push" type="object" class="oe_highlight"/>
                    <button name="action_commit" string="Commit" type="object" class="oe_highlight"/>
                </header>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="path"/>
                        <field name="remote_url"/>
                        <field name="branch"/>
                        <field name="last_commit"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="action_git_repository" model="ir.actions.act_window">
        <field name="name">Git Repositories</field>
        <field name="res_model">git.repository</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_git_nostr_bridge" name="Git-Nostr Bridge" sequence="10"/>
    <menuitem id="menu_git_repository" name="Git Repositories" parent="menu_git_nostr_bridge" action="action_git_repository" sequence="10"/>
</odoo>
=== ./git_nostr_bridge/models/git_repository.py ===
# models/git_repository.py
import os
import git
from odoo import models, fields, api, _
from odoo.exceptions import UserError

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Name', required=True)
    path = fields.Char(string='Local Path', required=True)
    remote_url = fields.Char(string='Remote URL')
    branch = fields.Char(string='Current Branch', default='main')
    last_commit = fields.Char(string='Last Commit', readonly=True)

    @api.model
    def create(self, vals):
        repo = super(GitRepository, self).create(vals)
        repo._initialize_repository()
        return repo

    def _initialize_repository(self):
        if not os.path.exists(self.path):
            os.makedirs(self.path)
            repo = git.Repo.init(self.path)
            if self.remote_url:
                repo.create_remote('origin', self.remote_url)
            open(os.path.join(self.path, 'README.md'), 'w').close()
            repo.index.add(['README.md'])
            repo.index.commit('Initial commit')
            self.last_commit = repo.head.commit.hexsha

    def action_pull(self):
        repo = git.Repo(self.path)
        origin = repo.remotes.origin
        origin.pull()
        self.last_commit = repo.head.commit.hexsha

    def action_push(self):
        repo = git.Repo(self.path)
        origin = repo.remotes.origin
        origin.push()

    def action_commit(self):
        return {
            'name': _('Create Commit'),
            'type': 'ir.actions.act_window',
            'res_model': 'create.nostr.event.wizard',
            'view_mode': 'form',
            'target': 'new',
            'context': {'default_repository_id': self.id, 'default_event_type': 'commit'},
        }
=== ./git_nostr_bridge/models/__init__.py ===
from . import git_repository
from . import nostr_event
from . import res_config_settings
=== ./git_nostr_bridge/models/res_users.py ===
from odoo import models, fields, api
from nostr.key import PrivateKey

class ResUsers(models.Model):
    _inherit = 'res.users'

    nostr_public_key = fields.Char(string="Nostr Public Key")
    nostr_private_key = fields.Char(string="Nostr Private Key")
    nostr_relay_url = fields.Char(string="Nostr Relay URL")

    @api.depends('nostr_private_key')
    def _compute_public_key(self):
        for user in self:
            if user.nostr_private_key:
                try:
                    private_key = PrivateKey.from_nsec(user.nostr_private_key)
                    user.nostr_public_key = private_key.public_key.hex()
                except Exception:
                    user.nostr_public_key = False
            else:
                user.nostr_public_key = False

    @api.model
    def create(self, vals):
        if 'nostr_private_key' not in vals or not vals['nostr_private_key']:
            private_key = PrivateKey()
            vals['nostr_private_key'] = private_key.bech32()
        return super(ResUsers, self).create(vals)
=== ./git_nostr_bridge/models/nostr_event.py ===
# File: /opt/odoo/custom_addons/git_nostr_bridge/models/nostr_event.py

import asyncio
import json
import logging
import websockets
from urllib.parse import urlparse
import time
import traceback

from odoo import models, fields, api, _
from odoo.exceptions import UserError
from nostr.event import Event as NostrLibEvent
from nostr.key import PrivateKey

_logger = logging.getLogger(__name__)

class NostrEvent(models.Model):
    _name = 'nostr.event'
    _description = 'Nostr Event'
    _inherit = 'nostr.event'

    name = fields.Char(string='Name', required=True)
    event_type = fields.Selection([
        ('repo_anchor', 'Repository Anchor'),
        ('branch', 'Branch'),
        ('commit', 'Commit'),
        ('tree', 'Tree'),
        ('blob', 'Blob'),
    ], string='Event Type', required=True)
    content = fields.Text(string='Content')
    tags = fields.Text(string='Tags')
    published = fields.Boolean(string='Published', default=False)
    event_id = fields.Char(string='Event ID', readonly=True)
    kind = fields.Integer(string='Nostr Event Kind', default=1)
    repository_id = fields.Many2one('git.repository', string='Related Repository')
    signature = fields.Char(string='Signature', readonly=True)
    public_key = fields.Char(string='Public Key', readonly=True)
    created_at = fields.Integer(string='Created At', readonly=True)

    @api.model
    def create(self, vals):
        record = super(NostrEvent, self).create(vals)
        record.generate_event_details()
        return record

    def generate_event_details(self):
        if not self.event_id or not self.signature:
            try:
                private_key = PrivateKey()
                public_key = private_key.public_key.hex()
                
                event = NostrLibEvent(
                    kind=self.kind,
                    content=self.content or '',
                    tags=json.loads(self.tags) if self.tags else [],
                    public_key=public_key,
                    created_at=int(time.time())
                )
                
                private_key.sign_event(event)
                
                self.write({
                    'event_id': event.id,
                    'signature': event.signature,
                    'public_key': public_key,
                    'created_at': event.created_at
                })
            except Exception as e:
                _logger.error(f"Error generating Nostr event details: {str(e)}")
                # Not raising UserError here to avoid disrupting the creation process

    @api.model
    def action_publish(self, event_id):
        event = self.browse(event_id)
        _logger.info(f"Starting publish action for event: {event.name}")
        start_time = time.time()

        try:
            if not self.env.user.nostr_private_key:
                raise UserError(_("Nostr private key is not set for the current user."))

            _logger.info("Generating private key")
            try:
                private_key = PrivateKey.from_nsec(self.env.user.nostr_private_key)
                _logger.info("Private key generated successfully")
            except Exception as e:
                _logger.error(f"Failed to generate private key: {str(e)}")
                _logger.error(traceback.format_exc())
                raise UserError(_("Invalid Nostr private key: %s") % str(e))

            public_key = private_key.public_key.hex()
            _logger.info(f"Public key: {public_key}")

            _logger.info("Parsing tags")
            try:
                tags = json.loads(event.tags) if event.tags else []
                _logger.info(f"Parsed tags: {tags}")
                if not isinstance(tags, list):
                    raise ValueError("Tags must be a list of lists")
                for tag in tags:
                    if not isinstance(tag, list):
                        raise ValueError("Each tag must be a list")
            except json.JSONDecodeError as e:
                _logger.error(f"JSON decode error: {str(e)}")
                _logger.error(traceback.format_exc())
                raise UserError(_("Invalid tags format. Please ensure tags are in valid JSON format."))
            except ValueError as e:
                _logger.error(f"Value error: {str(e)}")
                _logger.error(traceback.format_exc())
                raise UserError(_("Invalid tags format: %s") % str(e))

            _logger.info("Creating Nostr event")
            nostr_event = NostrLibEvent(
                kind=1,  # Assuming TEXT_NOTE, adjust if needed
                content=str(event.content),
                tags=tags,
                public_key=public_key  # Ensure public_key is provided
            )
            private_key.sign_event(nostr_event)
            _logger.info(f"Event created: {nostr_event.to_message()}")

            _logger.info("Fetching relay URLs")
            relay_urls = self.env['ir.config_parameter'].sudo().get_param('git_nostr_bridge.relay_urls', '').split(',')
            relay_urls = [url.strip() for url in relay_urls if url.strip()][:5]  # Limit to 5 relays
            _logger.info(f"Relay URLs: {relay_urls}")

            if not relay_urls:
                raise UserError(_("No Nostr relay URLs configured. Please set them in the settings."))

            _logger.info("Validating relay URLs")
            for url in relay_urls:
                parsed = urlparse(url)
                if parsed.scheme not in ('ws', 'wss'):
                    _logger.error(f"Invalid relay URL: {url}")
                    raise UserError(_("Invalid relay URL: %s. Must start with ws:// or wss://") % url)

            async def publish_to_relay(relay_url, nostr_event, retries=3):
                for attempt in range(retries):
                    try:
                        _logger.info(f"Attempting to connect to {relay_url} (attempt {attempt + 1})")
                        connection_start = time.time()
                        async with websockets.connect(relay_url, timeout=30) as websocket:
                            connection_end = time.time()
                            _logger.info(f"Connected to {relay_url} in {connection_end - connection_start:.2f} seconds")
                            
                            message = nostr_event.to_message()
                            _logger.debug(f"Raw event message: {message}")
                            
                            _logger.info(f"Sending Nostr event to {relay_url}: {message}")
                            
                            send_start = time.time()
                            await websocket.send(message)
                            send_end = time.time()
                            _logger.info(f"Sent message to {relay_url} in {send_end - send_start:.2f} seconds")
                            
                            _logger.info(f"Waiting for response from {relay_url}")
                            response_start = time.time()
                            response = await asyncio.wait_for(websocket.recv(), timeout=10.0)
                            response_end = time.time()
                            _logger.info(f"Received response from {relay_url} in {response_end - response_start:.2f} seconds: {response}")
                            
                            try:
                                return json.loads(response)
                            except json.JSONDecodeError as e:
                                _logger.error(f"Failed to parse response from {relay_url}: {str(e)}")
                                return f"Invalid response from {relay_url}: {response}"
                    except (websockets.exceptions.WebSocketException, asyncio.TimeoutError) as e:
                        _logger.error(f"Error publishing to {relay_url} (attempt {attempt + 1}): {str(e)}")
                        _logger.error(traceback.format_exc())
                        await asyncio.sleep(5 * (attempt + 1))  # Increased delay between attempts
                return f"Failed to publish to {relay_url} after {retries} attempts"

            async def publish_with_timeout():
                tasks = [publish_to_relay(url, nostr_event) for url in relay_urls]
                return await asyncio.gather(*tasks, return_exceptions=True)

            async def run_publication():
                _logger.info("Starting publication process")
                try:
                    results = await asyncio.wait_for(publish_with_timeout(), timeout=120)  # Increased overall timeout
                    _logger.info(f"Publication results: {results}")
                    return results
                except asyncio.TimeoutError:
                    _logger.error("Publication process timed out after 120 seconds")
                    raise UserError(_("Publishing timed out after 120 seconds"))

            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            try:
                results = loop.run_until_complete(run_publication())
            finally:
                loop.close()

            success = any(isinstance(result, list) and result[0] == "OK" for result in results)
            if success:
                event.write({
                    'published': True,
                    'event_id': nostr_event.id
                })
                _logger.info(f"Successfully published Nostr event: {nostr_event.id}")
                
                # Verify event publication
                self.verify_event_publication(nostr_event.id, relay_urls)
                
                end_time = time.time()
                _logger.info(f"Total publish action time: {end_time - start_time:.2f} seconds")
                
                return {
                    'type': 'ir.actions.client',
                    'tag': 'display_notification',
                    'params': {
                        'message': _("Nostr event successfully published to at least one relay."),
                        'type': 'success',
                        'sticky': False,
                    }
                }
            else:
                error_messages = [str(result) for result in results if isinstance(result, str)]
                _logger.error(f"Failed to publish Nostr event: {'; '.join(error_messages)}")
                raise UserError(_("Failed to publish Nostr event: %s") % "; ".join(error_messages))

        except Exception as e:
            _logger.error(f"Unexpected error in action_publish: {str(e)}")
            _logger.error(traceback.format_exc())
            raise UserError(_("An unexpected error occurred: %s") % str(e))

    @api.model
    def verify_event_publication(self, event_id, relay_urls, max_attempts=5, delay=2):
        _logger.info(f"Starting verification for event: {event_id}")
        for attempt in range(max_attempts):
            _logger.info(f"Verification attempt {attempt + 1}")
            for url in relay_urls:
                try:
                    loop = asyncio.new_event_loop()
                    asyncio.set_event_loop(loop)
                    result = loop.run_until_complete(self.query_event(url, event_id))
                    if result:
                        _logger.info(f"Event {event_id} found on relay {url}")
                        return True
                except Exception as e:
                    _logger.error(f"Error querying event from {url}: {str(e)}")
                    _logger.error(traceback.format_exc())
                finally:
                    loop.close()
            _logger.info(f"Waiting {delay} seconds before next attempt")
            time.sleep(delay)
        _logger.warning(f"Event {event_id} not found on any relay after {max_attempts} attempts")
        return False

    async def query_event(self, relay_url, event_id):
        _logger.info(f"Querying event {event_id} from {relay_url}")
        start_time = time.time()
        try:
            async with websockets.connect(relay_url, timeout=10) as websocket:
                request = json.dumps(["REQ", "query", {"ids": [event_id]}])
                _logger.info(f"Sending query to {relay_url}: {request}")
                await websocket.send(request)
                response = await asyncio.wait_for(websocket.recv(), timeout=5.0)
                _logger.info(f"Response from {relay_url}: {response}")
                end_time = time.time()
                _logger.info(f"Query to {relay_url} took {end_time - start_time:.2f} seconds")
                return json.loads(response)
        except Exception as e:
            _logger.error(f"Error querying {relay_url}: {str(e)}")
            _logger.error(traceback.format_exc())
            end_time = time.time()
            _logger.info(f"Failed query to {relay_url} took {end_time - start_time:.2f} seconds")
            return None
=== ./git_nostr_bridge/models/res_config_settings.py ===
import requests
import json
from odoo import fields, models, api
import logging

_logger = logging.getLogger(__name__)

class ResConfigSettings(models.TransientModel):
    _inherit = 'res.config.settings'

    git_nostr_relay_urls = fields.Char(
        string="Nostr Relay URLs", 
        config_parameter='git_nostr_bridge.relay_urls',
        default=lambda self: self._default_nostr_relays()
    )

    def _default_nostr_relays(self):
        return self._get_top_nostr_relays()

    @api.model
    def _get_top_nostr_relays(self, limit=108):
        url = "https://api.nostr.watch/v1/online"
        try:
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
            }
            response = requests.get(url, headers=headers, timeout=10)
            response.raise_for_status()
            _logger.info(f"Response status code: {response.status_code}")
            
            data = response.json()
            _logger.info(f"API response (first 108 items): {data[:108]}")
            
            relays = data[:108]
            _logger.info(f"Number of relay links found: {len(relays)}")
            _logger.info(f"Extracted relays (first 5): {relays[:5]}")
            
            relay_urls = ",".join(relays)
            return relay_urls
        except requests.RequestException as e:
            _logger.error(f"Error fetching Nostr relays: {e}")
            return "wss://nostr-relay.app,wss://nos.lol,wss://relay.snort.social,wss://relay.nostr.net"

    nostr_relay_urls = fields.Char(
        string="Nostr Relay URLs", 
        config_parameter='nostr_bridge.relay_urls',
        default=_default_nostr_relays
    )

    @api.model
    def get_values(self):
        res = super(ResConfigSettings, self).get_values()
        ICPSudo = self.env['ir.config_parameter'].sudo()
        
        relay_urls = ICPSudo.get_param('git_nostr_bridge.relay_urls')
        if not relay_urls:
            relay_urls = self._default_nostr_relays()
            ICPSudo.set_param('git_nostr_bridge.relay_urls', relay_urls)
            _logger.info(f"Set new relay URLs: {relay_urls[:100]}...")
        else:
            _logger.info(f"Using existing relay URLs: {relay_urls[:100]}...")
        
        res.update(git_nostr_relay_urls=relay_urls)
        return res

    def set_values(self):
        super(ResConfigSettings, self).set_values()
        ICPSudo = self.env['ir.config_parameter'].sudo()
        if self.git_nostr_relay_urls:
            ICPSudo.set_param('git_nostr_bridge.relay_urls', self.git_nostr_relay_urls)
            _logger.info(f"Updated relay URLs: {self.git_nostr_relay_urls[:100]}...")
        else:
            default_urls = self._default_nostr_relays()
            ICPSudo.set_param('git_nostr_bridge.relay_urls', default_urls)
            _logger.info(f"Set default relay URLs: {default_urls[:100]}...")
=== ./git_nostr_bridge/models/git_repository ===
# models/git_repository.py
import os
import git
from odoo import models, fields, api, _
from odoo.exceptions import UserError

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Name', required=True)
    path = fields.Char(string='Local Path', required=True)
    remote_url = fields.Char(string='Remote URL')
    branch = fields.Char(string='Current Branch', default='main')
    last_commit = fields.Char(string='Last Commit', readonly=True)

    @api.model
    def create(self, vals):
        repo = super(GitRepository, self).create(vals)
        repo._initialize_repository()
        return repo

    def _initialize_repository(self):
        if not os.path.exists(self.path):
            os.makedirs(self.path)
            repo = git.Repo.init(self.path)
            if self.remote_url:
                repo.create_remote('origin', self.remote_url)
            open(os.path.join(self.path, 'README.md'), 'w').close()
            repo.index.add(['README.md'])
            repo.index.commit('Initial commit')
            self.last_commit = repo.head.commit.hexsha

    def action_pull(self):
        repo = git.Repo(self.path)
        origin = repo.remotes.origin
        origin.pull()
        self.last_commit = repo.head.commit.hexsha

    def action_push(self):
        repo = git.Repo(self.path)
        origin = repo.remotes.origin
        origin.push()

    def action_commit(self):
        return {
            'name': _('Create Commit'),
            'type': 'ir.actions.act_window',
            'res_model': 'create.nostr.event.wizard',
            'view_mode': 'form',
            'target': 'new',
            'context': {'default_repository_id': self.id, 'default_event_type': 'commit'},
        }
=== ./git_nostr_bridge/__init__.py ===
from . import models
from . import wizard
=== ./git_nostr_bridge/__manifest__.py ===
{
    'name': 'Git-Nostr Bridge',
    'version': '1.0',
    'category': 'Tools',
    'summary': 'Integrates Git repositories with Nostr network',
    'author': 'Your Name',
    'website': 'https://www.example.com',
    'depends': ['base', 'mail', 'nostr_auth', 'nostr_bridge', 'integrated_ivcs'],
    'data': [
        'security/ir.model.access.csv',
        'views/git_repository_views.xml',
        'views/nostr_event_views.xml',
        'views/res_config_settings_views.xml',
        'views/res_users_views.xml',
        'wizard/create_nostr_event_wizard_views.xml',
    ],
    'installable': True,
    'application': True,
    'auto_install': False,
    'external_dependencies': {
        'python': ['git', 'nostr', 'websockets'],
    },
}
=== ./git_nostr_bridge/wizard/create_nostr_event_wizard.py ===
# wizard/create_nostr_event_wizard.py
from odoo import models, fields, api
import git
import json

class CreateNostrEventWizard(models.TransientModel):
    _name = 'create.nostr.event.wizard'
    _description = 'Create Nostr Event Wizard'

    repository_id = fields.Many2one('git.repository', string='Repository', required=True)
    event_type = fields.Selection([
        ('repo_anchor', 'Repository Anchor'),
        ('branch', 'Branch'),
        ('commit', 'Commit'),
        ('tree', 'Tree'),
        ('blob', 'Blob'),
    ], string='Event Type', required=True)
    commit_message = fields.Text(string='Commit Message')
    branch_name = fields.Char(string='Branch Name')
    file_content = fields.Text(string='File Content')
    file_name = fields.Char(string='File Name')

    def action_create_event(self):
        repo = git.Repo(self.repository_id.path)
        
        if self.event_type == 'commit':
            # Stage all changes
            repo.git.add(A=True)
            # Commit changes
            commit = repo.index.commit(self.commit_message)
            self.repository_id.last_commit = commit.hexsha
            content = json.dumps({
                'type': 'commit',
                'repository': self.repository_id.name,
                'commit_hash': commit.hexsha,
                'message': self.commit_message,
            })
        elif self.event_type == 'branch':
            repo.git.checkout('-b', self.branch_name)
            self.repository_id.branch = self.branch_name
            content = json.dumps({
                'type': 'branch',
                'repository': self.repository_id.name,
                'branch_name': self.branch_name,
            })
        elif self.event_type == 'blob':
            with open(os.path.join(self.repository_id.path, self.file_name), 'w') as f:
                f.write(self.file_content)
            repo.index.add([self.file_name])
            commit = repo.index.commit(f"Add file: {self.file_name}")
            self.repository_id.last_commit = commit.hexsha
            content = json.dumps({
                'type': 'blob',
                'repository': self.repository_id.name,
                'file_name': self.file_name,
                'commit_hash': commit.hexsha,
            })
        
        self.env['nostr.event'].create({
            'name': f"{self.event_type.capitalize()} - {self.repository_id.name}",
            'event_type': self.event_type,
            'content': content,
            'tags': json.dumps([['r', self.repository_id.remote_url]]),
        })

        return {'type': 'ir.actions.act_window_close'}
=== ./git_nostr_bridge/wizard/__init__.py ===
# wizard/__init__.py
from . import create_nostr_event_wizard
=== ./git_nostr_bridge/wizard/create_nostr_event_wizard_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_create_nostr_event_wizard_form" model="ir.ui.view">
        <field name="name">create.nostr.event.wizard.form</field>
        <field name="model">create.nostr.event.wizard</field>
        <field name="arch" type="xml">
            <form string="Create Nostr Event">
                <group>
                    <field name="repository_id"/>
                    <field name="event_type"/>
                    <field name="commit_message" attrs="{'invisible': [('event_type', '!=', 'commit')], 'required': [('event_type', '=', 'commit')]}"/>
                    <field name="branch_name" attrs="{'invisible': [('event_type', '!=', 'branch')], 'required': [('event_type', '=', 'branch')]}"/>
                    <field name="file_name" attrs="{'invisible': [('event_type', '!=', 'blob')], 'required': [('event_type', '=', 'blob')]}"/>
                    <field name="file_content" attrs="{'invisible': [('event_type', '!=', 'blob')], 'required': [('event_type', '=', 'blob')]}" widget="ace" options="{'mode': 'xml'}"/>
                </group>
                <footer>
                    <button name="action_create_event" string="Create Event" type="object" class="btn-primary"/>
                    <button string="Cancel" class="btn-secondary" special="cancel"/>
                </footer>
            </form>
        </field>
    </record>

    <record id="action_create_nostr_event_wizard" model="ir.actions.act_window">
        <field name="name">Create Nostr Event</field>
        <field name="res_model">create.nostr.event.wizard</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
    </record>
</odoo>
=== ./git_nostr_bridge/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_git_repository,access_git_repository,model_git_repository,base.group_user,1,1,1,1
access_nostr_event,access_nostr_event,model_nostr_event,base.group_user,1,1,1,1
access_create_nostr_event_wizard,access_create_nostr_event_wizard,model_create_nostr_event_wizard,base.group_user,1,1,1,0
=== ./git_nostr_bridge/views/res_users_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_users_form_inherit_git_nostr" model="ir.ui.view">
        <field name="name">res.users.form.inherit.git.nostr</field>
        <field name="model">res.users</field>
        <field name="inherit_id" ref="base.view_users_form"/>
        <field name="arch" type="xml">
            <notebook position="inside">
                <page string="Nostr Settings" name="nostr_settings">
                    <group>
                        <field name="nostr_private_key" password="True"/>
                        <field name="nostr_public_key"/>
                    </group>
                </page>
            </notebook>
        </field>
    </record>
</odoo>
=== ./git_nostr_bridge/views/res_config_settings_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="res_config_settings_view_form" model="ir.ui.view">
        <field name="name">res.config.settings.view.form.inherit.git_nostr_bridge</field>
        <field name="model">res.config.settings</field>
        <field name="inherit_id" ref="base.res_config_settings_view_form"/>
        <field name="arch" type="xml">
            <xpath expr="//div[hasclass('settings')]" position="inside">
                <div class="app_settings_block" data-string="Git-Nostr Bridge" string="Git-Nostr Bridge" data-key="git_nostr_bridge">
                    <h2>Nostr Settings</h2>
                    <div class="row mt16 o_settings_container">
                        <div class="col-12 col-lg-6 o_setting_box">
                            <div class="o_setting_left_pane"/>
                            <div class="o_setting_right_pane">
                                <span class="o_form_label">Nostr Relay URLs</span>
                                <div class="text-muted">
                                    Comma-separated list of Nostr relay URLs
                                </div>
                                <div class="content-group">
                                    <div class="mt16">
                                        <field name="git_nostr_relay_urls"/>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </xpath>
        </field>
    </record>
</odoo>
=== ./git_nostr_bridge/views/nostr_event_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_nostr_event_form" model="ir.ui.view">
        <field name="name">nostr.event.form</field>
        <field name="model">nostr.event</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="action_publish" string="Publish" type="object" class="oe_highlight" attrs="{'invisible': [('published', '=', True)]}"/>
                </header>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="event_type"/>
                        <field name="content"/>
                        <field name="tags"/>
                        <field name="published"/>
                        <field name="event_id"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_nostr_event_form_git_nostr" model="ir.ui.view">
        <field name="name">nostr.event.form.git.nostr</field>
        <field name="model">nostr.event</field>
        <field name="inherit_id" ref="integrated_ivcs.view_nostr_event_form"/>
        <field name="arch" type="xml">
            <xpath expr="//field[@name='event_type']" position="after">
                <field name="repository_id" attrs="{'invisible': [('event_type', 'not in', ['repo_anchor', 'branch', 'commit', 'tree', 'blob'])]}"/>
            </xpath>
        </field>
    </record>

    <record id="action_nostr_event" model="ir.actions.act_window">
        <field name="name">Nostr Events</field>
        <field name="res_model">nostr.event</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_nostr_event_git" name="Git Nostr Events" parent="menu_git_nostr_bridge" action="integrated_ivcs.action_nostr_event" sequence="20"/>
</odoo>
=== ./git_nostr_bridge/views/git_repository_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_repository_form" model="ir.ui.view">
        <field name="name">git.repository.form</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="action_pull" string="Pull" type="object" class="oe_highlight"/>
                    <button name="action_push" string="Push" type="object" class="oe_highlight"/>
                    <button name="action_commit" string="Commit" type="object" class="oe_highlight"/>
                </header>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="path"/>
                        <field name="remote_url"/>
                        <field name="branch"/>
                        <field name="last_commit"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="action_git_repository" model="ir.actions.act_window">
        <field name="name">Git Repositories</field>
        <field name="res_model">git.repository</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_git_nostr_bridge" name="Git-Nostr Bridge" sequence="10"/>
    <menuitem id="menu_git_repository" name="Git Repositories" parent="menu_git_nostr_bridge" action="action_git_repository" sequence="10"/>
</odoo>
=== ./custom_auth/models/res_users.py ===
from odoo import models, api
from odoo.exceptions import AccessDenied
import requests

class ResUsers(models.Model):
    _inherit = 'res.users'

    @classmethod
    def _login(cls, db, login, password):
        if not cls.validate_external_auth(login, password):
            raise AccessDenied()
        return super(ResUsers, cls)._login(db, login, password)

    @classmethod
    def validate_external_auth(cls, login, token):
        # Replace with your actual localhost API endpoint
        validation_url = 'http://localhost/validate_admin'
        response = requests.post(validation_url, json={'login': login, 'token': token})
        return response.status_code == 200 and response.json().get('is_admin', False)
=== ./custom_auth/__manifest__.py ===
{
    'name': 'Custom External Authentication',
    'version': '1.0',
    'category': 'Hidden',
    'summary': 'Custom authentication for external admin access',
    'depends': ['base'],
    'data': [],
    'installable': True,
}
=== ./opinion_reputation_nostr/models/__init__.py ===
from . import opinion_reputation
from . import nostr_event
=== ./opinion_reputation_nostr/models/nostr_event.py ===
from odoo import models, api, _
from odoo.exceptions import UserError
import json
import logging

_logger = logging.getLogger(__name__)

class NostrEvent(models.AbstractModel):
    _name = 'opinion.nostr.event'
    _description = 'Nostr Event for Opinion Reputation'

    @api.model
    def create_prediction_event(self, prediction):
        content = json.dumps({
            'question_id': prediction.question_id.id,
            'question_text': prediction.question_id.text,
            'answer': prediction.answer,
            'confidence': prediction.confidence
        })
        
        try:
            nostr_event = self.env['nostr.event']
            event = nostr_event.create_event(
                kind=1,  # You might want to use a custom event kind for predictions
                content=content,
                tags=[['p', prediction.user_id.nostr_public_key]],
                private_key=prediction.user_id.nostr_private_key
            )
            
            nostr_event.publish_event(event)
            _logger.info(f"Nostr event created and published for prediction {prediction.id}")
        except AttributeError:
            _logger.warning("Nostr bridge not available. Prediction event not published to Nostr.")
        except Exception as e:
            _logger.error(f"Error creating Nostr event: {str(e)}")
            raise UserError(_("Failed to create Nostr event: %s") % str(e))
=== ./opinion_reputation_nostr/models/opinion_reputation.py ===
from odoo import models, fields, api
from odoo.exceptions import UserError
import enum
import logging

_logger = logging.getLogger(__name__)

class AnswerChoice(enum.Enum):
    AGREE = "I Agree"
    DO_NOT_DISAGREE = "I do not disagree"
    DO_NOT_AGREE = "I do not agree"
    DISAGREE = "I Disagree"

class User(models.Model):
    _inherit = 'res.users'

    reputation = fields.Float(default=0)

class Question(models.Model):
    _name = 'opinion.question'
    _description = 'Opinion Question'

    text = fields.Text(required=True)
    explanation = fields.Text()
    created_by = fields.Many2one('res.users', string='Created By')
    created_at = fields.Datetime(default=fields.Datetime.now)
    is_settled = fields.Boolean(default=False)
    last_revisited = fields.Datetime()

class Prediction(models.Model):
    _name = 'opinion.prediction'
    _description = 'Opinion Prediction'

    user_id = fields.Many2one('res.users', required=True)
    question_id = fields.Many2one('opinion.question', required=True)
    answer = fields.Selection([
        ('AGREE', 'I Agree'),
        ('DO_NOT_DISAGREE', 'I do not disagree'),
        ('DO_NOT_AGREE', 'I do not agree'),
        ('DISAGREE', 'I Disagree')
    ], required=True)
    confidence = fields.Float(required=True)
    timestamp = fields.Datetime(default=fields.Datetime.now)
    is_correct = fields.Boolean()

    @api.model
    def create(self, vals):
        prediction = super(Prediction, self).create(vals)
        try:
            self.env['opinion.nostr.event'].create_prediction_event(prediction)
        except Exception as e:
            _logger.error(f"Failed to create Nostr event for prediction {prediction.id}: {str(e)}")
        self.update_reputation(prediction.user_id.id)
        return prediction

    def update_reputation(self, user_id):
        user = self.env['res.users'].browse(user_id)
        predictions = self.search([('user_id', '=', user_id)])
        correct_predictions = predictions.filtered(lambda p: p.is_correct)
        if predictions:
            user.reputation = (len(correct_predictions) / len(predictions)) * 100

class OpinionReputationSystem(models.AbstractModel):
    _name = 'opinion.reputation.system'
    _description = 'Opinion Reputation System'

    @api.model
    def revisit_question(self, question_id):
        question = self.env['opinion.question'].browse(question_id)
        if (fields.Datetime.now() - question.created_at).days >= 4*365:
            predictions = self.env['opinion.prediction'].search([('question_id', '=', question_id)])
            total_votes = len(predictions)
            if total_votes > 0:
                agreement_ratio = len(predictions.filtered(lambda p: p.answer in ['AGREE', 'DO_NOT_DISAGREE'])) / total_votes
                question.write({
                    'is_settled': agreement_ratio >= 0.8333334,
                    'last_revisited': fields.Datetime.now()
                })

    @api.model
    def explain_answer_choices(self):
        return """
        Answer choices explanation:
        1. I Agree: You fully support and believe in the statement.
        2. I do not disagree: You somewhat agree or have no strong objection to the statement.
        3. I do not agree: You somewhat disagree or have some reservations about the statement.
        4. I Disagree: You fully oppose or do not believe in the statement.
        """
=== ./opinion_reputation_nostr/__init__.py ===
from . import models
=== ./opinion_reputation_nostr/__manifest__.py ===
{
    'name': 'Opinion Reputation with Nostr',
    'version': '1.0',
    'category': 'Tools',
    'summary': 'Opinion Reputation System with optional Nostr integration',
    'depends': ['base'],
    'data': [
        'security/ir.model.access.csv',
        'views/opinion_reputation_views.xml',
        'data/default_questions.xml',
    ],
    'installable': True,
    'application': True,
}
=== ./opinion_reputation_nostr/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_opinion_question,access_opinion_question,model_opinion_question,base.group_user,1,1,1,1
access_opinion_prediction,access_opinion_prediction,model_opinion_prediction,base.group_user,1,1,1,1
access_opinion_nostr_event,access_opinion_nostr_event,model_opinion_nostr_event,base.group_user,1,1,1,1
=== ./opinion_reputation_nostr/data/default_questions.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <!-- Add your default questions here -->
        <record id="question_1" model="opinion.question">
            <field name="text">Do life's challenges sometimes lead to self-doubt?</field>
            <field name="explanation">Sometimes when things get tough, we might wonder if we're good enough or if we can handle it.</field>
        </record>
        <!-- Add more questions as needed -->
    </data>
</odoo>
=== ./opinion_reputation_nostr/views/opinion_reputation_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_question_form" model="ir.ui.view">
        <field name="name">opinion.question.form</field>
        <field name="model">opinion.question</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="text"/>
                        <field name="explanation"/>
                        <field name="created_by"/>
                        <field name="created_at"/>
                        <field name="is_settled"/>
                        <field name="last_revisited"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_prediction_form" model="ir.ui.view">
        <field name="name">opinion.prediction.form</field>
        <field name="model">opinion.prediction</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="user_id"/>
                        <field name="question_id"/>
                        <field name="answer"/>
                        <field name="confidence"/>
                        <field name="timestamp"/>
                        <field name="is_correct"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="action_questions" model="ir.actions.act_window">
        <field name="name">Questions</field>
        <field name="res_model">opinion.question</field>
        <field name="view_mode">tree,form</field>
    </record>

    <record id="action_predictions" model="ir.actions.act_window">
        <field name="name">Predictions</field>
        <field name="res_model">opinion.prediction</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_opinion_reputation" name="Opinion Reputation"/>
    <menuitem id="menu_questions" parent="menu_opinion_reputation" action="action_questions"/>
    <menuitem id="menu_predictions" parent="menu_opinion_reputation" action="action_predictions"/>
</odoo>
=== ./integrated_ivcs/models/git_repository.py ===
from odoo import models, fields, api
import git
import os

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Repository Name', required=True)
    path = fields.Char(string='Repository Path', required=True)
    
    @api.model
    def create(self, vals):
        repo = super(GitRepository, self).create(vals)
        if not os.path.exists(repo.path):
            os.makedirs(repo.path)
            git.Repo.init(repo.path)
        return repo

    def commit_changes(self, message):
        repo = git.Repo(self.path)
        repo.git.add(A=True)
        commit = repo.index.commit(message)
        
        self.env['nostr.event'].create_git_event(self.path, commit.hexsha)
        
        return commit.hexsha
=== ./integrated_ivcs/models/__init__.py ===
from . import ivcs_item
from . import ivcs_version
from . import ivcs_commit
from . import git_repository
from . import nostr_event
from . import branch_manager
from . import res_config_settings
=== ./integrated_ivcs/models/ivcs_version.py ===
from odoo import models, fields, api

class IVCSVersion(models.Model):
    _name = 'ivcs.version'
    _description = 'IVCS Version'

    name = fields.Char(string='Version Name', required=True)
    description = fields.Text(string='Description')
    item_id = fields.Many2one('ivcs.item', string='IVCS Item', required=True, ondelete='cascade')
    commit_id = fields.Many2one('ivcs.commit', string='Associated Commit')
    create_date = fields.Datetime(string='Created On', readonly=True, default=fields.Datetime.now)

    @api.model
    def create(self, vals):
        version = super(IVCSVersion, self).create(vals)
        if not version.item_id.current_version_id:
            version.item_id.current_version_id = version.id
        return version

    def name_get(self):
        result = []
        for version in self:
            name = f"{version.item_id.name} - {version.name}"
            result.append((version.id, name))
        return result
=== ./integrated_ivcs/models/nostr_event.py ===
from odoo import models, fields, api, _
from odoo.exceptions import UserError
from nostr.event import Event
from nostr.key import PrivateKey
import json
import logging
import time
import git

_logger = logging.getLogger(__name__)

class NostrEvent(models.Model):
    _name = 'nostr.event'
    _description = 'Nostr Event'

    event_id = fields.Char(string='Event ID', required=True)
    kind = fields.Integer(string='Event Kind', required=True)
    content = fields.Text(string='Content', required=True)
    tags = fields.Text(string='Tags')
    public_key = fields.Char(string='Public Key')
    created_at = fields.Integer(string='Created At', required=True)
    signature = fields.Char(string='Signature', required=True)
    published = fields.Boolean(string='Published', default=False)
    name = fields.Char(string='Name')
    event_type = fields.Selection([
        ('repo_anchor', 'Repository Anchor'),
        ('branch', 'Branch'),
        ('commit', 'Commit'),
        ('tree', 'Tree'),
        ('blob', 'Blob'),
    ], string='Event Type')

    def create_and_publish(self, event):
        vals = {
            'event_id': event.id,
            'kind': event.kind,
            'content': event.content,
            'tags': json.dumps(event.tags),
            'public_key': event.public_key,
            'created_at': event.created_at,
            'signature': event.signature,
        }
        nostr_event = self.create(vals)
        nostr_event.publish_event()
        return nostr_event

    def publish_event(self):
        self.ensure_one()
        relay_urls = self.env['ir.config_parameter'].sudo().get_param('integrated_ivcs.relay_urls', '').split(',')
        
        event_data = {
            'id': self.event_id,
            'kind': self.kind,
            'created_at': self.created_at,
            'tags': json.loads(self.tags),
            'content': self.content,
            'pubkey': self.public_key,
            'sig': self.signature,
        }

        for url in relay_urls:
            try:
                # Here you would typically use a Nostr client library to publish the event
                # For simplicity, we'll just log the action
                _logger.info(f"Publishing event {self.event_id} to relay: {url}")
                # Example: nostr_client.publish_event(url, event_data)
                self.published = True
            except Exception as e:
                _logger.error(f"Failed to publish event to {url}: {str(e)}")

    @api.model
    def create_git_event(self, repo_path, commit_hash):
        repo = git.Repo(repo_path)
        commit = repo.commit(commit_hash)
        
        content = json.dumps({
            "action": "commit",
            "message": commit.message,
            "author": commit.author.name,
            "email": commit.author.email,
            "date": commit.authored_datetime.isoformat(),
            "hash": commit_hash,
            "parent_hashes": [c.hexsha for c in commit.parents],
            "tree_hash": commit.tree.hexsha,
        })
        
        event = Event(
            kind=3121,
            content=content,
            tags=[
                ["r", repo_path],
                ["h", commit_hash],
            ],
            public_key=self.env.user.nostr_public_key,
        )
        
        private_key = PrivateKey(bytes.fromhex(self.env.user.nostr_private_key))
        private_key.sign_event(event)
        
        return self.create_and_publish(event)

    @api.model
    def create_tree_event(self, repo_path, tree_hash):
        repo = git.Repo(repo_path)
        tree = repo.tree(tree_hash)
        
        content = json.dumps({
            "action": "tree",
            "hash": tree_hash,
            "items": [{"mode": item.mode, "type": item.type, "hash": item.hexsha, "path": item.path} for item in tree.traverse()],
        })
        
        event = Event(
            kind=3122,
            content=content,
            tags=[
                ["r", repo_path],
                ["h", tree_hash],
            ],
            public_key=self.env.user.nostr_public_key,
        )
        
        private_key = PrivateKey(bytes.fromhex(self.env.user.nostr_private_key))
        private_key.sign_event(event)
        
        return self.create_and_publish(event)

    @api.model
    def create_blob_event(self, repo_path, blob_hash):
        repo = git.Repo(repo_path)
        blob = repo.blob(blob_hash)
        
        content = json.dumps({
            "action": "blob",
            "hash": blob_hash,
            "size": blob.size,
            "data": blob.data_stream.read().decode('utf-8', errors='replace'),
        })
        
        event = Event(
            kind=3123,
            content=content,
            tags=[
                ["r", repo_path],
                ["h", blob_hash],
            ],
            public_key=self.env.user.nostr_public_key,
        )
        
        private_key = PrivateKey(bytes.fromhex(self.env.user.nostr_private_key))
        private_key.sign_event(event)
        
        return self.create_and_publish(event)

    @api.model
    def reconstruct_git_objects(self, repo_path):
        repo = git.Repo(repo_path)
        events = self.search([('tags', 'ilike', repo_path)])
        
        for event in events:
            content = json.loads(event.content)
            if event.kind == 3121:  # Commit
                self._reconstruct_commit(repo, content)
            elif event.kind == 3122:  # Tree
                self._reconstruct_tree(repo, content)
            elif event.kind == 3123:  # Blob
                self._reconstruct_blob(repo, content)

    def _reconstruct_commit(self, repo, content):
        commit_hash = content['hash']
        if commit_hash not in repo.objects:
            repo.create_commit(
                tree=repo.tree(content['tree_hash']),
                message=content['message'],
                author=git.Actor(content['author'], content['email']),
                committer=git.Actor(content['author'], content['email']),
                parent_commits=[repo.commit(p) for p in content['parent_hashes']],
                commit_timestamp=int(content['date']),
                ref=f'refs/heads/{content["branch"]}' if 'branch' in content else None
            )

    def _reconstruct_tree(self, repo, content):
        tree_hash = content['hash']
        if tree_hash not in repo.objects:
            tree_items = []
            for item in content['items']:
                if item['type'] == 'blob':
                    tree_items.append((item['mode'], 'blob', item['hash'], item['path']))
                elif item['type'] == 'tree':
                    tree_items.append((item['mode'], 'tree', item['hash'], item['path']))
            repo.create_tree(tree_items)

    def _reconstruct_blob(self, repo, content):
        blob_hash = content['hash']
        if blob_hash not in repo.objects:
            repo.create_blob(content['data'].encode('utf-8'))

    def sync_git_nostr(self, repo_path):
        repo = git.Repo(repo_path)
        for obj in repo.objects:
            if isinstance(obj, git.Commit):
                self.create_git_event(repo_path, obj.hexsha)
            elif isinstance(obj, git.Tree):
                self.create_tree_event(repo_path, obj.hexsha)
            elif isinstance(obj, git.Blob):
                self.create_blob_event(repo_path, obj.hexsha)

        self.reconstruct_git_objects(repo_path)
=== ./integrated_ivcs/models/res_config_settings.py ===
from odoo import fields, models

class ResConfigSettings(models.TransientModel):
    _inherit = 'res.config.settings'

    integrated_ivcs_relay_urls = fields.Char(string="Nostr Relay URLs", config_parameter='integrated_ivcs.relay_urls')
=== ./integrated_ivcs/models/ivcs_commit.py ===
from odoo import models, fields, api
import json
from nostr.event import Event
from nostr.key import PrivateKey
import logging

_logger = logging.getLogger(__name__)

class IVCSCommit(models.Model):
    _name = 'ivcs.commit'
    _description = 'IVCS Commit'

    hash = fields.Char(string='Commit Hash', required=True)
    message = fields.Text(string='Commit Message', required=True)
    author = fields.Char(string='Author', required=True, default=lambda self: self.env.user.name)
    date = fields.Datetime(string='Commit Date', required=True, default=fields.Datetime.now)
    item_id = fields.Many2one('ivcs.item', string='IVCS Item', required=True, ondelete='cascade')
    version_id = fields.Many2one('ivcs.version', string='Associated Version')

    @api.model
    def create(self, vals):
        commit = super(IVCSCommit, self).create(vals)
        try:
            commit._create_nostr_commit_event()
        except Exception as e:
            _logger.error(f"Failed to create Nostr commit event: {str(e)}")
        return commit

    def _create_nostr_commit_event(self):
        if not self.item_id.nostr_private_key:
            _logger.warning(f"No Nostr private key set for IVCS Item {self.item_id.name}")
            return

        try:
            private_key = PrivateKey.from_nsec(self.item_id.nostr_private_key)
        except Exception as e:
            _logger.error(f"Invalid Nostr private key for IVCS Item {self.item_id.name}: {str(e)}")
            return

        event = Event(
            kind=3121,
            content=json.dumps({
                "hash": self.hash,
                "message": self.message,
                "author": self.author,
                "date": self.date.isoformat(),
            }),
            tags=[['r', self.item_id.repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)
        
        try:
            self.env['nostr.event'].create_and_publish(event)
            _logger.info(f"Nostr commit event created and published for commit {self.hash}")
        except Exception as e:
            _logger.error(f"Failed to create and publish Nostr event for commit {self.hash}: {str(e)}")
=== ./integrated_ivcs/models/ivcs_item.py ===
from odoo import models, fields, api, _
from odoo.exceptions import UserError
import git
import json
from nostr.event import Event
from nostr.key import PrivateKey
import os
import logging

_logger = logging.getLogger(__name__)

class IVCSItem(models.Model):
    _name = 'ivcs.item'
    _description = 'IVCS Item'

    name = fields.Char(string='Name', required=True)
    description = fields.Text('Description')
    current_version_id = fields.Many2one('ivcs.version', string='Current Version', compute='_compute_current_version', store=True)
    version_ids = fields.One2many('ivcs.version', 'item_id', string='Versions')
    repo_path = fields.Char('Repository Path', compute='_compute_repo_path', store=True)
    current_branch = fields.Char('Current Branch', default='main')
    commit_ids = fields.One2many('ivcs.commit', 'item_id', string='Commits')
    nostr_private_key = fields.Char(string="Nostr Private Key")
    branch_manager_id = fields.Many2one('ivcs.branch.manager', string='Branch Manager')

    @api.depends('name')
    def _compute_repo_path(self):
        for item in self:
            item.repo_path = f"/opt/ivcs_repos/item_{item.id}"

    @api.depends('version_ids')
    def _compute_current_version(self):
        for item in self:
            if item.version_ids:
                item.current_version_id = item.version_ids.sorted(lambda v: v.create_date, reverse=True)[0]
            else:
                item.current_version_id = False

    @api.model
    def create(self, vals):
        if 'nostr_private_key' in vals and vals['nostr_private_key']:
            try:
                # Validate and format the private key
                private_key = PrivateKey.from_nsec(vals['nostr_private_key'])
                vals['nostr_private_key'] = private_key.hex()  # Store the private key as a hex string
            except Exception as e:
                raise UserError(_("Invalid Nostr private key: %s") % str(e))
        return super(IVCSItem, self).create(vals)

    def write(self, vals):
        if 'nostr_private_key' in vals and vals['nostr_private_key']:
            try:
                # Validate and format the private key
                private_key = PrivateKey.from_nsec(vals['nostr_private_key'])
                vals['nostr_private_key'] = private_key.hex()  # Store the private key as a hex string
            except Exception as e:
                raise UserError(_("Invalid Nostr private key: %s") % str(e))
        return super(IVCSItem, self).write(vals)

    def _initialize_repository(self):
        self.ensure_one()
        if not os.path.exists(self.repo_path):
            os.makedirs(self.repo_path)
            repo = git.Repo.init(self.repo_path)
            readme_path = os.path.join(self.repo_path, 'README.md')
            with open(readme_path, 'w') as f:
                f.write(f"# {self.name}\n\n{self.description}")
            repo.index.add(['README.md'])
            commit = repo.index.commit("Initial commit")
            self._create_initial_version(commit.hexsha)
            self._create_nostr_repo_event()

    def _create_initial_version(self, commit_hash):
        version = self.env['ivcs.version'].create({
            'name': 'v1.0',
            'description': 'Initial version',
            'item_id': self.id,
        })
        self.env['ivcs.commit'].create({
            'hash': commit_hash,
            'message': "Initial commit",
            'item_id': self.id,
            'version_id': version.id,
        })

    def _create_nostr_repo_event(self):
        if not self.nostr_private_key:
            raise UserError(_("Nostr private key is not set for this item."))
    
        private_key = PrivateKey(bytes.fromhex(self.nostr_private_key))
        event = Event(
            kind=31228,
            content=json.dumps({
                "action": "create_repository",
                "repo_name": self.name,
                "description": self.description
            }),
            tags=[['r', self.repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)
        
        self.env['nostr.event'].create_and_publish(event)

    def create_branch(self, branch_name):
        self.ensure_one()
        repo = git.Repo(self.repo_path)
        if not self.branch_manager_id:
            self.branch_manager_id = self.env['ivcs.branch.manager'].create({
                'name': f"Branch Manager for {self.name}",
                'item_id': self.id,
            })
        if branch_name not in repo.heads:
            repo.create_head(branch_name)
            self.current_branch = branch_name
            self._create_nostr_branch_event(branch_name)
            if self.branch_manager_id:
                self.branch_manager_id.create_branch(branch_name)
            return self._return_success('Branch Created', f'Branch {branch_name} has been created.')
        else:
            return self._return_warning('Branch Exists', f'Branch {branch_name} already exists.')

    def _create_nostr_branch_event(self, branch_name):
        if not self.nostr_private_key:
            raise UserError(_("Nostr private key is not set for this item."))
        
        private_key = PrivateKey(bytes.fromhex(self.nostr_private_key))
        event = Event(
            kind=31227,
            content=json.dumps({
                "action": "create_branch",
                "branch_name": branch_name,
                "repo_name": self.name
            }),
            tags=[['r', self.repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)
        
        self.env['nostr.event'].create_and_publish(event)

    def _return_success(self, title, message):
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _(title),
                'message': _(message),
                'type': 'success',
            }
        }

    def _return_warning(self, title, message):
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _(title),
                'message': _(message),
                'type': 'warning',
            }
        }

    def delete_branch(self, branch_name):
        self.ensure_one()
        if self.branch_manager_id.delete_branch(branch_name):
            return self._return_success('Branch Deleted', f'Branch {branch_name} has been deleted.')
        else:
            return self._return_warning('Branch Not Found', f'Branch {branch_name} does not exist.')

    def merge_branches(self, source_branch, target_branch):
        self.ensure_one()
        if self.branch_manager_id.merge_branches(source_branch, target_branch):
            return self._return_success('Branches Merged', f'Branch {source_branch} has been merged into {target_branch}.')
        else:
            return self._return_warning('Merge Failed', f'Failed to merge {source_branch} into {target_branch}.')

    def reconstruct_branches(self):
        self.ensure_one()
        branches = self.branch_manager_id.reconstruct_branches_from_events()
        return self._return_success('Branches Reconstructed', f'Reconstructed {len(branches)} branches from Nostr events.')

    # Add other methods as needed (e.g., commit, push, pull, etc.)
=== ./integrated_ivcs/models/branch_manager.py ===
from odoo import models, fields, api
from git import Repo, GitCommandError
import json
from nostr.event import Event
from nostr.key import PrivateKey
import logging

_logger = logging.getLogger(__name__)

class BranchManager(models.Model):
    _name = 'ivcs.branch.manager'
    _description = 'IVCS Branch Manager'

    name = fields.Char(string='Name', required=True)
    item_id = fields.Many2one('ivcs.item', string='IVCS Item', required=True)

    def create_branch(self, branch_name):
        self.ensure_one()
        repo = Repo(self.item_id.repo_path)
        if branch_name not in repo.heads:
            repo.create_head(branch_name)
            self._create_branch_event(branch_name, 'create')
            return True
        return False

    def delete_branch(self, branch_name):
        self.ensure_one()
        repo = Repo(self.item_id.repo_path)
        if branch_name in repo.heads:
            repo.delete_head(branch_name, force=True)
            self._create_branch_event(branch_name, 'delete')
            return True
        return False

    def update_branch(self, branch_name, new_commit):
        self.ensure_one()
        repo = Repo(self.item_id.repo_path)
        if branch_name in repo.heads:
            branch = repo.heads[branch_name]
            branch.set_commit(new_commit)
            self._create_branch_event(branch_name, 'update', new_commit)
            return True
        return False

    def merge_branches(self, source_branch, target_branch):
        self.ensure_one()
        repo = Repo(self.item_id.repo_path)
        if source_branch in repo.heads and target_branch in repo.heads:
            try:
                repo.git.checkout(target_branch)
                repo.git.merge(source_branch)
                self._create_branch_event(target_branch, 'merge', source_branch)
                return True
            except GitCommandError as e:
                _logger.error(f"Merge conflict: {str(e)}")
                repo.git.merge('--abort')
                return False
        return False

    def _create_branch_event(self, branch_name, action, additional_info=None):
        if not self.item_id.nostr_private_key:
            _logger.warning(f"No Nostr private key for item {self.item_id.name}")
            return

        private_key = PrivateKey(bytes.fromhex(self.item_id.nostr_private_key))
        content = {
            "action": action,
            "branch_name": branch_name,
            "repo_name": self.item_id.name
        }
        if additional_info:
            content["additional_info"] = additional_info

        event = Event(
            kind=31227,
            content=json.dumps(content),
            tags=[['r', self.item_id.repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)
        
        self.env['nostr.event'].create_and_publish(event)

    def list_branches(self):
        self.ensure_one()
        repo = Repo(self.item_id.repo_path)
        return [head.name for head in repo.heads]

    def reconstruct_branches_from_events(self):
        self.ensure_one()
        events = self.env['nostr.event'].search([
            ('kind', '=', 31227),
            ('tags', 'ilike', self.item_id.repo_path)
        ], order='created_at asc')

        branches = {}
        for event in events:
            content = json.loads(event.content)
            action = content.get('action')
            branch_name = content.get('branch_name')

            if action == 'create':
                branches[branch_name] = {'created_at': event.created_at}
            elif action == 'delete':
                branches.pop(branch_name, None)
            elif action == 'update':
                if branch_name in branches:
                    branches[branch_name]['last_updated'] = event.created_at
            elif action == 'merge':
                if branch_name in branches:
                    branches[branch_name]['last_merged'] = event.created_at
                    branches[branch_name]['merged_from'] = content.get('additional_info')

        return branches
=== ./integrated_ivcs/__init__.py ===
from . import models
from . import wizards
=== ./integrated_ivcs/wizards/create_commit_wizard_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_create_commit_wizard_form" model="ir.ui.view">
        <field name="name">create.commit.wizard.form</field>
        <field name="model">create.commit.wizard</field>
        <field name="arch" type="xml">
            <form string="Create Commit">
                <group>
                    <field name="item_id"/>
                    <field name="message"/>
                </group>
                <footer>
                    <button name="action_create_commit" string="Create Commit" type="object" class="btn-primary"/>
                    <button string="Cancel" class="btn-secondary" special="cancel"/>
                </footer>
            </form>
        </field>
    </record>

    <record id="action_create_commit_wizard" model="ir.actions.act_window">
        <field name="name">Create Commit</field>
        <field name="res_model">create.commit.wizard</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
    </record>
</odoo>
=== ./integrated_ivcs/wizards/__init__.py ===
from . import create_branch_wizard
from . import create_commit_wizard
=== ./integrated_ivcs/wizards/create_commit_wizard.py ===
from odoo import models, fields, api

class CreateCommitWizard(models.TransientModel):
    _name = 'create.commit.wizard'
    _description = 'Create Commit Wizard'

    item_id = fields.Many2one('ivcs.item', string='IVCS Item', required=True)
    message = fields.Text(string='Commit Message', required=True)

    def action_create_commit(self):
        self.ensure_one()
        repo = self.env['git.repository'].search([('path', '=', self.item_id.repo_path)])
        commit_hash = repo.commit_changes(self.message)
        self.env['ivcs.commit'].create({
            'hash': commit_hash,
            'message': self.message,
            'author': self.env.user.name,
            'date': fields.Datetime.now(),
            'item_id': self.item_id.id,
        })
        return {'type': 'ir.actions.act_window_close'}
=== ./integrated_ivcs/wizards/create_branch_wizard.py ===
from odoo import models, fields, api

class CreateBranchWizard(models.TransientModel):
    _name = 'create.branch.wizard'
    _description = 'Create Branch Wizard'

    item_id = fields.Many2one('ivcs.item', string='IVCS Item', required=True)
    branch_name = fields.Char(string='Branch Name', required=True)

    def action_create_branch(self):
        self.ensure_one()
        return self.item_id.create_branch(self.branch_name)
=== ./integrated_ivcs/wizards/create_branch_wizard_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_create_branch_wizard_form" model="ir.ui.view">
        <field name="name">create.branch.wizard.form</field>
        <field name="model">create.branch.wizard</field>
        <field name="arch" type="xml">
            <form string="Create Branch">
                <group>
                    <field name="item_id"/>
                    <field name="branch_name"/>
                </group>
                <footer>
                    <button name="action_create_branch" string="Create Branch" type="object" class="btn-primary"/>
                    <button string="Cancel" class="btn-secondary" special="cancel"/>
                </footer>
            </form>
        </field>
    </record>

    <record id="action_create_branch_wizard" model="ir.actions.act_window">
        <field name="name">Create Branch</field>
        <field name="res_model">create.branch.wizard</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
    </record>
</odoo>
=== ./integrated_ivcs/cli.py ===
import argparse
import os
import git
from nostr.event import Event
from nostr.key import PrivateKey
import json
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class GitNostrCLI:
    def __init__(self, repo_path):
        self.repo_path = repo_path
        self.repo = git.Repo(repo_path)
        self.private_key = PrivateKey()

    def create_branch(self, branch_name):
        logger.info(f"Creating branch: {branch_name}")
        self.repo.create_head(branch_name)
        self._create_branch_event(branch_name, 'create')
        logger.info(f"Branch {branch_name} created successfully")

    def delete_branch(self, branch_name):
        logger.info(f"Deleting branch: {branch_name}")
        self.repo.delete_head(branch_name, force=True)
        self._create_branch_event(branch_name, 'delete')
        logger.info(f"Branch {branch_name} deleted successfully")

    def merge_branches(self, source_branch, target_branch):
        logger.info(f"Merging {source_branch} into {target_branch}")
        self.repo.git.checkout(target_branch)
        try:
            self.repo.git.merge(source_branch)
            self._create_branch_event(target_branch, 'merge', source_branch)
            logger.info(f"Merged {source_branch} into {target_branch} successfully")
        except git.GitCommandError as e:
            logger.error(f"Merge conflict: {str(e)}")
            self.repo.git.merge('--abort')
            logger.info("Merge aborted due to conflicts")

    def commit_changes(self, message):
        logger.info(f"Committing changes with message: {message}")
        self.repo.git.add(A=True)
        commit = self.repo.index.commit(message)
        self._create_commit_event(commit)
        logger.info(f"Changes committed successfully. Commit hash: {commit.hexsha}")

    def _create_branch_event(self, branch_name, action, additional_info=None):
        logger.info(f"Creating Nostr event for branch action: {action}")
        content = {
            "action": action,
            "branch_name": branch_name,
            "repo_name": os.path.basename(self.repo_path)
        }
        if additional_info:
            content["additional_info"] = additional_info

        event = Event(
            kind=31227,
            content=json.dumps(content),
            tags=[['r', self.repo_path]],
            public_key=self.private_key.public_key.hex()
        )
        self.private_key.sign_event(event)
        logger.info(f"Nostr event created: {event.id}")
        # Here you would typically publish the event to Nostr relays

    def _create_commit_event(self, commit):
        logger.info(f"Creating Nostr event for commit: {commit.hexsha}")
        content = json.dumps({
            "action": "commit",
            "message": commit.message,
            "author": commit.author.name,
            "email": commit.author.email,
            "date": commit.authored_datetime.isoformat(),
            "hash": commit.hexsha,
            "parent_hashes": [c.hexsha for c in commit.parents],
            "tree_hash": commit.tree.hexsha,
        })
        
        event = Event(
            kind=3121,
            content=content,
            tags=[
                ["r", self.repo_path],
                ["h", commit.hexsha],
            ],
            public_key=self.private_key.public_key.hex()
        )
        self.private_key.sign_event(event)
        logger.info(f"Nostr event created: {event.id}")
        # Here you would typically publish the event to Nostr relays

def main():
    parser = argparse.ArgumentParser(description="Git-Nostr CLI")
    parser.add_argument('repo_path', help="Path to the Git repository")
    parser.add_argument('action', choices=['create-branch', 'delete-branch', 'merge-branches', 'commit'])
    parser.add_argument('--branch-name', help="Name of the branch (for create-branch and delete-branch)")
    parser.add_argument('--source-branch', help="Source branch for merge")
    parser.add_argument('--target-branch', help="Target branch for merge")
    parser.add_argument('--commit-message', help="Commit message")

    args = parser.parse_args()

    cli = GitNostrCLI(args.repo_path)

    if args.action == 'create-branch':
        cli.create_branch(args.branch_name)
    elif args.action == 'delete-branch':
        cli.delete_branch(args.branch_name)
    elif args.action == 'merge-branches':
        cli.merge_branches(args.source_branch, args.target_branch)
    elif args.action == 'commit':
        cli.commit_changes(args.commit_message)

if __name__ == "__main__":
    main()
=== ./integrated_ivcs/__manifest__.py ===
{
    'name': 'Integrated IVCS',
    'version': '1.0',
    'category': 'Development',
    'summary': 'Integrated Version Control System with Git and Nostr',
    'author': 'Your Name',
    'website': 'https://www.example.com',
    'depends': ['base', 'mail'],
    'data': [
        'security/ir.model.access.csv',
        'views/ivcs_item_views.xml',
        'views/ivcs_version_views.xml',
        'views/ivcs_commit_views.xml',
        'views/git_repository_views.xml',
        'views/nostr_event_views.xml',
        'views/res_config_settings_views.xml',
        'wizards/create_branch_wizard_views.xml',
        'wizards/create_commit_wizard_views.xml',
    ],
    'external_dependencies': {
        'python': ['git', 'nostr'],
    },
    'installable': True,
    'application': True,
    'auto_install': False,
}
=== ./integrated_ivcs/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_ivcs_item_user,ivcs.item user,model_ivcs_item,base.group_user,1,1,1,1
access_ivcs_version_user,ivcs.version user,model_ivcs_version,base.group_user,1,1,1,1
access_ivcs_commit_user,ivcs.commit user,model_ivcs_commit,base.group_user,1,1,1,1
access_git_repository_user,git.repository user,model_git_repository,base.group_user,1,1,1,1
access_nostr_event_user,nostr.event user,model_nostr_event,base.group_user,1,1,1,1
access_ivcs_branch_manager_user,ivcs.branch.manager user,model_ivcs_branch_manager,base.group_user,1,1,1,1
access_create_branch_wizard_user,create.branch.wizard user,model_create_branch_wizard,base.group_user,1,1,1,0
access_create_commit_wizard_user,create.commit.wizard user,model_create_commit_wizard,base.group_user,1,1,1,0
=== ./integrated_ivcs/tests/test_git_nostr_integration.py ===
import unittest
import tempfile
import os
import git
import json
from nostr.event import Event
from nostr.key import PrivateKey
from odoo.tests.common import TransactionCase
from odoo.exceptions import UserError

class TestGitNostrIntegration(TransactionCase):

    def setUp(self):
        super(TestGitNostrIntegration, self).setUp()
        self.IVCSItem = self.env['ivcs.item']
        self.NostrEvent = self.env['nostr.event']
        self.temp_dir = tempfile.mkdtemp()
        self.repo_path = os.path.join(self.temp_dir, 'test_repo')

    def tearDown(self):
        super(TestGitNostrIntegration, self).tearDown()
        if os.path.exists(self.temp_dir):
            import shutil
            shutil.rmtree(self.temp_dir)

    def test_create_repository(self):
        item = self.IVCSItem.create({
            'name': 'Test Repo',
            'description': 'Test repository',
            'repo_path': self.repo_path,
        })
        self.assertTrue(os.path.exists(self.repo_path))
        self.assertTrue(os.path.exists(os.path.join(self.repo_path, '.git')))
        self.assertTrue(os.path.exists(os.path.join(self.repo_path, 'README.md')))

    def test_create_branch(self):
        item = self.IVCSItem.create({
            'name': 'Test Repo',
            'description': 'Test repository',
            'repo_path': self.repo_path,
        })
        result = item.create_branch('test-branch')
        self.assertEqual(result['type'], 'ir.actions.client')
        self.assertEqual(result['params']['type'], 'success')
        repo = git.Repo(self.repo_path)
        self.assertIn('test-branch', repo.heads)

    def test_merge_branches(self):
        item = self.IVCSItem.create({
            'name': 'Test Repo',
            'description': 'Test repository',
            'repo_path': self.repo_path,
        })
        item.create_branch('branch1')
        item.create_branch('branch2')
        repo = git.Repo(self.repo_path)
        repo.heads.branch1.checkout()
        with open(os.path.join(self.repo_path, 'file1.txt'), 'w') as f:
            f.write('Content in branch1')
        repo.index.add(['file1.txt'])
        repo.index.commit('Commit in branch1')
        
        result = item.merge_branches('branch1', 'branch2')
        self.assertEqual(result['type'], 'ir.actions.client')
        self.assertEqual(result['params']['type'], 'success')
        
        repo.heads.branch2.checkout()
        self.assertTrue(os.path.exists(os.path.join(self.repo_path, 'file1.txt')))

    def test_create_nostr_events(self):
        item = self.IVCSItem.create({
            'name': 'Test Repo',
            'description': 'Test repository',
            'repo_path': self.repo_path,
        })
        repo = git.Repo(self.repo_path)
        with open(os.path.join(self.repo_path, 'test.txt'), 'w') as f:
            f.write('Test content')
        repo.index.add(['test.txt'])
        commit = repo.index.commit('Test commit')
        
        event = self.NostrEvent.create_git_event(self.repo_path, commit.hexsha)
        self.assertEqual(event.kind, 3121)
        self.assertIn(commit.hexsha, event.content)

    def test_reconstruct_git_objects(self):
        item = self.IVCSItem.create({
            'name': 'Test Repo',
            'description': 'Test repository',
            'repo_path': self.repo_path,
        })
        repo = git.Repo(self.repo_path)
        with open(os.path.join(self.repo_path, 'test.txt'), 'w') as f:
            f.write('Test content')
        repo.index.add(['test.txt'])
        commit = repo.index.commit('Test commit')
        
        self.NostrEvent.create_git_event(self.repo_path, commit.hexsha)
        
        # Delete the .git directory to simulate a fresh repository
        import shutil
        shutil.rmtree(os.path.join(self.repo_path, '.git'))
        
        # Reconstruct the repository from Nostr events
        self.NostrEvent.reconstruct_git_objects(self.repo_path)
        
        reconstructed_repo = git.Repo(self.repo_path)
        self.assertIn(commit.hexsha, reconstructed_repo.heads.master.commit.hexsha)
        self.assertTrue(os.path.exists(os.path.join(self.repo_path, 'test.txt')))

if __name__ == '__main__':
    unittest.main()
=== ./integrated_ivcs/views/res_config_settings_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="res_config_settings_view_form" model="ir.ui.view">
        <field name="name">res.config.settings.view.form.inherit.integrated_ivcs</field>
        <field name="model">res.config.settings</field>
        <field name="inherit_id" ref="base.res_config_settings_view_form"/>
        <field name="arch" type="xml">
            <xpath expr="//div[hasclass('settings')]" position="inside">
                <div class="app_settings_block" data-string="Integrated IVCS" string="Integrated IVCS" data-key="integrated_ivcs">
                    <h2>Nostr Settings</h2>
                    <div class="row mt16 o_settings_container">
                        <div class="col-12 col-lg-6 o_setting_box">
                            <div class="o_setting_left_pane"/>
                            <div class="o_setting_right_pane">
                                <span class="o_form_label">Nostr Relay URLs</span>
                                <div class="text-muted">
                                    Comma-separated list of Nostr relay URLs
                                </div>
                                <div class="content-group">
                                    <field name="integrated_ivcs_relay_urls"/>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </xpath>
        </field>
    </record>
</odoo>
=== ./integrated_ivcs/views/ivcs_version_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_ivcs_version_form" model="ir.ui.view">
        <field name="name">ivcs.version.form</field>
        <field name="model">ivcs.version</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="description"/>
                        <field name="item_id"/>
                        <field name="commit_id"/>
                        <field name="create_date"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_ivcs_version_tree" model="ir.ui.view">
        <field name="name">ivcs.version.tree</field>
        <field name="model">ivcs.version</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="item_id"/>
                <field name="create_date"/>
            </tree>
        </field>
    </record>

    <record id="action_ivcs_version" model="ir.actions.act_window">
        <field name="name">IVCS Versions</field>
        <field name="res_model">ivcs.version</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_ivcs_version" name="Versions" parent="menu_ivcs_root" action="action_ivcs_version"/>
</odoo>
=== ./integrated_ivcs/views/nostr_event_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_nostr_event_form" model="ir.ui.view">
        <field name="name">nostr.event.form</field>
        <field name="model">nostr.event</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="event_id"/>
                        <field name="kind"/>
                        <field name="event_type"/>
                        <field name="content"/>
                        <field name="tags"/>
                        <field name="public_key"/>
                        <field name="created_at"/>
                        <field name="signature"/>
                        <field name="published"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_nostr_event_tree" model="ir.ui.view">
        <field name="name">nostr.event.tree</field>
        <field name="model">nostr.event</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="event_id"/>
                <field name="kind"/>
                <field name="event_type"/>
                <field name="public_key"/>
                <field name="created_at"/>
                <field name="published"/>
            </tree>
        </field>
    </record>

    <record id="action_nostr_event" model="ir.actions.act_window">
        <field name="name">Nostr Events</field>
        <field name="res_model">nostr.event</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_nostr_event" name="Nostr Events" parent="menu_ivcs_root" action="action_nostr_event"/>
</odoo>
=== ./integrated_ivcs/views/ivcs_item_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_ivcs_item_form" model="ir.ui.view">
        <field name="name">ivcs.item.form</field>
        <field name="model">ivcs.item</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="description"/>
                        <field name="repo_path"/>
                        <field name="current_branch"/>
                        <field name="current_version_id"/>
                        <field name="nostr_private_key" password="True"/>
                    </group>
                    <notebook>
                        <page string="Versions">
                            <field name="version_ids"/>
                        </page>
                        <page string="Commits">
                            <field name="commit_ids"/>
                        </page>
                    </notebook>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_ivcs_item_tree" model="ir.ui.view">
        <field name="name">ivcs.item.tree</field>
        <field name="model">ivcs.item</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="repo_path"/>
                <field name="current_branch"/>
                <field name="current_version_id"/>
            </tree>
        </field>
    </record>

    <record id="action_ivcs_item" model="ir.actions.act_window">
        <field name="name">IVCS Items</field>
        <field name="res_model">ivcs.item</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_ivcs_root" name="Integrated IVCS"/>
    <menuitem id="menu_ivcs_item" name="IVCS Items" parent="menu_ivcs_root" action="action_ivcs_item"/>
</odoo>
=== ./integrated_ivcs/views/git_repository_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_repository_form" model="ir.ui.view">
        <field name="name">git.repository.form</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="path"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_git_repository_tree" model="ir.ui.view">
        <field name="name">git.repository.tree</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="path"/>
            </tree>
        </field>
    </record>

    <record id="action_git_repository" model="ir.actions.act_window">
        <field name="name">Git Repositories</field>
        <field name="res_model">git.repository</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_git_repository" name="Git Repositories" parent="menu_ivcs_root" action="action_git_repository"/>
</odoo>
=== ./integrated_ivcs/views/ivcs_commit_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_ivcs_commit_form" model="ir.ui.view">
        <field name="name">ivcs.commit.form</field>
        <field name="model">ivcs.commit</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="hash"/>
                        <field name="message"/>
                        <field name="author"/>
                        <field name="date"/>
                        <field name="item_id"/>
                        <field name="version_id"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_ivcs_commit_tree" model="ir.ui.view">
        <field name="name">ivcs.commit.tree</field>
        <field name="model">ivcs.commit</field>
        <field name="arch" type="xml">
            <tree>
                <field name="hash"/>
                <field name="message"/>
                <field name="author"/>
                <field name="date"/>
                <field name="item_id"/>
            </tree>
        </field>
    </record>

    <record id="action_ivcs_commit" model="ir.actions.act_window">
        <field name="name">IVCS Commits</field>
        <field name="res_model">ivcs.commit</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_ivcs_commit" name="Commits" parent="menu_ivcs_root" action="action_ivcs_commit"/>
</odoo>







Additional considerations:


The attached codebase does not directly implement the specific Nostr event kinds and structures as defined by Snub (31228, 31227, 3121, 3122, 3123) in the way described in the prompt. While the codebase does include some Nostr-related functionality, it doesn't match the exact requirements outlined in the prompt. Here's a breakdown:

1. The codebase does not contain separate classes for each event type inheriting from a base NostrEvent class.

2. There are no specific methods for serialization to JSON and deserialization from JSON for each event type.

3. The validation for required and optional fields for each event type is not explicitly implemented as described in the prompt.

4. The unit tests specifically requested in the prompt are not present.

However, the codebase does show integration with Odoo and includes some Nostr-related functionality:

1. There is a `NostrEvent` model in `integrated_ivcs/models/nostr_event.py` which handles some Nostr event creation and publishing.

2. The `create_git_event`, `create_tree_event`, and `create_blob_event` methods in the `NostrEvent` model do use some of the event kinds mentioned (3121, 3122, 3123).

3. The codebase is integrated into Odoo, with proper model definitions, views, and manifest files.

4. There are some methods for creating and publishing Nostr events, but they don't fully match the structure requested in the prompt.

In conclusion, while the codebase does implement some Nostr functionality and is integrated into Odoo, it does not strictly adhere to the specific requirements outlined in the prompt. The implementation is more focused on integrating Nostr events with Git operations in an Odoo environment, rather than creating a standalone Python script with the specified event classes and unit tests.




Based on the provided codebase, the system does partially implement the functionality described in the prompt, but it's not a complete or standalone implementation. It is integrated into Odoo, but some aspects are missing or not fully developed. Let's break it down:

1. Git tree and blob representation:
   - The system does have support for git trees and blobs as Nostr events.
   - In `integrated_ivcs/models/nostr_event.py`, there are methods `create_tree_event` and `create_blob_event` that create Nostr events for git trees and blobs (kinds 3122 and 3123).

2. GitTree and GitBlob classes:
   - There are no separate `GitTree` and `GitBlob` classes as described in the prompt.
   - Instead, the functionality is integrated into the `NostrEvent` model in Odoo.

3. Serialization and deserialization:
   - The system implements serialization of git objects into Nostr events.
   - Deserialization is partially implemented in the `reconstruct_git_objects` method.

4. Repository traversal and reconstruction:
   - The `sync_git_nostr` method in the `NostrEvent` model traverses a git repository and converts objects into Nostr events.
   - The `reconstruct_git_objects` method attempts to reconstruct a repository from Nostr events.

5. Testing:
   - There is a test file `integrated_ivcs/tests/test_git_nostr_integration.py` that includes some tests for the functionality.
   - However, the tests are not as comprehensive as described in the prompt, and they're integrated into Odoo's testing framework rather than being standalone console tests.

6. Odoo integration:
   - The functionality is integrated into Odoo models, views, and actions.
   - There are appropriate Odoo model definitions, views, and menu items for interacting with the git-nostr functionality.

In conclusion:
The system does implement significant parts of the requested functionality and integrates it into Odoo. However, it doesn't fully match the prompt's requirements:

1. It lacks separate `GitTree` and `GitBlob` classes.
2. The serialization and deserialization are not as clearly defined as requested.
3. The testing is not as comprehensive as described and is not designed for a standalone console environment.
4. The implementation is tightly coupled with Odoo, rather than being a separate Python script that could work independently.

While the core ideas are present and integrated into Odoo, the implementation doesn't fully meet the standalone nature and comprehensive testing described in the prompt. It's more of an Odoo-specific implementation of git-nostr integration rather than a standalone Python script with the specified classes and console-based testing.





The system does implement some aspects of the prompt, but it's not a full implementation of the described BranchManager class. Let's analyze the implementation:

1. BranchManager class:
   - There is a `BranchManager` model in `integrated_ivcs/models/branch_manager.py`.
   - It's implemented as an Odoo model rather than a standalone Python class.

2. Branch operations:
   - The class includes methods for creating branches (`create_branch`), deleting branches (`delete_branch`), and updating branches (`update_branch`).
   - There's also a `merge_branches` method, which goes beyond the basic operations mentioned in the prompt.

3. Nostr event generation:
   - Branch operations do generate Nostr events using kind 31227, as specified in the prompt.
   - This is implemented in the `_create_branch_event` method.

4. Branch reconstruction:
   - There's a `reconstruct_branches_from_events` method that attempts to reconstruct the branch structure from Nostr events.

5. Listing branches:
   - The `list_branches` method is implemented to list all branches in the repository.

6. Integration with Odoo:
   - The BranchManager is fully integrated into the Odoo framework as a model.
   - It's associated with the `ivcs.item` model, which represents a repository.

7. Testing:
   - There are no specific tests for the BranchManager in the provided codebase.
   - The testing described in the prompt (covering branch creation, deletion, updating, and reconstruction from events) is not present.

8. Console verification:
   - As this is implemented as an Odoo module, there's no direct console interface for testing as described in the prompt.

In conclusion:
The system partially implements the functionality described in the prompt and integrates it into Odoo. However, there are some key differences and missing elements:

1. It's implemented as an Odoo model rather than a standalone Python class.
2. While core branch operations are implemented, they're adapted to work within the Odoo framework.
3. The testing described in the prompt is not implemented.
4. There's no console interface for direct testing as described.
5. The handling of complex scenarios like multiple branches and merges is partially implemented but not extensively tested.

The implementation is tailored for integration with Odoo rather than being a standalone system that can be tested from the console. While it covers many of the core concepts described in the prompt, it doesn't fully meet the requirements of a standalone BranchManager class with comprehensive console-based testing.





Based on the provided codebase, the system partially implements some aspects of the RepositoryAnchor functionality described in the prompt, but it's not a complete or standalone implementation. Let's analyze the implementation:

1. RepositoryAnchor class:
   - There isn't a specific `RepositoryAnchor` class as described in the prompt.
   - Some of the functionality is spread across different Odoo models, particularly in `integrated_ivcs/models/ivcs_item.py` and `integrated_ivcs/models/nostr_event.py`.

2. Anchor event creation (kind 31228):
   - The `_create_nostr_repo_event` method in the `IVCSItem` model creates an event of kind 31228 for repository anchoring.

3. Updating anchor:
   - There's no specific method for updating the anchor event when maintainers change.

4. Resolving repository state:
   - The system doesn't have a dedicated method to resolve the current state of a repository from its anchor event.

5. Maintainer management:
   - There's no explicit method for listing maintainers or checking permissions based on the anchor event.

6. Repository forking:
   - The provided code doesn't include specific functionality for handling repository forking as described in the prompt.

7. Integration with git object and branch management:
   - The system does integrate with git object management (commits, trees, blobs) and has some branch management functionality, but it's not explicitly tied to the anchoring mechanism as described in the prompt.

8. Testing:
   - There are no specific tests for the repository anchoring functionality as described in the prompt.

9. Odoo Integration:
   - The implemented functionality is integrated into Odoo models and views, rather than being a standalone class.

10. Console verification:
    - As this is implemented as an Odoo module, there's no direct console interface for testing as described in the prompt.

In conclusion:
The system partially implements some concepts related to repository anchoring and integrates them into Odoo, but it doesn't fully match the requirements outlined in the prompt:

1. There's no standalone RepositoryAnchor class; the functionality is spread across Odoo models.
2. While there is basic support for creating anchor events, many of the specified methods (updating anchors, resolving state, listing maintainers, checking permissions, forking) are either missing or not fully implemented.
3. The testing described in the prompt is not present.
4. There's no console interface for direct testing as described.

The implementation is designed to work within the Odoo framework rather than as a standalone system that can be tested from the console. While it touches on some of the concepts described in the prompt, it doesn't fully meet the requirements of a comprehensive RepositoryAnchor class with the specified functionality and testing capabilities.






Based on the analysis of the existing codebase and the requirements outlined in the prompts, here's a deep dive into what needs to be done to fully implement the Git-Nostr integration:

1. Nostr Event Kinds Implementation:

- Create a base `NostrEvent` class with common attributes and methods.
- Implement separate classes for each event kind (31228, 31227, 3121, 3122, 3123) inheriting from `NostrEvent`.
- For each class, implement:
  - Proper validation for required and optional fields
  - Serialization to JSON
  - Deserialization from JSON
  - Any kind-specific methods (e.g., specific getters/setters)
- Write comprehensive unit tests for each event type
- Ensure these classes can work independently of Odoo

This foundation will allow for consistent handling of different Nostr event types related to Git operations.

2. Git Object Representation:

- Implement `GitTree` and `GitBlob` classes that can:
  - Serialize git tree and blob objects into Nostr events (kinds 3122 and 3123)
  - Deserialize Nostr events back into git objects
- Enhance the existing git commit representation to work seamlessly with trees and blobs
- Create methods to traverse a git repository and convert all objects (commits, trees, blobs) into Nostr events
- Implement repository reconstruction from a set of Nostr events
- Develop comprehensive tests for serialization, deserialization, traversal, and reconstruction

This will enable full representation of Git repositories in Nostr events, allowing for decentralized storage and sharing of repositories.

3. Branch Management:

- Develop a standalone `BranchManager` class (not tied to Odoo) that:
  - Creates branches and generates corresponding Nostr events (kind 31227)
  - Updates branch heads
  - Deletes branches
  - Lists all branches in a repository
  - Handles merges between branches
- Implement methods to reconstruct the branch structure from Nostr events
- Create comprehensive tests for all branch operations and reconstruction
- Ensure the `BranchManager` can handle complex scenarios like multiple branches and merges

This will allow for decentralized management of Git branches using Nostr events.

4. Repository Anchoring:

- Create a standalone `RepositoryAnchor` class that:
  - Generates the initial anchor event (kind 31228) for a new repository
  - Updates the anchor event when repository details change (e.g., maintainers)
  - Resolves the current state of a repository from its anchor event
  - Lists maintainers and checks permissions based on the anchor event
  - Handles repository forking
- Implement methods to integrate anchoring with git object and branch management
- Develop tests for anchor creation, updates, permission checks, and fork management

This will provide a robust mechanism for managing repository metadata and permissions in a decentralized manner.

5. Integration and Consilidation:

- Create a high-level `GitNostrManager` class that:
  - Utilizes all the above components (NostrEvents, GitObjects, BranchManager, RepositoryAnchor)
  - Provides a unified interface for all Git-Nostr operations
  - Handles the flow of data between different components
- Implement comprehensive integration tests that cover end-to-end scenarios

This will tie all the components together into a cohesive system.

6. Odoo Integration:

- Create Odoo models that wrap the standalone classes:
  - `NostrEventModel` that can create and manage different types of Nostr events
  - `GitRepositoryModel` that uses `GitNostrManager` for repository operations
  - `BranchManagerModel` that interfaces with the `BranchManager` class
  - `RepositoryAnchorModel` that manages repository anchoring within Odoo
- Implement Odoo views and controllers to interact with these models
- Ensure all Odoo-specific code is separate from the core Git-Nostr logic

This will allow the Git-Nostr functionality to be used within Odoo while maintaining the ability to use it independently.

7. Console Interface:

- Develop a command-line interface that interacts with the `GitNostrManager`
- Implement commands for all major operations (create repository, commit, branch, merge, etc.)
- Create a test suite that uses this console interface to verify functionality

This will provide a way to test and use the system outside of Odoo.

8. Documentation and Examples:

- Write detailed documentation for each component
- Create example scripts demonstrating various use cases
- Provide guidelines for extending the system

To implement this, you'd start by creating the core classes and their unit tests. Then, build the integration layer (`GitNostrManager`) and its tests. After that, implement the Odoo integration and the console interface. Throughout the process, maintain a separation between the core Git-Nostr logic and the Odoo-specific code to ensure the system can function both within and outside of Odoo.

This approach will result in a flexible, well-tested system that fully implements the Git-Nostr integration as described in the prompts, while also providing Odoo integration for those who need it.






You've provided excellent suggestions that will indeed enhance the integration of Git with Nostr and create a more robust, user-friendly, and secure system. Let's dive deeper into each of these points and discuss how they can be implemented:

1. Detailed Documentation:
   - Create a comprehensive API reference for all classes and methods.
   - Write tutorials covering basic to advanced usage scenarios.
   - Use tools like Sphinx or MkDocs to generate navigable documentation.
   - Include inline comments in the code for better maintainability.

2. Security Considerations:
   - Implement encryption for storing private keys, possibly using libraries like cryptography.
   - Use OAuth or a similar protocol for user authentication in Odoo.
   - Implement role-based access control (RBAC) for repository operations.
   - Regularly audit the codebase for security vulnerabilities.

3. Error Handling:
   - Create custom exception classes for different types of errors (e.g., NostrConnectionError, GitOperationError).
   - Implement proper exception handling and logging throughout the codebase.
   - Develop a user-friendly error reporting system in the Odoo interface.

4. Performance Optimization:
   - Use caching mechanisms to store frequently accessed data (e.g., repository metadata).
   - Implement pagination for large datasets (e.g., when listing commits or branches).
   - Use asynchronous programming (e.g., asyncio in Python) for I/O-bound operations like Nostr event publishing.

5. Testing:
   - Use a testing framework like pytest for unit and integration tests.
   - Implement property-based testing for complex operations using libraries like Hypothesis.
   - Set up continuous integration (CI) to run tests automatically on each commit.
   - Create a comprehensive test suite covering all components and their interactions.

6. User Interface:
   - Design intuitive forms and views in Odoo for repository management.
   - Implement real-time notifications for long-running operations.
   - Use Odoo's QWeb framework to create dynamic, responsive interfaces.
   - Consider adding visualizations (e.g., commit graphs) using libraries like D3.js.

7. Scalability:
   - Implement database indexing for frequently queried fields.
   - Use background jobs (e.g., Odoo's queue_job module) for time-consuming tasks.
   - Consider implementing sharding for large-scale deployments.
   - Optimize database queries to handle large volumes of data efficiently.

8. Interoperability:
   - Provide clear documentation on how to import existing Git repositories.
   - Implement export functionality to standard Git formats.
   - Ensure compatibility with common Git workflows (e.g., GitFlow, GitHub Flow).
   - Create hooks or plugins for popular Git hosting platforms (e.g., GitHub, GitLab).

9. Community Feedback:
   - Set up a public repository for the project on GitHub or GitLab.
   - Implement a system for tracking feature requests and bug reports (e.g., using GitHub Issues).
   - Create a roadmap for future development and share it with the community.
   - Consider setting up a discussion forum or chat channel for user support.

10. CLI Integration:
    - Use a library like Click or argparse to create a user-friendly CLI.
    - Implement shell completion for CLI commands.
    - Ensure the CLI can be used both with local Git repositories and Odoo-managed ones.
    - Provide options for output formatting (e.g., JSON, YAML) for easy integration with other tools.

Additional considerations:

11. Versioning and Migrations:
    - Implement a clear versioning system for your Odoo module.
    - Provide migration scripts for updates that change data structures.

12. Localization:
    - Use Odoo's built-in translation system to make the interface multilingual.
    - Ensure all user-facing strings are translatable.

13. API Development:
    - Create a RESTful API to allow third-party integrations.
    - Use OpenAPI (Swagger) to document the API endpoints.

14. Monitoring and Logging:
    - Implement comprehensive logging throughout the system.
    - Consider integrating with monitoring tools like Prometheus for production deployments.

By addressing these points, you'll create a robust, scalable, and user-friendly system that integrates Git with Nostr while leveraging Odoo's capabilities. This approach will result in a solution that's not only powerful but also accessible to a wide range of users, from developers working via CLI to non-technical users managing repositories through the Odoo interface.





Absolutely! Adding example items or demo data to each part of these new modules is an excellent idea. It provides users with a practical understanding of how the system works and serves as a template for their own usage. Here's how you could implement this for different components of the Git-Nostr integration in Odoo:

1. Example Repositories:
   - Create a few sample repositories with different characteristics:
     * A simple "Hello World" project
     * A more complex project with multiple branches
     * A forked repository to demonstrate the forking process

2. Sample Commits:
   - Populate the example repositories with a series of commits:
     * Initial commit with basic project structure
     * Feature addition commits
     * Bug fix commits
     * Merge commits

3. Branch Examples:
   - Create various types of branches in the sample repositories:
     * Main/master branch
     * Feature branches (e.g., "feature/new-login")
     * Hotfix branches (e.g., "hotfix/critical-bug")
     * Release branches (e.g., "release/v1.0")

4. Nostr Events:
   - Generate example Nostr events for each type (31228, 31227, 3121, 3122, 3123):
     * Repository anchor events
     * Branch creation and update events
     * Commit events
     * Tree and blob events

5. User Accounts:
   - Create demo user accounts with different roles:
     * Repository owner
     * Contributor
     * Read-only user

6. Permission Examples:
   - Set up various permission scenarios:
     * Public repository accessible to all
     * Private repository with limited access
     * Repository with multiple collaborators having different access levels

7. Merge and Fork Examples:
   - Include examples of:
     * A successfully merged pull request
     * A fork of one of the sample repositories
     * A merge conflict scenario

8. Anchor Updates:
   - Demonstrate anchor event updates:
     * Initial repository creation
     * Adding a new maintainer
     * Changing repository metadata

9. CLI Command Examples:
   - Provide a script or documentation with example CLI commands:
     * Creating a new repository
     * Making a commit
     * Creating and switching branches
     * Publishing events to Nostr

10. Odoo Views:
    - Populate Odoo views with these examples:
      * List view of repositories
      * Form view of a repository with commits and branches
      * Kanban view for visualizing repository status

Implementation Steps:

1. Data Files:
   - Create XML data files in your Odoo module to define these examples.
   - Use `noupdate="1"` to prevent overwriting user changes on module updates.

2. Demo Flag:
   - Mark these data files as demo data in the module's `__manifest__.py`:
     ```python
     {
         'name': 'Git-Nostr Integration',
         # ... other keys ...
         'demo': [
             'data/demo_repositories.xml',
             'data/demo_commits.xml',
             'data/demo_branches.xml',
             'data/demo_nostr_events.xml',
             'data/demo_users.xml',
         ],
     }
     ```

3. Documentation:
   - In your module's documentation, reference these examples and explain how users can explore them.
   - Provide a guide on how users can recreate similar structures for their own use.

4. Tour:
   - Implement an Odoo tour that guides new users through the example data, explaining each component.

5. Sample Code:
   - In your documentation or as comments in the demo data files, include sample Python code for interacting with these examples programmatically.

Example XML for demo data:

```xml
<odoo>
    <data noupdate="1">
        <!-- Sample Repository -->
        <record id="demo_repo_hello_world" model="ivcs.item">
            <field name="name">Hello World Project</field>
            <field name="description">A simple demo repository</field>
            <field name="repo_path">/path/to/hello_world</field>
        </record>

        <!-- Sample Commit -->
        <record id="demo_commit_initial" model="ivcs.commit">
            <field name="hash">abcdef1234567890</field>
            <field name="message">Initial commit</field>
            <field name="author">Demo User</field>
            <field name="item_id" ref="demo_repo_hello_world"/>
        </record>

        <!-- Sample Branch -->
        <record id="demo_branch_feature" model="ivcs.branch">
            <field name="name">feature/new-login</field>
            <field name="item_id" ref="demo_repo_hello_world"/>
        </record>

        <!-- More examples... -->
    </data>
</odoo>
```

By providing these examples, you give users a concrete starting point to understand and explore the Git-Nostr integration. They can see how different components interact, experiment with the system safely, and use these examples as templates for their own repositories and workflows.
=== ./odoo_custom_addons (copy)/git_nostr_object/models/git_repository.py ===
# models/git_repository.py
from odoo import models, fields, api
import git
import json

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Name', required=True)
    path = fields.Char(string='Path', required=True)
    logs = fields.Text(string='Logs')

    def traverse_and_publish(self):
        self.ensure_one()
        logs = []
        try:
            git_repo = git.Repo(self.path)
            for commit in git_repo.iter_commits():
                nostr_event = self.env['nostr.event.object'].create({
                    'kind': 1,
                    'content': commit.message,
                    'tags': json.dumps([['commit', commit.hexsha]]),
                    'created_at': commit.committed_date,
                })
                nostr_event.action_publish()
                logs.append(f"Published commit {commit.hexsha}")

            self.write({'logs': '\n'.join(logs)})
            self.env['bus.bus']._sendone(self.env.user.partner_id, 'simple_notification', {
                'title': _("Git Repository Traversed"),
                'message': _("All commits published to Nostr network"),
            })
        except Exception as e:
            error_msg = f"Error traversing repository: {e}"
            logs.append(error_msg)
            self.write({'logs': '\n'.join(logs)})
            raise UserError(_(error_msg))

        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _("Git Repository"),
                'message': _("Repository traversed and commits published. Check logs for details."),
                'sticky': False,
                'type': 'success',
            }
        }
=== ./odoo_custom_addons (copy)/git_nostr_object/models/git_commit.py ===
from odoo import models, fields, api
from .git_object import GitObject

class GitCommit(models.Model):
    _name = 'git.commit'
    _inherit = 'git.object'
    _description = 'Git Commit'

    message = fields.Text(string='Commit Message')
    author = fields.Char(string='Author')
    timestamp = fields.Datetime(string='Timestamp')

    def to_nostr_event(self):
        return self.env['nostr.event.object'].create({
            'kind': 3121,
            'content': self.data,
            'tags': [['sha', self.sha]],
        })

    @api.model
    def create_from_nostr_event(self, event):
        git_commit = GitObject.from_nostr_event(event)
        return self.create({
            'sha': git_commit.sha,
            'data': git_commit.data.decode('utf-8', errors='replace'),
            'message': git_commit.message,
            'author': git_commit.author,
            'timestamp': git_commit.timestamp,
        })
    @api.model
    def create_from_git_commit(self, commit):
        return self.create({
            'sha': commit.hexsha,
            'message': commit.message,
            'author': f"{commit.author.name} <{commit.author.email}>",
            'timestamp': commit.committed_datetime,
            'data': commit.tree.data_stream.read().decode('utf-8', errors='replace'),
        })
=== ./odoo_custom_addons (copy)/git_nostr_object/models/nostr_websocket_client.py ===
import websocket
import json
import logging
import time

_logger = logging.getLogger(__name__)

class NostrWebSocketClient:
    def __init__(self, relay_urls):
        self.relay_urls = relay_urls

    def connect_and_publish(self, event_data):
        responses = []
        for url in self.relay_urls:
            try:
                _logger.info(f"Attempting to connect to {url}")
                start_time = time.time()
                ws = websocket.create_connection(url, timeout=10)
                _logger.info(f"Connected to {url} in {time.time() - start_time:.2f} seconds")

                # Construct the message correctly
                message = ["EVENT", event_data]
                _logger.debug(f"Raw event message: {message}")

                ws.send(json.dumps(message))
                _logger.info(f"Sent message to {url} in {time.time() - start_time:.2f} seconds")

                _logger.info(f"Waiting for response from {url}")
                response = ws.recv()
                _logger.info(f"Received response from {url} in {time.time() - start_time:.2f} seconds: {response}")

                responses.append(json.loads(response))
                ws.close()
            except Exception as e:
                _logger.error(f"Error publishing to {url}: {str(e)}")
                responses.append(["ERROR", str(e)])
        return responses
=== ./odoo_custom_addons (copy)/git_nostr_object/models/__init__.py ===
# __init__.py
from . import git_object
from . import git_commit
from . import git_tree
from . import git_blob
from . import git_repository
from . import nostr_event
from . import admin_test
from . import git_commit_wizard
=== ./odoo_custom_addons (copy)/git_nostr_object/models/git_object.py ===
from odoo import models, fields, api

class GitObject(models.AbstractModel):
    _name = 'git.object'
    _description = 'Git Object'

    sha = fields.Char(string='SHA', required=True)
    data = fields.Text(string='Data', required=True)

    def to_nostr_event(self):
        raise NotImplementedError("This method should be implemented by subclasses")

    @api.model
    def create_from_nostr_event(self, event):
        raise NotImplementedError("This method should be implemented by subclasses")
=== ./odoo_custom_addons (copy)/git_nostr_object/models/git_nostr_object.py ===
# models/git_nostr_event.py
from odoo import models, fields, api
from utils.nostr_websocket_client import NostrWebSocketClient
from nostr.event import Event as NostrEvent
import logging
import time
import json

_logger = logging.getLogger(__name__)

class GitNostrEventObject(models.Model):
    _name = 'git_nostr.event.object'
    _description = 'Git Nostr Event Object'

    kind = fields.Integer(string='Event Kind', required=True)
    content = fields.Text(string='Content', required=True)
    tags = fields.Text(string='Tags')
    created_at = fields.Integer(string='Created At', required=True)
    signature = fields.Char(string='Signature', required=True)
    public_key = fields.Char(string='Public Key', required=True)
    published = fields.Boolean(string='Published', default=False)

    def action_publish(self):
        """
        Publish the Nostr event to the configured relays.
        """
        relay_urls = [
            'wss://relay.damus.io',
            'wss://nostr-pub.wellorder.net',
            'wss://nostr.mom',
            'wss://nostr.slothy.win',
            'wss://relay.stoner.com'
        ]

        event_data = {
            'kind': self.kind,
            'content': self.content,
            'tags': self.tags,
            'created_at': self.created_at,
            'pubkey': self.public_key,
            'sig': self.signature,
        }

        websocket_client = NostrWebSocketClient(relay_urls)

        try:
            responses = websocket_client.connect_and_publish(event_data)
            if all(response[0] == 'OK' and response[2] for response in responses):
                self.write({'published': True})
                _logger.info(f"Nostr event successfully published: {self.id}")
            else:
                self.write({'published': False})
                _logger.error(f"Error publishing Nostr event {self.id}: {responses}")
        except Exception as e:
            self.write({'published': False})
            _logger.error(f"Error publishing Nostr event {self.id}: {e}")

    def to_nostr_event(self):
        try:
            tags = json.loads(self.tags) if self.tags else []
        except json.JSONDecodeError:
            _logger.warning(f"Invalid JSON in tags for event {self.id}. Using empty tags list.")
            tags = []

        return NostrEvent(
            kind=self.kind,
            content=self.content,
            tags=tags,
            public_key=self.public_key,
            created_at=self.created_at,
            sig=self.signature
        )
=== ./odoo_custom_addons (copy)/git_nostr_object/models/git_blob.py ===
from odoo import models, fields, api
from .git_object import GitObject

class GitBlob(models.Model):
    _name = 'git.blob'
    _inherit = 'git.object'
    _description = 'Git Blob'

    def to_nostr_event(self):
        return self.env['nostr.event.object'].create({
            'kind': 3123,
            'content': self.data,
            'tags': [['sha', self.sha]],
        })

    @api.model
    def create_from_nostr_event(self, event):
        git_blob = GitObject.from_nostr_event(event)
        return self.create({
            'sha': git_blob.sha,
            'data': git_blob.data.hex(),
        })
=== ./odoo_custom_addons (copy)/git_nostr_object/models/git_tree.py ===
from odoo import models, fields, api
from .git_object import GitObject

class GitTree(models.Model):
    _name = 'git.tree'
    _inherit = 'git.object'
    _description = 'Git Tree'

    def to_nostr_event(self):
        return self.env['nostr.event.object'].create({
            'kind': 3122,
            'content': self.data,
            'tags': [['sha', self.sha]],
        })

    @api.model
    def create_from_nostr_event(self, event):
        git_tree = GitObject.from_nostr_event(event)
        return self.create({
            'sha': git_tree.sha,
            'data': git_tree.data.decode('utf-8', errors='replace'),
        })
=== ./odoo_custom_addons (copy)/git_nostr_object/models/nostr_event.py ===
# models/nostr_event.py
from odoo import models, fields, api, _
from odoo.exceptions import UserError
from ..utils.nostr_websocket_client import NostrWebSocketClient
from nostr.event import Event as NostrEvent
from nostr.key import PrivateKey
import logging
import json
import time

_logger = logging.getLogger(__name__)

class NostrEventObject(models.Model):
    _name = 'nostr.event.object'
    _description = 'Nostr Event Object'

    kind = fields.Integer(string='Event Kind', required=True)
    content = fields.Text(string='Content', required=True)
    tags = fields.Text(string='Tags')
    created_at = fields.Integer(string='Created At', required=True)
    signature = fields.Char(string='Signature')
    public_key = fields.Char(string='Public Key', required=True)
    published = fields.Boolean(string='Published', default=False)
    logs = fields.Text(string='Logs')

    def action_publish(self):
        self.ensure_one()
        if self.published:
            raise UserError(_("This event has already been published."))

        start_time = time.time()
        logs = []

        # Get the user's private key
        user = self.env.user
        private_key_nsec = user.nostr_private_key
        if not private_key_nsec:
            raise UserError(_("Nostr private key is not set for the current user."))

        try:
            private_key = PrivateKey.from_nsec(private_key_nsec)
        except Exception as e:
            raise UserError(_("Invalid Nostr private key: %s") % str(e))

        logs.append(f"Key preparation took {time.time() - start_time:.4f} seconds")

        # Create and sign the Nostr event
        event_creation_start = time.time()
        event = NostrEvent(
            kind=self.kind,
            content=self.content,
            tags=json.loads(self.tags) if self.tags else [],
            public_key=private_key.public_key.hex(),
            created_at=int(time.time())
        )
        private_key.sign_event(event)
        logs.append(f"Event creation and signing took {time.time() - event_creation_start:.4f} seconds")

        # Update the record
        self.write({
            'signature': event.signature,
            'public_key': event.public_key,
            'created_at': event.created_at
        })

        relay_urls = [
            'wss://relay.damus.io',
            'wss://nostr-pub.wellorder.net',
            'wss://nostr.mom',
            'wss://nostr.slothy.win',
            'wss://relay.stoner.com'
        ]

        event_data = json.loads(event.to_message())[1]
        websocket_client = NostrWebSocketClient(relay_urls)

        publish_start = time.time()
        try:
            responses, ws_logs = websocket_client.connect_and_publish(event_data)
            logs.extend(ws_logs)
            if any(response[0] == 'OK' for response in responses):
                self.write({'published': True})
                logs.append(f"Nostr event successfully published: {self.id}")
                self.env['bus.bus']._sendone(self.env.user.partner_id, 'simple_notification', {
                    'title': _("Nostr Event Published"),
                    'message': _("Event successfully published to Nostr network"),
                })
            else:
                error_msg = f"Error publishing Nostr event {self.id}: {responses}"
                logs.append(error_msg)
                raise UserError(_(error_msg))
        except Exception as e:
            error_msg = f"Error publishing Nostr event {self.id}: {e}"
            logs.append(error_msg)
            raise UserError(_(error_msg))
        finally:
            logs.append(f"Publishing process took {time.time() - publish_start:.4f} seconds")

        logs.append(f"Total publish action took {time.time() - start_time:.4f} seconds")
        self.write({'logs': '\n'.join(logs)})

        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _("Nostr Event"),
                'message': _("Event published successfully. Check logs for details."),
                'sticky': False,
                'type': 'success',
            }
        }
=== ./odoo_custom_addons (copy)/git_nostr_object/models/git_commit_wizard.py ===
from odoo import models, fields, api

class GitCommitWizard(models.TransientModel):
    _name = 'git.commit.wizard'
    _description = 'Git Commit Wizard'

    repository_id = fields.Many2one('git.repository', string='Repository', required=True)
    message = fields.Text(string='Commit Message', required=True)
    file_data = fields.Text(string='File Content')
    file_name = fields.Char(string='File Name')

    def action_create_commit(self):
        repo = self.repository_id
        with open(f"{repo.path}/{self.file_name}", 'w') as f:
            f.write(self.file_data)
        commit = repo.create_commit(self.message, [self.file_name])
        return {'type': 'ir.actions.act_window_close'}
=== ./odoo_custom_addons (copy)/git_nostr_object/models/admin_test.py ===
# /opt/odoo/custom_addons/git_nostr_object/models/admin_test.py
from odoo import models, api
from ..tests.test_git_nostr_object import test_git_nostr_object, test_nostr_auth

class AdminTest(models.TransientModel):
    _name = 'git_nostr_object.admin_test'
    _description = 'Admin Test for Git-Nostr Object'

    def run_tests(self):
        test_git_nostr_object()
        test_nostr_auth()
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': 'Test Results',
                'message': 'Tests completed. Check the logs for details.',
                'sticky': False,
            }
        }
=== ./odoo_custom_addons (copy)/git_nostr_object/__init__.py ===
from . import models
from . import controllers
=== ./odoo_custom_addons (copy)/git_nostr_object/utils/nostr_websocket_client.py ===
# utils/nostr_websocket_client.py
import logging
import time
import websocket
import json

_logger = logging.getLogger(__name__)

class NostrWebSocketClient:
    def __init__(self, relay_urls):
        self.relay_urls = relay_urls

    def connect_and_publish(self, event_data):
        responses = []
        logs = []
        for url in self.relay_urls:
            try:
                response, log = self._connect_and_publish_to_relay(url, event_data)
                responses.append(response)
                logs.extend(log)
            except Exception as e:
                error_message = f"Error publishing event to relay {url}: {e}"
                _logger.error(error_message)
                logs.append(error_message)
        return responses, logs

    def _connect_and_publish_to_relay(self, relay_url, event_data):
        log = []
        log.append(f"Attempting to connect to {relay_url}")
        start_time = time.time()

        ws = websocket.create_connection(relay_url)
        log.append(f"Connected to {relay_url} in {time.time() - start_time:.2f} seconds")

        event_message = json.dumps(["EVENT", event_data])
        log.append(f"Sending Nostr event to {relay_url}")
        ws.send(event_message)
        log.append(f"Sent message to {relay_url} in {time.time() - start_time:.2f} seconds")

        log.append(f"Waiting for response from {relay_url}")
        response = ws.recv()
        log.append(f"Received response from {relay_url} in {time.time() - start_time:.2f} seconds: {response}")
        ws.close()
        return json.loads(response), log
=== ./odoo_custom_addons (copy)/git_nostr_object/__manifest__.py ===
{
    'name': 'git_nostr_object',
    'version': '1.0',
    'depends': ['base', 'bus'],
    'data': [
        'security/ir.model.access.csv',
        'views/git_repository_views.xml',
        'views/git_commit_views.xml',
        'views/git_tree_views.xml',
        'views/git_blob_views.xml',
        'views/git_object_views.xml',
        'views/nostr_event_object_views.xml',
        'views/actions.xml',
        'views/menus.xml',
        'views/admin_test_views.xml',
        'views/git_commit_wizard_views.xml'
    ],
    'assets': {
        'web.assets_backend': [
            'git_nostr_object/static/src/js/git_nostr_notifications.js',
        ],
    },
    'installable': True,
    'application': True,
    'auto_install': False,
}
=== ./odoo_custom_addons (copy)/git_nostr_object/static/src/js/git_nostr_notifications.js ===
// static/src/js/git_nostr_notifications.js
odoo.define('git_nostr_object.notifications', function (require) {
    "use strict";

    var core = require('web.core');
    var session = require('web.session');
    var BusService = require('bus.BusService');

    BusService.include({
        _onNotification: function (notifications) {
            var self = this;
            _.each(notifications, function (notification) {
                if (notification[0][1] === 'simple_notification') {
                    self.displayNotification({
                        title: notification[1].title,
                        message: notification[1].message,
                        type: 'info',
                    });
                }
            });
            this._super.apply(this, arguments);
        },
    });
});
=== ./odoo_custom_addons (copy)/git_nostr_object/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_git_commit,access_git_commit,model_git_commit,base.group_user,1,1,1,1
access_git_tree,access_git_tree,model_git_tree,base.group_user,1,1,1,1
access_git_blob,access_git_blob,model_git_blob,base.group_user,1,1,1,1
access_git_repository,access_git_repository,model_git_repository,base.group_user,1,1,1,1
access_nostr_event_object,access_nostr_event_object,model_nostr_event_object,base.group_user,1,1,1,1
=== ./odoo_custom_addons (copy)/git_nostr_object/tests/__init__.py ===
# /opt/odoo/custom_addons/git_nostr_object/tests/__init__.py
from . import test_git_nostr_object
=== ./odoo_custom_addons (copy)/git_nostr_object/tests/test_git_nostr_object.py ===
from odoo.tests.common import TransactionCase
from datetime import datetime
import random
import string
import logging
import os

_logger = logging.getLogger(__name__)

def random_string(length=10):
    return ''.join(random.choices(string.ascii_letters + string.digits, k=length))

def generate_sha():
    """Generate a random 40-character SHA hash"""
    return ''.join(random.choices('0123456789abcdef', k=40))

def get_current_timestamp():
    """Return the current timestamp"""
    return int(datetime.now().timestamp())

def get_author(env):
    """Return the logged-in user's name as the author"""
    return env.user.name

def get_local_path():
    """Return the Odoo installation path as the local path"""
    return '/opt/odoo'

def generate_nostr_keys():
    """Generate random 64-character Nostr public and private keys for the logged-in user"""
    public_key = random_string(64)
    private_key = random_string(64)
    return public_key, private_key

def get_event_type(content):
    """Extract the event type from the first line of the content"""
    return int(content.split('\n')[0].strip('# '))

def get_event_name(content):
    """Extract the event name from the first line of the content"""
    return content.split('\n', 1)[0]

def check_method_existence(env, methods):
    """Check if the required methods exist in the corresponding models"""
    for model, method_name in methods.items():
        model_obj = env[model]
        if not hasattr(model_obj, method_name):
            return False, f"Method '{method_name}' not found in model '{model}'"
    return True, "All required methods found"

class TestGitNostrObject(TransactionCase):

    def setUp(self):
        super(TestGitNostrObject, self).setUp()
        self.GitRepository = self.env['git.repository']
        self.GitCommit = self.env['git.commit']
        self.GitTree = self.env['git.tree']
        self.GitBlob = self.env['git.blob']
        self.GitNostrEventObject = self.env['git_nostr.event.object']
        self.NostrKey = self.env['nostr.key']
        self.NostrRelay = self.env['nostr.relay']
        self.NostrProfile = self.env['nostr.profile']

        # Check if required methods exist in the corresponding models
        required_methods = {
            'git.repository': 'traverse_and_publish',
            'nostr.event.object': 'action_publish',
            'nostr.key': 'generate_key_pair',
            'nostr.key': 'sign_event'
        }
        success, message = check_method_existence(self.env, required_methods)
        if not success:
            self.fail(message)

    def test_git_nostr_object(self):
        _logger.info("Testing Git-Nostr Object module...")

        # Test Git Repository
        repo_name = f'Test Repo {random_string()}'
        repo_path = f'{get_local_path()}/custom_addons/git_nostr_object/tests/test_repo_{random_string()}'
        repo = self.GitRepository.create({
            'name': repo_name,
            'path': repo_path
        })
        _logger.info(f"Created Git Repository with ID: {repo.id}")

        # Test traverse_and_publish
        try:
            repo.traverse_and_publish()
            _logger.info("traverse_and_publish executed successfully")
        except Exception as e:
            _logger.error(f"Error in traverse_and_publish: {e}")

        # Test Git Commit
        commit_sha = generate_sha()
        commit_author = get_author(self.env)
        commit_timestamp = get_current_timestamp()
        commit_data = 'Test commit data'
        commit = self.GitCommit.create({
            'sha': commit_sha,
            'message': 'Test commit message',
            'author': commit_author,
            'timestamp': commit_timestamp,
            'data': commit_data
        })
        _logger.info(f"Created Git Commit with ID: {commit.id}")

        # Test Git Tree
        tree_sha = generate_sha()
        tree_data = 'Test tree data'
        tree = self.GitTree.create({
            'sha': tree_sha,
            'data': tree_data
        })
        _logger.info(f"Created Git Tree with ID: {tree.id}")

        # Test Git Blob
        blob_sha = generate_sha()
        blob_data = 'Test blob data'
        blob = self.GitBlob.create({
            'sha': blob_sha,
            'data': blob_data
        })
        _logger.info(f"Created Git Blob with ID: {blob.id}")

        # Test Nostr Event Object
        event_content = '# 1\nTest Nostr event content'
        event_type = get_event_type(event_content)
        event_tags = '[]'
        event_created_at = get_current_timestamp()
        event_signature = random_string(64)
        event_name = get_event_name(event_content)
        event = self.GitNostrEventObject.create({
            'kind': event_type,
            'content': event_content,
            'tags': event_tags,
            'created_at': event_created_at,
            'signature': event_signature,
            'name': event_name
        })
        _logger.info(f"Created Nostr Event Object with ID: {event.id}")

        # Test action_publish
        try:
            event.action_publish()
            _logger.info("action_publish executed successfully")
        except Exception as e:
            _logger.error(f"Error in action_publish: {e}")

    def test_nostr_auth(self):
        _logger.info("Testing Nostr Authentication module...")

        # Test Nostr Key
        public_key, private_key = generate_nostr_keys()
        key = self.NostrKey.create({
            'public_key': public_key,
            'private_key': private_key,
            'user_id': self.env.user.id
        })
        _logger.info(f"Created Nostr Key with ID: {key.id}")

        # Test Nostr Relay
        relay_url = f'wss://relay{random_string()}.com'
        relay = self.NostrRelay.create({
            'url': relay_url,
            'is_active': True
        })
        _logger.info(f"Created Nostr Relay with ID: {relay.id}")

        # Test Nostr Profile
        profile_name = f'Test Profile {random_string()}'
        profile_about = 'Test profile description'
        profile_picture = 'http://example.com/pic.jpg'
        profile = self.NostrProfile.create({
            'name': profile_name,
            'about': profile_about,
            'picture': profile_picture,
            'user_id': self.env.user.id
        })
        _logger.info(f"Created Nostr Profile with ID: {profile.id}")

        # Test generate_key_pair method
        try:
            result = self.NostrKey.generate_key_pair()
            _logger.info(f"Generated key pair: {result}")
        except Exception as e:
            _logger.error(f"Error in generate_key_pair: {e}")

        # Test sign_event method (assuming it exists)
        try:
            event_data = {
                'kind': 1,
                'content': 'Test content',
                'created_at': get_current_timestamp(),
                'tags': []
            }
            result = key.sign_event(event_data)
            _logger.info(f"Signed event: {result}")
        except Exception as e:
            _logger.error(f"Error in sign_event: {e}")

def test_git_nostr_object():
    test_case = TestGitNostrObject.create({})
    test_case.test_git_nostr_object()

def test_nostr_auth():
    test_case = TestGitNostrObject.create({})
    test_case.test_nostr_auth()

# This allows running the test from the Odoo shell
if __name__ == '__main__':
    test_git_nostr_object()
    test_nostr_auth()
=== ./odoo_custom_addons (copy)/git_nostr_object/views/git_blob_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_blob_form" model="ir.ui.view">
        <field name="name">git.blob.form</field>
        <field name="model">git.blob</field>
        <field name="arch" type="xml">
            <form>
                <group>
                    <field name="sha"/>
                    <field name="data"/>
                </group>
            </form>
        </field>
    </record>

    <record id="view_git_blob_tree" model="ir.ui.view">
        <field name="name">git.blob.tree</field>
        <field name="model">git.blob</field>
        <field name="arch" type="xml">
            <tree>
                <field name="sha"/>
            </tree>
        </field>
    </record>

    <record id="action_git_blob" model="ir.actions.act_window">
        <field name="name">Git Blobs</field>
        <field name="res_model">git.blob</field>
        <field name="view_mode">tree,form</field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/git_nostr_object/views/menus.xml ===
<!-- views/menus.xml -->
<odoo>
    <menuitem id="menu_git_nostr_object_root" name="Git-Nostr Object">
        <menuitem id="menu_git_repository" name="Repositories" action="action_git_repository"/>
        <menuitem id="menu_git_commit" name="Commits" action="action_git_commit"/>
        <menuitem id="menu_git_tree" name="Trees" action="action_git_tree"/>
        <menuitem id="menu_git_blob" name="Blobs" action="action_git_blob"/>
        <menuitem id="menu_git_nostr_event_object" name="Nostr Event Objects" action="action_git_nostr_event_object"/>
    </menuitem>
</odoo>
=== ./odoo_custom_addons (copy)/git_nostr_object/views/git_commit_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_commit_form" model="ir.ui.view">
        <field name="name">git.commit.form</field>
        <field name="model">git.commit</field>
        <field name="arch" type="xml">
            <form>
                <group>
                    <field name="sha"/>
                    <field name="message"/>
                    <field name="author"/>
                    <field name="timestamp"/>
                    <field name="data"/>
                </group>
            </form>
        </field>
    </record>

    <record id="view_git_commit_tree" model="ir.ui.view">
        <field name="name">git.commit.tree</field>
        <field name="model">git.commit</field>
        <field name="arch" type="xml">
            <tree>
                <field name="sha"/>
                <field name="message"/>
                <field name="author"/>
                <field name="timestamp"/>
            </tree>
        </field>
    </record>

    <record id="action_git_commit" model="ir.actions.act_window">
        <field name="name">Git Commits</field>
        <field name="res_model">git.commit</field>
        <field name="view_mode">tree,form</field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/git_nostr_object/views/git_object_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_object_form" model="ir.ui.view">
        <field name="name">git.object.form</field>
        <field name="model">git.object</field>
        <field name="arch" type="xml">
            <form>
                <group>
                    <field name="sha"/>
                    <field name="data"/>
                </group>
            </form>
        </field>
    </record>

    <record id="view_git_object_tree" model="ir.ui.view">
        <field name="name">git.object.tree</field>
        <field name="model">git.object</field>
        <field name="arch" type="xml">
            <tree>
                <field name="sha"/>
            </tree>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/git_nostr_object/views/admin_test_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_admin_test_form" model="ir.ui.view">
        <field name="name">git_nostr_object.admin_test.form</field>
        <field name="model">git_nostr_object.admin_test</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="run_tests" string="Run Tests" type="object" class="oe_highlight"/>
                </header>
                <div>
                    <p>Click the button to run the Git-Nostr Object tests.</p>
                </div>
            </form>
        </field>
    </record>

    <record id="action_admin_test" model="ir.actions.act_window">
        <field name="name">Admin Tests</field>
        <field name="res_model">git_nostr_object.admin_test</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
    </record>

    <menuitem id="menu_admin_test" name="Admin Tests" parent="menu_git_nostr_object_root" action="action_admin_test" groups="base.group_system"/>
</odoo>
=== ./odoo_custom_addons (copy)/git_nostr_object/views/git_commit_wizard_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_commit_wizard_form" model="ir.ui.view">
        <field name="name">git.commit.wizard.form</field>
        <field name="model">git.commit.wizard</field>
        <field name="arch" type="xml">
            <form string="Create Commit">
                <group>
                    <field name="repository_id" invisible="1"/>
                    <field name="message"/>
                    <field name="file_name"/>
                    <field name="file_data"/>
                </group>
                <footer>
                    <button name="action_create_commit" string="Create Commit" type="object" class="btn-primary"/>
                    <button string="Cancel" class="btn-secondary" special="cancel"/>
                </footer>
            </form>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/git_nostr_object/views/git_tree_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_tree_form" model="ir.ui.view">
        <field name="name">git.tree.form</field>
        <field name="model">git.tree</field>
        <field name="arch" type="xml">
            <form>
                <group>
                    <field name="sha"/>
                    <field name="data"/>
                </group>
            </form>
        </field>
    </record>

    <record id="view_git_tree_tree" model="ir.ui.view">
        <field name="name">git.tree.tree</field>
        <field name="model">git.tree</field>
        <field name="arch" type="xml">
            <tree>
                <field name="sha"/>
            </tree>
        </field>
    </record>

    <record id="action_git_tree" model="ir.actions.act_window">
        <field name="name">Git Trees</field>
        <field name="res_model">git.tree</field>
        <field name="view_mode">tree,form</field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/git_nostr_object/views/nostr_event_object_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_nostr_event_object_form" model="ir.ui.view">
        <field name="name">nostr.event.object.form</field>
        <field name="model">nostr.event.object</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="action_publish" string="Publish Event" type="object" class="oe_highlight" attrs="{'invisible': [('published', '=', True)]}"/>
                </header>
                <sheet>
                    <group>
                        <field name="kind"/>
                        <field name="content"/>
                        <field name="tags"/>
                        <field name="created_at"/>
                        <field name="signature"/>
                        <field name="public_key"/>
                        <field name="published"/>
                    </group>
                    <notebook>
                        <page string="Logs">
                            <field name="logs" widget="text" readonly="1"/>
                        </page>
                    </notebook>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_nostr_event_object_tree" model="ir.ui.view">
        <field name="name">nostr.event.object.tree</field>
        <field name="model">nostr.event.object</field>
        <field name="arch" type="xml">
            <tree string="Nostr Event Objects">
                <field name="kind"/>
                <field name="content"/>
                <field name="tags"/>
                <field name="created_at"/>
                <field name="signature"/>
                <field name="public_key"/>
                <field name="published"/>
            </tree>
        </field>
    </record>

    <record id="action_nostr_event_object" model="ir.actions.act_window">
        <field name="name">Nostr Event Objects</field>
        <field name="res_model">nostr.event.object</field>
        <field name="view_mode">tree,form</field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/git_nostr_object/views/git_repository_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_repository_form" model="ir.ui.view">
        <field name="name">git.repository.form</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="traverse_and_publish" string="Traverse and Publish" type="object" class="oe_highlight"/>
                </header>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="path" string="Local Path"/>
                    </group>
                    <notebook>
                        <page string="Logs">
                            <field name="logs" widget="text" readonly="1"/>
                        </page>
                    </notebook>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_git_repository_tree" model="ir.ui.view">
        <field name="name">git.repository.tree</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="path"/>
            </tree>
        </field>
    </record>

    <record id="action_git_repository" model="ir.actions.act_window">
        <field name="name">Git Repositories</field>
        <field name="res_model">git.repository</field>
        <field name="view_mode">tree,form</field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/git_nostr_object/views/actions.xml ===
<!-- views/actions.xml -->
<odoo>
    <record id="action_git_nostr_event_object" model="ir.actions.act_window">
        <field name="name">Nostr Event Objects</field>
        <field name="res_model">nostr.event.object</field>
        <field name="view_mode">tree,form</field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/git_nostr_object/controllers/git_controller.py ===
from odoo import http
from odoo.http import request
import logging

_logger = logging.getLogger(__name__)

class GitController(http.Controller):

    @http.route('/git_nostr_object/traverse_repo', type='json', auth='user')
    def traverse_repo(self, repo_id):
        try:
            repo = request.env['git.repository'].browse(repo_id)
            repo.traverse_and_publish()
            return {'status': 'success'}
        except Exception as e:
            _logger.exception("Error traversing repository")
            return {'status': 'error', 'message': str(e)}

    @http.route('/git_nostr_object/publish_event', type='json', auth='user')
    def publish_event(self, event_id):
        try:
            event = request.env['git_nostr.event.object'].browse(event_id)
            event.action_publish()
            return {'status': 'success'}
        except Exception as e:
            _logger.exception("Error publishing Nostr event")
            return {'status': 'error', 'message': str(e)}
=== ./odoo_custom_addons (copy)/custom_thunderbird_mail/models/custom_mail.py ===
import smtplib
from email.mime.text import MIMEText
from odoo import models, fields, api

class CustomMail(models.Model):
    _name = 'custom.mail'
    _description = 'Custom Mail Integration with Thunderbird Mail'

    @api.model
    def send_thunderbird_mail(self, recipient, subject, body):
        # Thunderbird SMTP server configuration
        smtp_server = 'test'
        smtp_port = 587
        smtp_user = 'g'
        smtp_password = 'your_thunderbird_password'  # Replace with the actual password

        # Create the email message
        msg = MIMEText(body)
        msg['Subject'] = subject
        msg['From'] = smtp_user
        msg['To'] = recipient

        # Send the email
        try:
            with smtplib.SMTP(smtp_server, smtp_port) as server:
                server.login(smtp_user, smtp_password)
                server.sendmail(smtp_user, [recipient], msg.as_string())
            return True
        except Exception as e:
            _logger.error('Failed to send email: %s', e)
            return False
=== ./odoo_custom_addons (copy)/custom_thunderbird_mail/__init__.py ===
from . import models
=== ./odoo_custom_addons (copy)/custom_thunderbird_mail/__manifest__.py ===
{
    'name': 'Custom Thunderbird Mail Integration',
    'version': '1.0',
    'category': 'Tools',
    'summary': 'Integrate Odoo with Thunderbird Mail',
    'description': 'A module to integrate Odoo with Thunderbird Mail for sending emails.',
    'depends': ['base'],
    'data': [],
    'installable': True,
    'application': True,
}
=== ./odoo_custom_addons (copy)/custom_thunderbird_mail/wizard/create_nostr_event_wizard.py ===
# wizard/create_nostr_event_wizard.py
from odoo import models, fields, api
import git
import json

class CreateNostrEventWizard(models.TransientModel):
    _name = 'create.nostr.event.wizard'
    _description = 'Create Nostr Event Wizard'

    repository_id = fields.Many2one('git.repository', string='Repository', required=True)
    event_type = fields.Selection([
        ('repo_anchor', 'Repository Anchor'),
        ('branch', 'Branch'),
        ('commit', 'Commit'),
        ('tree', 'Tree'),
        ('blob', 'Blob'),
    ], string='Event Type', required=True)
    commit_message = fields.Text(string='Commit Message')
    branch_name = fields.Char(string='Branch Name')
    file_content = fields.Text(string='File Content')
    file_name = fields.Char(string='File Name')

    def action_create_event(self):
        repo = git.Repo(self.repository_id.path)
        
        if self.event_type == 'commit':
            # Stage all changes
            repo.git.add(A=True)
            # Commit changes
            commit = repo.index.commit(self.commit_message)
            self.repository_id.last_commit = commit.hexsha
            content = json.dumps({
                'type': 'commit',
                'repository': self.repository_id.name,
                'commit_hash': commit.hexsha,
                'message': self.commit_message,
            })
        elif self.event_type == 'branch':
            repo.git.checkout('-b', self.branch_name)
            self.repository_id.branch = self.branch_name
            content = json.dumps({
                'type': 'branch',
                'repository': self.repository_id.name,
                'branch_name': self.branch_name,
            })
        elif self.event_type == 'blob':
            with open(os.path.join(self.repository_id.path, self.file_name), 'w') as f:
                f.write(self.file_content)
            repo.index.add([self.file_name])
            commit = repo.index.commit(f"Add file: {self.file_name}")
            self.repository_id.last_commit = commit.hexsha
            content = json.dumps({
                'type': 'blob',
                'repository': self.repository_id.name,
                'file_name': self.file_name,
                'commit_hash': commit.hexsha,
            })
        
        self.env['nostr.event'].create({
            'name': f"{self.event_type.capitalize()} - {self.repository_id.name}",
            'event_type': self.event_type,
            'content': content,
            'tags': json.dumps([['r', self.repository_id.remote_url]]),
        })

        return {'type': 'ir.actions.act_window_close'}
=== ./odoo_custom_addons (copy)/custom_thunderbird_mail/wizard/__init__.py ===
# wizard/__init__.py
from . import create_nostr_event_wizard
=== ./odoo_custom_addons (copy)/custom_thunderbird_mail/wizard/create_nostr_event_wizard_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_create_nostr_event_wizard_form" model="ir.ui.view">
        <field name="name">create.nostr.event.wizard.form</field>
        <field name="model">create.nostr.event.wizard</field>
        <field name="arch" type="xml">
            <form string="Create Nostr Event">
                <group>
                    <field name="repository_id"/>
                    <field name="event_type"/>
                    <field name="commit_message" attrs="{'invisible': [('event_type', '!=', 'commit')], 'required': [('event_type', '=', 'commit')]}"/>
                    <field name="branch_name" attrs="{'invisible': [('event_type', '!=', 'branch')], 'required': [('event_type', '=', 'branch')]}"/>
                    <field name="file_name" attrs="{'invisible': [('event_type', '!=', 'blob')], 'required': [('event_type', '=', 'blob')]}"/>
                    <field name="file_content" attrs="{'invisible': [('event_type', '!=', 'blob')], 'required': [('event_type', '=', 'blob')]}" widget="ace" options="{'mode': 'xml'}"/>
                </group>
                <footer>
                    <button name="action_create_event" string="Create Event" type="object" class="btn-primary"/>
                    <button string="Cancel" class="btn-secondary" special="cancel"/>
                </footer>
            </form>
        </field>
    </record>

    <record id="action_create_nostr_event_wizard" model="ir.actions.act_window">
        <field name="name">Create Nostr Event</field>
        <field name="res_model">create.nostr.event.wizard</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/custom_thunderbird_mail/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_git_repository,access_git_repository,model_git_repository,base.group_user,1,1,1,1
access_nostr_event,access_nostr_event,model_nostr_event,base.group_user,1,1,1,1
access_create_nostr_event_wizard,access_create_nostr_event_wizard,model_create_nostr_event_wizard,base.group_user,1,1,1,0
=== ./odoo_custom_addons (copy)/custom_thunderbird_mail/views/res_users_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_users_form_inherit_git_nostr" model="ir.ui.view">
        <field name="name">res.users.form.inherit.git.nostr</field>
        <field name="model">res.users</field>
        <field name="inherit_id" ref="base.view_users_form"/>
        <field name="arch" type="xml">
            <notebook position="inside">
                <page string="Nostr Settings" name="nostr_settings">
                    <group>
                        <field name="nostr_private_key" password="True"/>
                        <field name="nostr_public_key"/>
                    </group>
                </page>
            </notebook>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/custom_thunderbird_mail/views/res_config_settings_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="res_config_settings_view_form" model="ir.ui.view">
        <field name="name">res.config.settings.view.form.inherit.git_nostr_bridge</field>
        <field name="model">res.config.settings</field>
        <field name="inherit_id" ref="base.res_config_settings_view_form"/>
        <field name="arch" type="xml">
            <xpath expr="//div[hasclass('settings')]" position="inside">
                <div class="app_settings_block" data-string="Git-Nostr Bridge" string="Git-Nostr Bridge" data-key="git_nostr_bridge">
                    <h2>Nostr Settings</h2>
                    <div class="row mt16 o_settings_container">
                        <div class="col-12 col-lg-6 o_setting_box">
                            <div class="o_setting_left_pane"/>
                            <div class="o_setting_right_pane">
                                <span class="o_form_label">Nostr Relay URLs</span>
                                <div class="text-muted">
                                    Comma-separated list of Nostr relay URLs
                                </div>
                                <div class="content-group">
                                    <div class="mt16">
                                        <field name="git_nostr_relay_urls"/>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </xpath>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/custom_thunderbird_mail/views/nostr_event_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_nostr_event_form" model="ir.ui.view">
        <field name="name">nostr.event.form</field>
        <field name="model">nostr.event</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="action_publish" string="Publish" type="object" class="oe_highlight" attrs="{'invisible': [('published', '=', True)]}"/>
                </header>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="event_type"/>
                        <field name="content"/>
                        <field name="tags"/>
                        <field name="published"/>
                        <field name="event_id"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_nostr_event_form_git_nostr" model="ir.ui.view">
        <field name="name">nostr.event.form.git.nostr</field>
        <field name="model">nostr.event</field>
        <field name="inherit_id" ref="integrated_ivcs.view_nostr_event_form"/>
        <field name="arch" type="xml">
            <xpath expr="//field[@name='event_type']" position="after">
                <field name="repository_id" attrs="{'invisible': [('event_type', 'not in', ['repo_anchor', 'branch', 'commit', 'tree', 'blob'])]}"/>
            </xpath>
        </field>
    </record>

    <record id="action_nostr_event" model="ir.actions.act_window">
        <field name="name">Nostr Events</field>
        <field name="res_model">nostr.event</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_nostr_event_git" name="Git Nostr Events" parent="menu_git_nostr_bridge" action="integrated_ivcs.action_nostr_event" sequence="20"/>
</odoo>
=== ./odoo_custom_addons (copy)/custom_thunderbird_mail/views/git_repository_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_repository_form" model="ir.ui.view">
        <field name="name">git.repository.form</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="action_pull" string="Pull" type="object" class="oe_highlight"/>
                    <button name="action_push" string="Push" type="object" class="oe_highlight"/>
                    <button name="action_commit" string="Commit" type="object" class="oe_highlight"/>
                </header>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="path"/>
                        <field name="remote_url"/>
                        <field name="branch"/>
                        <field name="last_commit"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="action_git_repository" model="ir.actions.act_window">
        <field name="name">Git Repositories</field>
        <field name="res_model">git.repository</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_git_nostr_bridge" name="Git-Nostr Bridge" sequence="10"/>
    <menuitem id="menu_git_repository" name="Git Repositories" parent="menu_git_nostr_bridge" action="action_git_repository" sequence="10"/>
</odoo>
=== ./odoo_custom_addons (copy)/git_nostr_bridge/models/git_repository.py ===
# models/git_repository.py
import os
import git
from odoo import models, fields, api, _
from odoo.exceptions import UserError

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Name', required=True)
    path = fields.Char(string='Local Path', required=True)
    remote_url = fields.Char(string='Remote URL')
    branch = fields.Char(string='Current Branch', default='main')
    last_commit = fields.Char(string='Last Commit', readonly=True)

    @api.model
    def create(self, vals):
        repo = super(GitRepository, self).create(vals)
        repo._initialize_repository()
        return repo

    def _initialize_repository(self):
        if not os.path.exists(self.path):
            os.makedirs(self.path)
            repo = git.Repo.init(self.path)
            if self.remote_url:
                repo.create_remote('origin', self.remote_url)
            open(os.path.join(self.path, 'README.md'), 'w').close()
            repo.index.add(['README.md'])
            repo.index.commit('Initial commit')
            self.last_commit = repo.head.commit.hexsha

    def action_pull(self):
        repo = git.Repo(self.path)
        origin = repo.remotes.origin
        origin.pull()
        self.last_commit = repo.head.commit.hexsha

    def action_push(self):
        repo = git.Repo(self.path)
        origin = repo.remotes.origin
        origin.push()

    def action_commit(self):
        return {
            'name': _('Create Commit'),
            'type': 'ir.actions.act_window',
            'res_model': 'create.nostr.event.wizard',
            'view_mode': 'form',
            'target': 'new',
            'context': {'default_repository_id': self.id, 'default_event_type': 'commit'},
        }
=== ./odoo_custom_addons (copy)/git_nostr_bridge/models/__init__.py ===
from . import git_repository
from . import nostr_event
from . import res_config_settings
=== ./odoo_custom_addons (copy)/git_nostr_bridge/models/res_users.py ===
from odoo import models, fields, api
from nostr.key import PrivateKey

class ResUsers(models.Model):
    _inherit = 'res.users'

    nostr_public_key = fields.Char(string="Nostr Public Key")
    nostr_private_key = fields.Char(string="Nostr Private Key")
    nostr_relay_url = fields.Char(string="Nostr Relay URL")

    @api.depends('nostr_private_key')
    def _compute_public_key(self):
        for user in self:
            if user.nostr_private_key:
                try:
                    private_key = PrivateKey.from_nsec(user.nostr_private_key)
                    user.nostr_public_key = private_key.public_key.hex()
                except Exception:
                    user.nostr_public_key = False
            else:
                user.nostr_public_key = False

    @api.model
    def create(self, vals):
        if 'nostr_private_key' not in vals or not vals['nostr_private_key']:
            private_key = PrivateKey()
            vals['nostr_private_key'] = private_key.bech32()
        return super(ResUsers, self).create(vals)
=== ./odoo_custom_addons (copy)/git_nostr_bridge/models/nostr_event.py ===
# File: /opt/odoo/custom_addons/git_nostr_bridge/models/nostr_event.py

import asyncio
import json
import logging
import websockets
from urllib.parse import urlparse
import time
import traceback

from odoo import models, fields, api, _
from odoo.exceptions import UserError
from nostr.event import Event as NostrLibEvent
from nostr.key import PrivateKey

_logger = logging.getLogger(__name__)

class NostrEvent(models.Model):
    _name = 'nostr.event'
    _description = 'Nostr Event'
    _inherit = 'nostr.event'

    name = fields.Char(string='Name', required=True)
    event_type = fields.Selection([
        ('repo_anchor', 'Repository Anchor'),
        ('branch', 'Branch'),
        ('commit', 'Commit'),
        ('tree', 'Tree'),
        ('blob', 'Blob'),
    ], string='Event Type', required=True)
    content = fields.Text(string='Content')
    tags = fields.Text(string='Tags')
    published = fields.Boolean(string='Published', default=False)
    event_id = fields.Char(string='Event ID', readonly=True)
    kind = fields.Integer(string='Nostr Event Kind', default=1)
    repository_id = fields.Many2one('git.repository', string='Related Repository')
    signature = fields.Char(string='Signature', readonly=True)
    public_key = fields.Char(string='Public Key', readonly=True)
    created_at = fields.Integer(string='Created At', readonly=True)

    @api.model
    def create(self, vals):
        record = super(NostrEvent, self).create(vals)
        record.generate_event_details()
        return record

    def generate_event_details(self):
        if not self.event_id or not self.signature:
            try:
                private_key = PrivateKey()
                public_key = private_key.public_key.hex()
                
                event = NostrLibEvent(
                    kind=self.kind,
                    content=self.content or '',
                    tags=json.loads(self.tags) if self.tags else [],
                    public_key=public_key,
                    created_at=int(time.time())
                )
                
                private_key.sign_event(event)
                
                self.write({
                    'event_id': event.id,
                    'signature': event.signature,
                    'public_key': public_key,
                    'created_at': event.created_at
                })
            except Exception as e:
                _logger.error(f"Error generating Nostr event details: {str(e)}")
                # Not raising UserError here to avoid disrupting the creation process

    @api.model
    def action_publish(self, event_id):
        event = self.browse(event_id)
        _logger.info(f"Starting publish action for event: {event.name}")
        start_time = time.time()

        try:
            if not self.env.user.nostr_private_key:
                raise UserError(_("Nostr private key is not set for the current user."))

            _logger.info("Generating private key")
            try:
                private_key = PrivateKey.from_nsec(self.env.user.nostr_private_key)
                _logger.info("Private key generated successfully")
            except Exception as e:
                _logger.error(f"Failed to generate private key: {str(e)}")
                _logger.error(traceback.format_exc())
                raise UserError(_("Invalid Nostr private key: %s") % str(e))

            public_key = private_key.public_key.hex()
            _logger.info(f"Public key: {public_key}")

            _logger.info("Parsing tags")
            try:
                tags = json.loads(event.tags) if event.tags else []
                _logger.info(f"Parsed tags: {tags}")
                if not isinstance(tags, list):
                    raise ValueError("Tags must be a list of lists")
                for tag in tags:
                    if not isinstance(tag, list):
                        raise ValueError("Each tag must be a list")
            except json.JSONDecodeError as e:
                _logger.error(f"JSON decode error: {str(e)}")
                _logger.error(traceback.format_exc())
                raise UserError(_("Invalid tags format. Please ensure tags are in valid JSON format."))
            except ValueError as e:
                _logger.error(f"Value error: {str(e)}")
                _logger.error(traceback.format_exc())
                raise UserError(_("Invalid tags format: %s") % str(e))

            _logger.info("Creating Nostr event")
            nostr_event = NostrLibEvent(
                kind=1,  # Assuming TEXT_NOTE, adjust if needed
                content=str(event.content),
                tags=tags,
                public_key=public_key  # Ensure public_key is provided
            )
            private_key.sign_event(nostr_event)
            _logger.info(f"Event created: {nostr_event.to_message()}")

            _logger.info("Fetching relay URLs")
            relay_urls = self.env['ir.config_parameter'].sudo().get_param('git_nostr_bridge.relay_urls', '').split(',')
            relay_urls = [url.strip() for url in relay_urls if url.strip()][:5]  # Limit to 5 relays
            _logger.info(f"Relay URLs: {relay_urls}")

            if not relay_urls:
                raise UserError(_("No Nostr relay URLs configured. Please set them in the settings."))

            _logger.info("Validating relay URLs")
            for url in relay_urls:
                parsed = urlparse(url)
                if parsed.scheme not in ('ws', 'wss'):
                    _logger.error(f"Invalid relay URL: {url}")
                    raise UserError(_("Invalid relay URL: %s. Must start with ws:// or wss://") % url)

            async def publish_to_relay(relay_url, nostr_event, retries=3):
                for attempt in range(retries):
                    try:
                        _logger.info(f"Attempting to connect to {relay_url} (attempt {attempt + 1})")
                        connection_start = time.time()
                        async with websockets.connect(relay_url, timeout=30) as websocket:
                            connection_end = time.time()
                            _logger.info(f"Connected to {relay_url} in {connection_end - connection_start:.2f} seconds")
                            
                            message = nostr_event.to_message()
                            _logger.debug(f"Raw event message: {message}")
                            
                            _logger.info(f"Sending Nostr event to {relay_url}: {message}")
                            
                            send_start = time.time()
                            await websocket.send(message)
                            send_end = time.time()
                            _logger.info(f"Sent message to {relay_url} in {send_end - send_start:.2f} seconds")
                            
                            _logger.info(f"Waiting for response from {relay_url}")
                            response_start = time.time()
                            response = await asyncio.wait_for(websocket.recv(), timeout=10.0)
                            response_end = time.time()
                            _logger.info(f"Received response from {relay_url} in {response_end - response_start:.2f} seconds: {response}")
                            
                            try:
                                return json.loads(response)
                            except json.JSONDecodeError as e:
                                _logger.error(f"Failed to parse response from {relay_url}: {str(e)}")
                                return f"Invalid response from {relay_url}: {response}"
                    except (websockets.exceptions.WebSocketException, asyncio.TimeoutError) as e:
                        _logger.error(f"Error publishing to {relay_url} (attempt {attempt + 1}): {str(e)}")
                        _logger.error(traceback.format_exc())
                        await asyncio.sleep(5 * (attempt + 1))  # Increased delay between attempts
                return f"Failed to publish to {relay_url} after {retries} attempts"

            async def publish_with_timeout():
                tasks = [publish_to_relay(url, nostr_event) for url in relay_urls]
                return await asyncio.gather(*tasks, return_exceptions=True)

            async def run_publication():
                _logger.info("Starting publication process")
                try:
                    results = await asyncio.wait_for(publish_with_timeout(), timeout=120)  # Increased overall timeout
                    _logger.info(f"Publication results: {results}")
                    return results
                except asyncio.TimeoutError:
                    _logger.error("Publication process timed out after 120 seconds")
                    raise UserError(_("Publishing timed out after 120 seconds"))

            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            try:
                results = loop.run_until_complete(run_publication())
            finally:
                loop.close()

            success = any(isinstance(result, list) and result[0] == "OK" for result in results)
            if success:
                event.write({
                    'published': True,
                    'event_id': nostr_event.id
                })
                _logger.info(f"Successfully published Nostr event: {nostr_event.id}")
                
                # Verify event publication
                self.verify_event_publication(nostr_event.id, relay_urls)
                
                end_time = time.time()
                _logger.info(f"Total publish action time: {end_time - start_time:.2f} seconds")
                
                return {
                    'type': 'ir.actions.client',
                    'tag': 'display_notification',
                    'params': {
                        'message': _("Nostr event successfully published to at least one relay."),
                        'type': 'success',
                        'sticky': False,
                    }
                }
            else:
                error_messages = [str(result) for result in results if isinstance(result, str)]
                _logger.error(f"Failed to publish Nostr event: {'; '.join(error_messages)}")
                raise UserError(_("Failed to publish Nostr event: %s") % "; ".join(error_messages))

        except Exception as e:
            _logger.error(f"Unexpected error in action_publish: {str(e)}")
            _logger.error(traceback.format_exc())
            raise UserError(_("An unexpected error occurred: %s") % str(e))

    @api.model
    def verify_event_publication(self, event_id, relay_urls, max_attempts=5, delay=2):
        _logger.info(f"Starting verification for event: {event_id}")
        for attempt in range(max_attempts):
            _logger.info(f"Verification attempt {attempt + 1}")
            for url in relay_urls:
                try:
                    loop = asyncio.new_event_loop()
                    asyncio.set_event_loop(loop)
                    result = loop.run_until_complete(self.query_event(url, event_id))
                    if result:
                        _logger.info(f"Event {event_id} found on relay {url}")
                        return True
                except Exception as e:
                    _logger.error(f"Error querying event from {url}: {str(e)}")
                    _logger.error(traceback.format_exc())
                finally:
                    loop.close()
            _logger.info(f"Waiting {delay} seconds before next attempt")
            time.sleep(delay)
        _logger.warning(f"Event {event_id} not found on any relay after {max_attempts} attempts")
        return False

    async def query_event(self, relay_url, event_id):
        _logger.info(f"Querying event {event_id} from {relay_url}")
        start_time = time.time()
        try:
            async with websockets.connect(relay_url, timeout=10) as websocket:
                request = json.dumps(["REQ", "query", {"ids": [event_id]}])
                _logger.info(f"Sending query to {relay_url}: {request}")
                await websocket.send(request)
                response = await asyncio.wait_for(websocket.recv(), timeout=5.0)
                _logger.info(f"Response from {relay_url}: {response}")
                end_time = time.time()
                _logger.info(f"Query to {relay_url} took {end_time - start_time:.2f} seconds")
                return json.loads(response)
        except Exception as e:
            _logger.error(f"Error querying {relay_url}: {str(e)}")
            _logger.error(traceback.format_exc())
            end_time = time.time()
            _logger.info(f"Failed query to {relay_url} took {end_time - start_time:.2f} seconds")
            return None
=== ./odoo_custom_addons (copy)/git_nostr_bridge/models/res_config_settings.py ===
import requests
import json
from odoo import fields, models, api
import logging

_logger = logging.getLogger(__name__)

class ResConfigSettings(models.TransientModel):
    _inherit = 'res.config.settings'

    git_nostr_relay_urls = fields.Char(
        string="Nostr Relay URLs", 
        config_parameter='git_nostr_bridge.relay_urls',
        default=lambda self: self._default_nostr_relays()
    )

    def _default_nostr_relays(self):
        return self._get_top_nostr_relays()

    @api.model
    def _get_top_nostr_relays(self, limit=108):
        url = "https://api.nostr.watch/v1/online"
        try:
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
            }
            response = requests.get(url, headers=headers, timeout=10)
            response.raise_for_status()
            _logger.info(f"Response status code: {response.status_code}")
            
            data = response.json()
            _logger.info(f"API response (first 108 items): {data[:108]}")
            
            relays = data[:108]
            _logger.info(f"Number of relay links found: {len(relays)}")
            _logger.info(f"Extracted relays (first 5): {relays[:5]}")
            
            relay_urls = ",".join(relays)
            return relay_urls
        except requests.RequestException as e:
            _logger.error(f"Error fetching Nostr relays: {e}")
            return "wss://nostr-relay.app,wss://nos.lol,wss://relay.snort.social,wss://relay.nostr.net"

    nostr_relay_urls = fields.Char(
        string="Nostr Relay URLs", 
        config_parameter='nostr_bridge.relay_urls',
        default=_default_nostr_relays
    )

    @api.model
    def get_values(self):
        res = super(ResConfigSettings, self).get_values()
        ICPSudo = self.env['ir.config_parameter'].sudo()
        
        relay_urls = ICPSudo.get_param('git_nostr_bridge.relay_urls')
        if not relay_urls:
            relay_urls = self._default_nostr_relays()
            ICPSudo.set_param('git_nostr_bridge.relay_urls', relay_urls)
            _logger.info(f"Set new relay URLs: {relay_urls[:100]}...")
        else:
            _logger.info(f"Using existing relay URLs: {relay_urls[:100]}...")
        
        res.update(git_nostr_relay_urls=relay_urls)
        return res

    def set_values(self):
        super(ResConfigSettings, self).set_values()
        ICPSudo = self.env['ir.config_parameter'].sudo()
        if self.git_nostr_relay_urls:
            ICPSudo.set_param('git_nostr_bridge.relay_urls', self.git_nostr_relay_urls)
            _logger.info(f"Updated relay URLs: {self.git_nostr_relay_urls[:100]}...")
        else:
            default_urls = self._default_nostr_relays()
            ICPSudo.set_param('git_nostr_bridge.relay_urls', default_urls)
            _logger.info(f"Set default relay URLs: {default_urls[:100]}...")
=== ./odoo_custom_addons (copy)/git_nostr_bridge/models/git_repository ===
# models/git_repository.py
import os
import git
from odoo import models, fields, api, _
from odoo.exceptions import UserError

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Name', required=True)
    path = fields.Char(string='Local Path', required=True)
    remote_url = fields.Char(string='Remote URL')
    branch = fields.Char(string='Current Branch', default='main')
    last_commit = fields.Char(string='Last Commit', readonly=True)

    @api.model
    def create(self, vals):
        repo = super(GitRepository, self).create(vals)
        repo._initialize_repository()
        return repo

    def _initialize_repository(self):
        if not os.path.exists(self.path):
            os.makedirs(self.path)
            repo = git.Repo.init(self.path)
            if self.remote_url:
                repo.create_remote('origin', self.remote_url)
            open(os.path.join(self.path, 'README.md'), 'w').close()
            repo.index.add(['README.md'])
            repo.index.commit('Initial commit')
            self.last_commit = repo.head.commit.hexsha

    def action_pull(self):
        repo = git.Repo(self.path)
        origin = repo.remotes.origin
        origin.pull()
        self.last_commit = repo.head.commit.hexsha

    def action_push(self):
        repo = git.Repo(self.path)
        origin = repo.remotes.origin
        origin.push()

    def action_commit(self):
        return {
            'name': _('Create Commit'),
            'type': 'ir.actions.act_window',
            'res_model': 'create.nostr.event.wizard',
            'view_mode': 'form',
            'target': 'new',
            'context': {'default_repository_id': self.id, 'default_event_type': 'commit'},
        }
=== ./odoo_custom_addons (copy)/git_nostr_bridge/__init__.py ===
from . import models
from . import wizard
=== ./odoo_custom_addons (copy)/git_nostr_bridge/__manifest__.py ===
{
    'name': 'Git-Nostr Bridge',
    'version': '1.0',
    'category': 'Tools',
    'summary': 'Integrates Git repositories with Nostr network',
    'author': 'Your Name',
    'website': 'https://www.example.com',
    'depends': ['base', 'mail', 'nostr_auth', 'nostr_bridge', 'integrated_ivcs'],
    'data': [
        'security/ir.model.access.csv',
        'views/git_repository_views.xml',
        'views/nostr_event_views.xml',
        'views/res_config_settings_views.xml',
        'views/res_users_views.xml',
        'wizard/create_nostr_event_wizard_views.xml',
    ],
    'installable': True,
    'application': True,
    'auto_install': False,
    'external_dependencies': {
        'python': ['git', 'nostr', 'websockets'],
    },
}
=== ./odoo_custom_addons (copy)/git_nostr_bridge/wizard/create_nostr_event_wizard.py ===
# wizard/create_nostr_event_wizard.py
from odoo import models, fields, api
import git
import json

class CreateNostrEventWizard(models.TransientModel):
    _name = 'create.nostr.event.wizard'
    _description = 'Create Nostr Event Wizard'

    repository_id = fields.Many2one('git.repository', string='Repository', required=True)
    event_type = fields.Selection([
        ('repo_anchor', 'Repository Anchor'),
        ('branch', 'Branch'),
        ('commit', 'Commit'),
        ('tree', 'Tree'),
        ('blob', 'Blob'),
    ], string='Event Type', required=True)
    commit_message = fields.Text(string='Commit Message')
    branch_name = fields.Char(string='Branch Name')
    file_content = fields.Text(string='File Content')
    file_name = fields.Char(string='File Name')

    def action_create_event(self):
        repo = git.Repo(self.repository_id.path)
        
        if self.event_type == 'commit':
            # Stage all changes
            repo.git.add(A=True)
            # Commit changes
            commit = repo.index.commit(self.commit_message)
            self.repository_id.last_commit = commit.hexsha
            content = json.dumps({
                'type': 'commit',
                'repository': self.repository_id.name,
                'commit_hash': commit.hexsha,
                'message': self.commit_message,
            })
        elif self.event_type == 'branch':
            repo.git.checkout('-b', self.branch_name)
            self.repository_id.branch = self.branch_name
            content = json.dumps({
                'type': 'branch',
                'repository': self.repository_id.name,
                'branch_name': self.branch_name,
            })
        elif self.event_type == 'blob':
            with open(os.path.join(self.repository_id.path, self.file_name), 'w') as f:
                f.write(self.file_content)
            repo.index.add([self.file_name])
            commit = repo.index.commit(f"Add file: {self.file_name}")
            self.repository_id.last_commit = commit.hexsha
            content = json.dumps({
                'type': 'blob',
                'repository': self.repository_id.name,
                'file_name': self.file_name,
                'commit_hash': commit.hexsha,
            })
        
        self.env['nostr.event'].create({
            'name': f"{self.event_type.capitalize()} - {self.repository_id.name}",
            'event_type': self.event_type,
            'content': content,
            'tags': json.dumps([['r', self.repository_id.remote_url]]),
        })

        return {'type': 'ir.actions.act_window_close'}
=== ./odoo_custom_addons (copy)/git_nostr_bridge/wizard/__init__.py ===
# wizard/__init__.py
from . import create_nostr_event_wizard
=== ./odoo_custom_addons (copy)/git_nostr_bridge/wizard/create_nostr_event_wizard_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_create_nostr_event_wizard_form" model="ir.ui.view">
        <field name="name">create.nostr.event.wizard.form</field>
        <field name="model">create.nostr.event.wizard</field>
        <field name="arch" type="xml">
            <form string="Create Nostr Event">
                <group>
                    <field name="repository_id"/>
                    <field name="event_type"/>
                    <field name="commit_message" attrs="{'invisible': [('event_type', '!=', 'commit')], 'required': [('event_type', '=', 'commit')]}"/>
                    <field name="branch_name" attrs="{'invisible': [('event_type', '!=', 'branch')], 'required': [('event_type', '=', 'branch')]}"/>
                    <field name="file_name" attrs="{'invisible': [('event_type', '!=', 'blob')], 'required': [('event_type', '=', 'blob')]}"/>
                    <field name="file_content" attrs="{'invisible': [('event_type', '!=', 'blob')], 'required': [('event_type', '=', 'blob')]}" widget="ace" options="{'mode': 'xml'}"/>
                </group>
                <footer>
                    <button name="action_create_event" string="Create Event" type="object" class="btn-primary"/>
                    <button string="Cancel" class="btn-secondary" special="cancel"/>
                </footer>
            </form>
        </field>
    </record>

    <record id="action_create_nostr_event_wizard" model="ir.actions.act_window">
        <field name="name">Create Nostr Event</field>
        <field name="res_model">create.nostr.event.wizard</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/git_nostr_bridge/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_git_repository,access_git_repository,model_git_repository,base.group_user,1,1,1,1
access_nostr_event,access_nostr_event,model_nostr_event,base.group_user,1,1,1,1
access_create_nostr_event_wizard,access_create_nostr_event_wizard,model_create_nostr_event_wizard,base.group_user,1,1,1,0
=== ./odoo_custom_addons (copy)/git_nostr_bridge/views/res_users_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_users_form_inherit_git_nostr" model="ir.ui.view">
        <field name="name">res.users.form.inherit.git.nostr</field>
        <field name="model">res.users</field>
        <field name="inherit_id" ref="base.view_users_form"/>
        <field name="arch" type="xml">
            <notebook position="inside">
                <page string="Nostr Settings" name="nostr_settings">
                    <group>
                        <field name="nostr_private_key" password="True"/>
                        <field name="nostr_public_key"/>
                    </group>
                </page>
            </notebook>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/git_nostr_bridge/views/res_config_settings_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="res_config_settings_view_form" model="ir.ui.view">
        <field name="name">res.config.settings.view.form.inherit.git_nostr_bridge</field>
        <field name="model">res.config.settings</field>
        <field name="inherit_id" ref="base.res_config_settings_view_form"/>
        <field name="arch" type="xml">
            <xpath expr="//div[hasclass('settings')]" position="inside">
                <div class="app_settings_block" data-string="Git-Nostr Bridge" string="Git-Nostr Bridge" data-key="git_nostr_bridge">
                    <h2>Nostr Settings</h2>
                    <div class="row mt16 o_settings_container">
                        <div class="col-12 col-lg-6 o_setting_box">
                            <div class="o_setting_left_pane"/>
                            <div class="o_setting_right_pane">
                                <span class="o_form_label">Nostr Relay URLs</span>
                                <div class="text-muted">
                                    Comma-separated list of Nostr relay URLs
                                </div>
                                <div class="content-group">
                                    <div class="mt16">
                                        <field name="git_nostr_relay_urls"/>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </xpath>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/git_nostr_bridge/views/nostr_event_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_nostr_event_form" model="ir.ui.view">
        <field name="name">nostr.event.form</field>
        <field name="model">nostr.event</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="action_publish" string="Publish" type="object" class="oe_highlight" attrs="{'invisible': [('published', '=', True)]}"/>
                </header>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="event_type"/>
                        <field name="content"/>
                        <field name="tags"/>
                        <field name="published"/>
                        <field name="event_id"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_nostr_event_form_git_nostr" model="ir.ui.view">
        <field name="name">nostr.event.form.git.nostr</field>
        <field name="model">nostr.event</field>
        <field name="inherit_id" ref="integrated_ivcs.view_nostr_event_form"/>
        <field name="arch" type="xml">
            <xpath expr="//field[@name='event_type']" position="after">
                <field name="repository_id" attrs="{'invisible': [('event_type', 'not in', ['repo_anchor', 'branch', 'commit', 'tree', 'blob'])]}"/>
            </xpath>
        </field>
    </record>

    <record id="action_nostr_event" model="ir.actions.act_window">
        <field name="name">Nostr Events</field>
        <field name="res_model">nostr.event</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_nostr_event_git" name="Git Nostr Events" parent="menu_git_nostr_bridge" action="integrated_ivcs.action_nostr_event" sequence="20"/>
</odoo>
=== ./odoo_custom_addons (copy)/git_nostr_bridge/views/git_repository_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_repository_form" model="ir.ui.view">
        <field name="name">git.repository.form</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="action_pull" string="Pull" type="object" class="oe_highlight"/>
                    <button name="action_push" string="Push" type="object" class="oe_highlight"/>
                    <button name="action_commit" string="Commit" type="object" class="oe_highlight"/>
                </header>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="path"/>
                        <field name="remote_url"/>
                        <field name="branch"/>
                        <field name="last_commit"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="action_git_repository" model="ir.actions.act_window">
        <field name="name">Git Repositories</field>
        <field name="res_model">git.repository</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_git_nostr_bridge" name="Git-Nostr Bridge" sequence="10"/>
    <menuitem id="menu_git_repository" name="Git Repositories" parent="menu_git_nostr_bridge" action="action_git_repository" sequence="10"/>
</odoo>
=== ./odoo_custom_addons (copy)/custom_auth/models/res_users.py ===
from odoo import models, api
from odoo.exceptions import AccessDenied
import requests

class ResUsers(models.Model):
    _inherit = 'res.users'

    @classmethod
    def _login(cls, db, login, password):
        if not cls.validate_external_auth(login, password):
            raise AccessDenied()
        return super(ResUsers, cls)._login(db, login, password)

    @classmethod
    def validate_external_auth(cls, login, token):
        # Replace with your actual localhost API endpoint
        validation_url = 'http://localhost/validate_admin'
        response = requests.post(validation_url, json={'login': login, 'token': token})
        return response.status_code == 200 and response.json().get('is_admin', False)
=== ./odoo_custom_addons (copy)/custom_auth/__manifest__.py ===
{
    'name': 'Custom External Authentication',
    'version': '1.0',
    'category': 'Hidden',
    'summary': 'Custom authentication for external admin access',
    'depends': ['base'],
    'data': [],
    'installable': True,
}
=== ./odoo_custom_addons (copy)/opinion_reputation_nostr/models/__init__.py ===
from . import opinion_reputation
from . import nostr_event
=== ./odoo_custom_addons (copy)/opinion_reputation_nostr/models/nostr_event.py ===
from odoo import models, api, _
from odoo.exceptions import UserError
import json
import logging

_logger = logging.getLogger(__name__)

class NostrEvent(models.AbstractModel):
    _name = 'opinion.nostr.event'
    _description = 'Nostr Event for Opinion Reputation'

    @api.model
    def create_prediction_event(self, prediction):
        content = json.dumps({
            'question_id': prediction.question_id.id,
            'question_text': prediction.question_id.text,
            'answer': prediction.answer,
            'confidence': prediction.confidence
        })
        
        try:
            nostr_event = self.env['nostr.event']
            event = nostr_event.create_event(
                kind=1,  # You might want to use a custom event kind for predictions
                content=content,
                tags=[['p', prediction.user_id.nostr_public_key]],
                private_key=prediction.user_id.nostr_private_key
            )
            
            nostr_event.publish_event(event)
            _logger.info(f"Nostr event created and published for prediction {prediction.id}")
        except AttributeError:
            _logger.warning("Nostr bridge not available. Prediction event not published to Nostr.")
        except Exception as e:
            _logger.error(f"Error creating Nostr event: {str(e)}")
            raise UserError(_("Failed to create Nostr event: %s") % str(e))
=== ./odoo_custom_addons (copy)/opinion_reputation_nostr/models/opinion_reputation.py ===
from odoo import models, fields, api
from odoo.exceptions import UserError
import enum
import logging

_logger = logging.getLogger(__name__)

class AnswerChoice(enum.Enum):
    AGREE = "I Agree"
    DO_NOT_DISAGREE = "I do not disagree"
    DO_NOT_AGREE = "I do not agree"
    DISAGREE = "I Disagree"

class User(models.Model):
    _inherit = 'res.users'

    reputation = fields.Float(default=0)

class Question(models.Model):
    _name = 'opinion.question'
    _description = 'Opinion Question'

    text = fields.Text(required=True)
    explanation = fields.Text()
    created_by = fields.Many2one('res.users', string='Created By')
    created_at = fields.Datetime(default=fields.Datetime.now)
    is_settled = fields.Boolean(default=False)
    last_revisited = fields.Datetime()

class Prediction(models.Model):
    _name = 'opinion.prediction'
    _description = 'Opinion Prediction'

    user_id = fields.Many2one('res.users', required=True)
    question_id = fields.Many2one('opinion.question', required=True)
    answer = fields.Selection([
        ('AGREE', 'I Agree'),
        ('DO_NOT_DISAGREE', 'I do not disagree'),
        ('DO_NOT_AGREE', 'I do not agree'),
        ('DISAGREE', 'I Disagree')
    ], required=True)
    confidence = fields.Float(required=True)
    timestamp = fields.Datetime(default=fields.Datetime.now)
    is_correct = fields.Boolean()

    @api.model
    def create(self, vals):
        prediction = super(Prediction, self).create(vals)
        try:
            self.env['opinion.nostr.event'].create_prediction_event(prediction)
        except Exception as e:
            _logger.error(f"Failed to create Nostr event for prediction {prediction.id}: {str(e)}")
        self.update_reputation(prediction.user_id.id)
        return prediction

    def update_reputation(self, user_id):
        user = self.env['res.users'].browse(user_id)
        predictions = self.search([('user_id', '=', user_id)])
        correct_predictions = predictions.filtered(lambda p: p.is_correct)
        if predictions:
            user.reputation = (len(correct_predictions) / len(predictions)) * 100

class OpinionReputationSystem(models.AbstractModel):
    _name = 'opinion.reputation.system'
    _description = 'Opinion Reputation System'

    @api.model
    def revisit_question(self, question_id):
        question = self.env['opinion.question'].browse(question_id)
        if (fields.Datetime.now() - question.created_at).days >= 4*365:
            predictions = self.env['opinion.prediction'].search([('question_id', '=', question_id)])
            total_votes = len(predictions)
            if total_votes > 0:
                agreement_ratio = len(predictions.filtered(lambda p: p.answer in ['AGREE', 'DO_NOT_DISAGREE'])) / total_votes
                question.write({
                    'is_settled': agreement_ratio >= 0.8333334,
                    'last_revisited': fields.Datetime.now()
                })

    @api.model
    def explain_answer_choices(self):
        return """
        Answer choices explanation:
        1. I Agree: You fully support and believe in the statement.
        2. I do not disagree: You somewhat agree or have no strong objection to the statement.
        3. I do not agree: You somewhat disagree or have some reservations about the statement.
        4. I Disagree: You fully oppose or do not believe in the statement.
        """
=== ./odoo_custom_addons (copy)/opinion_reputation_nostr/__init__.py ===
from . import models
=== ./odoo_custom_addons (copy)/opinion_reputation_nostr/__manifest__.py ===
{
    'name': 'Opinion Reputation with Nostr',
    'version': '1.0',
    'category': 'Tools',
    'summary': 'Opinion Reputation System with optional Nostr integration',
    'depends': ['base'],
    'data': [
        'security/ir.model.access.csv',
        'views/opinion_reputation_views.xml',
        'data/default_questions.xml',
    ],
    'installable': True,
    'application': True,
}
=== ./odoo_custom_addons (copy)/opinion_reputation_nostr/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_opinion_question,access_opinion_question,model_opinion_question,base.group_user,1,1,1,1
access_opinion_prediction,access_opinion_prediction,model_opinion_prediction,base.group_user,1,1,1,1
access_opinion_nostr_event,access_opinion_nostr_event,model_opinion_nostr_event,base.group_user,1,1,1,1
=== ./odoo_custom_addons (copy)/opinion_reputation_nostr/data/default_questions.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <!-- Add your default questions here -->
        <record id="question_1" model="opinion.question">
            <field name="text">Do life's challenges sometimes lead to self-doubt?</field>
            <field name="explanation">Sometimes when things get tough, we might wonder if we're good enough or if we can handle it.</field>
        </record>
        <!-- Add more questions as needed -->
    </data>
</odoo>
=== ./odoo_custom_addons (copy)/opinion_reputation_nostr/views/opinion_reputation_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_question_form" model="ir.ui.view">
        <field name="name">opinion.question.form</field>
        <field name="model">opinion.question</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="text"/>
                        <field name="explanation"/>
                        <field name="created_by"/>
                        <field name="created_at"/>
                        <field name="is_settled"/>
                        <field name="last_revisited"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_prediction_form" model="ir.ui.view">
        <field name="name">opinion.prediction.form</field>
        <field name="model">opinion.prediction</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="user_id"/>
                        <field name="question_id"/>
                        <field name="answer"/>
                        <field name="confidence"/>
                        <field name="timestamp"/>
                        <field name="is_correct"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="action_questions" model="ir.actions.act_window">
        <field name="name">Questions</field>
        <field name="res_model">opinion.question</field>
        <field name="view_mode">tree,form</field>
    </record>

    <record id="action_predictions" model="ir.actions.act_window">
        <field name="name">Predictions</field>
        <field name="res_model">opinion.prediction</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_opinion_reputation" name="Opinion Reputation"/>
    <menuitem id="menu_questions" parent="menu_opinion_reputation" action="action_questions"/>
    <menuitem id="menu_predictions" parent="menu_opinion_reputation" action="action_predictions"/>
</odoo>
=== ./odoo_custom_addons (copy)/integrated_ivcs/models/git_repository.py ===
from odoo import models, fields, api
import git
import os

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Repository Name', required=True)
    path = fields.Char(string='Repository Path', required=True)
    
    @api.model
    def create(self, vals):
        repo = super(GitRepository, self).create(vals)
        if not os.path.exists(repo.path):
            os.makedirs(repo.path)
            git.Repo.init(repo.path)
        return repo

    def commit_changes(self, message):
        repo = git.Repo(self.path)
        repo.git.add(A=True)
        commit = repo.index.commit(message)
        
        self.env['nostr.event'].create_git_event(self.path, commit.hexsha)
        
        return commit.hexsha
=== ./odoo_custom_addons (copy)/integrated_ivcs/models/__init__.py ===
from . import ivcs_item
from . import ivcs_version
from . import ivcs_commit
from . import git_repository
from . import nostr_event
from . import branch_manager
from . import res_config_settings
=== ./odoo_custom_addons (copy)/integrated_ivcs/models/ivcs_version.py ===
from odoo import models, fields, api

class IVCSVersion(models.Model):
    _name = 'ivcs.version'
    _description = 'IVCS Version'

    name = fields.Char(string='Version Name', required=True)
    description = fields.Text(string='Description')
    item_id = fields.Many2one('ivcs.item', string='IVCS Item', required=True, ondelete='cascade')
    commit_id = fields.Many2one('ivcs.commit', string='Associated Commit')
    create_date = fields.Datetime(string='Created On', readonly=True, default=fields.Datetime.now)

    @api.model
    def create(self, vals):
        version = super(IVCSVersion, self).create(vals)
        if not version.item_id.current_version_id:
            version.item_id.current_version_id = version.id
        return version

    def name_get(self):
        result = []
        for version in self:
            name = f"{version.item_id.name} - {version.name}"
            result.append((version.id, name))
        return result
=== ./odoo_custom_addons (copy)/integrated_ivcs/models/nostr_event.py ===
from odoo import models, fields, api, _
from odoo.exceptions import UserError
from nostr.event import Event
from nostr.key import PrivateKey
import json
import logging
import time
import git

_logger = logging.getLogger(__name__)

class NostrEvent(models.Model):
    _name = 'nostr.event'
    _description = 'Nostr Event'

    event_id = fields.Char(string='Event ID', required=True)
    kind = fields.Integer(string='Event Kind', required=True)
    content = fields.Text(string='Content', required=True)
    tags = fields.Text(string='Tags')
    public_key = fields.Char(string='Public Key')
    created_at = fields.Integer(string='Created At', required=True)
    signature = fields.Char(string='Signature', required=True)
    published = fields.Boolean(string='Published', default=False)
    name = fields.Char(string='Name')
    event_type = fields.Selection([
        ('repo_anchor', 'Repository Anchor'),
        ('branch', 'Branch'),
        ('commit', 'Commit'),
        ('tree', 'Tree'),
        ('blob', 'Blob'),
    ], string='Event Type')

    def create_and_publish(self, event):
        vals = {
            'event_id': event.id,
            'kind': event.kind,
            'content': event.content,
            'tags': json.dumps(event.tags),
            'public_key': event.public_key,
            'created_at': event.created_at,
            'signature': event.signature,
        }
        nostr_event = self.create(vals)
        nostr_event.publish_event()
        return nostr_event

    def publish_event(self):
        self.ensure_one()
        relay_urls = self.env['ir.config_parameter'].sudo().get_param('integrated_ivcs.relay_urls', '').split(',')
        
        event_data = {
            'id': self.event_id,
            'kind': self.kind,
            'created_at': self.created_at,
            'tags': json.loads(self.tags),
            'content': self.content,
            'pubkey': self.public_key,
            'sig': self.signature,
        }

        for url in relay_urls:
            try:
                # Here you would typically use a Nostr client library to publish the event
                # For simplicity, we'll just log the action
                _logger.info(f"Publishing event {self.event_id} to relay: {url}")
                # Example: nostr_client.publish_event(url, event_data)
                self.published = True
            except Exception as e:
                _logger.error(f"Failed to publish event to {url}: {str(e)}")

    @api.model
    def create_git_event(self, repo_path, commit_hash):
        repo = git.Repo(repo_path)
        commit = repo.commit(commit_hash)
        
        content = json.dumps({
            "action": "commit",
            "message": commit.message,
            "author": commit.author.name,
            "email": commit.author.email,
            "date": commit.authored_datetime.isoformat(),
            "hash": commit_hash,
            "parent_hashes": [c.hexsha for c in commit.parents],
            "tree_hash": commit.tree.hexsha,
        })
        
        event = Event(
            kind=3121,
            content=content,
            tags=[
                ["r", repo_path],
                ["h", commit_hash],
            ],
            public_key=self.env.user.nostr_public_key,
        )
        
        private_key = PrivateKey(bytes.fromhex(self.env.user.nostr_private_key))
        private_key.sign_event(event)
        
        return self.create_and_publish(event)

    @api.model
    def create_tree_event(self, repo_path, tree_hash):
        repo = git.Repo(repo_path)
        tree = repo.tree(tree_hash)
        
        content = json.dumps({
            "action": "tree",
            "hash": tree_hash,
            "items": [{"mode": item.mode, "type": item.type, "hash": item.hexsha, "path": item.path} for item in tree.traverse()],
        })
        
        event = Event(
            kind=3122,
            content=content,
            tags=[
                ["r", repo_path],
                ["h", tree_hash],
            ],
            public_key=self.env.user.nostr_public_key,
        )
        
        private_key = PrivateKey(bytes.fromhex(self.env.user.nostr_private_key))
        private_key.sign_event(event)
        
        return self.create_and_publish(event)

    @api.model
    def create_blob_event(self, repo_path, blob_hash):
        repo = git.Repo(repo_path)
        blob = repo.blob(blob_hash)
        
        content = json.dumps({
            "action": "blob",
            "hash": blob_hash,
            "size": blob.size,
            "data": blob.data_stream.read().decode('utf-8', errors='replace'),
        })
        
        event = Event(
            kind=3123,
            content=content,
            tags=[
                ["r", repo_path],
                ["h", blob_hash],
            ],
            public_key=self.env.user.nostr_public_key,
        )
        
        private_key = PrivateKey(bytes.fromhex(self.env.user.nostr_private_key))
        private_key.sign_event(event)
        
        return self.create_and_publish(event)

    @api.model
    def reconstruct_git_objects(self, repo_path):
        repo = git.Repo(repo_path)
        events = self.search([('tags', 'ilike', repo_path)])
        
        for event in events:
            content = json.loads(event.content)
            if event.kind == 3121:  # Commit
                self._reconstruct_commit(repo, content)
            elif event.kind == 3122:  # Tree
                self._reconstruct_tree(repo, content)
            elif event.kind == 3123:  # Blob
                self._reconstruct_blob(repo, content)

    def _reconstruct_commit(self, repo, content):
        commit_hash = content['hash']
        if commit_hash not in repo.objects:
            repo.create_commit(
                tree=repo.tree(content['tree_hash']),
                message=content['message'],
                author=git.Actor(content['author'], content['email']),
                committer=git.Actor(content['author'], content['email']),
                parent_commits=[repo.commit(p) for p in content['parent_hashes']],
                commit_timestamp=int(content['date']),
                ref=f'refs/heads/{content["branch"]}' if 'branch' in content else None
            )

    def _reconstruct_tree(self, repo, content):
        tree_hash = content['hash']
        if tree_hash not in repo.objects:
            tree_items = []
            for item in content['items']:
                if item['type'] == 'blob':
                    tree_items.append((item['mode'], 'blob', item['hash'], item['path']))
                elif item['type'] == 'tree':
                    tree_items.append((item['mode'], 'tree', item['hash'], item['path']))
            repo.create_tree(tree_items)

    def _reconstruct_blob(self, repo, content):
        blob_hash = content['hash']
        if blob_hash not in repo.objects:
            repo.create_blob(content['data'].encode('utf-8'))

    def sync_git_nostr(self, repo_path):
        repo = git.Repo(repo_path)
        for obj in repo.objects:
            if isinstance(obj, git.Commit):
                self.create_git_event(repo_path, obj.hexsha)
            elif isinstance(obj, git.Tree):
                self.create_tree_event(repo_path, obj.hexsha)
            elif isinstance(obj, git.Blob):
                self.create_blob_event(repo_path, obj.hexsha)

        self.reconstruct_git_objects(repo_path)
=== ./odoo_custom_addons (copy)/integrated_ivcs/models/res_config_settings.py ===
from odoo import fields, models

class ResConfigSettings(models.TransientModel):
    _inherit = 'res.config.settings'

    integrated_ivcs_relay_urls = fields.Char(string="Nostr Relay URLs", config_parameter='integrated_ivcs.relay_urls')
=== ./odoo_custom_addons (copy)/integrated_ivcs/models/ivcs_commit.py ===
from odoo import models, fields, api
import json
from nostr.event import Event
from nostr.key import PrivateKey
import logging

_logger = logging.getLogger(__name__)

class IVCSCommit(models.Model):
    _name = 'ivcs.commit'
    _description = 'IVCS Commit'

    hash = fields.Char(string='Commit Hash', required=True)
    message = fields.Text(string='Commit Message', required=True)
    author = fields.Char(string='Author', required=True, default=lambda self: self.env.user.name)
    date = fields.Datetime(string='Commit Date', required=True, default=fields.Datetime.now)
    item_id = fields.Many2one('ivcs.item', string='IVCS Item', required=True, ondelete='cascade')
    version_id = fields.Many2one('ivcs.version', string='Associated Version')

    @api.model
    def create(self, vals):
        commit = super(IVCSCommit, self).create(vals)
        try:
            commit._create_nostr_commit_event()
        except Exception as e:
            _logger.error(f"Failed to create Nostr commit event: {str(e)}")
        return commit

    def _create_nostr_commit_event(self):
        if not self.item_id.nostr_private_key:
            _logger.warning(f"No Nostr private key set for IVCS Item {self.item_id.name}")
            return

        try:
            private_key = PrivateKey.from_nsec(self.item_id.nostr_private_key)
        except Exception as e:
            _logger.error(f"Invalid Nostr private key for IVCS Item {self.item_id.name}: {str(e)}")
            return

        event = Event(
            kind=3121,
            content=json.dumps({
                "hash": self.hash,
                "message": self.message,
                "author": self.author,
                "date": self.date.isoformat(),
            }),
            tags=[['r', self.item_id.repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)
        
        try:
            self.env['nostr.event'].create_and_publish(event)
            _logger.info(f"Nostr commit event created and published for commit {self.hash}")
        except Exception as e:
            _logger.error(f"Failed to create and publish Nostr event for commit {self.hash}: {str(e)}")
=== ./odoo_custom_addons (copy)/integrated_ivcs/models/ivcs_item.py ===
from odoo import models, fields, api, _
from odoo.exceptions import UserError
import git
import json
from nostr.event import Event
from nostr.key import PrivateKey
import os
import logging

_logger = logging.getLogger(__name__)

class IVCSItem(models.Model):
    _name = 'ivcs.item'
    _description = 'IVCS Item'

    name = fields.Char(string='Name', required=True)
    description = fields.Text('Description')
    current_version_id = fields.Many2one('ivcs.version', string='Current Version', compute='_compute_current_version', store=True)
    version_ids = fields.One2many('ivcs.version', 'item_id', string='Versions')
    repo_path = fields.Char('Repository Path', compute='_compute_repo_path', store=True)
    current_branch = fields.Char('Current Branch', default='main')
    commit_ids = fields.One2many('ivcs.commit', 'item_id', string='Commits')
    nostr_private_key = fields.Char(string="Nostr Private Key")
    branch_manager_id = fields.Many2one('ivcs.branch.manager', string='Branch Manager')

    @api.depends('name')
    def _compute_repo_path(self):
        for item in self:
            item.repo_path = f"/opt/ivcs_repos/item_{item.id}"

    @api.depends('version_ids')
    def _compute_current_version(self):
        for item in self:
            if item.version_ids:
                item.current_version_id = item.version_ids.sorted(lambda v: v.create_date, reverse=True)[0]
            else:
                item.current_version_id = False

    @api.model
    def create(self, vals):
        if 'nostr_private_key' in vals and vals['nostr_private_key']:
            try:
                # Validate and format the private key
                private_key = PrivateKey.from_nsec(vals['nostr_private_key'])
                vals['nostr_private_key'] = private_key.hex()  # Store the private key as a hex string
            except Exception as e:
                raise UserError(_("Invalid Nostr private key: %s") % str(e))
        return super(IVCSItem, self).create(vals)

    def write(self, vals):
        if 'nostr_private_key' in vals and vals['nostr_private_key']:
            try:
                # Validate and format the private key
                private_key = PrivateKey.from_nsec(vals['nostr_private_key'])
                vals['nostr_private_key'] = private_key.hex()  # Store the private key as a hex string
            except Exception as e:
                raise UserError(_("Invalid Nostr private key: %s") % str(e))
        return super(IVCSItem, self).write(vals)

    def _initialize_repository(self):
        self.ensure_one()
        if not os.path.exists(self.repo_path):
            os.makedirs(self.repo_path)
            repo = git.Repo.init(self.repo_path)
            readme_path = os.path.join(self.repo_path, 'README.md')
            with open(readme_path, 'w') as f:
                f.write(f"# {self.name}\n\n{self.description}")
            repo.index.add(['README.md'])
            commit = repo.index.commit("Initial commit")
            self._create_initial_version(commit.hexsha)
            self._create_nostr_repo_event()

    def _create_initial_version(self, commit_hash):
        version = self.env['ivcs.version'].create({
            'name': 'v1.0',
            'description': 'Initial version',
            'item_id': self.id,
        })
        self.env['ivcs.commit'].create({
            'hash': commit_hash,
            'message': "Initial commit",
            'item_id': self.id,
            'version_id': version.id,
        })

    def _create_nostr_repo_event(self):
        if not self.nostr_private_key:
            raise UserError(_("Nostr private key is not set for this item."))
    
        private_key = PrivateKey(bytes.fromhex(self.nostr_private_key))
        event = Event(
            kind=31228,
            content=json.dumps({
                "action": "create_repository",
                "repo_name": self.name,
                "description": self.description
            }),
            tags=[['r', self.repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)
        
        self.env['nostr.event'].create_and_publish(event)

    def create_branch(self, branch_name):
        self.ensure_one()
        repo = git.Repo(self.repo_path)
        if not self.branch_manager_id:
            self.branch_manager_id = self.env['ivcs.branch.manager'].create({
                'name': f"Branch Manager for {self.name}",
                'item_id': self.id,
            })
        if branch_name not in repo.heads:
            repo.create_head(branch_name)
            self.current_branch = branch_name
            self._create_nostr_branch_event(branch_name)
            if self.branch_manager_id:
                self.branch_manager_id.create_branch(branch_name)
            return self._return_success('Branch Created', f'Branch {branch_name} has been created.')
        else:
            return self._return_warning('Branch Exists', f'Branch {branch_name} already exists.')

    def _create_nostr_branch_event(self, branch_name):
        if not self.nostr_private_key:
            raise UserError(_("Nostr private key is not set for this item."))
        
        private_key = PrivateKey(bytes.fromhex(self.nostr_private_key))
        event = Event(
            kind=31227,
            content=json.dumps({
                "action": "create_branch",
                "branch_name": branch_name,
                "repo_name": self.name
            }),
            tags=[['r', self.repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)
        
        self.env['nostr.event'].create_and_publish(event)

    def _return_success(self, title, message):
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _(title),
                'message': _(message),
                'type': 'success',
            }
        }

    def _return_warning(self, title, message):
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _(title),
                'message': _(message),
                'type': 'warning',
            }
        }

    def delete_branch(self, branch_name):
        self.ensure_one()
        if self.branch_manager_id.delete_branch(branch_name):
            return self._return_success('Branch Deleted', f'Branch {branch_name} has been deleted.')
        else:
            return self._return_warning('Branch Not Found', f'Branch {branch_name} does not exist.')

    def merge_branches(self, source_branch, target_branch):
        self.ensure_one()
        if self.branch_manager_id.merge_branches(source_branch, target_branch):
            return self._return_success('Branches Merged', f'Branch {source_branch} has been merged into {target_branch}.')
        else:
            return self._return_warning('Merge Failed', f'Failed to merge {source_branch} into {target_branch}.')

    def reconstruct_branches(self):
        self.ensure_one()
        branches = self.branch_manager_id.reconstruct_branches_from_events()
        return self._return_success('Branches Reconstructed', f'Reconstructed {len(branches)} branches from Nostr events.')

    # Add other methods as needed (e.g., commit, push, pull, etc.)
=== ./odoo_custom_addons (copy)/integrated_ivcs/models/branch_manager.py ===
from odoo import models, fields, api
from git import Repo, GitCommandError
import json
from nostr.event import Event
from nostr.key import PrivateKey
import logging

_logger = logging.getLogger(__name__)

class BranchManager(models.Model):
    _name = 'ivcs.branch.manager'
    _description = 'IVCS Branch Manager'

    name = fields.Char(string='Name', required=True)
    item_id = fields.Many2one('ivcs.item', string='IVCS Item', required=True)

    def create_branch(self, branch_name):
        self.ensure_one()
        repo = Repo(self.item_id.repo_path)
        if branch_name not in repo.heads:
            repo.create_head(branch_name)
            self._create_branch_event(branch_name, 'create')
            return True
        return False

    def delete_branch(self, branch_name):
        self.ensure_one()
        repo = Repo(self.item_id.repo_path)
        if branch_name in repo.heads:
            repo.delete_head(branch_name, force=True)
            self._create_branch_event(branch_name, 'delete')
            return True
        return False

    def update_branch(self, branch_name, new_commit):
        self.ensure_one()
        repo = Repo(self.item_id.repo_path)
        if branch_name in repo.heads:
            branch = repo.heads[branch_name]
            branch.set_commit(new_commit)
            self._create_branch_event(branch_name, 'update', new_commit)
            return True
        return False

    def merge_branches(self, source_branch, target_branch):
        self.ensure_one()
        repo = Repo(self.item_id.repo_path)
        if source_branch in repo.heads and target_branch in repo.heads:
            try:
                repo.git.checkout(target_branch)
                repo.git.merge(source_branch)
                self._create_branch_event(target_branch, 'merge', source_branch)
                return True
            except GitCommandError as e:
                _logger.error(f"Merge conflict: {str(e)}")
                repo.git.merge('--abort')
                return False
        return False

    def _create_branch_event(self, branch_name, action, additional_info=None):
        if not self.item_id.nostr_private_key:
            _logger.warning(f"No Nostr private key for item {self.item_id.name}")
            return

        private_key = PrivateKey(bytes.fromhex(self.item_id.nostr_private_key))
        content = {
            "action": action,
            "branch_name": branch_name,
            "repo_name": self.item_id.name
        }
        if additional_info:
            content["additional_info"] = additional_info

        event = Event(
            kind=31227,
            content=json.dumps(content),
            tags=[['r', self.item_id.repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)
        
        self.env['nostr.event'].create_and_publish(event)

    def list_branches(self):
        self.ensure_one()
        repo = Repo(self.item_id.repo_path)
        return [head.name for head in repo.heads]

    def reconstruct_branches_from_events(self):
        self.ensure_one()
        events = self.env['nostr.event'].search([
            ('kind', '=', 31227),
            ('tags', 'ilike', self.item_id.repo_path)
        ], order='created_at asc')

        branches = {}
        for event in events:
            content = json.loads(event.content)
            action = content.get('action')
            branch_name = content.get('branch_name')

            if action == 'create':
                branches[branch_name] = {'created_at': event.created_at}
            elif action == 'delete':
                branches.pop(branch_name, None)
            elif action == 'update':
                if branch_name in branches:
                    branches[branch_name]['last_updated'] = event.created_at
            elif action == 'merge':
                if branch_name in branches:
                    branches[branch_name]['last_merged'] = event.created_at
                    branches[branch_name]['merged_from'] = content.get('additional_info')

        return branches
=== ./odoo_custom_addons (copy)/integrated_ivcs/__init__.py ===
from . import models
from . import wizards
=== ./odoo_custom_addons (copy)/integrated_ivcs/wizards/create_commit_wizard_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_create_commit_wizard_form" model="ir.ui.view">
        <field name="name">create.commit.wizard.form</field>
        <field name="model">create.commit.wizard</field>
        <field name="arch" type="xml">
            <form string="Create Commit">
                <group>
                    <field name="item_id"/>
                    <field name="message"/>
                </group>
                <footer>
                    <button name="action_create_commit" string="Create Commit" type="object" class="btn-primary"/>
                    <button string="Cancel" class="btn-secondary" special="cancel"/>
                </footer>
            </form>
        </field>
    </record>

    <record id="action_create_commit_wizard" model="ir.actions.act_window">
        <field name="name">Create Commit</field>
        <field name="res_model">create.commit.wizard</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/integrated_ivcs/wizards/__init__.py ===
from . import create_branch_wizard
from . import create_commit_wizard
=== ./odoo_custom_addons (copy)/integrated_ivcs/wizards/create_commit_wizard.py ===
from odoo import models, fields, api

class CreateCommitWizard(models.TransientModel):
    _name = 'create.commit.wizard'
    _description = 'Create Commit Wizard'

    item_id = fields.Many2one('ivcs.item', string='IVCS Item', required=True)
    message = fields.Text(string='Commit Message', required=True)

    def action_create_commit(self):
        self.ensure_one()
        repo = self.env['git.repository'].search([('path', '=', self.item_id.repo_path)])
        commit_hash = repo.commit_changes(self.message)
        self.env['ivcs.commit'].create({
            'hash': commit_hash,
            'message': self.message,
            'author': self.env.user.name,
            'date': fields.Datetime.now(),
            'item_id': self.item_id.id,
        })
        return {'type': 'ir.actions.act_window_close'}
=== ./odoo_custom_addons (copy)/integrated_ivcs/wizards/create_branch_wizard.py ===
from odoo import models, fields, api

class CreateBranchWizard(models.TransientModel):
    _name = 'create.branch.wizard'
    _description = 'Create Branch Wizard'

    item_id = fields.Many2one('ivcs.item', string='IVCS Item', required=True)
    branch_name = fields.Char(string='Branch Name', required=True)

    def action_create_branch(self):
        self.ensure_one()
        return self.item_id.create_branch(self.branch_name)
=== ./odoo_custom_addons (copy)/integrated_ivcs/wizards/create_branch_wizard_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_create_branch_wizard_form" model="ir.ui.view">
        <field name="name">create.branch.wizard.form</field>
        <field name="model">create.branch.wizard</field>
        <field name="arch" type="xml">
            <form string="Create Branch">
                <group>
                    <field name="item_id"/>
                    <field name="branch_name"/>
                </group>
                <footer>
                    <button name="action_create_branch" string="Create Branch" type="object" class="btn-primary"/>
                    <button string="Cancel" class="btn-secondary" special="cancel"/>
                </footer>
            </form>
        </field>
    </record>

    <record id="action_create_branch_wizard" model="ir.actions.act_window">
        <field name="name">Create Branch</field>
        <field name="res_model">create.branch.wizard</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/integrated_ivcs/cli.py ===
import argparse
import os
import git
from nostr.event import Event
from nostr.key import PrivateKey
import json
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class GitNostrCLI:
    def __init__(self, repo_path):
        self.repo_path = repo_path
        self.repo = git.Repo(repo_path)
        self.private_key = PrivateKey()

    def create_branch(self, branch_name):
        logger.info(f"Creating branch: {branch_name}")
        self.repo.create_head(branch_name)
        self._create_branch_event(branch_name, 'create')
        logger.info(f"Branch {branch_name} created successfully")

    def delete_branch(self, branch_name):
        logger.info(f"Deleting branch: {branch_name}")
        self.repo.delete_head(branch_name, force=True)
        self._create_branch_event(branch_name, 'delete')
        logger.info(f"Branch {branch_name} deleted successfully")

    def merge_branches(self, source_branch, target_branch):
        logger.info(f"Merging {source_branch} into {target_branch}")
        self.repo.git.checkout(target_branch)
        try:
            self.repo.git.merge(source_branch)
            self._create_branch_event(target_branch, 'merge', source_branch)
            logger.info(f"Merged {source_branch} into {target_branch} successfully")
        except git.GitCommandError as e:
            logger.error(f"Merge conflict: {str(e)}")
            self.repo.git.merge('--abort')
            logger.info("Merge aborted due to conflicts")

    def commit_changes(self, message):
        logger.info(f"Committing changes with message: {message}")
        self.repo.git.add(A=True)
        commit = self.repo.index.commit(message)
        self._create_commit_event(commit)
        logger.info(f"Changes committed successfully. Commit hash: {commit.hexsha}")

    def _create_branch_event(self, branch_name, action, additional_info=None):
        logger.info(f"Creating Nostr event for branch action: {action}")
        content = {
            "action": action,
            "branch_name": branch_name,
            "repo_name": os.path.basename(self.repo_path)
        }
        if additional_info:
            content["additional_info"] = additional_info

        event = Event(
            kind=31227,
            content=json.dumps(content),
            tags=[['r', self.repo_path]],
            public_key=self.private_key.public_key.hex()
        )
        self.private_key.sign_event(event)
        logger.info(f"Nostr event created: {event.id}")
        # Here you would typically publish the event to Nostr relays

    def _create_commit_event(self, commit):
        logger.info(f"Creating Nostr event for commit: {commit.hexsha}")
        content = json.dumps({
            "action": "commit",
            "message": commit.message,
            "author": commit.author.name,
            "email": commit.author.email,
            "date": commit.authored_datetime.isoformat(),
            "hash": commit.hexsha,
            "parent_hashes": [c.hexsha for c in commit.parents],
            "tree_hash": commit.tree.hexsha,
        })
        
        event = Event(
            kind=3121,
            content=content,
            tags=[
                ["r", self.repo_path],
                ["h", commit.hexsha],
            ],
            public_key=self.private_key.public_key.hex()
        )
        self.private_key.sign_event(event)
        logger.info(f"Nostr event created: {event.id}")
        # Here you would typically publish the event to Nostr relays

def main():
    parser = argparse.ArgumentParser(description="Git-Nostr CLI")
    parser.add_argument('repo_path', help="Path to the Git repository")
    parser.add_argument('action', choices=['create-branch', 'delete-branch', 'merge-branches', 'commit'])
    parser.add_argument('--branch-name', help="Name of the branch (for create-branch and delete-branch)")
    parser.add_argument('--source-branch', help="Source branch for merge")
    parser.add_argument('--target-branch', help="Target branch for merge")
    parser.add_argument('--commit-message', help="Commit message")

    args = parser.parse_args()

    cli = GitNostrCLI(args.repo_path)

    if args.action == 'create-branch':
        cli.create_branch(args.branch_name)
    elif args.action == 'delete-branch':
        cli.delete_branch(args.branch_name)
    elif args.action == 'merge-branches':
        cli.merge_branches(args.source_branch, args.target_branch)
    elif args.action == 'commit':
        cli.commit_changes(args.commit_message)

if __name__ == "__main__":
    main()
=== ./odoo_custom_addons (copy)/integrated_ivcs/__manifest__.py ===
{
    'name': 'Integrated IVCS',
    'version': '1.0',
    'category': 'Development',
    'summary': 'Integrated Version Control System with Git and Nostr',
    'author': 'Your Name',
    'website': 'https://www.example.com',
    'depends': ['base', 'mail'],
    'data': [
        'security/ir.model.access.csv',
        'views/ivcs_item_views.xml',
        'views/ivcs_version_views.xml',
        'views/ivcs_commit_views.xml',
        'views/git_repository_views.xml',
        'views/nostr_event_views.xml',
        'views/res_config_settings_views.xml',
        'wizards/create_branch_wizard_views.xml',
        'wizards/create_commit_wizard_views.xml',
    ],
    'external_dependencies': {
        'python': ['git', 'nostr'],
    },
    'installable': True,
    'application': True,
    'auto_install': False,
}
=== ./odoo_custom_addons (copy)/integrated_ivcs/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_ivcs_item_user,ivcs.item user,model_ivcs_item,base.group_user,1,1,1,1
access_ivcs_version_user,ivcs.version user,model_ivcs_version,base.group_user,1,1,1,1
access_ivcs_commit_user,ivcs.commit user,model_ivcs_commit,base.group_user,1,1,1,1
access_git_repository_user,git.repository user,model_git_repository,base.group_user,1,1,1,1
access_nostr_event_user,nostr.event user,model_nostr_event,base.group_user,1,1,1,1
access_ivcs_branch_manager_user,ivcs.branch.manager user,model_ivcs_branch_manager,base.group_user,1,1,1,1
access_create_branch_wizard_user,create.branch.wizard user,model_create_branch_wizard,base.group_user,1,1,1,0
access_create_commit_wizard_user,create.commit.wizard user,model_create_commit_wizard,base.group_user,1,1,1,0
=== ./odoo_custom_addons (copy)/integrated_ivcs/tests/test_git_nostr_integration.py ===
import unittest
import tempfile
import os
import git
import json
from nostr.event import Event
from nostr.key import PrivateKey
from odoo.tests.common import TransactionCase
from odoo.exceptions import UserError

class TestGitNostrIntegration(TransactionCase):

    def setUp(self):
        super(TestGitNostrIntegration, self).setUp()
        self.IVCSItem = self.env['ivcs.item']
        self.NostrEvent = self.env['nostr.event']
        self.temp_dir = tempfile.mkdtemp()
        self.repo_path = os.path.join(self.temp_dir, 'test_repo')

    def tearDown(self):
        super(TestGitNostrIntegration, self).tearDown()
        if os.path.exists(self.temp_dir):
            import shutil
            shutil.rmtree(self.temp_dir)

    def test_create_repository(self):
        item = self.IVCSItem.create({
            'name': 'Test Repo',
            'description': 'Test repository',
            'repo_path': self.repo_path,
        })
        self.assertTrue(os.path.exists(self.repo_path))
        self.assertTrue(os.path.exists(os.path.join(self.repo_path, '.git')))
        self.assertTrue(os.path.exists(os.path.join(self.repo_path, 'README.md')))

    def test_create_branch(self):
        item = self.IVCSItem.create({
            'name': 'Test Repo',
            'description': 'Test repository',
            'repo_path': self.repo_path,
        })
        result = item.create_branch('test-branch')
        self.assertEqual(result['type'], 'ir.actions.client')
        self.assertEqual(result['params']['type'], 'success')
        repo = git.Repo(self.repo_path)
        self.assertIn('test-branch', repo.heads)

    def test_merge_branches(self):
        item = self.IVCSItem.create({
            'name': 'Test Repo',
            'description': 'Test repository',
            'repo_path': self.repo_path,
        })
        item.create_branch('branch1')
        item.create_branch('branch2')
        repo = git.Repo(self.repo_path)
        repo.heads.branch1.checkout()
        with open(os.path.join(self.repo_path, 'file1.txt'), 'w') as f:
            f.write('Content in branch1')
        repo.index.add(['file1.txt'])
        repo.index.commit('Commit in branch1')
        
        result = item.merge_branches('branch1', 'branch2')
        self.assertEqual(result['type'], 'ir.actions.client')
        self.assertEqual(result['params']['type'], 'success')
        
        repo.heads.branch2.checkout()
        self.assertTrue(os.path.exists(os.path.join(self.repo_path, 'file1.txt')))

    def test_create_nostr_events(self):
        item = self.IVCSItem.create({
            'name': 'Test Repo',
            'description': 'Test repository',
            'repo_path': self.repo_path,
        })
        repo = git.Repo(self.repo_path)
        with open(os.path.join(self.repo_path, 'test.txt'), 'w') as f:
            f.write('Test content')
        repo.index.add(['test.txt'])
        commit = repo.index.commit('Test commit')
        
        event = self.NostrEvent.create_git_event(self.repo_path, commit.hexsha)
        self.assertEqual(event.kind, 3121)
        self.assertIn(commit.hexsha, event.content)

    def test_reconstruct_git_objects(self):
        item = self.IVCSItem.create({
            'name': 'Test Repo',
            'description': 'Test repository',
            'repo_path': self.repo_path,
        })
        repo = git.Repo(self.repo_path)
        with open(os.path.join(self.repo_path, 'test.txt'), 'w') as f:
            f.write('Test content')
        repo.index.add(['test.txt'])
        commit = repo.index.commit('Test commit')
        
        self.NostrEvent.create_git_event(self.repo_path, commit.hexsha)
        
        # Delete the .git directory to simulate a fresh repository
        import shutil
        shutil.rmtree(os.path.join(self.repo_path, '.git'))
        
        # Reconstruct the repository from Nostr events
        self.NostrEvent.reconstruct_git_objects(self.repo_path)
        
        reconstructed_repo = git.Repo(self.repo_path)
        self.assertIn(commit.hexsha, reconstructed_repo.heads.master.commit.hexsha)
        self.assertTrue(os.path.exists(os.path.join(self.repo_path, 'test.txt')))

if __name__ == '__main__':
    unittest.main()
=== ./odoo_custom_addons (copy)/integrated_ivcs/views/res_config_settings_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="res_config_settings_view_form" model="ir.ui.view">
        <field name="name">res.config.settings.view.form.inherit.integrated_ivcs</field>
        <field name="model">res.config.settings</field>
        <field name="inherit_id" ref="base.res_config_settings_view_form"/>
        <field name="arch" type="xml">
            <xpath expr="//div[hasclass('settings')]" position="inside">
                <div class="app_settings_block" data-string="Integrated IVCS" string="Integrated IVCS" data-key="integrated_ivcs">
                    <h2>Nostr Settings</h2>
                    <div class="row mt16 o_settings_container">
                        <div class="col-12 col-lg-6 o_setting_box">
                            <div class="o_setting_left_pane"/>
                            <div class="o_setting_right_pane">
                                <span class="o_form_label">Nostr Relay URLs</span>
                                <div class="text-muted">
                                    Comma-separated list of Nostr relay URLs
                                </div>
                                <div class="content-group">
                                    <field name="integrated_ivcs_relay_urls"/>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </xpath>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons (copy)/integrated_ivcs/views/ivcs_version_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_ivcs_version_form" model="ir.ui.view">
        <field name="name">ivcs.version.form</field>
        <field name="model">ivcs.version</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="description"/>
                        <field name="item_id"/>
                        <field name="commit_id"/>
                        <field name="create_date"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_ivcs_version_tree" model="ir.ui.view">
        <field name="name">ivcs.version.tree</field>
        <field name="model">ivcs.version</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="item_id"/>
                <field name="create_date"/>
            </tree>
        </field>
    </record>

    <record id="action_ivcs_version" model="ir.actions.act_window">
        <field name="name">IVCS Versions</field>
        <field name="res_model">ivcs.version</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_ivcs_version" name="Versions" parent="menu_ivcs_root" action="action_ivcs_version"/>
</odoo>
=== ./odoo_custom_addons (copy)/integrated_ivcs/views/nostr_event_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_nostr_event_form" model="ir.ui.view">
        <field name="name">nostr.event.form</field>
        <field name="model">nostr.event</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="event_id"/>
                        <field name="kind"/>
                        <field name="event_type"/>
                        <field name="content"/>
                        <field name="tags"/>
                        <field name="public_key"/>
                        <field name="created_at"/>
                        <field name="signature"/>
                        <field name="published"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_nostr_event_tree" model="ir.ui.view">
        <field name="name">nostr.event.tree</field>
        <field name="model">nostr.event</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="event_id"/>
                <field name="kind"/>
                <field name="event_type"/>
                <field name="public_key"/>
                <field name="created_at"/>
                <field name="published"/>
            </tree>
        </field>
    </record>

    <record id="action_nostr_event" model="ir.actions.act_window">
        <field name="name">Nostr Events</field>
        <field name="res_model">nostr.event</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_nostr_event" name="Nostr Events" parent="menu_ivcs_root" action="action_nostr_event"/>
</odoo>
=== ./odoo_custom_addons (copy)/integrated_ivcs/views/ivcs_item_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_ivcs_item_form" model="ir.ui.view">
        <field name="name">ivcs.item.form</field>
        <field name="model">ivcs.item</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="description"/>
                        <field name="repo_path"/>
                        <field name="current_branch"/>
                        <field name="current_version_id"/>
                        <field name="nostr_private_key" password="True"/>
                    </group>
                    <notebook>
                        <page string="Versions">
                            <field name="version_ids"/>
                        </page>
                        <page string="Commits">
                            <field name="commit_ids"/>
                        </page>
                    </notebook>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_ivcs_item_tree" model="ir.ui.view">
        <field name="name">ivcs.item.tree</field>
        <field name="model">ivcs.item</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="repo_path"/>
                <field name="current_branch"/>
                <field name="current_version_id"/>
            </tree>
        </field>
    </record>

    <record id="action_ivcs_item" model="ir.actions.act_window">
        <field name="name">IVCS Items</field>
        <field name="res_model">ivcs.item</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_ivcs_root" name="Integrated IVCS"/>
    <menuitem id="menu_ivcs_item" name="IVCS Items" parent="menu_ivcs_root" action="action_ivcs_item"/>
</odoo>
=== ./odoo_custom_addons (copy)/integrated_ivcs/views/git_repository_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_repository_form" model="ir.ui.view">
        <field name="name">git.repository.form</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="path"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_git_repository_tree" model="ir.ui.view">
        <field name="name">git.repository.tree</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="path"/>
            </tree>
        </field>
    </record>

    <record id="action_git_repository" model="ir.actions.act_window">
        <field name="name">Git Repositories</field>
        <field name="res_model">git.repository</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_git_repository" name="Git Repositories" parent="menu_ivcs_root" action="action_git_repository"/>
</odoo>
=== ./odoo_custom_addons (copy)/integrated_ivcs/views/ivcs_commit_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_ivcs_commit_form" model="ir.ui.view">
        <field name="name">ivcs.commit.form</field>
        <field name="model">ivcs.commit</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="hash"/>
                        <field name="message"/>
                        <field name="author"/>
                        <field name="date"/>
                        <field name="item_id"/>
                        <field name="version_id"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_ivcs_commit_tree" model="ir.ui.view">
        <field name="name">ivcs.commit.tree</field>
        <field name="model">ivcs.commit</field>
        <field name="arch" type="xml">
            <tree>
                <field name="hash"/>
                <field name="message"/>
                <field name="author"/>
                <field name="date"/>
                <field name="item_id"/>
            </tree>
        </field>
    </record>

    <record id="action_ivcs_commit" model="ir.actions.act_window">
        <field name="name">IVCS Commits</field>
        <field name="res_model">ivcs.commit</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_ivcs_commit" name="Commits" parent="menu_ivcs_root" action="action_ivcs_commit"/>
</odoo>
=== ./allfiles.txt ===
=== ./check_nostr_bridge.sh ===
#!/bin/bash

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Function to print colored output
print_status() {
    if [ $1 -eq 0 ]; then
        echo -e "${GREEN}[OK]${NC} $2"
    else
        echo -e "${RED}[FAIL]${NC} $2"
    fi
}

echo "Running pre-update checks for nostr_bridge module..."

# 1. Verify required Python libraries
echo -e "\n${YELLOW}Checking required Python libraries...${NC}"
required_libs=("websockets" "nostr")
for lib in "${required_libs[@]}"; do
    if pip3 list | grep -F "$lib" > /dev/null; then
        print_status 0 "$lib is installed"
    else
        print_status 1 "$lib is not installed"
    fi
done

# 2. Check module file location
echo -e "\n${YELLOW}Checking module file location...${NC}"
module_path="/opt/odoo/custom_addons/nostr_bridge"
if [ -d "$module_path" ]; then
    print_status 0 "Module directory exists at $module_path"
    if [ -f "$module_path/__manifest__.py" ]; then
        print_status 0 "__manifest__.py file exists"
    else
        print_status 1 "__manifest__.py file not found in $module_path"
    fi
else
    print_status 1 "Module directory not found at $module_path"
fi

# 3. Check __manifest__.py content
echo -e "\n${YELLOW}Checking __manifest__.py content...${NC}"
manifest_file="$module_path/__manifest__.py"
if [ -f "$manifest_file" ]; then
    if grep -q "'depends':" "$manifest_file" && grep -q "'data':" "$manifest_file"; then
        print_status 0 "__manifest__.py contains 'depends' and 'data' sections"
    else
        print_status 1 "__manifest__.py might be missing 'depends' or 'data' sections"
    fi
else
    print_status 1 "__manifest__.py file not found"
fi

# 4. Verify configuration parameters
echo -e "\n${YELLOW}Checking configuration parameters...${NC}"
odoo_db="odoodb"  # Replace with your actual database name if different
config_param="git_nostr_bridge.relay_urls"
relay_urls=$(psql -d $odoo_db -t -c "SELECT value FROM ir_config_parameter WHERE key='$config_param';")
if [ -n "$relay_urls" ]; then
    print_status 0 "Relay URLs are set: $relay_urls"
else
    print_status 1 "Relay URLs are not set in the database"
fi

# 5. Test network connectivity
echo -e "\n${YELLOW}Testing network connectivity...${NC}"
test_urls=("wss://nostr-pub.wellorder.net" "wss://relay.nostr.info" "wss://nostr.zebedee.cloud")
for url in "${test_urls[@]}"; do
    if curl --output /dev/null --silent --head --fail "$url"; then
        print_status 0 "Connection to $url successful"
    else
        print_status 1 "Failed to connect to $url"
    fi
done

echo -e "\n${YELLOW}Pre-update checks completed.${NC}"
=== ./Dockerfile ===
FROM ubuntu:22.04
ENV ODOO_VERSION 16.0
ENV OPENEDUCAT_VERSION 16.0
ENV DEBIAN_FRONTEND noninteractive

# Install dependencies
RUN apt-get update && apt-get install -y \
    python3 python3-pip python3-dev python3-venv \
    postgresql-client \
    nodejs npm \
    git \
    wget \
    libxml2-dev libxslt1-dev \
    libjpeg-dev libfreetype6-dev \
    libpq-dev \
    build-essential \
    libldap2-dev libsasl2-dev \
    libssl-dev \
    libffi-dev \
    iputils-ping \
    curl \
    && rm -rf /var/lib/apt/lists/*

# Create Odoo user
RUN useradd -m -d /opt/odoo -U -r -s /bin/bash odoo

# Clone Odoo and OpenEduCat
RUN git clone https://github.com/odoo/odoo.git --depth 1 --branch ${ODOO_VERSION} /opt/odoo/odoo
RUN git clone https://github.com/openeducat/openeducat_erp.git --depth 1 --branch ${OPENEDUCAT_VERSION} /opt/odoo/openeducat

# Install Python dependencies
RUN pip3 install --upgrade pip
RUN pip3 install --no-cache-dir -r /opt/odoo/odoo/requirements.txt
RUN pip3 install cryptography pyopenssl==22.1.0 psycopg2-binary bs4 BeautifulSoup4 gitpython bech32 websocket-client websockets
RUN pip3 install nostr
RUN pip3 install python-gitlab

# Copy OpenEduCat addons
RUN cp -r /opt/odoo/openeducat/* /opt/odoo/odoo/addons/

# Copy custom files
COPY ./nostr_auth.py /opt/odoo/
COPY ./custom_odoo_server.py /opt/odoo/
COPY ./odoo_custom_addons /opt/odoo/custom_addons
COPY ./check_nostr_bridge.sh /opt/odoo/check_nostr_bridge.sh

# Set up directories and permissions
RUN mkdir -p /etc/odoo /opt/ivcs_repos /var/lib/odoo /opt/odoo/.local/share/Odoo/filestore /opt/odoo/.local/share/Odoo/sessions
RUN chown -R odoo:odoo /opt/odoo /etc/odoo /opt/ivcs_repos /var/lib/odoo
RUN chmod +x /opt/odoo/check_nostr_bridge.sh /opt/odoo/custom_odoo_server.py

# Switch to odoo user
USER odoo

# Patch OpenSSL
RUN echo "from OpenSSL import crypto" > /tmp/patch_openssl.py && \
    echo "if not hasattr(crypto, 'X509_V_FLAG_EXPLICIT_POLICY'):" >> /tmp/patch_openssl.py && \
    echo "    crypto.X509_V_FLAG_EXPLICIT_POLICY = 0x8000" >> /tmp/patch_openssl.py && \
    echo "exec(open('/tmp/patch_openssl.py').read())" >> /opt/odoo/odoo/odoo/addons/base/models/ir_mail_server.py

# Initialize the database and start Odoo
CMD ["/bin/bash", "-c", "\
    /opt/odoo/check_nostr_bridge.sh && \
    python3 /opt/odoo/odoo/odoo-bin -c /etc/odoo/odoo.conf -d odoodb -i base && \
    python3 /opt/odoo/custom_odoo_server.py -c /etc/odoo/odoo.conf \
    "]
=== ./COPY OF THE Git Nostr Bridge Test Code ===
import asyncio
import json
import logging
import websockets
from urllib.parse import urlparse
import time
import traceback

from odoo import models, fields, api, _
from odoo.exceptions import UserError
from nostr.event import Event as NostrLibEvent
from nostr.key import PrivateKey

_logger = logging.getLogger(__name__)

class NostrEvent(models.Model):
    _name = 'nostr.event'
    _description = 'Nostr Event'

    name = fields.Char(string='Name', required=True)
    event_type = fields.Selection([
        ('repo_anchor', 'Repository Anchor'),
        ('branch', 'Branch'),
        ('commit', 'Commit'),
        ('tree', 'Tree'),
        ('blob', 'Blob'),
    ], string='Event Type', required=True)
    content = fields.Text(string='Content')
    tags = fields.Text(string='Tags')
    published = fields.Boolean(string='Published', default=False)
    event_id = fields.Char(string='Event ID', readonly=True)

    @api.model
    def action_publish(self, event_id):
        event = self.browse(event_id)
        _logger.info(f"Starting publish action for event: {event.name}")
        start_time = time.time()

        try:
            if not self.env.user.nostr_private_key:
                raise UserError(_("Nostr private key is not set for the current user."))

            _logger.info("Generating private key")
            try:
                private_key = PrivateKey.from_nsec(self.env.user.nostr_private_key)
                _logger.info("Private key generated successfully")
            except Exception as e:
                _logger.error(f"Failed to generate private key: {str(e)}")
                _logger.error(traceback.format_exc())
                raise UserError(_("Invalid Nostr private key: %s") % str(e))

            public_key = private_key.public_key.hex()
            _logger.info(f"Public key: {public_key}")

            _logger.info("Parsing tags")
            try:
                tags = json.loads(event.tags) if event.tags else []
                _logger.info(f"Parsed tags: {tags}")
                if not isinstance(tags, list):
                    raise ValueError("Tags must be a list of lists")
                for tag in tags:
                    if not isinstance(tag, list):
                        raise ValueError("Each tag must be a list")
            except json.JSONDecodeError as e:
                _logger.error(f"JSON decode error: {str(e)}")
                _logger.error(traceback.format_exc())
                raise UserError(_("Invalid tags format. Please ensure tags are in valid JSON format."))
            except ValueError as e:
                _logger.error(f"Value error: {str(e)}")
                _logger.error(traceback.format_exc())
                raise UserError(_("Invalid tags format: %s") % str(e))

            _logger.info("Creating Nostr event")
            nostr_event = NostrLibEvent(
                kind=1,  # Assuming TEXT_NOTE, adjust if needed
                content=str(event.content),
                tags=tags,
                public_key=public_key  # Ensure public_key is provided
            )
            private_key.sign_event(nostr_event)
            _logger.info(f"Event created: {nostr_event.to_message()}")

            _logger.info("Fetching relay URLs")
            relay_urls = self.env['ir.config_parameter'].sudo().get_param('git_nostr_bridge.relay_urls', '').split(',')
            relay_urls = [url.strip() for url in relay_urls if url.strip()][:5]  # Limit to 5 relays
            _logger.info(f"Relay URLs: {relay_urls}")

            if not relay_urls:
                raise UserError(_("No Nostr relay URLs configured. Please set them in the settings."))

            _logger.info("Validating relay URLs")
            for url in relay_urls:
                parsed = urlparse(url)
                if parsed.scheme not in ('ws', 'wss'):
                    _logger.error(f"Invalid relay URL: {url}")
                    raise UserError(_("Invalid relay URL: %s. Must start with ws:// or wss://") % url)

            async def publish_to_relay(relay_url, nostr_event, retries=3):
                for attempt in range(retries):
                    try:
                        _logger.info(f"Attempting to connect to {relay_url} (attempt {attempt + 1})")
                        connection_start = time.time()
                        async with websockets.connect(relay_url, timeout=30) as websocket:
                            connection_end = time.time()
                            _logger.info(f"Connected to {relay_url} in {connection_end - connection_start:.2f} seconds")
                            
                            message = nostr_event.to_message()
                            _logger.debug(f"Raw event message: {message}")
                            
                            # The message is already in the correct format, so we don't need to modify it
                            _logger.info(f"Sending Nostr event to {relay_url}: {message}")
                            
                            send_start = time.time()
                            await websocket.send(message)
                            send_end = time.time()
                            _logger.info(f"Sent message to {relay_url} in {send_end - send_start:.2f} seconds")
                            
                            _logger.info(f"Waiting for response from {relay_url}")
                            response_start = time.time()
                            response = await asyncio.wait_for(websocket.recv(), timeout=10.0)
                            response_end = time.time()
                            _logger.info(f"Received response from {relay_url} in {response_end - response_start:.2f} seconds: {response}")
                            
                            try:
                                return json.loads(response)
                            except json.JSONDecodeError as e:
                                _logger.error(f"Failed to parse response from {relay_url}: {str(e)}")
                                return f"Invalid response from {relay_url}: {response}"
                    except (websockets.exceptions.WebSocketException, asyncio.TimeoutError) as e:
                        _logger.error(f"Error publishing to {relay_url} (attempt {attempt + 1}): {str(e)}")
                        _logger.error(traceback.format_exc())
                        await asyncio.sleep(5 * (attempt + 1))  # Increased delay between attempts
                return f"Failed to publish to {relay_url} after {retries} attempts"

            async def publish_with_timeout():
                tasks = [publish_to_relay(url, nostr_event) for url in relay_urls]
                return await asyncio.gather(*tasks, return_exceptions=True)

            async def run_publication():
                _logger.info("Starting publication process")
                try:
                    results = await asyncio.wait_for(publish_with_timeout(), timeout=120)  # Increased overall timeout
                    _logger.info(f"Publication results: {results}")
                    return results
                except asyncio.TimeoutError:
                    _logger.error("Publication process timed out after 120 seconds")
                    raise UserError(_("Publishing timed out after 120 seconds"))

            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            try:
                results = loop.run_until_complete(run_publication())
            finally:
                loop.close()

            success = any(isinstance(result, list) and result[0] == "OK" for result in results)
            if success:
                event.write({
                    'published': True,
                    'event_id': nostr_event.id
                })
                _logger.info(f"Successfully published Nostr event: {nostr_event.id}")
                
                # Verify event publication
                self.verify_event_publication(nostr_event.id, relay_urls)
                
                end_time = time.time()
                _logger.info(f"Total publish action time: {end_time - start_time:.2f} seconds")
                
                return {
                    'type': 'ir.actions.client',
                    'tag': 'display_notification',
                    'params': {
                        'message': _("Nostr event successfully published to at least one relay."),
                        'type': 'success',
                        'sticky': False,
                    }
                }
            else:
                error_messages = [str(result) for result in results if isinstance(result, str)]
                _logger.error(f"Failed to publish Nostr event: {'; '.join(error_messages)}")
                raise UserError(_("Failed to publish Nostr event: %s") % "; ".join(error_messages))

        except Exception as e:
            _logger.error(f"Unexpected error in action_publish: {str(e)}")
            _logger.error(traceback.format_exc())
            raise UserError(_("An unexpected error occurred: %s") % str(e))

    @api.model
    def verify_event_publication(self, event_id, relay_urls, max_attempts=5, delay=2):
        _logger.info(f"Starting verification for event: {event_id}")
        for attempt in range(max_attempts):
            _logger.info(f"Verification attempt {attempt + 1}")
            for url in relay_urls:
                try:
                    loop = asyncio.new_event_loop()
                    asyncio.set_event_loop(loop)
                    result = loop.run_until_complete(self.query_event(url, event_id))
                    if result:
                        _logger.info(f"Event {event_id} found on relay {url}")
                        return True
                except Exception as e:
                    _logger.error(f"Error querying event from {url}: {str(e)}")
                    _logger.error(traceback.format_exc())
                finally:
                    loop.close()
            _logger.info(f"Waiting {delay} seconds before next attempt")
            time.sleep(delay)
        _logger.warning(f"Event {event_id} not found on any relay after {max_attempts} attempts")
        return False

    async def query_event(self, relay_url, event_id):
        _logger.info(f"Querying event {event_id} from {relay_url}")
        start_time = time.time()
        try:
            async with websockets.connect(relay_url, timeout=10) as websocket:
                request = json.dumps(["REQ", "query", {"ids": [event_id]}])
                _logger.info(f"Sending query to {relay_url}: {request}")
                await websocket.send(request)
                response = await asyncio.wait_for(websocket.recv(), timeout=5.0)
                _logger.info(f"Response from {relay_url}: {response}")
                end_time = time.time()
                _logger.info(f"Query to {relay_url} took {end_time - start_time:.2f} seconds")
                return json.loads(response)
        except Exception as e:
            _logger.error(f"Error querying {relay_url}: {str(e)}")
            _logger.error(traceback.format_exc())
            end_time = time.time()
            _logger.info(f"Failed query to {relay_url} took {end_time - start_time:.2f} seconds")
            return None
=== ./custom_odoo_server.py ===
#!/usr/bin/env python3
import sys
import os

# Add Odoo to Python path
odoo_path = '/opt/odoo/odoo'
sys.path.append(odoo_path)

import odoo
from odoo.tools import config
from odoo.exceptions import AccessDenied

if __name__ == "__main__":
    config.parse_config(sys.argv[1:])
    
    if config.get('auth_method') == 'nostr':
        def check_security(method, *args, **kwargs):
            if odoo.http.request and odoo.http.request.params:
                public_key = odoo.http.request.params.get('public_key')
                signature = odoo.http.request.params.get('signature')
                message = odoo.http.request.params.get('message')
                
                if public_key and signature and message:
                    user_id = odoo.http.request.env['res.users'].sudo().authenticate_nostr(public_key, signature, message)
                    if user_id:
                        odoo.http.request.uid = user_id
                        return
            
            return method(*args, **kwargs)

        odoo.http.Root.check_security = check_security

    # Force database initialization
    db_name = config['db_name']
    if not odoo.service.db.exp_db_exist(db_name):
        odoo.service.db.exp_create_database(
            db_name,
            demo=False,
            lang='en_US',
            user_password='admin'
        )
        print(f"Database '{db_name}' created.")
    else:
        print(f"Database '{db_name}' already exists.")

    # Initialize the database with base module
    odoo.modules.registry.Registry.new(db_name, update_module=True)
    
    odoo.cli.main()
=== ./odoo_custom_addons/git_repository_anchor/models/git_repository.py ===
from odoo import models, fields, api, _
from odoo.exceptions import UserError
import git
import os
import logging

_logger = logging.getLogger(__name__)

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'
    _inherit = ['mail.thread', 'mail.activity.mixin']

    name = fields.Char(string='Repository Name', required=True)
    path = fields.Char(string='Repository Path', required=True)
    description = fields.Text(string='Description', tracking=True)
    maintainer_ids = fields.Many2many('res.users', string='Maintainers')
    anchor_event_id = fields.Many2one('nostr.event', string='Anchor Event')
    #company_id = fields.Many2one('res.company', string='Company', required=True, default=lambda self: self.env.company)

    @api.model
    def create(self, vals):
        repo = super(GitRepository, self).create(vals)
        repo._initialize_repository()
        return repo

    def _initialize_repository(self):
        if not os.path.exists(self.path):
            os.makedirs(self.path)
            git.Repo.init(self.path)
            readme_path = os.path.join(self.path, 'README.md')
            with open(readme_path, 'w') as f:
                f.write(f"# {self.name}\n\n{self.description or ''}")
            repo = git.Repo(self.path)
            repo.index.add(['README.md'])
            repo.index.commit("Initial commit")

    def _create_anchor_event(self):
        anchor = self.env['git.repository.anchor']
        event = anchor.create_anchor_event(self.path, self.maintainer_ids.mapped('nostr_public_key'))
        self.env['nostr.event'].create_and_publish(event)
        self.anchor_event_id = self.env['nostr.event'].search([('event_id', '=', event.id)], limit=1).id

    def update_maintainers(self):
        anchor = self.env['git.repository.anchor']
        event = anchor.update_anchor(self.path, self.maintainer_ids.mapped('nostr_public_key'))
        self.env['nostr.event'].create_and_publish(event)
        self.anchor_event_id = self.env['nostr.event'].search([('event_id', '=', event.id)], limit=1).id

    def fork_repository(self, new_name, new_path, new_maintainer_ids):
        anchor = self.env['git.repository.anchor']
        new_maintainers = self.env['res.users'].browse(new_maintainer_ids).mapped('nostr_public_key')
        event = anchor.fork_repository(self.path, new_path, new_maintainers)
        self.env['nostr.event'].create_and_publish(event)
        
        new_repo = self.create({
            'name': new_name,
            'path': new_path,
            'maintainer_ids': [(6, 0, new_maintainer_ids)],
        })
        new_repo.anchor_event_id = self.env['nostr.event'].search([('event_id', '=', event.id)], limit=1).id
        
        # Clone the repository
        git.Repo.clone_from(self.path, new_path)
        
        return new_repo

    def check_permission(self, user_id):
        user = self.env['res.users'].browse(user_id)
        anchor = self.env['git.repository.anchor']
        return anchor.check_permission(self.anchor_event_id, user.nostr_public_key)
=== ./odoo_custom_addons/git_repository_anchor/models/__init__.py ===
from . import repository_anchor
from . import branch_manager
from . import odoo_models
from . import git_repository
from . import nostr_event
=== ./odoo_custom_addons/git_repository_anchor/models/repository_anchor.py ===
from odoo import models, fields, api, _
from odoo.exceptions import UserError
from nostr.event import Event
from nostr.key import PrivateKey
import json
import os
import logging
import time
from functools import wraps  # Add this import

_logger = logging.getLogger(__name__)

def log_execution_time(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        _logger.info(f"{func.__name__} executed in {end_time - start_time:.2f} seconds")
        return result
    return wrapper

class RepositoryAnchor(models.AbstractModel):
    _name = 'git.repository.anchor'
    _description = 'Git Repository Anchor'

    @api.model
    def _get_private_key(self):
        # In practice, you'd retrieve this securely
        return PrivateKey()

    @log_execution_time
    def create_anchor_event(self, repo_path, maintainers):
        _logger.info(f"Creating anchor event for repository: {repo_path}")
        start_time = time.time()

        private_key = self._get_private_key()
        content = json.dumps({
            "action": "create_repository",
            "repo_name": os.path.basename(repo_path),
            "maintainers": maintainers
        })
        event = Event(
            kind=31228,
            content=content,
            tags=[['r', repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)

        end_time = time.time()
        _logger.info(f"Anchor event created in {end_time - start_time:.2f} seconds")
        return event

    def update_anchor(self, repo_path, maintainers):
        _logger.info(f"Updating anchor for repository: {repo_path}")
        start_time = time.time()

        private_key = self._get_private_key()
        content = json.dumps({
            "action": "update_repository",
            "repo_name": os.path.basename(repo_path),
            "maintainers": maintainers
        })
        event = Event(
            kind=31228,
            content=content,
            tags=[['r', repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)

        end_time = time.time()
        _logger.info(f"Anchor updated in {end_time - start_time:.2f} seconds")
        return event

    def resolve_repository_state(self, anchor_event):
        _logger.info("Resolving repository state from anchor event")
        start_time = time.time()

        try:
            content = json.loads(anchor_event.content)
            state = {
                "repo_name": content["repo_name"],
                "maintainers": content["maintainers"]
            }
        except json.JSONDecodeError as e:
            _logger.error(f"Error decoding anchor event content: {str(e)}")
            raise UserError(_("Invalid anchor event content"))
        except KeyError as e:
            _logger.error(f"Missing key in anchor event content: {str(e)}")
            raise UserError(_("Incomplete anchor event content"))

        end_time = time.time()
        _logger.info(f"Repository state resolved in {end_time - start_time:.2f} seconds")
        return state

    def list_maintainers(self, anchor_event):
        _logger.info("Listing maintainers from anchor event")
        start_time = time.time()

        try:
            content = json.loads(anchor_event.content)
            maintainers = content["maintainers"]
        except json.JSONDecodeError as e:
            _logger.error(f"Error decoding anchor event content: {str(e)}")
            raise UserError(_("Invalid anchor event content"))
        except KeyError:
            _logger.error("Maintainers key not found in anchor event content")
            raise UserError(_("Incomplete anchor event content"))

        end_time = time.time()
        _logger.info(f"Maintainers listed in {end_time - start_time:.2f} seconds")
        return maintainers

    def check_permission(self, anchor_event, public_key):
        _logger.info(f"Checking permission for public key: {public_key}")
        start_time = time.time()

        maintainers = self.list_maintainers(anchor_event)
        has_permission = public_key in maintainers

        end_time = time.time()
        _logger.info(f"Permission check completed in {end_time - start_time:.2f} seconds")
        return has_permission

    def fork_repository(self, original_repo_path, new_repo_path, new_maintainers):
        _logger.info(f"Forking repository from {original_repo_path} to {new_repo_path}")
        start_time = time.time()

        private_key = self._get_private_key()
        content = json.dumps({
            "action": "fork_repository",
            "original_repo": original_repo_path,
            "new_repo": new_repo_path,
            "maintainers": new_maintainers
        })
        event = Event(
            kind=31228,
            content=content,
            tags=[['r', new_repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)

        end_time = time.time()
        _logger.info(f"Repository forked in {end_time - start_time:.2f} seconds")
        return event
=== ./odoo_custom_addons/git_repository_anchor/models/nostr_event.py ===
# File: /opt/odoo/custom_addons/git_repository_anchor/models/nostr_event.py

from odoo import models, fields, api, _
from odoo.exceptions import UserError
from nostr.event import Event as NostrLibEvent
from nostr.key import PrivateKey
import json
import time
import logging

_logger = logging.getLogger(__name__)

class NostrEvent(models.Model):
    _name = 'nostr.event'
    _description = 'Nostr Event'

    name = fields.Char(string='Name', required=True)
    event_id = fields.Char(string='Event ID', readonly=True)
    kind = fields.Integer(string='Event Kind', required=True)
    content = fields.Text(string='Content')
    tags = fields.Text(string='Tags')
    public_key = fields.Char(string='Public Key', readonly=True)
    created_at = fields.Integer(string='Created At', readonly=True)
    signature = fields.Char(string='Signature', readonly=True)
    published = fields.Boolean(string='Published', default=False)
    event_type = fields.Selection([
        ('commit', 'Commit'),
        ('branch', 'Branch'),
        ('tree', 'Tree'),
        ('blob', 'Blob'),
    ], string='Event Type')
    repository_id = fields.Many2one('git.repository', string='Related Repository')

    @api.model
    def create(self, vals):
        try:
            # Generate a new private key for this event
            private_key = PrivateKey()
            public_key = private_key.public_key.hex()
            
            created_at = int(time.time())
            tags = json.loads(vals.get('tags', '[]'))
            
            event = NostrLibEvent(
                kind=vals['kind'],
                content=vals.get('content', ''),
                tags=tags,
                pub_key=public_key,
                created_at=created_at
            )
            
            # Sign the event
            private_key.sign_event(event)
            
            # Update vals with generated data
            vals.update({
                'event_id': event.id,
                'public_key': public_key,
                'created_at': created_at,
                'signature': event.sig
            })
            
            _logger.info(f"Created Nostr event: {event.id}")
        except Exception as e:
            _logger.error(f"Error creating Nostr event: {str(e)}")
            raise UserError(_("Failed to create Nostr event: %s") % str(e))
        
        return super(NostrEvent, self).create(vals)

    @api.model
    def create_and_publish(self, event):
        vals = {
            'name': f"Event {event.id[:8]}",  # Use first 8 characters of event ID as name
            'event_id': event.id,
            'kind': event.kind,
            'content': event.content,
            'tags': json.dumps(event.tags),
            'public_key': event.public_key,
            'created_at': event.created_at,
            'signature': event.sig,
        }
        nostr_event = self.create(vals)
        # Here you would typically publish the event to Nostr relays
        # For demonstration purposes, we'll just log it
        _logger.info(f"Published Nostr event: {event.to_message()}")
        return nostr_event
=== ./odoo_custom_addons/git_repository_anchor/models/odoo_models.py ===
from odoo import models, fields, api
import logging

_logger = logging.getLogger(__name__)

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Repository Name', required=True)
    path = fields.Char(string='Repository Path', required=True)
    description = fields.Text(string='Description')
    maintainer_ids = fields.Many2many('res.users', string='Maintainers')
    created_at = fields.Datetime(string='Created At', default=fields.Datetime.now)
    last_updated = fields.Datetime(string='Last Updated', default=fields.Datetime.now)
    branch_ids = fields.One2many('git.branch', 'repository_id', string='Branches')

    @api.model
    def fields_get(self, allfields=None, attributes=None):
        res = super(GitRepository, self).fields_get(allfields, attributes)
        _logger.info(f"Fields in GitRepository model: {res.keys()}")
        return res

    @api.model
    def search_read(self, domain=None, fields=None, offset=0, limit=None, order=None):
        _logger.info(f"Search_read called with fields: {fields}")
        return super(GitRepository, self).search_read(domain=domain, fields=fields, offset=offset, limit=limit, order=order)

    def read(self, fields=None, load='_classic_read'):
        _logger.info(f"Read called with fields: {fields}")
        return super(GitRepository, self).read(fields=fields, load=load)

    @api.model
    def create(self, vals):
        repo = super(GitRepository, self).create(vals)
        repo._create_default_branch()
        return repo

    def _create_default_branch(self):
        self.env['git.branch'].create({
            'name': 'main',
            'repository_id': self.id,
            'head': 'initial commit',
        })

class GitBranch(models.Model):
    _name = 'git.branch'
    _description = 'Git Branch'

    name = fields.Char(string='Branch Name', required=True)
    repository_id = fields.Many2one('git.repository', string='Repository', required=True)
    head = fields.Char(string='Head Commit', required=True)

class GitEvent(models.Model):
    _name = 'git.event'
    _description = 'Git Event'

    event_type = fields.Selection([
        ('create_repository', 'Create Repository'),
        ('update_repository', 'Update Repository'),
        ('fork_repository', 'Fork Repository'),
        ('create_branch', 'Create Branch'),
        ('update_branch', 'Update Branch'),
        ('delete_branch', 'Delete Branch')
    ], string='Event Type')
    content = fields.Text(string='Event Content')
    created_at = fields.Datetime(string='Created At', default=fields.Datetime.now)

class GitRepositoryManager(models.Model):
    _name = 'git.repository.manager'
    _description = 'Git Repository Manager'

    @api.model
    def create_repository(self, name, path, description, maintainer_ids):
        anchor = self.env['git.repository.anchor']
        repo = anchor.create_repository(name, path, description, maintainer_ids)
        return repo.id

    @api.model
    def update_repository(self, repo_id, description=None, maintainer_ids=None):
        anchor = self.env['git.repository.anchor']
        repo = self.env['git.repository'].browse(repo_id)
        updated_repo = anchor.update_repository(repo, description, maintainer_ids)
        return updated_repo.id

    @api.model
    def fork_repository(self, original_repo_id, new_name, new_maintainer_id):
        anchor = self.env['git.repository.anchor']
        original_repo = self.env['git.repository'].browse(original_repo_id)
        forked_repo = anchor.fork_repository(original_repo, new_name, new_maintainer_id)
        return forked_repo.id

    @api.model
    def list_maintainers(self, repo_id):
        anchor = self.env['git.repository.anchor']
        repo = self.env['git.repository'].browse(repo_id)
        maintainers = anchor.list_maintainers(repo)
        return maintainers.ids
=== ./odoo_custom_addons/git_repository_anchor/models/branch_manager.py ===
from odoo import models, fields, api
from .repository_anchor import log_execution_time
from git import Repo, GitCommandError
import json
from nostr.event import Event
from nostr.key import PrivateKey
import logging

_logger = logging.getLogger(__name__)

class BranchManager(models.AbstractModel):
    _name = 'ivcs.branch.manager'
    _description = 'IVCS Branch Manager'

    name = fields.Char(string='Name', required=True)
    item_id = fields.Many2one('ivcs.item', string='IVCS Item', required=True)

    @api.model
    @log_execution_time
    def create_branch(self, repository_id, name, head):
        repo = self.env['git.repository'].browse(repository_id)
        branch = self.env['git.branch'].create({
            'name': name,
            'repository_id': repository_id,
            'head': head,
        })
        self._create_event('create_branch', branch)
        return branch.id

    @api.model
    @log_execution_time
    def update_branch(self, branch_id, new_head):
        branch = self.env['git.branch'].browse(branch_id)
        branch.write({'head': new_head})
        self._create_event('update_branch', branch)
        return branch.id

    @api.model
    @log_execution_time
    def delete_branch(self, branch_id):
        branch = self.env['git.branch'].browse(branch_id)
        self._create_event('delete_branch', branch)
        branch.unlink()
        return True

    @api.model
    def _create_event(self, event_type, branch):
        self.env['git.event'].create({
            'event_type': event_type,
            'content': f"{event_type}: {branch.name} in {branch.repository_id.name}",
        })
=== ./odoo_custom_addons/git_repository_anchor/__init__.py ===
from . import models
from . import controllers
=== ./odoo_custom_addons/git_repository_anchor/__manifest__.py ===
{
    'name': 'Git Repository Anchor',
    'version': '1.0',
    'category': 'Development',
    'summary': 'Manage Git repositories using Nostr events',
    'author': 'Your Name',
    'website': 'https://www.example.com',
    'depends': ['base', 'mail'],
    'data': [
        'security/git_repository_security.xml',
        'security/ir.model.access.csv',
        'views/git_repository_views.xml',
        'views/nostr_event_views.xml',
    ],
    'installable': True,
    'application': True,
    'auto_install': False,
    'external_dependencies': {
        'python': ['git', 'nostr'],
    },
}
=== ./odoo_custom_addons/git_repository_anchor/security/git_repository_security.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="module_category_git_repository" model="ir.module.category">
        <field name="name">Git Repository</field>
        <field name="description">Manage Git repositories</field>
        <field name="sequence">20</field>
    </record>

    <record id="group_git_repository_user" model="res.groups">
        <field name="name">User</field>
        <field name="category_id" ref="module_category_git_repository"/>
    </record>

    <record id="group_git_repository_manager" model="res.groups">
        <field name="name">Manager</field>
        <field name="category_id" ref="module_category_git_repository"/>
        <field name="implied_ids" eval="[(4, ref('group_git_repository_user'))]"/>
        <field name="users" eval="[(4, ref('base.user_root')), (4, ref('base.user_admin'))]"/>
    </record>
</odoo>
=== ./odoo_custom_addons/git_repository_anchor/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_git_repository_user,git.repository user,model_git_repository,group_git_repository_user,1,0,0,0
access_git_repository_manager,git.repository manager,model_git_repository,group_git_repository_manager,1,1,1,1
access_git_branch_user,git.branch user,model_git_branch,group_git_repository_user,1,1,1,0
access_git_branch_manager,git.branch manager,model_git_branch,group_git_repository_manager,1,1,1,1
access_git_event_user,git.event user,model_git_event,group_git_repository_user,1,0,0,0
access_git_event_manager,git.event manager,model_git_event,group_git_repository_manager,1,1,1,1
access_git_repository_manager_user,git.repository.manager user,model_git_repository_manager,group_git_repository_user,1,1,1,0
access_git_repository_manager_manager,git.repository.manager manager,model_git_repository_manager,group_git_repository_manager,1,1,1,1
access_nostr_event_user,nostr.event user,model_nostr_event,group_git_repository_user,1,0,0,0
access_nostr_event_manager,nostr.event manager,model_nostr_event,group_git_repository_manager,1,1,1,1
access_git_repository_user,git.repository user,model_git_repository,base.group_user,1,1,1,0
access_git_repository_manager,git.repository manager,model_git_repository,base.group_system,1,1,1,1
access_nostr_event_user,nostr.event user,model_nostr_event,base.group_user,1,0,0,0
access_nostr_event_manager,nostr.event manager,model_nostr_event,base.group_system,1,1,1,1
=== ./odoo_custom_addons/git_repository_anchor/security/oldgit_repository_security.xml.txt ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="module_category_git_repository" model="ir.module.category">
        <field name="name">Git Repository</field>
        <field name="description">Manage Git repositories</field>
        <field name="sequence">20</field>
    </record>

    <record id="group_git_repository_user" model="res.groups">
        <field name="name">User</field>
        <field name="category_id" ref="module_category_git_repository"/>
    </record>

    <record id="group_git_repository_manager" model="res.groups">
        <field name="name">Manager</field>
        <field name="category_id" ref="module_category_git_repository"/>
        <field name="implied_ids" eval="[(4, ref('group_git_repository_user'))]"/>
        <field name="users" eval="[(4, ref('base.user_root')), (4, ref('base.user_admin'))]"/>
    </record>

    <record id="git_repository_comp_rule" model="ir.rule">
        <field name="name">Git Repository multi-company</field>
        <field name="model_id" ref="model_git_repository"/>
        <field name="global" eval="True"/>
        <field name="domain_force">['|', ('company_id', '=', False), ('company_id', 'in', company_ids)]</field>
    </record>
</odoo>
=== ./odoo_custom_addons/git_repository_anchor/tests/test_repository_anchor.py ===
from odoo.tests.common import TransactionCase
from odoo.exceptions import AccessError

class TestRepositoryAnchor(TransactionCase):

    def setUp(self):
        super(TestRepositoryAnchor, self).setUp()
        self.repo_manager = self.env['git.repository.manager'].sudo()
        self.user_admin = self.env.ref('base.user_admin')
        self.user_demo = self.env.ref('base.user_demo')

    def test_create_repository(self):
        repo_id = self.repo_manager.create_repository(
            "test-repo", "/path/to/test-repo", "Test repository", [self.user_admin.id]
        )
        repo = self.env['git.repository'].browse(repo_id)
        self.assertEqual(repo.name, "test-repo")
        self.assertEqual(repo.path, "/path/to/test-repo")
        self.assertEqual(repo.description, "Test repository")
        self.assertIn(self.user_admin, repo.maintainer_ids)
        self.assertEqual(len(repo.branch_ids), 1)
        self.assertEqual(repo.branch_ids[0].name, 'main')

    def test_update_repository(self):
        repo_id = self.repo_manager.create_repository(
            "test-repo", "Test repository", [self.user_admin.id]
        )
        updated_repo_id = self.repo_manager.update_repository(
            repo_id, "Updated description", [self.user_admin.id, self.user_demo.id]
        )
        repo = self.env['git.repository'].browse(updated_repo_id)
        self.assertEqual(repo.description, "Updated description")
        self.assertIn(self.user_demo, repo.maintainer_ids)

    def test_fork_repository(self):
        original_repo_id = self.repo_manager.create_repository(
            "original-repo", "Original repository", [self.user_admin.id]
        )
        forked_repo_id = self.repo_manager.fork_repository(
            original_repo_id, "forked-repo", self.user_demo.id
        )
        forked_repo = self.env['git.repository'].browse(forked_repo_id)
        self.assertEqual(forked_repo.name, "forked-repo")
        self.assertIn(self.user_demo, forked_repo.maintainer_ids)
        self.assertEqual(len(forked_repo.branch_ids), 1)
        self.assertEqual(forked_repo.branch_ids[0].name, 'main')

    def test_list_maintainers(self):
        repo_id = self.repo_manager.create_repository(
            "test-repo", "Test repository", [self.user_admin.id, self.user_demo.id]
        )
        maintainer_ids = self.repo_manager.list_maintainers(repo_id)
        self.assertIn(self.user_admin.id, maintainer_ids)
        self.assertIn(self.user_demo.id, maintainer_ids)

    def test_access_rights(self):
        repo_id = self.repo_manager.create_repository(
            "test-repo", "Test repository", [self.user_admin.id]
        )
        
        # Test that non-maintainer can't update the repository
        with self.assertRaises(AccessError):
            self.repo_manager.with_user(self.user_demo).update_repository(
                repo_id, "Unauthorized update"
            )

        # Test that maintainer can update the repository
        self.repo_manager.with_user(self.user_admin).update_repository(
            repo_id, "Authorized update"
        )
        repo = self.env['git.repository'].browse(repo_id)
        self.assertEqual(repo.description, "Authorized update")
=== ./odoo_custom_addons/git_repository_anchor/tests/__init__.py ===
from . import test_repository_anchor
=== ./odoo_custom_addons/git_repository_anchor/data/README.md ===
# Git Repository Anchor

This Odoo module provides a system for managing Git repositories using Nostr events. It allows users to create, update, and fork repositories, as well as manage branches and maintainers.

## Features

- Create, update, and fork Git repositories
- Manage repository maintainers
- Create and manage branches
- Log all actions as Nostr events
- Odoo views for easy management through the UI
- CLI for standalone usage

## Installation

1. Place the `git_repository_anchor` directory in your Odoo addons path.
2. Update your Odoo apps list.
3. Install the "Git Repository Anchor" module from the Odoo Apps menu.

## Usage

### Through Odoo Interface

1. Navigate to the "Git Repositories" menu item.
2. Use the provided views to manage repositories, branches, and maintainers.

### Using CLI

A CLI script is provided for standalone usage. Example usage:

```bash
python cli_script.py create --name "New Repo" --description "A new repository" --maintainers 1 2
python cli_script.py update --repo-id 1 --description "Updated description"
python cli_script.py fork --original-repo-id 1 --new-name "Forked Repo"
=== ./odoo_custom_addons/git_repository_anchor/data/git_repository_data.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <!-- Example repository data -->
        <record id="git_repository_example" model="git.repository">
            <field name="name">Example Repository</field>
            <field name="path">/path/to/example-repo</field>
            <field name="description">This is an example repository created during module installation.</field>
            <field name="maintainer_ids" eval="[(4, ref('base.user_admin'))]"/>
        </record>
    </data>
</odoo>
=== ./odoo_custom_addons/git_repository_anchor/views/nostr_event_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_nostr_event_form" model="ir.ui.view">
        <field name="name">nostr.event.form</field>
        <field name="model">nostr.event</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="event_id" readonly="1"/>
                        <field name="kind"/>
                        <field name="content"/>
                        <field name="tags"/>
                        <field name="public_key" readonly="1"/>
                        <field name="created_at" readonly="1"/>
                        <field name="signature" readonly="1"/>
                        <field name="published"/>
                        <field name="event_type"/>
                        <field name="repository_id"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_nostr_event_tree" model="ir.ui.view">
        <field name="name">nostr.event.tree</field>
        <field name="model">nostr.event</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="event_id"/>
                <field name="kind"/>
                <field name="event_type"/>
                <field name="repository_id"/>
                <field name="public_key"/>
                <field name="created_at"/>
                <field name="published"/>
            </tree>
        </field>
    </record>

    <record id="action_nostr_event" model="ir.actions.act_window">
        <field name="name">Nostr Events</field>
        <field name="res_model">nostr.event</field>
        <field name="view_mode">tree,form</field>
    </record>

    <!-- Menu item for Nostr Events -->
    <menuitem id="menu_nostr_event"
              name="Nostr Events"
              parent="menu_git_nostr_bridge_root"
              action="action_nostr_event"
              sequence="20"/>
</odoo>
=== ./odoo_custom_addons/git_repository_anchor/views/git_repository_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_repository_form" model="ir.ui.view">
        <field name="name">git.repository.form</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="path"/>
                        <field name="description"/>
                    </group>
                </sheet>
                <div class="oe_chatter">
                    <field name="message_follower_ids" widget="mail_followers"/>
                    <field name="message_ids" widget="mail_thread"/>
                </div>
            </form>
        </field>
    </record>

    <record id="view_git_repository_tree" model="ir.ui.view">
        <field name="name">git.repository.tree</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="path"/>
            </tree>
        </field>
    </record>

    <record id="action_git_repository" model="ir.actions.act_window">
        <field name="name">Git Repositories</field>
        <field name="res_model">git.repository</field>
        <field name="view_mode">tree,form</field>
    </record>

    <!-- Root menu for the module -->
    <menuitem id="menu_git_nostr_bridge_root"
              name="Git Repository Anchor"
              sequence="10"/>

    <!-- Submenu for Git Repositories -->
    <menuitem id="menu_git_repository"
              name="Git Repositories"
              parent="menu_git_nostr_bridge_root"
              action="action_git_repository"
              sequence="10"/>
</odoo>
=== ./odoo_custom_addons/git_repository_anchor/views/repository_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data>
        <!-- Repository Form View -->
        <record id="view_git_repository_form" model="ir.ui.view">
            <field name="name">git.repository.form</field>
            <field name="model">git.repository</field>
            <field name="arch" type="xml">
                <form string="Git Repository">
                    <sheet>
                        <group>
                            <field name="name"/>
                            <field name="path"/>
                            <field name="description"/>
                            <field name="maintainer_ids" widget="many2many_tags"/>
                            <field name="created_at"/>
                            <field name="last_updated"/>
                        </group>
                        <notebook>
                            <page string="Branches">
                                <field name="branch_ids">
                                    <tree editable="bottom">
                                        <field name="name"/>
                                        <field name="head"/>
                                    </tree>
                                </field>
                            </page>
                        </notebook>
                    </sheet>
                </form>
            </field>
        </record>

        <!-- Repository Tree View -->
        <record id="view_git_repository_tree" model="ir.ui.view">
            <field name="name">git.repository.tree</field>
            <field name="model">git.repository</field>
            <field name="arch" type="xml">
                <tree string="Git Repositories">
                    <field name="name"/>
                    <field name="path"/>
                    <field name="description"/>
                    <field name="created_at"/>
                    <field name="last_updated"/>
                </tree>
            </field>
        </record>

        <!-- Repository Search View -->
        <record id="view_git_repository_search" model="ir.ui.view">
            <field name="name">git.repository.search</field>
            <field name="model">git.repository</field>
            <field name="arch" type="xml">
                <search string="Search Repositories">
                    <field name="name"/>
                    <field name="path"/>
                    <field name="description"/>
                    <field name="maintainer_ids"/>
                    <filter string="My Repositories" name="my_repositories" domain="[('maintainer_ids', 'in', uid)]"/>
                    <group expand="0" string="Group By">
                        <filter string="Created Date" name="group_by_created_at" context="{'group_by': 'created_at:month'}"/>
                    </group>
                </search>
            </field>
        </record>

        <!-- Repository Action -->
        <record id="action_git_repository" model="ir.actions.act_window">
            <field name="name">Git Repositories</field>
            <field name="res_model">git.repository</field>
            <field name="view_mode">tree,form</field>
            <field name="search_view_id" ref="view_git_repository_search"/>
        </record>

        <!-- Menu Items -->
        <menuitem id="menu_git_repository_root" name="Git Repositories" sequence="10"/>
        <menuitem id="menu_git_repository" parent="menu_git_repository_root" action="action_git_repository" sequence="10"/>
    </data>
</odoo>
=== ./odoo_custom_addons/git_repository_anchor/controllers/__init__.py ===
from . import main
=== ./odoo_custom_addons/git_repository_anchor/controllers/main.py ===
from odoo import http
from odoo.http import request

class GitRepositoryController(http.Controller):
    @http.route('/git/repository/create', type='json', auth='user')
    def create_repository(self, name, path, description, maintainer_ids):
        repo_manager = request.env['git.repository.manager'].sudo()
        repo_id = repo_manager.create_repository(name, path, description, maintainer_ids)
        return {'success': True, 'repository_id': repo_id}

    @http.route('/git/repository/update', type='json', auth='user')
    def update_repository(self, repo_id, description=None, maintainer_ids=None):
        repo_manager = request.env['git.repository.manager'].sudo()
        updated_repo_id = repo_manager.update_repository(repo_id, description, maintainer_ids)
        return {'success': True, 'repository_id': updated_repo_id}

    @http.route('/git/repository/fork', type='json', auth='user')
    def fork_repository(self, original_repo_id, new_name):
        repo_manager = request.env['git.repository.manager'].sudo()
        forked_repo_id = repo_manager.fork_repository(original_repo_id, new_name, request.env.user.id)
        return {'success': True, 'repository_id': forked_repo_id}

    @http.route('/git/repository/list_maintainers', type='json', auth='user')
    def list_maintainers(self, repo_id):
        repo_manager = request.env['git.repository.manager'].sudo()
        maintainer_ids = repo_manager.list_maintainers(repo_id)
        return {'success': True, 'maintainer_ids': maintainer_ids}
=== ./odoo_custom_addons/git_branch_manager/git-branch-manager-module.py ===
# Directory structure:
# git_branch_manager/
# ├── __init__.py
# ├── __manifest__.py
# ├── models/
# │   ├── __init__.py
# │   ├── branch.py
# │   ├── event.py
# │   └── branch_manager.py
# ├── controllers/
# │   ├── __init__.py
# │   └── main.py
# ├── security/
# │   └── ir.model.access.csv
# └── views/
#     ├── branch_views.xml
#     └── event_views.xml

# __init__.py
from . import models
from . import controllers

# __manifest__.py
{
    'name': 'Git Branch Manager',
    'version': '1.0',
    'summary': 'Manage Git branches using Nostr events',
    'description': """
    This module allows you to manage Git branches using Nostr events.
    It integrates with the Nostr-Odoo application to handle branch operations.
    """,
    'author': 'Your Name',
    'depends': ['base'],
    'data': [
        'security/ir.model.access.csv',
        'views/branch_views.xml',
        'views/event_views.xml',
    ],
    'installable': True,
    'application': True,
}

# models/__init__.py
from . import branch
from . import event
from . import branch_manager

# models/branch.py
from odoo import models, fields

class GitBranch(models.Model):
    _name = 'git.branch'
    _description = 'Git Branch'

    name = fields.Char(string='Branch Name', required=True)
    head = fields.Char(string='Head Commit', required=True)
    created_at = fields.Datetime(string='Created At')
    last_updated = fields.Datetime(string='Last Updated')

# models/event.py
from odoo import models, fields

class GitEvent(models.Model):
    _name = 'git.event'
    _description = 'Git Event'

    event_type = fields.Selection([('create', 'Create'), ('update', 'Update'), ('delete', 'Delete')], string='Event Type')
    content = fields.Text(string='Event Content')
    created_at = fields.Datetime(string='Created At', default=fields.Datetime.now)

# models/branch_manager.py
from odoo import models, api
from nostr.event import Event
from nostr.key import PrivateKey
import json
import logging
import time

_logger = logging.getLogger(__name__)

class GitBranchManager(models.AbstractModel):
    _name = 'git.branch.manager'
    _description = 'Git Branch Manager'

    @api.model
    def create_branch(self, name, head):
        _logger.info(f"Creating branch: {name} with head: {head}")
        start_time = time.time()

        try:
            if self.env['git.branch'].search([('name', '=', name)]):
                raise ValueError(f"Branch {name} already exists")

            branch = self.env['git.branch'].create({
                'name': name,
                'head': head,
                'created_at': fields.Datetime.now(),
                'last_updated': fields.Datetime.now(),
            })

            event = self._create_branch_event(branch, 'create')
            self._publish_event(event)

            end_time = time.time()
            _logger.info(f"Branch {name} created in {end_time - start_time:.2f} seconds")
            return True
        except Exception as e:
            _logger.exception(f"Error creating branch: {str(e)}")
            raise

    @api.model
    def update_branch(self, name, new_head):
        _logger.info(f"Updating branch: {name} to new head: {new_head}")
        start_time = time.time()

        try:
            branch = self.env['git.branch'].search([('name', '=', name)])
            if not branch:
                raise ValueError(f"Branch {name} does not exist")

            branch.write({
                'head': new_head,
                'last_updated': fields.Datetime.now(),
            })

            event = self._create_branch_event(branch, 'update')
            self._publish_event(event)

            end_time = time.time()
            _logger.info(f"Branch {name} updated in {end_time - start_time:.2f} seconds")
            return True
        except Exception as e:
            _logger.exception(f"Error updating branch: {str(e)}")
            raise

    @api.model
    def delete_branch(self, name):
        _logger.info(f"Deleting branch: {name}")
        start_time = time.time()

        try:
            branch = self.env['git.branch'].search([('name', '=', name)])
            if not branch:
                raise ValueError(f"Branch {name} does not exist")

            event = self._create_branch_event(branch, 'delete')
            branch.unlink()
            self._publish_event(event)

            end_time = time.time()
            _logger.info(f"Branch {name} deleted in {end_time - start_time:.2f} seconds")
            return True
        except Exception as e:
            _logger.exception(f"Error deleting branch: {str(e)}")
            raise

    def _create_branch_event(self, branch, operation):
        event = Event()
        event.kind = 31227  # Custom event kind for git branch operations
        event.content = json.dumps({
            'operation': operation,
            'name': branch.name,
            'head': branch.head,
            'timestamp': fields.Datetime.now().isoformat(),
        })
        event.tags = [['e', 'git_branch']]

        private_key = PrivateKey()  # In practice, securely store and retrieve this
        event.sign(private_key.hex())

        return event

    def _publish_event(self, event):
        self.env['git.event'].create({
            'event_type': json.loads(event.content)['operation'],
            'content': event.to_message(),
        })
        # Here you would also publish the event to the Nostr network
        # This part depends on how you've implemented your Nostr client in Odoo

# controllers/__init__.py
from . import main

# controllers/main.py
from odoo import http
from odoo.http import request

class GitBranchController(http.Controller):

    @http.route('/git/branch/create', type='json', auth='user')
    def create_branch(self, name, head):
        branch_manager = request.env['git.branch.manager'].sudo()
        result = branch_manager.create_branch(name, head)
        return {'success': result}

    @http.route('/git/branch/update', type='json', auth='user')
    def update_branch(self, name, new_head):
        branch_manager = request.env['git.branch.manager'].sudo()
        result = branch_manager.update_branch(name, new_head)
        return {'success': result}

    @http.route('/git/branch/delete', type='json', auth='user')
    def delete_branch(self, name):
        branch_manager = request.env['git.branch.manager'].sudo()
        result = branch_manager.delete_branch(name)
        return {'success': result}

# security/ir.model.access.csv
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_git_branch_user,access_git_branch_user,model_git_branch,,1,1,1,1
access_git_event_user,access_git_event_user,model_git_event,,1,1,1,1

# views/branch_views.xml
<?xml version="1.0" encoding="UTF-8"?>
<odoo>
    <record id="view_git_branch_form" model="ir.ui.view">
        <field name="name">git.branch.form</field>
        <field name="model">git.branch</field>
        <field name="arch" type="xml">
            <form string="Git Branch">
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="head"/>
                        <field name="created_at"/>
                        <field name="last_updated"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_git_branch_tree" model="ir.ui.view">
        <field name="name">git.branch.tree</field>
        <field name="model">git.branch</field>
        <field name="arch" type="xml">
            <tree string="Git Branches">
                <field name="name"/>
                <field name="head"/>
                <field name="created_at"/>
                <field name="last_updated"/>
            </tree>
        </field>
    </record>

    <record id="action_git_branch" model="ir.actions.act_window">
        <field name="name">Branches</field>
        <field name="res_model">git.branch</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_git_branch_root" name="Git Branches" sequence="10"/>
    <menuitem id="menu_git_branch" parent="menu_git_branch_root"
              action="action_git_branch" sequence="10"/>
</odoo>

# views/event_views.xml
<?xml version="1.0" encoding="UTF-8"?>
<odoo>
    <record id="view_git_event_form" model="ir.ui.view">
        <field name="name">git.event.form</field>
        <field name="model">git.event</field>
        <field name="arch" type="xml">
            <form string="Git Event">
                <sheet>
                    <group>
                        <field name="event_type"/>
                        <field name="content"/>
                        <field name="created_at"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_git_event_tree" model="ir.ui.view">
        <field name="name">git.event.tree</field>
        <field name="model">git.event</field>
        <field name="arch" type="xml">
            <tree string="Git Events">
                <field name="event_type"/>
                <field name="content"/>
                <field name="created_at"/>
            </tree>
        </field>
    </record>

    <record id="action_git_event" model="ir.actions.act_window">
        <field name="name">Events</field>
        <field name="res_model">git.event</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_git_events" parent="menu_git_branch_root"
              action="action_git_event" sequence="20"/>
</odoo>
=== ./odoo_custom_addons/nostr_auth/models/__init__.py ===
# File: odoo_custom_addons/nostr_auth/models/__init__.py
from . import res_users
from . import nostr_auth_module
=== ./odoo_custom_addons/nostr_auth/models/res_users.py ===
# File: odoo_custom_addons/nostr_auth/models/res_users.py

from odoo import models, fields, api
from odoo.exceptions import ValidationError
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import hashes
import base64

class ResUsers(models.Model):
    _inherit = 'res.users'

    nostr_public_key = fields.Char(string='Nostr Public Key')
    nostr_private_key = fields.Char(string='Nostr Private Key')
    nostr_relay_url = fields.Char(string='Nostr Relay URL')

    @api.model_create_multi
    def create(self, vals_list):
        nostr_auth = self.env['nostr.auth.module']
        for vals in vals_list:
            if not vals.get('nostr_private_key'):
                keys = nostr_auth.generate_keypair()
                vals['nostr_private_key'] = keys['private_key']
                vals['nostr_public_key'] = keys['public_key']
        return super(ResUsers, self).create(vals_list)

    @api.constrains('nostr_public_key')
    def _check_nostr_public_key(self):
        for user in self:
            if user.nostr_public_key:
                if not user.nostr_public_key.startswith('npub1'):
                    raise ValidationError("Invalid Nostr public key format. It should start with 'npub1'.")

    @api.model
    def authenticate_nostr(self, public_key, signature, message):
        user = self.search([('nostr_public_key', '=', public_key)], limit=1)
        if user:
            nostr_auth = self.env['nostr.auth.module']
            if nostr_auth.verify_signature(public_key, message, signature):
                return user.id
        return False
=== ./odoo_custom_addons/nostr_auth/models/nostr_auth_module.py ===
# File: odoo_custom_addons/nostr_auth/models/nostr_auth_module.py

from odoo import models, api
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.serialization import Encoding, PublicFormat, PrivateFormat, NoEncryption
import base64
from bech32 import bech32_encode, bech32_decode, convertbits

class NostrAuthModule(models.AbstractModel):
    _name = 'nostr.auth.module'
    _description = 'Nostr Authentication Module'

    @api.model
    def generate_keypair(self):
        private_key = ec.generate_private_key(ec.SECP256K1())
        public_key = private_key.public_key()
        
        private_bytes = private_key.private_numbers().private_value.to_bytes(32, 'big')
        public_bytes = public_key.public_bytes(
            encoding=Encoding.X962,
            format=PublicFormat.UncompressedPoint
        )[1:]
        
        return {
            'private_key': self.bytes_to_nsec(private_bytes),
            'public_key': self.bytes_to_npub(public_bytes)
        }

    @api.model
    def verify_signature(self, public_key, message, signature):
        try:
            public_key_bytes = self.npub_to_bytes(public_key)
            public_key_obj = ec.EllipticCurvePublicKey.from_encoded_point(ec.SECP256K1(), b'\x04' + public_key_bytes)
            signature_bytes = base64.b64decode(signature)
            public_key_obj.verify(
                signature_bytes,
                message.encode('utf-8'),
                ec.ECDSA(hashes.SHA256())
            )
            return True
        except:
            return False

    @api.model
    def bytes_to_npub(self, key_bytes):
        data = convertbits(key_bytes[:32], 8, 5)
        return bech32_encode('npub', data)

    @api.model
    def bytes_to_nsec(self, key_bytes):
        data = convertbits(key_bytes[:32], 8, 5)
        return bech32_encode('nsec', data)
        
    @api.model
    def npub_to_bytes(self, npub):
        hrp, data = bech32_decode(npub)
        return bytes(convertbits(data, 5, 8, False))

    @api.model
    def nsec_to_bytes(self, nsec):
        hrp, data = bech32_decode(nsec)
        return bytes(convertbits(data, 5, 8, False))
=== ./odoo_custom_addons/nostr_auth/__init__.py ===
from . import models
=== ./odoo_custom_addons/nostr_auth/__manifest__.py ===
# File: odoo_custom_addons/nostr_auth/__manifest__.py
{
    'name': 'Nostr Authentication',
    'version': '1.0',
    'category': 'Authentication',
    'summary': 'Extends user model with Nostr fields and authentication',
    'depends': ['base', 'auth_signup'],
    'data': [
        'views/res_users_views.xml',
    ],
    'installable': True,
    'application': False,
    'auto_install': False,
    'external_dependencies': {
        'python': ['cryptography', 'bech32'],
    },
}
=== ./odoo_custom_addons/nostr_auth/views/res_users_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_users_form_nostr" model="ir.ui.view">
        <field name="name">res.users.form.nostr</field>
        <field name="model">res.users</field>
        <field name="inherit_id" ref="base.view_users_form"/>
        <field name="arch" type="xml">
            <xpath expr="//page[@name='access_rights']" position="after">
                <page string="Nostr Authentication" name="nostr_auth">
                    <group>
                        <field name="nostr_public_key"/>
                        <field name="nostr_relay_url"/>
                    </group>
                </page>
            </xpath>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons/nostr_auth/controllers/__init__.py ===
from . import main
=== ./odoo_custom_addons/nostr_auth/controllers/main.py ===
# controllers/main.py
from odoo import http
from odoo.http import request
import json

class NostrAuthController(http.Controller):
    @http.route('/web/nostr/authenticate', type='json', auth='none')
    def authenticate(self, public_key, signature, message):
        uid = request.env['res.users'].sudo().authenticate_nostr(public_key, signature, message)
        if uid:
            request.session.authenticate(request.session.db, uid, public_key)
            return {'success': True, 'uid': uid}
        return {'success': False, 'error': 'Authentication failed'}
=== ./odoo_custom_addons/nostr_identity/models/__init__.py ===
# models/__init__.py
from . import nostr_identity
from . import nostr_identity_verifier
from . import nostr_message
=== ./odoo_custom_addons/nostr_identity/models/nostr_identity_verifier.py ===
from odoo import models, fields, api, _
from odoo.exceptions import UserError
import logging
import json
import websocket
import threading
import ssl
import time
from odoo.tools import config

_logger = logging.getLogger(__name__)

class NostrIdentityVerifier(models.Model):
    _name = 'nostr.identity.verifier'
    _description = 'Nostr Identity Verifier'

    name = fields.Char(string='Name', required=True)
    active = fields.Boolean(default=True)
    relay_url = fields.Char(string='Relay URL', required=True)
    websocket_state = fields.Selection([
        ('disconnected', 'Disconnected'),
        ('connecting', 'Connecting'),
        ('connected', 'Connected')
    ], default='disconnected', string='WebSocket State', readonly=True)
    last_error = fields.Text(string='Last Error', readonly=True)

    def _get_ws_connection(self):
        return self.env.context.get('ws_connection')

    def _set_ws_connection(self, ws):
        self = self.with_context(ws_connection=ws)

    def connect_to_relay(self):
        self.ensure_one()
        if self.websocket_state == 'connected':
            return True

        self.websocket_state = 'connecting'
        self.last_error = False

        try:
            ws = self._create_websocket(self.relay_url)
            self._set_ws_connection(ws)
            
            # Wait for connection to establish or fail
            for _ in range(20):  # Wait up to 10 seconds
                if self.websocket_state == 'connected':
                    return True
                elif self.websocket_state == 'disconnected':
                    raise UserError(self.last_error or _("Connection failed"))
                time.sleep(0.5)

            raise UserError(_("Connection timeout"))
        except Exception as e:
            self.websocket_state = 'disconnected'
            self.last_error = str(e)
            _logger.error(f"Failed to connect to {self.relay_url}: {str(e)}")
            return False

    def _create_websocket(self, relay_url):
        def on_message(ws, message):
            with self.pool.cursor() as new_cr:
                self.with_env(self.env(cr=new_cr))._handle_message(message)

        def on_error(ws, error):
            with self.pool.cursor() as new_cr:
                self.with_env(self.env(cr=new_cr))._handle_error(error)

        def on_close(ws, close_status_code, close_msg):
            with self.pool.cursor() as new_cr:
                self.with_env(self.env(cr=new_cr))._handle_close()

        def on_open(ws):
            with self.pool.cursor() as new_cr:
                self.with_env(self.env(cr=new_cr))._handle_open()

        ws = websocket.WebSocketApp(relay_url,
                                    on_message=on_message,
                                    on_error=on_error,
                                    on_close=on_close,
                                    on_open=on_open)

        wst = threading.Thread(target=lambda: ws.run_forever(sslopt={"cert_reqs": ssl.CERT_NONE}))
        wst.daemon = True
        wst.start()

        return ws

    def _handle_message(self, message):
        _logger.info(f"Received message from {self.relay_url}: {message}")
        self.env['nostr.message'].create({
            'verifier_id': self.id,
            'content': message
        })

    def _handle_error(self, error):
        _logger.error(f"WebSocket error for {self.relay_url}: {error}")
        self.write({'last_error': str(error), 'websocket_state': 'disconnected'})

    def _handle_close(self):
        _logger.info(f"WebSocket connection closed for {self.relay_url}")
        self.write({'websocket_state': 'disconnected'})

    def _handle_open(self):
        _logger.info(f"WebSocket connection opened for {self.relay_url}")
        self.write({'websocket_state': 'connected'})

    def publish_event(self, event):
        self.ensure_one()
        if self.websocket_state != 'connected':
            if not self.connect_to_relay():
                raise UserError(_("Failed to connect to relay"))

        try:
            message = json.dumps(["EVENT", event])
            ws = self._get_ws_connection()
            if ws:
                ws.send(message)
                _logger.info(f"Published event to {self.relay_url}")
                return True
            else:
                raise UserError(_("WebSocket connection is not available"))
        except Exception as e:
            _logger.error(f"Failed to publish event to {self.relay_url}: {str(e)}")
            raise UserError(_("Failed to publish event: %s") % str(e))

    @api.model
    def process_messages(self):
        messages = self.env['nostr.message'].search([('processed', '=', False)])
        for message in messages:
            try:
                # Process the message here
                _logger.info(f"Processing message: {message.content}")
                # Add your message processing logic here
                message.write({'processed': True})
            except Exception as e:
                _logger.error(f"Error processing message {message.id}: {str(e)}")

    def close_connection(self):
        self.ensure_one()
        ws = self._get_ws_connection()
        if ws:
            try:
                ws.close()
            except Exception as e:
                _logger.error(f"Error closing WebSocket for {self.relay_url}: {str(e)}")
        self._set_ws_connection(None)
        self.write({'websocket_state': 'disconnected'})
=== ./odoo_custom_addons/nostr_identity/models/nostr_identity.py ===
from odoo import models, fields, api, _
from odoo.exceptions import UserError, ValidationError
import base64
from cryptography.fernet import Fernet
import logging
import secrets
from nostr.key import PrivateKey
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import serialization
import bech32

_logger = logging.getLogger(__name__)

def hex_to_nostr_key(hex_key, prefix):
    # Convert hex to bytes
    data = bytes.fromhex(hex_key)
    
    # Convert to 5-bit words
    words = bech32.convertbits(data, 8, 5)
    
    # Encode with bech32
    encoded = bech32.bech32_encode(prefix, words)
    
    return encoded

class NostrIdentity(models.Model):
    _name = 'nostr.identity'
    _description = 'Nostr Identity'

    name = fields.Char(string='Name', required=True)
    public_key = fields.Char(string='Public Key (hex)', readonly=True)
    private_key = fields.Char(string='Private Key (hex)', readonly=True)
    public_key_bech32 = fields.Char(string='Public Key (npub)', readonly=True, compute='_compute_bech32_keys')
    private_key_bech32 = fields.Char(string='Private Key (nsec)', readonly=True, compute='_compute_bech32_keys')
    relay_urls = fields.Text(string='Relay URLs')
    profile_data = fields.Text(string='Profile Data')

    @api.model
    def create(self, vals):
        if 'public_key' not in vals or 'private_key' not in vals:
            try:
                private_key = PrivateKey()
                public_key = private_key.public_key
                vals['private_key'] = private_key.hex()
                vals['public_key'] = public_key.hex()
            except Exception as e:
                _logger.error(f"Failed to generate Nostr keys: {str(e)}")
                raise UserError(_("Failed to generate Nostr keys: %s") % str(e))
        return super(NostrIdentity, self).create(vals)

    @api.depends('public_key', 'private_key')
    def _compute_bech32_keys(self):
        for record in self:
            if record.public_key:
                record.public_key_bech32 = hex_to_nostr_key(record.public_key, "npub")
            else:
                record.public_key_bech32 = False
            
            if record.private_key:
                record.private_key_bech32 = hex_to_nostr_key(record.private_key, "nsec")
            else:
                record.private_key_bech32 = False

    def get_private_key(self):
        self.ensure_one()
        try:
            encryption_key = self.env['ir.config_parameter'].sudo().get_param('nostr.encryption_key')
            if not encryption_key:
                raise UserError(_("Encryption key not found. Unable to decrypt private key."))
            
            fernet = Fernet(encryption_key.encode())
            decrypted_private_key = fernet.decrypt(base64.b64decode(self.encrypted_private_key))
            return PrivateKey(bytes.fromhex(decrypted_private_key.decode()))
        except Exception as e:
            _logger.error(f"Failed to decrypt private key: {str(e)}")
            raise UserError(_("Failed to decrypt private key: %s") % str(e))

    def get_public_key_bech32(self):
        return self.public_key_bech32
=== ./odoo_custom_addons/nostr_identity/models/nostr_message.py ===
# models/nostr_message.py

from odoo import models, fields

class NostrMessage(models.Model):
    _name = 'nostr.message'
    _description = 'Nostr Message'

    verifier_id = fields.Many2one('nostr.identity.verifier', string='Verifier', required=True, ondelete='cascade')
    content = fields.Text(string='Message Content', required=True)
    processed = fields.Boolean(string='Processed', default=False)
=== ./odoo_custom_addons/nostr_identity/__init__.py ===
# nostr_identity/__init__.py

from . import models
from . import nostr_cleanup

def post_init_hook(cr, registry):
    from odoo import api, SUPERUSER_ID
    env = api.Environment(cr, SUPERUSER_ID, {})
    
    # Generate encryption key if it doesn't exist
    if not env['ir.config_parameter'].get_param('nostr.encryption_key'):
        from cryptography.fernet import Fernet
        encryption_key = Fernet.generate_key()
        env['ir.config_parameter'].set_param('nostr.encryption_key', encryption_key.decode())

def uninstall_hook(cr, registry):
    from odoo import api, SUPERUSER_ID
    env = api.Environment(cr, SUPERUSER_ID, {})
    
    # Remove the encryption key
    env['ir.config_parameter'].set_param('nostr.encryption_key', False)
    
    # Close all active WebSocket connections
    verifiers = env['nostr.identity.verifier'].search([])
    for verifier in verifiers:
        verifier.close_connection()
=== ./odoo_custom_addons/nostr_identity/__manifest__.py ===
# __manifest__.py
{
    'name': 'Nostr Identity Verifier',
    'version': '1.0',
    'category': 'Tools',
    'summary': 'Integrate Nostr identity verification into Odoo',
    'author': 'Your Name',
    'website': 'https://www.example.com',
    'license': 'LGPL-3',
    'depends': ['base', 'mail'],
    'data': [
        'security/nostr_security.xml',
        'security/ir.model.access.csv',
        'views/nostr_identity_views.xml',
        'data/ir_cron_data.xml',
    ],
    'demo': [],
    'external_dependencies': {
        'python': ['websocket-client', 'nostr'],
    },
    'installable': True,
    'application': False,
    'auto_install': False,
    'post_init_hook': 'post_init_hook',
    'uninstall_hook': 'uninstall_hook',
}
=== ./odoo_custom_addons/nostr_identity/nostr_cleanup.py ===
# nostr_identity/nostr_cleanup.py

import atexit
from odoo import api, SUPERUSER_ID

def cleanup_connections():
    try:
        with api.Environment.manage():
            env = api.Environment(odoo.registry(odoo.tools.config['db_name']).cursor(), SUPERUSER_ID, {})
            verifiers = env['nostr.identity.verifier'].search([])
            for verifier in verifiers:
                verifier.close_connection()
            env.cr.commit()
    except Exception as e:
        # Log the error, but don't raise it to avoid interfering with Odoo's shutdown process
        _logger.error(f"Error during Nostr connection cleanup: {e}")
    finally:
        if env and env.cr:
            env.cr.close()

atexit.register(cleanup_connections)
=== ./odoo_custom_addons/nostr_identity/security/nostr_security.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <!-- Rule: Users can only see their own Nostr Identity records -->
        <record id="rule_nostr_identity_users" model="ir.rule">
            <field name="name">Users can only see their own Nostr Identity</field>
            <field name="model_id" ref="model_nostr_identity"/>
            <field name="domain_force">[('create_uid', '=', user.id)]</field>
            <field name="groups" eval="[(4, ref('base.group_user'))]"/>
            <field name="perm_read" eval="True"/>
            <field name="perm_write" eval="False"/>
            <field name="perm_create" eval="False"/>
            <field name="perm_unlink" eval="False"/>
        </record>

        <!-- Rule: Managers can see all Nostr Identity records -->
        <record id="rule_nostr_identity_managers" model="ir.rule">
            <field name="name">Managers can see all Nostr Identity records</field>
            <field name="model_id" ref="model_nostr_identity"/>
            <field name="domain_force">[(1, '=', 1)]</field>
            <field name="groups" eval="[(4, ref('base.group_system'))]"/>
            <field name="perm_read" eval="True"/>
            <field name="perm_write" eval="True"/>
            <field name="perm_create" eval="True"/>
            <field name="perm_unlink" eval="True"/>
        </record>
    </data>
</odoo>
=== ./odoo_custom_addons/nostr_identity/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_nostr_identity_user,nostr.identity user,model_nostr_identity,base.group_user,1,1,1,0
access_nostr_identity_manager,nostr.identity manager,model_nostr_identity,base.group_system,1,1,1,1
access_nostr_identity_verifier_user,nostr.identity.verifier user,model_nostr_identity_verifier,base.group_user,1,0,0,0
access_nostr_identity_verifier_manager,nostr.identity.verifier manager,model_nostr_identity_verifier,base.group_system,1,1,1,1
access_nostr_message_user,nostr.message user,model_nostr_message,base.group_user,1,0,0,0
access_nostr_message_manager,nostr.message manager,model_nostr_message,base.group_system,1,1,1,1
=== ./odoo_custom_addons/nostr_identity/data/ir_cron_data.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <record id="ir_cron_nostr_process_messages" model="ir.cron">
            <field name="name">Nostr: Process Messages</field>
            <field name="model_id" ref="model_nostr_identity_verifier"/>
            <field name="state">code</field>
            <field name="code">model.process_messages()</field>
            <field name="interval_number">5</field>
            <field name="interval_type">minutes</field>
            <field name="numbercall">-1</field>
            <field name="doall" eval="False"/>
            <field name="active" eval="True"/>
        </record>
    </data>
</odoo>
=== ./odoo_custom_addons/nostr_identity/views/nostr_identity_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <!-- Nostr Identity Views -->
    <record id="view_nostr_identity_tree" model="ir.ui.view">
        <field name="name">nostr.identity.tree</field>
        <field name="model">nostr.identity</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="public_key"/>
                <field name="public_key_bech32"/>
            </tree>
        </field>
    </record>

    <record id="view_nostr_identity_form" model="ir.ui.view">
        <field name="name">nostr.identity.form</field>
        <field name="model">nostr.identity</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="public_key"/>
                        <field name="public_key_bech32"/>
                        <field name="relay_urls"/>
                        <field name="profile_data"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <!-- The rest of the XML remains unchanged -->
    <!-- Nostr Identity Verifier Views -->
    <record id="view_nostr_identity_verifier_tree" model="ir.ui.view">
        <field name="name">nostr.identity.verifier.tree</field>
        <field name="model">nostr.identity.verifier</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="relay_url"/>
                <field name="websocket_state"/>
            </tree>
        </field>
    </record>

    <record id="view_nostr_identity_verifier_form" model="ir.ui.view">
        <field name="name">nostr.identity.verifier.form</field>
        <field name="model">nostr.identity.verifier</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="connect_to_relay" string="Connect" type="object" class="oe_highlight" attrs="{'invisible': [('websocket_state', '=', 'connected')]}"/>
                    <button name="close_connection" string="Disconnect" type="object" attrs="{'invisible': [('websocket_state', '!=', 'connected')]}"/>
                </header>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="relay_url"/>
                        <field name="active"/>
                        <field name="websocket_state"/>
                        <field name="last_error"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <!-- Action Windows -->
    <record id="action_nostr_identity" model="ir.actions.act_window">
        <field name="name">Nostr Identities</field>
        <field name="res_model">nostr.identity</field>
        <field name="view_mode">tree,form</field>
    </record>

    <record id="action_nostr_identity_verifier" model="ir.actions.act_window">
        <field name="name">Nostr Identity Verifiers</field>
        <field name="res_model">nostr.identity.verifier</field>
        <field name="view_mode">tree,form</field>
    </record>

    <!-- Menu Items -->
    <menuitem id="menu_nostr_root" name="Nostr" sequence="10"/>
    <menuitem id="menu_nostr_identity" name="Identities" parent="menu_nostr_root" action="action_nostr_identity" sequence="10"/>
    <menuitem id="menu_nostr_identity_verifier" name="Verifiers" parent="menu_nostr_root" action="action_nostr_identity_verifier" sequence="20"/>
</odoo>
=== ./odoo_custom_addons/nostr_bridge/models/git_repository.py ===
# File: odoo_custom_addons/nostr_bridge/models/git_repository.py

from odoo import models, fields, api
import git
import os

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Repository Name', required=True)
    path = fields.Char(string='Repository Path', required=True)
    
    @api.model
    def create(self, vals):
        repo = super(GitRepository, self).create(vals)
        if not os.path.exists(repo.path):
            os.makedirs(repo.path)
            git.Repo.init(repo.path)
        return repo

    def commit_changes(self, message):
        repo = git.Repo(self.path)
        repo.git.add(A=True)
        commit = repo.index.commit(message)
        
        event_manager = self.env['nostr.event.manager']
        event = event_manager.create_git_event(self.path, commit.hexsha)
        event_manager.publish_event(event)
        
        return commit.hexsha
=== ./odoo_custom_addons/nostr_bridge/models/__init__.py ===
# File: odoo_custom_addons/nostr_bridge/models/__init__.py

from . import res_users
from . import mail_message
from . import nostr_adapter
from . import res_config_settings
from . import res_partner
from . import nostr_event_manager
from . import git_repository
=== ./odoo_custom_addons/nostr_bridge/models/res_users.py ===
"""from odoo import models, fields, api
from nostr.key import PrivateKey

class ResUsers(models.Model):
    _inherit = 'res.users'

    #nostr_private_key = fields.Char(string="Nostr Private Key")
    #nostr_public_key = fields.Char(string="Nostr Public Key", compute='_compute_public_key')
    #nostr_relay_url = fields.Char(string="Nostr Relay URL")

    nostr_public_key = fields.Char(string="Nostr Public Key")
    nostr_private_key = fields.Char(string="Nostr Private Key")
    nostr_relay_url = fields.Char(string="Nostr Relay URL")

    @api.model
    def create(self, vals):
        if not vals.get('nostr_private_key'):
            private_key = PrivateKey()
            vals['nostr_private_key'] = private_key.bech32()
        return super(ResUsers, self).create(vals)

    def write(self, vals):
        # Here you might want to handle updates to Nostr fields
        return super(ResUsers, self).write(vals)

    @api.depends('nostr_private_key')
    def _compute_public_key(self):
        for user in self:
            if user.nostr_private_key:
                private_key = PrivateKey.from_nsec(user.nostr_private_key)
                user.nostr_public_key = private_key.public_key.bech32()
            else:
                user.nostr_public_key = False
"""

"""from odoo import models, fields, api

class ResUsers(models.Model):
    _inherit = 'res.users'

    nostr_public_key = fields.Char(string="Nostr Public Key")
    nostr_private_key = fields.Char(string="Nostr Private Key")
    nostr_relay_url = fields.Char(string="Nostr Relay URL")

    @api.model
    def create(self, vals):
        # Here you might want to generate Nostr keys if they're not provided
        return super(ResUsers, self).create(vals)

    def write(self, vals):
        # Here you might want to handle updates to Nostr fields
        return super(ResUsers, self).write(vals)"""
        
        
from odoo import models, fields

class ResUsers(models.Model):
    _inherit = 'res.users'

    nostr_public_key = fields.Char(string="Nostr Public Key")
    nostr_private_key = fields.Char(string="Nostr Private Key", groups="base.group_system")
    nostr_relay_url = fields.Char(string="Nostr Relay URL")
=== ./odoo_custom_addons/nostr_bridge/models/nostr_adapter.py ===
import requests
import websocket
from odoo import models, api
from websocket._exceptions import WebSocketConnectionClosedException
from odoo.exceptions import UserError
from nostr.event import Event
from nostr.key import PrivateKey
from nostr.relay_manager import RelayManager
import logging
import time

_logger = logging.getLogger(__name__)

class NostrAdapter(models.AbstractModel):
    _name = 'nostr.adapter'
    _description = 'Nostr Adapter'

    @api.model
    def get_relay_manager(self):
        ICPSudo = self.env['ir.config_parameter'].sudo()
        relay_urls = ICPSudo.get_param('nostr_bridge.relay_urls', '').split(',')
        if not relay_urls:
            raise UserError("Nostr relay URL is not configured. Please set it in the settings.")
        _logger.info(f"Nostr relay URLs: {relay_urls}")

        relay_manager = RelayManager()
        for url in relay_urls:
            url = url.strip()
            if url:  # Only add non-empty URLs
                _logger.info(f"Adding relay: {url}")
                relay_manager.add_relay(url)
        return relay_manager

    @api.model
    def publish_event(self, event_data, max_retries=3, retry_delay=1):
        for attempt in range(max_retries):
            try:
                private_key = PrivateKey.from_nsec(self.env.user.nostr_private_key)
                public_key = private_key.public_key.hex()
                
                event = Event(
                    kind=event_data['kind'],
                    content=event_data['content'],
                    tags=event_data.get('tags', []),
                    public_key=public_key
                )
                private_key.sign_event(event)
                
                relay_manager = self.get_relay_manager()
                relay_manager.open_connections({"write": True})
                time.sleep(1)  # Give some time for connections to establish
                
                publish_result = relay_manager.publish_event(event)
                _logger.info(f"Relay publish response: {publish_result}")
    
                relay_manager.close_connections()
                return True
            except Exception as e:
                _logger.exception(f"Error publishing event to Nostr: {str(e)}")
                time.sleep(retry_delay)
        
        _logger.error("Failed to publish event after multiple attempts")
        return False
=== ./odoo_custom_addons/nostr_bridge/models/mail_message.py ===
from odoo import models, api
import logging

_logger = logging.getLogger(__name__)

class MailMessage(models.Model):
    _inherit = 'mail.message'

    @api.model_create_multi
    def create(self, vals_list):
        _logger.info("Creating new mail messages")
        messages = super(MailMessage, self).create(vals_list)
        for message in messages:
            self._publish_to_nostr(message)
        return messages

    def _publish_to_nostr(self, message):
        try:
            nostr_adapter = self.env['nostr.adapter'].sudo()
            event_data = {
                'kind': 1,  # Text note
                'content': message.body,
                'tags': [
                    ['e', str(message.parent_id.id)] if message.parent_id else [],
                    ['p', message.author_id.nostr_public_key] if message.author_id and message.author_id.nostr_public_key else [],
                    ['client', 'Odoo Nostr Bridge'],
                ],
            }
            result = nostr_adapter.publish_event(event_data)
            if result:
                _logger.info(f"Successfully published message {message.id} to Nostr")
            else:
                _logger.warning(f"Failed to publish message {message.id} to Nostr")
        except Exception as e:
            _logger.exception(f"Error publishing message {message.id} to Nostr: {str(e)}")
=== ./odoo_custom_addons/nostr_bridge/models/nostr_event_handler.py ===
import json
from odoo import api, models

class NostrEventHandler(models.AbstractModel):
    _name = 'nostr.event.handler'
    _description = 'Nostr Event Handler'

    @api.model
    def handle_event(self, event):
        content = json.loads(event.content)
        if event.kind == 1:  # Text note
            self._handle_message(content)
        elif event.kind == 7:  # Reaction
            self._handle_reaction(content)

    def _handle_message(self, content):
        self.env['mail.message'].create({
            'body': content['body'],
            'author_id': self._get_author_id(content['author']),
            'model': content['channel'],
            'res_id': content['res_id'],
        })

    def _handle_reaction(self, content):
        # Implement reaction handling (e.g., likes, emojis)
        pass

    def _get_author_id(self, author_name):
        partner = self.env['res.partner'].search([('name', '=', author_name)], limit=1)
        if not partner:
            partner = self.env['res.partner'].create({'name': author_name})
        return partner.id
=== ./odoo_custom_addons/nostr_bridge/models/res_config_settings.py ===
import requests
import json
from odoo import fields, models, api
import logging

_logger = logging.getLogger(__name__)

class ResConfigSettings(models.TransientModel):
    _inherit = 'res.config.settings'

    def _default_nostr_relays(self):
        return self._get_top_nostr_relays()

    @api.model
    def _get_top_nostr_relays(self, limit=108):
        url = "https://api.nostr.watch/v1/online"
        try:
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
            }
            response = requests.get(url, headers=headers, timeout=10)
            response.raise_for_status()
            _logger.info(f"Response status code: {response.status_code}")
            
            data = response.json()
            #_logger.info(f"API response (first 108 items): {json.dumps(data)[:1000]}")
            _logger.info(f"API response (first 108 items): {data[:108]}")
            
            relays = data[:108]
            _logger.info(f"Number of relay links found: {len(relays)}")
            _logger.info(f"Extracted relays (first 5): {relays[:5]}")
            
            relay_urls = ",".join(relays)
            return relay_urls
        except requests.RequestException as e:
            _logger.error(f"Error fetching Nostr relays: {e}")
            return "wss://nostr-relay.app,wss://nos.lol,wss://relay.snort.social,wss://relay.nostr.net"

    nostr_relay_urls = fields.Char(
        string="Nostr Relay URLs", 
        config_parameter='nostr_bridge.relay_urls',
        default=_default_nostr_relays
    )

    @api.model
    def get_values(self):
        res = super(ResConfigSettings, self).get_values()
        ICPSudo = self.env['ir.config_parameter'].sudo()
        
        relay_urls = ICPSudo.get_param('nostr_bridge.relay_urls')
        if not relay_urls:
            relay_urls = self._get_top_nostr_relays()
            ICPSudo.set_param('nostr_bridge.relay_urls', relay_urls)
            _logger.info(f"Set new relay URLs: {relay_urls[:100]}...")  # Log first 100 characters
        else:
            _logger.info(f"Using existing relay URLs: {relay_urls[:100]}...")  # Log first 100 characters
        
        res.update(nostr_relay_urls=relay_urls)
        return res

    def set_values(self):
        super(ResConfigSettings, self).set_values()
        ICPSudo = self.env['ir.config_parameter'].sudo()
        if self.nostr_relay_urls:
            ICPSudo.set_param('nostr_bridge.relay_urls', self.nostr_relay_urls)
            _logger.info(f"Updated relay URLs: {self.nostr_relay_urls[:100]}...")  # Log first 100 characters
        else:
            default_urls = self._get_top_nostr_relays()
            ICPSudo.set_param('nostr_bridge.relay_urls', default_urls)
            _logger.info(f"Set default relay URLs: {default_urls[:100]}...")  # Log first 100 characters
=== ./odoo_custom_addons/nostr_bridge/models/res_partner.py ===
from odoo import models, fields

class ResPartner(models.Model):
    _inherit = 'res.partner'

    nostr_public_key = fields.Char(string="Nostr Public Key")
=== ./odoo_custom_addons/nostr_bridge/models/nostr_event_manager.py ===
from odoo import models, fields, api
import json
import time
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.serialization import Encoding, PublicFormat
import logging
import git

_logger = logging.getLogger(__name__)

class NostrEventManager(models.AbstractModel):
    _name = 'nostr.event.manager'
    _description = 'Nostr Event Manager'

    @api.model
    def create_event(self, content, tags, private_key):
        private_key_obj = PrivateKey.from_nsec(private_key)
        event = Event(kind=1, content=content, tags=tags)
        private_key_obj.sign_event(event)
        return event.to_json()

    @api.model
    def get_public_key(self, private_key):
        private_key_obj = ec.derive_private_key(int(private_key, 16), ec.SECP256K1())
        public_key = private_key_obj.public_key()
        return public_key.public_bytes(
            encoding=Encoding.X962,
            format=PublicFormat.UncompressedPoint
        )[1:].hex()

    @api.model
    def calculate_event_id(self, event_data):
        serialized = json.dumps([
            0,
            event_data['pubkey'],
            event_data['created_at'],
            event_data['kind'],
            event_data['tags'],
            event_data['content']
        ], separators=(',', ':'))
        return self.sha256(serialized)

    @api.model
    def sign_event(self, event_data, private_key):
        private_key_obj = ec.derive_private_key(int(private_key, 16), ec.SECP256K1())
        signature = private_key_obj.sign(
            bytes.fromhex(event_data['id']),
            ec.ECDSA(hashes.SHA256())
        )
        return signature.hex()

    @api.model
    def sha256(self, data):
        digest = hashes.Hash(hashes.SHA256())
        digest.update(data.encode())
        return digest.finalize().hex()

    @api.model
    def create_git_event(self, repo_path, commit_hash):
        repo = git.Repo(repo_path)
        commit = repo.commit(commit_hash)
        
        content = json.dumps({
            "action": "commit",
            "message": commit.message,
            "author": commit.author.name,
            "email": commit.author.email,
            "date": commit.authored_datetime.isoformat()
        })
        
        tags = [
            ["t", "commit"],
            ["h", commit_hash],
            ["n", repo.active_branch.name],
            ["m", commit.author.name],
            ["v", "1.0"],
            ["r", repo.remotes.origin.url if repo.remotes else ""],
            ["p", self.env.user.nostr_public_key],
            ["d", commit.message],
            ["s", "success"]
        ]
        
        event = self.create_event(content, tags, self.env.user.nostr_private_key)
        self.publish_event(event)
        return event

    def sync_with_decentralized_manager(self, event):
        sync_managers = self.env['decentralized.sync.manager'].search([])
        for manager in sync_managers:
            program = self.env['decentralized.sync.program'].search([
                ('manager_id', '=', manager.id),
                ('content', '=', event['content'])
            ], limit=1)

            if not program:
                program = self.env['decentralized.sync.program'].create({
                    'manager_id': manager.id,
                    'creator_id': self.env['decentralized.sync.creator'].search([], limit=1).id,
                    'content': event['content'],
                    'version': 1,
                    'size': 0.5  # Arbitrary size
                })

            manager.propagate_update(program)

    @api.model
    def publish_event(self, event):
        sync_managers = self.env['decentralized.sync.manager'].search([])
        for manager in sync_managers:
            manager.publish_event(event['content'], event['tags'])
        return True

    @api.model
    def get_events(self, filters=None):
        nostr_adapter = self.env['nostr.adapter']
        return nostr_adapter.get_events(filters)
=== ./odoo_custom_addons/nostr_bridge/models/ivcs_item.py ===
# File: odoo_custom_addons/nostr_bridge/models/ivcs_item.py

from odoo import models, fields, api, _
from odoo.exceptions import UserError
import git
import os
import logging
from nostr.key import PrivateKey

_logger = logging.getLogger(__name__)

class IVCSItem(models.Model):
    _inherit = 'ivcs.item'

    nostr_private_key = fields.Char(string="Nostr Private Key")

    def _create_nostr_event_and_publish(self, commit):
        if not self.nostr_private_key:
            self.nostr_private_key = PrivateKey().hex()
            self.sudo().write({'nostr_private_key': self.nostr_private_key})

        private_key = PrivateKey(bytes.fromhex(self.nostr_private_key))
        nostr_manager = self.env['nostr.event.manager']
        event = nostr_manager.create_git_event(commit, private_key)

        relay_urls = self.env['ir.config_parameter'].sudo().get_param('nostr_bridge.relay_urls', '').split(',')
        for relay_url in relay_urls:
            if relay_url.strip():
                success = nostr_manager.publish_event_sync(event, relay_url.strip())
                if success:
                    _logger.info(f"Successfully published event to {relay_url}")
                else:
                    _logger.warning(f"Failed to publish event to {relay_url}")

    def sync_repository(self):
        result = super(IVCSItem, self).sync_repository()
        if result.get('type') == 'ir.actions.client' and result['params']['type'] == 'success':
            repo = git.Repo(self.repo_path)
            latest_commit = repo.head.commit
            self._create_nostr_event_and_publish(latest_commit)
        return result

    def create_file(self, filename, content):
        result = super(IVCSItem, self).create_file(filename, content)
        if result.get('type') == 'ir.actions.client' and result['params']['type'] == 'success':
            repo = git.Repo(self.repo_path)
            latest_commit = repo.head.commit
            self._create_nostr_event_and_publish(latest_commit)
        return result

    @api.model
    def create(self, vals):
        item = super(IVCSItem, self).create(vals)
        repo = git.Repo(item.repo_path)
        initial_commit = repo.head.commit
        item._create_nostr_event_and_publish(initial_commit)
        return item
=== ./odoo_custom_addons/nostr_bridge/__init__.py ===
from . import models
from . import controllers
=== ./odoo_custom_addons/nostr_bridge/__manifest__.py ===
# File: odoo_custom_addons/nostr_bridge/__manifest__.py

{
    'name': 'Nostr Bridge',
    'version': '1.0',
    'category': 'Social',
    'summary': 'Bridge between Odoo messages, Git, and Nostr network',
    'depends': ['base', 'mail', 'web'],
    'data': [
        'views/res_config_settings_views.xml',
        'views/res_users_views.xml',
        'views/res_partner_views.xml',
        'views/git_repository_views.xml',
        'security/ir.model.access.csv',
    ],
    'installable': True,
    'application': False,
    'auto_install': False,
    'license': 'LGPL-3',
    'external_dependencies': {
        'python': ['cryptography', 'gitpython', 'nostr'],
    },
}
=== ./odoo_custom_addons/nostr_bridge/static/src/js/nostr_client.js ===
odoo.define('nostr_bridge.NostrClient', function (require) {
    "use strict";

    var Class = require('web.Class');

    var NostrClient = Class.extend({
        init: function (relayUrls) {
            this.relayUrls = relayUrls;
            this.relayPool = new NostrTools.RelayPool(this.relayUrls);
        },

        subscribe: function (filters, callback) {
            this.relayPool.subscribe(filters, callback);
        },

        publish: function (event) {
            this.relayPool.publish(event);
        }
    });

    return NostrClient;
});
=== ./odoo_custom_addons/nostr_bridge/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_git_repository_user,git.repository.user,model_git_repository,base.group_user,1,1,1,1
=== ./odoo_custom_addons/nostr_bridge/data/ir_cron_data.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <record id="ir_cron_migrate_messages_to_nostr" model="ir.cron">
            <field name="name">Migrate Messages to Nostr</field>
            <field name="model_id" ref="model_mail_message"/>
            <field name="state">code</field>
            <field name="code">model.migrate_messages_to_nostr()</field>
            <field name="interval_number">1</field>
            <field name="interval_type">days</field>
            <field name="numbercall">1</field>
            <field name="doall" eval="False"/>
        </record>
    </data>
</odoo>
=== ./odoo_custom_addons/nostr_bridge/views/res_users_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_users_form_nostr" model="ir.ui.view">
        <field name="name">res.users.form.nostr</field>
        <field name="model">res.users</field>
        <field name="inherit_id" ref="base.view_users_form"/>
        <field name="arch" type="xml">
            <xpath expr="//notebook" position="inside">
                <page string="Nostr Settings" name="nostr_settings">
                    <group>
                        <field name="nostr_public_key"/>
                        <field name="nostr_private_key" password="True"/>
                        <field name="nostr_relay_url"/>
                    </group>
                </page>
            </xpath>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons/nostr_bridge/views/res_partner_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_partner_form_nostr" model="ir.ui.view">
        <field name="name">res.partner.form.nostr</field>
        <field name="model">res.partner</field>
        <field name="inherit_id" ref="base.view_partner_form"/>
        <field name="arch" type="xml">
            <xpath expr="//notebook" position="inside">
                <page string="Nostr Settings" name="nostr_settings">
                    <group>
                        <field name="nostr_public_key"/>
                    </group>
                </page>
            </xpath>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons/nostr_bridge/views/res_config_settings_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="res_config_settings_view_form_nostr" model="ir.ui.view">
        <field name="name">res.config.settings.view.form.inherit.nostr</field>
        <field name="model">res.config.settings</field>
        <field name="inherit_id" ref="base.res_config_settings_view_form"/>
        <field name="arch" type="xml">
            <xpath expr="//div[hasclass('settings')]" position="inside">
                <div class="app_settings_block" data-string="Nostr Bridge" string="Nostr Bridge" data-key="nostr_bridge">
                    <h2>Nostr Settings</h2>
                    <div class="row mt16 o_settings_container">
                        <div class="col-12 col-lg-6 o_setting_box">
                            <div class="o_setting_left_pane"/>
                            <div class="o_setting_right_pane">
                                <span class="o_form_label">Nostr Relay URLs</span>
                                <div class="text-muted">
                                    Comma-separated list of Nostr relay URLs
                                </div>
                                <div class="content-group">
                                    <div class="mt16">
                                        <field name="nostr_relay_urls" class="o_light_label"/>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </xpath>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons/nostr_bridge/views/templates.xml ===
<odoo>
    <template id="assets_backend" name="nostr_bridge assets" inherit_id="web.assets_backend">
        <xpath expr="." position="inside">
            <script type="text/javascript" src="/nostr_bridge/static/src/js/nostr_client.js"/>
        </xpath>
    </template>
</odoo>
=== ./odoo_custom_addons/nostr_bridge/views/git_repository_views.xml ===
<!-- File: odoo_custom_addons/nostr_bridge/views/git_repository_views.xml -->

<odoo>
    <record id="view_git_repository_form" model="ir.ui.view">
        <field name="name">git.repository.form</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="path"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="action_git_repository" model="ir.actions.act_window">
        <field name="name">Git Repositories</field>
        <field name="res_model">git.repository</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_git_repository" name="Git Repositories" action="action_git_repository" parent="base.menu_custom"/>
</odoo>
=== ./odoo_custom_addons/nostr_bridge/controllers/__init__.py ===
from . import main
=== ./odoo_custom_addons/nostr_bridge/controllers/main.py ===
from odoo import http
from odoo.http import request
import json
from nostr.event import Event
from nostr.key import PrivateKey

class NostrController(http.Controller):

    @http.route('/nostr/authenticate', type='json', auth='public')
    def authenticate(self, public_key, signature, message):
        User = request.env['res.users'].sudo()
        user_id = User.authenticate_nostr(public_key, signature, message)
        if user_id:
            request.session.authenticate(request.db, user_id, public_key)
            return {'success': True, 'uid': user_id}
        return {'success': False, 'error': 'Authentication failed'}

    @http.route('/nostr/publish', type='json', auth='user')
    def publish_event(self, event_data):
        nostr_adapter = request.env['nostr.adapter'].sudo().get_adapter()
        try:
            nostr_adapter.publish_event(event_data)
            return {'success': True}
        except Exception as e:
            return {'success': False, 'error': str(e)}

    @http.route('/nostr/subscribe', type='json', auth='user')
    def subscribe_to_events(self, filters):
        nostr_adapter = request.env['nostr.adapter'].sudo().get_adapter()
        try:
            def callback(event):
                # Process the event, e.g., create a message in Odoo
                request.env['nostr.event.handler'].sudo().handle_event(event)

            nostr_adapter.subscribe_to_events(filters, callback)
            return {'success': True}
        except Exception as e:
            return {'success': False, 'error': str(e)}

    @http.route('/nostr/get_public_key', type='json', auth='user')
    def get_public_key(self):
        user = request.env.user
        return {'public_key': user.nostr_public_key}

    @http.route('/nostr/create_event', type='json', auth='user')
    def create_event(self, kind, content, tags=None):
        user = request.env.user
        private_key = PrivateKey.from_nsec(user.nostr_private_key)
        event = Event(kind=kind, content=json.dumps(content), tags=tags or [])
        event.sign(private_key.hex())
        return {
            'id': event.id,
            'pubkey': event.public_key,
            'created_at': event.created_at,
            'kind': event.kind,
            'tags': event.tags,
            'content': event.content,
            'sig': event.signature,
        }
=== ./odoo_custom_addons/decentralized_sync/models/supporting_models.py ===
from odoo import models, fields, api

class DAO(models.Model):
    _name = 'decentralized.sync.dao'
    _description = 'DAO'

    manager_id = fields.Many2one('decentralized.sync.manager', string='Sync Manager')
    tier = fields.Selection([('primary', 'Primary'), ('secondary', 'Secondary'), ('tertiary', 'Tertiary')], string='Tier')
    location_lat = fields.Float(string='Latitude')
    location_lon = fields.Float(string='Longitude')
    storage_capacity = fields.Float(string='Storage Capacity')
    network_speed = fields.Float(string='Network Speed')
    local_state = fields.Text(string='Local State')

class Creator(models.Model):
    _name = 'decentralized.sync.creator'
    _description = 'Creator'

    manager_id = fields.Many2one('decentralized.sync.manager', string='Sync Manager')
    location_lat = fields.Float(string='Latitude')
    location_lon = fields.Float(string='Longitude')
    productivity = fields.Float(string='Productivity')
    dao_id = fields.Many2one('decentralized.sync.dao', string='Associated DAO')

class Program(models.Model):
    _name = 'decentralized.sync.program'
    _description = 'Program'

    manager_id = fields.Many2one('decentralized.sync.manager', string='Sync Manager')
    creator_id = fields.Many2one('decentralized.sync.creator', string='Creator')
    size = fields.Float(string='Size')
    version = fields.Integer(string='Version')
    content = fields.Text(string='Content')
    host_ids = fields.Many2many('decentralized.sync.dao', string='Hosts')

class Event(models.Model):
    _name = 'decentralized.sync.event'
    _description = 'Sync Event'

    manager_id = fields.Many2one('decentralized.sync.manager', string='Sync Manager')
    description = fields.Text(string='Event Description')
    timestamp = fields.Datetime(string='Timestamp', default=fields.Datetime.now)

class Connection(models.Model):
    _name = 'decentralized.sync.connection'
    _description = 'Connection between Creator and DAO'

    manager_id = fields.Many2one('decentralized.sync.manager', string='Sync Manager')
    creator_id = fields.Many2one('decentralized.sync.creator', string='Creator')
    dao_id = fields.Many2one('decentralized.sync.dao', string='DAO')
=== ./odoo_custom_addons/decentralized_sync/models/sync_manager.py ===
from odoo import models, fields, api
import logging
from nostr.key import PrivateKey
from nostr.event import Event
from nostr.relay_manager import RelayManager
import git
import os

_logger = logging.getLogger(__name__)

class DecentralizedNostrSyncManager(models.Model):
    _name = 'decentralized.sync.manager'
    _description = 'Decentralized Nostr Sync Manager'

    name = fields.Char(string='Name', required=True)
    relay_urls = fields.Text(string='Relay URLs', required=True)
    private_key = fields.Char(string='Private Key')
    public_key = fields.Char(string='Public Key', compute='_compute_public_key')

    @api.depends('private_key')
    def _compute_public_key(self):
        for record in self:
            if record.private_key:
                private_key = PrivateKey.from_nsec(record.private_key)
                record.public_key = private_key.public_key.bech32()
            else:
                record.public_key = False

    def initialize_nostr(self):
        if not self.private_key:
            private_key = PrivateKey()
            self.private_key = private_key.bech32()
        
        self.relay_manager = RelayManager()
        for url in self.relay_urls.split(','):
            self.relay_manager.add_relay(url.strip())
        self.relay_manager.open_connections()

    def publish_event(self, content, tags=None):
        if not hasattr(self, 'relay_manager'):
            self.initialize_nostr()

        private_key = PrivateKey.from_nsec(self.private_key)
        event = Event(content=content, tags=tags or [])
        private_key.sign_event(event)
        
        self.relay_manager.publish_event(event)
        return event

    def sync_git_repository(self, repo_path):
        repo = git.Repo(repo_path)
        if not repo.remotes:
            raise ValueError('No remote repository configured')

        origin = repo.remotes.origin
        origin.fetch()
        
        current_branch = repo.active_branch
        if f'origin/{current_branch.name}' not in repo.refs:
            origin.push(current_branch)
        else:
            origin.pull(current_branch)

        for commit in repo.iter_commits(f'{current_branch.name}@{{u}}..{current_branch.name}'):
            self.publish_event(
                content=f"New commit: {commit.hexsha}",
                tags=[['c', commit.hexsha], ['t', 'git_commit']]
            )

    @api.model
    def create(self, vals):
        manager = super(DecentralizedNostrSyncManager, self).create(vals)
        manager.initialize_nostr()
        return manager

    def write(self, vals):
        result = super(DecentralizedNostrSyncManager, self).write(vals)
        if 'relay_urls' in vals:
            self.initialize_nostr()
        return result
=== ./odoo_custom_addons/decentralized_sync/__init__.py ===
from . import models
from . import controllers
=== ./odoo_custom_addons/decentralized_sync/__manifest__.py ===
{
    'name': 'Decentralized Nostr Sync Manager',
    'version': '1.0',
    'category': 'Tools',
    'summary': 'Manage decentralized synchronization with Nostr and Git',
    'depends': ['base', 'ivcs_git', 'nostr_bridge'],
    'data': [
        'security/ir.model.access.csv',
        'views/sync_manager_views.xml',
        'views/dao_views.xml',
        'views/creator_views.xml',
        'views/program_views.xml',
        'views/event_views.xml',
        'views/menu_items.xml',
    ],
    'installable': True,
    'application': False,
    'auto_install': False,
}
=== ./odoo_custom_addons/decentralized_sync/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_decentralized_sync_manager_user,decentralized.sync.manager user,model_decentralized_sync_manager,base.group_user,1,1,1,1
access_decentralized_sync_dao_user,decentralized.sync.dao user,model_decentralized_sync_dao,base.group_user,1,1,1,1
access_decentralized_sync_creator_user,decentralized.sync.creator user,model_decentralized_sync_creator,base.group_user,1,1,1,1
access_decentralized_sync_program_user,decentralized.sync.program user,model_decentralized_sync_program,base.group_user,1,1,1,1
access_decentralized_sync_event_user,decentralized.sync.event user,model_decentralized_sync_event,base.group_user,1,1,1,1
access_decentralized_sync_connection_user,decentralized.sync.connection user,model_decentralized_sync_connection,base.group_user,1,1,1,1
=== ./odoo_custom_addons/decentralized_sync/controllers/main.py ===
from odoo import http
from odoo.http import request
from nostr.event import Event
import json

class DecentralizedSyncController(http.Controller):

    @http.route('/api/decentralized_sync/publish', type='json', auth='user')
    def publish_event(self, manager_id, content, tags=None):
        manager = request.env['decentralized.sync.manager'].browse(int(manager_id))
        event = manager.publish_event(content, tags)
        return {'status': 'success', 'event_id': event.id}

    @http.route('/api/decentralized_sync/sync_repo', type='json', auth='user')
    def sync_repository(self, manager_id, repo_path):
        manager = request.env['decentralized.sync.manager'].browse(int(manager_id))
        manager.sync_git_repository(repo_path)
        return {'status': 'success', 'message': 'Repository synced and events published'}

    @http.route('/api/decentralized_sync/events', type='json', auth='user')
    def get_events(self, manager_id):
        manager = request.env['decentralized.sync.manager'].browse(int(manager_id))
        # This would typically fetch events from Nostr relays
        # For now, we'll return an empty list
        return {'events': []}
=== ./odoo_custom_addons/nostr_auth_test/nostr_auth_module.py ===
import os
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import hashes
from odoo import models, fields, api
from odoo.exceptions import ValidationError
import base64

class NostrAuthModule(models.AbstractModel):
    _name = 'nostr.auth'
    _description = 'Nostr Authentication Module'

    @api.model
    def generate_keypair(self):
        """
        Generate a new Nostr keypair.
        This represents the 'Cause' in our 'Causal Relationship'.
        """
        private_key = ec.generate_private_key(ec.SECP256K1())
        public_key = private_key.public_key()
        
        private_bytes = private_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=serialization.NoEncryption()
        )
        public_bytes = public_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        )
        
        return {
            'private_key': base64.b64encode(private_bytes).decode('utf-8'),
            'public_key': base64.b64encode(public_bytes).decode('utf-8')
        }

    @api.model
    def store_keys(self, user_id, public_key, private_key):
        """
        Store the Nostr keys for a user.
        This action creates an 'Effect' in our 'Causal Relationship'.
        """
        user = self.env['res.users'].browse(user_id)
        if not user.exists():
            raise ValidationError("User does not exist")
        
        user.write({
            'nostr_public_key': public_key,
            'nostr_private_key': private_key  # In a real-world scenario, encrypt this before storage
        })

    @api.model
    def verify_signature(self, public_key, message, signature):
        """
        Verify a Nostr signature.
        This verification process is another 'Effect' in our 'Causal Relationship'.
        """
        try:
            public_key_obj = serialization.load_pem_public_key(base64.b64decode(public_key))
            signature_bytes = base64.b64decode(signature)
            public_key_obj.verify(
                signature_bytes,
                message.encode('utf-8'),
                ec.ECDSA(hashes.SHA256())
            )
            return True
        except:
            return False

    @api.model
    def authenticate_nostr(self, public_key, signature, message):
        """
        Authenticate a user using Nostr.
        This method embodies the complete 'Causal Relationship':
        The provided credentials (Cause) lead to authentication success or failure (Effect).
        """
        user = self.env['res.users'].search([('nostr_public_key', '=', public_key)], limit=1)
        if user and self.verify_signature(user.nostr_public_key, message, signature):
            return user.id
        return False

# For console testing
if __name__ == "__main__":
    # Simulate Odoo environment
    class MockEnv:
        def __init__(self):
            self.users = {}
        
        def __getitem__(self, key):
            return self
        
        def search(self, domain, limit=None):
            for user_id, user in self.users.items():
                if user['nostr_public_key'] == domain[0][2]:
                    return [MockUser(user_id, user)]
            return []
    
    class MockUser:
        def __init__(self, id, data):
            self.id = id
            self.__dict__.update(data)
        
        def exists(self):
            return True
        
        def write(self, vals):
            self.__dict__.update(vals)

    mock_env = MockEnv()
    
    # Create an instance of NostrAuthModule
    nostr_auth = NostrAuthModule()
    nostr_auth.env = mock_env

    # Test key generation
    print("Generating keypair...")
    keys = nostr_auth.generate_keypair()
    print(f"Public Key: {keys['public_key'][:32]}...")
    print(f"Private Key: {keys['private_key'][:32]}...")

    # Test key storage
    print("\nStoring keys...")
    mock_env.users[1] = {'name': 'Test User'}
    try:
        nostr_auth.store_keys(1, keys['public_key'], keys['private_key'])
        print("Keys stored successfully")
    except Exception as e:
        print(f"Error storing keys: {str(e)}")

    # Test signature verification
    print("\nTesting signature verification...")
    message = "Test message"
    private_key = serialization.load_pem_private_key(base64.b64decode(keys['private_key']), password=None)
    signature = base64.b64encode(private_key.sign(
        message.encode('utf-8'),
        ec.ECDSA(hashes.SHA256())
    )).decode('utf-8')
    
    is_valid = nostr_auth.verify_signature(keys['public_key'], message, signature)
    print(f"Signature valid: {is_valid}")

    # Test authentication
    print("\nTesting authentication...")
    user_id = nostr_auth.authenticate_nostr(keys['public_key'], signature, message)
    print(f"Authenticated user ID: {user_id}")

    print("\nAll tests completed.")
=== ./odoo_custom_addons/simple_git_integration/models/git_repository.py ===
from odoo import models, fields, api
import git
import os

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Repository Name', required=True)
    path = fields.Char(string='Repository Path', required=True)

    @api.model
    def create(self, vals):
        repo = super(GitRepository, self).create(vals)
        if not os.path.exists(repo.path):
            os.makedirs(repo.path)
            git.Repo.init(repo.path)
        return repo

    def commit_changes(self, message):
        repo = git.Repo(self.path)
        repo.git.add(A=True)
        commit = repo.index.commit(message)
        return commit.hexsha
=== ./odoo_custom_addons/simple_git_integration/models/git_commit.py ===
from odoo import models, fields

class GitCommit(models.Model):
    _name = 'git.commit'
    _description = 'Git Commit'

    hash = fields.Char(string='Commit Hash', required=True)
    message = fields.Text(string='Commit Message', required=True)
    author = fields.Char(string='Author', required=True)
    date = fields.Datetime(string='Date', required=True)
    repository_id = fields.Many2one('git.repository', string='Repository', required=True)
=== ./odoo_custom_addons/simple_git_integration/models/__init__.py ===
from . import git_repository
from . import git_commit
=== ./odoo_custom_addons/simple_git_integration/__init__.py ===
from . import models
from . import wizards
=== ./odoo_custom_addons/simple_git_integration/wizards/create_commit_wizard_views.xml ===
<?xml version="1.0" encoding="UTF-8"?>
<odoo>
    <record id="view_create_commit_wizard_form" model="ir.ui.view">
        <field name="name">create.commit.wizard.form</field>
        <field name="model">create.commit.wizard</field>
        <field name="arch" type="xml">
            <form string="Create Commit">
                <group>
                    <field name="repository_id"/>
                    <field name="message"/>
                </group>
                <footer>
                    <button string="Create Commit" type="object" name="action_create_commit" class="btn-primary"/>
                    <button string="Cancel" class="btn-secondary" special="cancel"/>
                </footer>
            </form>
        </field>
    </record>

    <record id="action_create_commit_wizard" model="ir.actions.act_window">
        <field name="name">Create Commit</field>
        <field name="type">ir.actions.act_window</field>
        <field name="res_model">create.commit.wizard</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
    </record>

    <menuitem id="menu_create_commit_wizard" name="Create Commit" parent="menu_git_root" action="action_create_commit_wizard" sequence="2"/>
</odoo>
=== ./odoo_custom_addons/simple_git_integration/wizards/__init__.py ===
from . import create_commit_wizard
=== ./odoo_custom_addons/simple_git_integration/wizards/create_commit_wizard.py ===
from odoo import models, fields

class CreateCommitWizard(models.TransientModel):
    _name = 'create.commit.wizard'

    repository_id = fields.Many2one('git.repository', string='Repository', required=True)
    message = fields.Text(string='Commit Message', required=True)

    def action_create_commit(self):
        self.ensure_one()

        # Commit changes to the repository
        commit_hash = self.repository_id.commit_changes(self.message)

        # Create a record of the commit in Odoo
        self.env['git.commit'].create({
            'hash': commit_hash,
            'message': self.message,
            'author': self.env.user.name,
            'date': fields.Datetime.now(),
            'repository_id': self.repository_id.id,
        })

        return {'type': 'ir.actions.act_window_close'}
=== ./odoo_custom_addons/simple_git_integration/__manifest__.py ===
{
    'name': 'Simple Git Integration',
    'version': '1.0',
    'category': 'Development',
    'summary': 'Simple Git integration for managing code repositories.',
    'author': 'Your Name',
    'depends': ['base'],
    'data': [
        'security/security.xml',
        'security/ir.model.access.csv',
        'views/git_repository_views.xml',
        'views/git_commit_views.xml',
        'wizards/create_commit_wizard_views.xml',
    ],
    'installable': True,
    'application': False,
    'auto_install': False,
}
=== ./odoo_custom_addons/simple_git_integration/security/security.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="group_git_user" model="res.groups">
        <field name="name">Git User</field>
        <field name="category_id" ref="base.module_category_hidden"/>
    </record>
</odoo>
=== ./odoo_custom_addons/simple_git_integration/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_git_repository_user,git.repository user,model_git_repository,group_git_user,1,1,1,1
access_git_commit_user,git.commit user,model_git_commit,group_git_user,1,1,1,0
access_create_commit_wizard,create.commit.wizard,model_create_commit_wizard,base.group_user,1,1,1,0
=== ./odoo_custom_addons/simple_git_integration/views/create_commit_wizard_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_users_form_inherit_git_nostr" model="ir.ui.view">
        <field name="name">res.users.form.inherit.git.nostr</field>
        <field name="model">res.users</field>
        <field name="inherit_id" ref="base.view_users_form"/>
        <field name="arch" type="xml">
            <notebook position="inside">
                <page string="Nostr Settings" name="nostr_settings">
                    <group>
                        <field name="nostr_private_key" password="True"/>
                        <field name="nostr_public_key"/>
                    </group>
                </page>
            </notebook>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons/simple_git_integration/views/git_commit_views.xml ===
<odoo>
    <record id="view_git_commit_tree" model="ir.ui.view">
        <field name="name">git.commit.tree</field>
        <field name="model">git.commit</field>
        <field name="arch" type="xml">
            <tree>
                <field name="hash"/>
                <field name="message"/>
                <field name="author"/>
                <field name="date"/>
                <field name="repository_id"/>
            </tree>
        </field>
    </record>

    <record id="action_git_commit" model="ir.actions.act_window">
        <field name="name">Git Commits</field>
        <field name="res_model">git.commit</field>
        <field name="view_mode">tree</field>
    </record>

    <menuitem id="menu_git_commit" parent="menu_git_root" action="action_git_commit" name="Commits"/>
</odoo>
=== ./odoo_custom_addons/simple_git_integration/views/git_repository_views.xml ===
<odoo>
    <record id="view_git_repository_form" model="ir.ui.view">
        <field name="name">git.repository.form</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="path"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_git_repository_tree" model="ir.ui.view">
        <field name="name">git.repository.tree</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="path"/>
            </tree>
        </field>
    </record>

    <record id="action_git_repository" model="ir.actions.act_window">
        <field name="name">Git Repositories</field>
        <field name="res_model">git.repository</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_git_root" name="Git Management"/>
    <menuitem id="menu_git_repository" parent="menu_git_root" action="action_git_repository" name="Repositories"/>
</odoo>
=== ./odoo_custom_addons/git_nostr_object/models/git_repository.py ===
# models/git_repository.py
from odoo import models, fields, api
import git
import json

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Name', required=True)
    path = fields.Char(string='Path', required=True)
    logs = fields.Text(string='Logs')

    def traverse_and_publish(self):
        self.ensure_one()
        logs = []
        try:
            git_repo = git.Repo(self.path)
            for commit in git_repo.iter_commits():
                nostr_event = self.env['nostr.event.object'].create({
                    'kind': 1,
                    'content': commit.message,
                    'tags': json.dumps([['commit', commit.hexsha]]),
                    'created_at': commit.committed_date,
                })
                nostr_event.action_publish()
                logs.append(f"Published commit {commit.hexsha}")

            self.write({'logs': '\n'.join(logs)})
            self.env['bus.bus']._sendone(self.env.user.partner_id, 'simple_notification', {
                'title': _("Git Repository Traversed"),
                'message': _("All commits published to Nostr network"),
            })
        except Exception as e:
            error_msg = f"Error traversing repository: {e}"
            logs.append(error_msg)
            self.write({'logs': '\n'.join(logs)})
            raise UserError(_(error_msg))

        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _("Git Repository"),
                'message': _("Repository traversed and commits published. Check logs for details."),
                'sticky': False,
                'type': 'success',
            }
        }
=== ./odoo_custom_addons/git_nostr_object/models/git_commit.py ===
from odoo import models, fields, api
from .git_object import GitObject

class GitCommit(models.Model):
    _name = 'git.commit'
    _inherit = 'git.object'
    _description = 'Git Commit'

    message = fields.Text(string='Commit Message')
    author = fields.Char(string='Author')
    timestamp = fields.Datetime(string='Timestamp')

    def to_nostr_event(self):
        return self.env['nostr.event.object'].create({
            'kind': 3121,
            'content': self.data,
            'tags': [['sha', self.sha]],
        })

    @api.model
    def create_from_nostr_event(self, event):
        git_commit = GitObject.from_nostr_event(event)
        return self.create({
            'sha': git_commit.sha,
            'data': git_commit.data.decode('utf-8', errors='replace'),
            'message': git_commit.message,
            'author': git_commit.author,
            'timestamp': git_commit.timestamp,
        })
    @api.model
    def create_from_git_commit(self, commit):
        return self.create({
            'sha': commit.hexsha,
            'message': commit.message,
            'author': f"{commit.author.name} <{commit.author.email}>",
            'timestamp': commit.committed_datetime,
            'data': commit.tree.data_stream.read().decode('utf-8', errors='replace'),
        })
=== ./odoo_custom_addons/git_nostr_object/models/nostr_websocket_client.py ===
import websocket
import json
import logging
import time

_logger = logging.getLogger(__name__)

class NostrWebSocketClient:
    def __init__(self, relay_urls):
        self.relay_urls = relay_urls

    def connect_and_publish(self, event_data):
        responses = []
        for url in self.relay_urls:
            try:
                _logger.info(f"Attempting to connect to {url}")
                start_time = time.time()
                ws = websocket.create_connection(url, timeout=10)
                _logger.info(f"Connected to {url} in {time.time() - start_time:.2f} seconds")

                # Construct the message correctly
                message = ["EVENT", event_data]
                _logger.debug(f"Raw event message: {message}")

                ws.send(json.dumps(message))
                _logger.info(f"Sent message to {url} in {time.time() - start_time:.2f} seconds")

                _logger.info(f"Waiting for response from {url}")
                response = ws.recv()
                _logger.info(f"Received response from {url} in {time.time() - start_time:.2f} seconds: {response}")

                responses.append(json.loads(response))
                ws.close()
            except Exception as e:
                _logger.error(f"Error publishing to {url}: {str(e)}")
                responses.append(["ERROR", str(e)])
        return responses
=== ./odoo_custom_addons/git_nostr_object/models/__init__.py ===
# __init__.py
from . import git_object
from . import git_commit
from . import git_tree
from . import git_blob
from . import git_repository
from . import nostr_event
from . import admin_test
from . import git_commit_wizard
=== ./odoo_custom_addons/git_nostr_object/models/git_object.py ===
from odoo import models, fields, api

class GitObject(models.AbstractModel):
    _name = 'git.object'
    _description = 'Git Object'

    sha = fields.Char(string='SHA', required=True)
    data = fields.Text(string='Data', required=True)

    def to_nostr_event(self):
        raise NotImplementedError("This method should be implemented by subclasses")

    @api.model
    def create_from_nostr_event(self, event):
        raise NotImplementedError("This method should be implemented by subclasses")
=== ./odoo_custom_addons/git_nostr_object/models/git_nostr_object.py ===
# models/git_nostr_event.py
from odoo import models, fields, api
from utils.nostr_websocket_client import NostrWebSocketClient
from nostr.event import Event as NostrEvent
import logging
import time
import json

_logger = logging.getLogger(__name__)

class GitNostrEventObject(models.Model):
    _name = 'git_nostr.event.object'
    _description = 'Git Nostr Event Object'

    kind = fields.Integer(string='Event Kind', required=True)
    content = fields.Text(string='Content', required=True)
    tags = fields.Text(string='Tags')
    created_at = fields.Integer(string='Created At', required=True)
    signature = fields.Char(string='Signature', required=True)
    public_key = fields.Char(string='Public Key', required=True)
    published = fields.Boolean(string='Published', default=False)

    def action_publish(self):
        """
        Publish the Nostr event to the configured relays.
        """
        relay_urls = [
            'wss://relay.damus.io',
            'wss://nostr-pub.wellorder.net',
            'wss://nostr.mom',
            'wss://nostr.slothy.win',
            'wss://relay.stoner.com'
        ]

        event_data = {
            'kind': self.kind,
            'content': self.content,
            'tags': self.tags,
            'created_at': self.created_at,
            'pubkey': self.public_key,
            'sig': self.signature,
        }

        websocket_client = NostrWebSocketClient(relay_urls)

        try:
            responses = websocket_client.connect_and_publish(event_data)
            if all(response[0] == 'OK' and response[2] for response in responses):
                self.write({'published': True})
                _logger.info(f"Nostr event successfully published: {self.id}")
            else:
                self.write({'published': False})
                _logger.error(f"Error publishing Nostr event {self.id}: {responses}")
        except Exception as e:
            self.write({'published': False})
            _logger.error(f"Error publishing Nostr event {self.id}: {e}")

    def to_nostr_event(self):
        try:
            tags = json.loads(self.tags) if self.tags else []
        except json.JSONDecodeError:
            _logger.warning(f"Invalid JSON in tags for event {self.id}. Using empty tags list.")
            tags = []

        return NostrEvent(
            kind=self.kind,
            content=self.content,
            tags=tags,
            public_key=self.public_key,
            created_at=self.created_at,
            sig=self.signature
        )
=== ./odoo_custom_addons/git_nostr_object/models/git_blob.py ===
from odoo import models, fields, api
from .git_object import GitObject

class GitBlob(models.Model):
    _name = 'git.blob'
    _inherit = 'git.object'
    _description = 'Git Blob'

    def to_nostr_event(self):
        return self.env['nostr.event.object'].create({
            'kind': 3123,
            'content': self.data,
            'tags': [['sha', self.sha]],
        })

    @api.model
    def create_from_nostr_event(self, event):
        git_blob = GitObject.from_nostr_event(event)
        return self.create({
            'sha': git_blob.sha,
            'data': git_blob.data.hex(),
        })
=== ./odoo_custom_addons/git_nostr_object/models/git_tree.py ===
from odoo import models, fields, api
from .git_object import GitObject

class GitTree(models.Model):
    _name = 'git.tree'
    _inherit = 'git.object'
    _description = 'Git Tree'

    def to_nostr_event(self):
        return self.env['nostr.event.object'].create({
            'kind': 3122,
            'content': self.data,
            'tags': [['sha', self.sha]],
        })

    @api.model
    def create_from_nostr_event(self, event):
        git_tree = GitObject.from_nostr_event(event)
        return self.create({
            'sha': git_tree.sha,
            'data': git_tree.data.decode('utf-8', errors='replace'),
        })
=== ./odoo_custom_addons/git_nostr_object/models/nostr_event.py ===
# models/nostr_event.py
from odoo import models, fields, api, _
from odoo.exceptions import UserError
from ..utils.nostr_websocket_client import NostrWebSocketClient
from nostr.event import Event as NostrEvent
from nostr.key import PrivateKey
import logging
import json
import time

_logger = logging.getLogger(__name__)

class NostrEventObject(models.Model):
    _name = 'nostr.event.object'
    _description = 'Nostr Event Object'

    kind = fields.Integer(string='Event Kind', required=True)
    content = fields.Text(string='Content', required=True)
    tags = fields.Text(string='Tags')
    created_at = fields.Integer(string='Created At', required=True)
    signature = fields.Char(string='Signature')
    public_key = fields.Char(string='Public Key', required=True)
    published = fields.Boolean(string='Published', default=False)
    logs = fields.Text(string='Logs')

    def action_publish(self):
        self.ensure_one()
        if self.published:
            raise UserError(_("This event has already been published."))

        start_time = time.time()
        logs = []

        # Get the user's private key
        user = self.env.user
        private_key_nsec = user.nostr_private_key
        if not private_key_nsec:
            raise UserError(_("Nostr private key is not set for the current user."))

        try:
            private_key = PrivateKey.from_nsec(private_key_nsec)
        except Exception as e:
            raise UserError(_("Invalid Nostr private key: %s") % str(e))

        logs.append(f"Key preparation took {time.time() - start_time:.4f} seconds")

        # Create and sign the Nostr event
        event_creation_start = time.time()
        event = NostrEvent(
            kind=self.kind,
            content=self.content,
            tags=json.loads(self.tags) if self.tags else [],
            public_key=private_key.public_key.hex(),
            created_at=int(time.time())
        )
        private_key.sign_event(event)
        logs.append(f"Event creation and signing took {time.time() - event_creation_start:.4f} seconds")

        # Update the record
        self.write({
            'signature': event.signature,
            'public_key': event.public_key,
            'created_at': event.created_at
        })

        relay_urls = [
            'wss://relay.damus.io',
            'wss://nostr-pub.wellorder.net',
            'wss://nostr.mom',
            'wss://nostr.slothy.win',
            'wss://relay.stoner.com'
        ]

        event_data = json.loads(event.to_message())[1]
        websocket_client = NostrWebSocketClient(relay_urls)

        publish_start = time.time()
        try:
            responses, ws_logs = websocket_client.connect_and_publish(event_data)
            logs.extend(ws_logs)
            if any(response[0] == 'OK' for response in responses):
                self.write({'published': True})
                logs.append(f"Nostr event successfully published: {self.id}")
                self.env['bus.bus']._sendone(self.env.user.partner_id, 'simple_notification', {
                    'title': _("Nostr Event Published"),
                    'message': _("Event successfully published to Nostr network"),
                })
            else:
                error_msg = f"Error publishing Nostr event {self.id}: {responses}"
                logs.append(error_msg)
                raise UserError(_(error_msg))
        except Exception as e:
            error_msg = f"Error publishing Nostr event {self.id}: {e}"
            logs.append(error_msg)
            raise UserError(_(error_msg))
        finally:
            logs.append(f"Publishing process took {time.time() - publish_start:.4f} seconds")

        logs.append(f"Total publish action took {time.time() - start_time:.4f} seconds")
        self.write({'logs': '\n'.join(logs)})

        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _("Nostr Event"),
                'message': _("Event published successfully. Check logs for details."),
                'sticky': False,
                'type': 'success',
            }
        }
=== ./odoo_custom_addons/git_nostr_object/models/git_commit_wizard.py ===
from odoo import models, fields, api

class GitCommitWizard(models.TransientModel):
    _name = 'git.commit.wizard'
    _description = 'Git Commit Wizard'

    repository_id = fields.Many2one('git.repository', string='Repository', required=True)
    message = fields.Text(string='Commit Message', required=True)
    file_data = fields.Text(string='File Content')
    file_name = fields.Char(string='File Name')

    def action_create_commit(self):
        repo = self.repository_id
        with open(f"{repo.path}/{self.file_name}", 'w') as f:
            f.write(self.file_data)
        commit = repo.create_commit(self.message, [self.file_name])
        return {'type': 'ir.actions.act_window_close'}
=== ./odoo_custom_addons/git_nostr_object/models/admin_test.py ===
# /opt/odoo/custom_addons/git_nostr_object/models/admin_test.py
from odoo import models, api
from ..tests.test_git_nostr_object import test_git_nostr_object, test_nostr_auth

class AdminTest(models.TransientModel):
    _name = 'git_nostr_object.admin_test'
    _description = 'Admin Test for Git-Nostr Object'

    def run_tests(self):
        test_git_nostr_object()
        test_nostr_auth()
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': 'Test Results',
                'message': 'Tests completed. Check the logs for details.',
                'sticky': False,
            }
        }
=== ./odoo_custom_addons/git_nostr_object/__init__.py ===
from . import models
from . import controllers
=== ./odoo_custom_addons/git_nostr_object/utils/nostr_websocket_client.py ===
# utils/nostr_websocket_client.py
import logging
import time
import websocket
import json

_logger = logging.getLogger(__name__)

class NostrWebSocketClient:
    def __init__(self, relay_urls):
        self.relay_urls = relay_urls

    def connect_and_publish(self, event_data):
        responses = []
        logs = []
        for url in self.relay_urls:
            try:
                response, log = self._connect_and_publish_to_relay(url, event_data)
                responses.append(response)
                logs.extend(log)
            except Exception as e:
                error_message = f"Error publishing event to relay {url}: {e}"
                _logger.error(error_message)
                logs.append(error_message)
        return responses, logs

    def _connect_and_publish_to_relay(self, relay_url, event_data):
        log = []
        log.append(f"Attempting to connect to {relay_url}")
        start_time = time.time()

        ws = websocket.create_connection(relay_url)
        log.append(f"Connected to {relay_url} in {time.time() - start_time:.2f} seconds")

        event_message = json.dumps(["EVENT", event_data])
        log.append(f"Sending Nostr event to {relay_url}")
        ws.send(event_message)
        log.append(f"Sent message to {relay_url} in {time.time() - start_time:.2f} seconds")

        log.append(f"Waiting for response from {relay_url}")
        response = ws.recv()
        log.append(f"Received response from {relay_url} in {time.time() - start_time:.2f} seconds: {response}")
        ws.close()
        return json.loads(response), log
=== ./odoo_custom_addons/git_nostr_object/__manifest__.py ===
{
    'name': 'git_nostr_object',
    'version': '1.0',
    'depends': ['base', 'bus'],
    'data': [
        'security/ir.model.access.csv',
        'views/git_repository_views.xml',
        'views/git_commit_views.xml',
        'views/git_tree_views.xml',
        'views/git_blob_views.xml',
        'views/git_object_views.xml',
        'views/nostr_event_object_views.xml',
        'views/actions.xml',
        'views/menus.xml',
        'views/admin_test_views.xml',
        'views/git_commit_wizard_views.xml'
    ],
    'assets': {
        'web.assets_backend': [
            'git_nostr_object/static/src/js/git_nostr_notifications.js',
        ],
    },
    'installable': True,
    'application': True,
    'auto_install': False,
}
=== ./odoo_custom_addons/git_nostr_object/static/src/js/git_nostr_notifications.js ===
// static/src/js/git_nostr_notifications.js
odoo.define('git_nostr_object.notifications', function (require) {
    "use strict";

    var core = require('web.core');
    var session = require('web.session');
    var BusService = require('bus.BusService');

    BusService.include({
        _onNotification: function (notifications) {
            var self = this;
            _.each(notifications, function (notification) {
                if (notification[0][1] === 'simple_notification') {
                    self.displayNotification({
                        title: notification[1].title,
                        message: notification[1].message,
                        type: 'info',
                    });
                }
            });
            this._super.apply(this, arguments);
        },
    });
});
=== ./odoo_custom_addons/git_nostr_object/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_git_commit,access_git_commit,model_git_commit,base.group_user,1,1,1,1
access_git_tree,access_git_tree,model_git_tree,base.group_user,1,1,1,1
access_git_blob,access_git_blob,model_git_blob,base.group_user,1,1,1,1
access_git_repository,access_git_repository,model_git_repository,base.group_user,1,1,1,1
access_nostr_event_object,access_nostr_event_object,model_nostr_event_object,base.group_user,1,1,1,1
=== ./odoo_custom_addons/git_nostr_object/tests/__init__.py ===
# /opt/odoo/custom_addons/git_nostr_object/tests/__init__.py
from . import test_git_nostr_object
=== ./odoo_custom_addons/git_nostr_object/tests/test_git_nostr_object.py ===
from odoo.tests.common import TransactionCase
from datetime import datetime
import random
import string
import logging
import os

_logger = logging.getLogger(__name__)

def random_string(length=10):
    return ''.join(random.choices(string.ascii_letters + string.digits, k=length))

def generate_sha():
    """Generate a random 40-character SHA hash"""
    return ''.join(random.choices('0123456789abcdef', k=40))

def get_current_timestamp():
    """Return the current timestamp"""
    return int(datetime.now().timestamp())

def get_author(env):
    """Return the logged-in user's name as the author"""
    return env.user.name

def get_local_path():
    """Return the Odoo installation path as the local path"""
    return '/opt/odoo'

def generate_nostr_keys():
    """Generate random 64-character Nostr public and private keys for the logged-in user"""
    public_key = random_string(64)
    private_key = random_string(64)
    return public_key, private_key

def get_event_type(content):
    """Extract the event type from the first line of the content"""
    return int(content.split('\n')[0].strip('# '))

def get_event_name(content):
    """Extract the event name from the first line of the content"""
    return content.split('\n', 1)[0]

def check_method_existence(env, methods):
    """Check if the required methods exist in the corresponding models"""
    for model, method_name in methods.items():
        model_obj = env[model]
        if not hasattr(model_obj, method_name):
            return False, f"Method '{method_name}' not found in model '{model}'"
    return True, "All required methods found"

class TestGitNostrObject(TransactionCase):

    def setUp(self):
        super(TestGitNostrObject, self).setUp()
        self.GitRepository = self.env['git.repository']
        self.GitCommit = self.env['git.commit']
        self.GitTree = self.env['git.tree']
        self.GitBlob = self.env['git.blob']
        self.GitNostrEventObject = self.env['git_nostr.event.object']
        self.NostrKey = self.env['nostr.key']
        self.NostrRelay = self.env['nostr.relay']
        self.NostrProfile = self.env['nostr.profile']

        # Check if required methods exist in the corresponding models
        required_methods = {
            'git.repository': 'traverse_and_publish',
            'nostr.event.object': 'action_publish',
            'nostr.key': 'generate_key_pair',
            'nostr.key': 'sign_event'
        }
        success, message = check_method_existence(self.env, required_methods)
        if not success:
            self.fail(message)

    def test_git_nostr_object(self):
        _logger.info("Testing Git-Nostr Object module...")

        # Test Git Repository
        repo_name = f'Test Repo {random_string()}'
        repo_path = f'{get_local_path()}/custom_addons/git_nostr_object/tests/test_repo_{random_string()}'
        repo = self.GitRepository.create({
            'name': repo_name,
            'path': repo_path
        })
        _logger.info(f"Created Git Repository with ID: {repo.id}")

        # Test traverse_and_publish
        try:
            repo.traverse_and_publish()
            _logger.info("traverse_and_publish executed successfully")
        except Exception as e:
            _logger.error(f"Error in traverse_and_publish: {e}")

        # Test Git Commit
        commit_sha = generate_sha()
        commit_author = get_author(self.env)
        commit_timestamp = get_current_timestamp()
        commit_data = 'Test commit data'
        commit = self.GitCommit.create({
            'sha': commit_sha,
            'message': 'Test commit message',
            'author': commit_author,
            'timestamp': commit_timestamp,
            'data': commit_data
        })
        _logger.info(f"Created Git Commit with ID: {commit.id}")

        # Test Git Tree
        tree_sha = generate_sha()
        tree_data = 'Test tree data'
        tree = self.GitTree.create({
            'sha': tree_sha,
            'data': tree_data
        })
        _logger.info(f"Created Git Tree with ID: {tree.id}")

        # Test Git Blob
        blob_sha = generate_sha()
        blob_data = 'Test blob data'
        blob = self.GitBlob.create({
            'sha': blob_sha,
            'data': blob_data
        })
        _logger.info(f"Created Git Blob with ID: {blob.id}")

        # Test Nostr Event Object
        event_content = '# 1\nTest Nostr event content'
        event_type = get_event_type(event_content)
        event_tags = '[]'
        event_created_at = get_current_timestamp()
        event_signature = random_string(64)
        event_name = get_event_name(event_content)
        event = self.GitNostrEventObject.create({
            'kind': event_type,
            'content': event_content,
            'tags': event_tags,
            'created_at': event_created_at,
            'signature': event_signature,
            'name': event_name
        })
        _logger.info(f"Created Nostr Event Object with ID: {event.id}")

        # Test action_publish
        try:
            event.action_publish()
            _logger.info("action_publish executed successfully")
        except Exception as e:
            _logger.error(f"Error in action_publish: {e}")

    def test_nostr_auth(self):
        _logger.info("Testing Nostr Authentication module...")

        # Test Nostr Key
        public_key, private_key = generate_nostr_keys()
        key = self.NostrKey.create({
            'public_key': public_key,
            'private_key': private_key,
            'user_id': self.env.user.id
        })
        _logger.info(f"Created Nostr Key with ID: {key.id}")

        # Test Nostr Relay
        relay_url = f'wss://relay{random_string()}.com'
        relay = self.NostrRelay.create({
            'url': relay_url,
            'is_active': True
        })
        _logger.info(f"Created Nostr Relay with ID: {relay.id}")

        # Test Nostr Profile
        profile_name = f'Test Profile {random_string()}'
        profile_about = 'Test profile description'
        profile_picture = 'http://example.com/pic.jpg'
        profile = self.NostrProfile.create({
            'name': profile_name,
            'about': profile_about,
            'picture': profile_picture,
            'user_id': self.env.user.id
        })
        _logger.info(f"Created Nostr Profile with ID: {profile.id}")

        # Test generate_key_pair method
        try:
            result = self.NostrKey.generate_key_pair()
            _logger.info(f"Generated key pair: {result}")
        except Exception as e:
            _logger.error(f"Error in generate_key_pair: {e}")

        # Test sign_event method (assuming it exists)
        try:
            event_data = {
                'kind': 1,
                'content': 'Test content',
                'created_at': get_current_timestamp(),
                'tags': []
            }
            result = key.sign_event(event_data)
            _logger.info(f"Signed event: {result}")
        except Exception as e:
            _logger.error(f"Error in sign_event: {e}")

def test_git_nostr_object():
    test_case = TestGitNostrObject.create({})
    test_case.test_git_nostr_object()

def test_nostr_auth():
    test_case = TestGitNostrObject.create({})
    test_case.test_nostr_auth()

# This allows running the test from the Odoo shell
if __name__ == '__main__':
    test_git_nostr_object()
    test_nostr_auth()
=== ./odoo_custom_addons/git_nostr_object/views/git_blob_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_blob_form" model="ir.ui.view">
        <field name="name">git.blob.form</field>
        <field name="model">git.blob</field>
        <field name="arch" type="xml">
            <form>
                <group>
                    <field name="sha"/>
                    <field name="data"/>
                </group>
            </form>
        </field>
    </record>

    <record id="view_git_blob_tree" model="ir.ui.view">
        <field name="name">git.blob.tree</field>
        <field name="model">git.blob</field>
        <field name="arch" type="xml">
            <tree>
                <field name="sha"/>
            </tree>
        </field>
    </record>

    <record id="action_git_blob" model="ir.actions.act_window">
        <field name="name">Git Blobs</field>
        <field name="res_model">git.blob</field>
        <field name="view_mode">tree,form</field>
    </record>
</odoo>
=== ./odoo_custom_addons/git_nostr_object/views/menus.xml ===
<!-- views/menus.xml -->
<odoo>
    <menuitem id="menu_git_nostr_object_root" name="Git-Nostr Object">
        <menuitem id="menu_git_repository" name="Repositories" action="action_git_repository"/>
        <menuitem id="menu_git_commit" name="Commits" action="action_git_commit"/>
        <menuitem id="menu_git_tree" name="Trees" action="action_git_tree"/>
        <menuitem id="menu_git_blob" name="Blobs" action="action_git_blob"/>
        <menuitem id="menu_git_nostr_event_object" name="Nostr Event Objects" action="action_git_nostr_event_object"/>
    </menuitem>
</odoo>
=== ./odoo_custom_addons/git_nostr_object/views/git_commit_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_commit_form" model="ir.ui.view">
        <field name="name">git.commit.form</field>
        <field name="model">git.commit</field>
        <field name="arch" type="xml">
            <form>
                <group>
                    <field name="sha"/>
                    <field name="message"/>
                    <field name="author"/>
                    <field name="timestamp"/>
                    <field name="data"/>
                </group>
            </form>
        </field>
    </record>

    <record id="view_git_commit_tree" model="ir.ui.view">
        <field name="name">git.commit.tree</field>
        <field name="model">git.commit</field>
        <field name="arch" type="xml">
            <tree>
                <field name="sha"/>
                <field name="message"/>
                <field name="author"/>
                <field name="timestamp"/>
            </tree>
        </field>
    </record>

    <record id="action_git_commit" model="ir.actions.act_window">
        <field name="name">Git Commits</field>
        <field name="res_model">git.commit</field>
        <field name="view_mode">tree,form</field>
    </record>
</odoo>
=== ./odoo_custom_addons/git_nostr_object/views/git_object_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_object_form" model="ir.ui.view">
        <field name="name">git.object.form</field>
        <field name="model">git.object</field>
        <field name="arch" type="xml">
            <form>
                <group>
                    <field name="sha"/>
                    <field name="data"/>
                </group>
            </form>
        </field>
    </record>

    <record id="view_git_object_tree" model="ir.ui.view">
        <field name="name">git.object.tree</field>
        <field name="model">git.object</field>
        <field name="arch" type="xml">
            <tree>
                <field name="sha"/>
            </tree>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons/git_nostr_object/views/admin_test_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_admin_test_form" model="ir.ui.view">
        <field name="name">git_nostr_object.admin_test.form</field>
        <field name="model">git_nostr_object.admin_test</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="run_tests" string="Run Tests" type="object" class="oe_highlight"/>
                </header>
                <div>
                    <p>Click the button to run the Git-Nostr Object tests.</p>
                </div>
            </form>
        </field>
    </record>

    <record id="action_admin_test" model="ir.actions.act_window">
        <field name="name">Admin Tests</field>
        <field name="res_model">git_nostr_object.admin_test</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
    </record>

    <menuitem id="menu_admin_test" name="Admin Tests" parent="menu_git_nostr_object_root" action="action_admin_test" groups="base.group_system"/>
</odoo>
=== ./odoo_custom_addons/git_nostr_object/views/git_commit_wizard_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_commit_wizard_form" model="ir.ui.view">
        <field name="name">git.commit.wizard.form</field>
        <field name="model">git.commit.wizard</field>
        <field name="arch" type="xml">
            <form string="Create Commit">
                <group>
                    <field name="repository_id" invisible="1"/>
                    <field name="message"/>
                    <field name="file_name"/>
                    <field name="file_data"/>
                </group>
                <footer>
                    <button name="action_create_commit" string="Create Commit" type="object" class="btn-primary"/>
                    <button string="Cancel" class="btn-secondary" special="cancel"/>
                </footer>
            </form>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons/git_nostr_object/views/git_tree_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_tree_form" model="ir.ui.view">
        <field name="name">git.tree.form</field>
        <field name="model">git.tree</field>
        <field name="arch" type="xml">
            <form>
                <group>
                    <field name="sha"/>
                    <field name="data"/>
                </group>
            </form>
        </field>
    </record>

    <record id="view_git_tree_tree" model="ir.ui.view">
        <field name="name">git.tree.tree</field>
        <field name="model">git.tree</field>
        <field name="arch" type="xml">
            <tree>
                <field name="sha"/>
            </tree>
        </field>
    </record>

    <record id="action_git_tree" model="ir.actions.act_window">
        <field name="name">Git Trees</field>
        <field name="res_model">git.tree</field>
        <field name="view_mode">tree,form</field>
    </record>
</odoo>
=== ./odoo_custom_addons/git_nostr_object/views/nostr_event_object_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_nostr_event_object_form" model="ir.ui.view">
        <field name="name">nostr.event.object.form</field>
        <field name="model">nostr.event.object</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="action_publish" string="Publish Event" type="object" class="oe_highlight" attrs="{'invisible': [('published', '=', True)]}"/>
                </header>
                <sheet>
                    <group>
                        <field name="kind"/>
                        <field name="content"/>
                        <field name="tags"/>
                        <field name="created_at"/>
                        <field name="signature"/>
                        <field name="public_key"/>
                        <field name="published"/>
                    </group>
                    <notebook>
                        <page string="Logs">
                            <field name="logs" widget="text" readonly="1"/>
                        </page>
                    </notebook>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_nostr_event_object_tree" model="ir.ui.view">
        <field name="name">nostr.event.object.tree</field>
        <field name="model">nostr.event.object</field>
        <field name="arch" type="xml">
            <tree string="Nostr Event Objects">
                <field name="kind"/>
                <field name="content"/>
                <field name="tags"/>
                <field name="created_at"/>
                <field name="signature"/>
                <field name="public_key"/>
                <field name="published"/>
            </tree>
        </field>
    </record>

    <record id="action_nostr_event_object" model="ir.actions.act_window">
        <field name="name">Nostr Event Objects</field>
        <field name="res_model">nostr.event.object</field>
        <field name="view_mode">tree,form</field>
    </record>
</odoo>
=== ./odoo_custom_addons/git_nostr_object/views/git_repository_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_repository_form" model="ir.ui.view">
        <field name="name">git.repository.form</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="traverse_and_publish" string="Traverse and Publish" type="object" class="oe_highlight"/>
                </header>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="path" string="Local Path"/>
                    </group>
                    <notebook>
                        <page string="Logs">
                            <field name="logs" widget="text" readonly="1"/>
                        </page>
                    </notebook>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_git_repository_tree" model="ir.ui.view">
        <field name="name">git.repository.tree</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="path"/>
            </tree>
        </field>
    </record>

    <record id="action_git_repository" model="ir.actions.act_window">
        <field name="name">Git Repositories</field>
        <field name="res_model">git.repository</field>
        <field name="view_mode">tree,form</field>
    </record>
</odoo>
=== ./odoo_custom_addons/git_nostr_object/views/actions.xml ===
<!-- views/actions.xml -->
<odoo>
    <record id="action_git_nostr_event_object" model="ir.actions.act_window">
        <field name="name">Nostr Event Objects</field>
        <field name="res_model">nostr.event.object</field>
        <field name="view_mode">tree,form</field>
    </record>
</odoo>
=== ./odoo_custom_addons/git_nostr_object/controllers/git_controller.py ===
from odoo import http
from odoo.http import request
import logging

_logger = logging.getLogger(__name__)

class GitController(http.Controller):

    @http.route('/git_nostr_object/traverse_repo', type='json', auth='user')
    def traverse_repo(self, repo_id):
        try:
            repo = request.env['git.repository'].browse(repo_id)
            repo.traverse_and_publish()
            return {'status': 'success'}
        except Exception as e:
            _logger.exception("Error traversing repository")
            return {'status': 'error', 'message': str(e)}

    @http.route('/git_nostr_object/publish_event', type='json', auth='user')
    def publish_event(self, event_id):
        try:
            event = request.env['git_nostr.event.object'].browse(event_id)
            event.action_publish()
            return {'status': 'success'}
        except Exception as e:
            _logger.exception("Error publishing Nostr event")
            return {'status': 'error', 'message': str(e)}
=== ./odoo_custom_addons/custom_thunderbird_mail/models/custom_mail.py ===
import smtplib
from email.mime.text import MIMEText
from odoo import models, fields, api

class CustomMail(models.Model):
    _name = 'custom.mail'
    _description = 'Custom Mail Integration with Thunderbird Mail'

    @api.model
    def send_thunderbird_mail(self, recipient, subject, body):
        # Thunderbird SMTP server configuration
        smtp_server = 'test'
        smtp_port = 587
        smtp_user = 'g'
        smtp_password = 'your_thunderbird_password'  # Replace with the actual password

        # Create the email message
        msg = MIMEText(body)
        msg['Subject'] = subject
        msg['From'] = smtp_user
        msg['To'] = recipient

        # Send the email
        try:
            with smtplib.SMTP(smtp_server, smtp_port) as server:
                server.login(smtp_user, smtp_password)
                server.sendmail(smtp_user, [recipient], msg.as_string())
            return True
        except Exception as e:
            _logger.error('Failed to send email: %s', e)
            return False
=== ./odoo_custom_addons/custom_thunderbird_mail/__init__.py ===
from . import models
=== ./odoo_custom_addons/custom_thunderbird_mail/__manifest__.py ===
{
    'name': 'Custom Thunderbird Mail Integration',
    'version': '1.0',
    'category': 'Tools',
    'summary': 'Integrate Odoo with Thunderbird Mail',
    'description': 'A module to integrate Odoo with Thunderbird Mail for sending emails.',
    'depends': ['base'],
    'data': [],
    'installable': True,
    'application': True,
}
=== ./odoo_custom_addons/custom_thunderbird_mail/wizard/create_nostr_event_wizard.py ===
# wizard/create_nostr_event_wizard.py
from odoo import models, fields, api
import git
import json

class CreateNostrEventWizard(models.TransientModel):
    _name = 'create.nostr.event.wizard'
    _description = 'Create Nostr Event Wizard'

    repository_id = fields.Many2one('git.repository', string='Repository', required=True)
    event_type = fields.Selection([
        ('repo_anchor', 'Repository Anchor'),
        ('branch', 'Branch'),
        ('commit', 'Commit'),
        ('tree', 'Tree'),
        ('blob', 'Blob'),
    ], string='Event Type', required=True)
    commit_message = fields.Text(string='Commit Message')
    branch_name = fields.Char(string='Branch Name')
    file_content = fields.Text(string='File Content')
    file_name = fields.Char(string='File Name')

    def action_create_event(self):
        repo = git.Repo(self.repository_id.path)
        
        if self.event_type == 'commit':
            # Stage all changes
            repo.git.add(A=True)
            # Commit changes
            commit = repo.index.commit(self.commit_message)
            self.repository_id.last_commit = commit.hexsha
            content = json.dumps({
                'type': 'commit',
                'repository': self.repository_id.name,
                'commit_hash': commit.hexsha,
                'message': self.commit_message,
            })
        elif self.event_type == 'branch':
            repo.git.checkout('-b', self.branch_name)
            self.repository_id.branch = self.branch_name
            content = json.dumps({
                'type': 'branch',
                'repository': self.repository_id.name,
                'branch_name': self.branch_name,
            })
        elif self.event_type == 'blob':
            with open(os.path.join(self.repository_id.path, self.file_name), 'w') as f:
                f.write(self.file_content)
            repo.index.add([self.file_name])
            commit = repo.index.commit(f"Add file: {self.file_name}")
            self.repository_id.last_commit = commit.hexsha
            content = json.dumps({
                'type': 'blob',
                'repository': self.repository_id.name,
                'file_name': self.file_name,
                'commit_hash': commit.hexsha,
            })
        
        self.env['nostr.event'].create({
            'name': f"{self.event_type.capitalize()} - {self.repository_id.name}",
            'event_type': self.event_type,
            'content': content,
            'tags': json.dumps([['r', self.repository_id.remote_url]]),
        })

        return {'type': 'ir.actions.act_window_close'}
=== ./odoo_custom_addons/custom_thunderbird_mail/wizard/__init__.py ===
# wizard/__init__.py
from . import create_nostr_event_wizard
=== ./odoo_custom_addons/custom_thunderbird_mail/wizard/create_nostr_event_wizard_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_create_nostr_event_wizard_form" model="ir.ui.view">
        <field name="name">create.nostr.event.wizard.form</field>
        <field name="model">create.nostr.event.wizard</field>
        <field name="arch" type="xml">
            <form string="Create Nostr Event">
                <group>
                    <field name="repository_id"/>
                    <field name="event_type"/>
                    <field name="commit_message" attrs="{'invisible': [('event_type', '!=', 'commit')], 'required': [('event_type', '=', 'commit')]}"/>
                    <field name="branch_name" attrs="{'invisible': [('event_type', '!=', 'branch')], 'required': [('event_type', '=', 'branch')]}"/>
                    <field name="file_name" attrs="{'invisible': [('event_type', '!=', 'blob')], 'required': [('event_type', '=', 'blob')]}"/>
                    <field name="file_content" attrs="{'invisible': [('event_type', '!=', 'blob')], 'required': [('event_type', '=', 'blob')]}" widget="ace" options="{'mode': 'xml'}"/>
                </group>
                <footer>
                    <button name="action_create_event" string="Create Event" type="object" class="btn-primary"/>
                    <button string="Cancel" class="btn-secondary" special="cancel"/>
                </footer>
            </form>
        </field>
    </record>

    <record id="action_create_nostr_event_wizard" model="ir.actions.act_window">
        <field name="name">Create Nostr Event</field>
        <field name="res_model">create.nostr.event.wizard</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
    </record>
</odoo>
=== ./odoo_custom_addons/custom_thunderbird_mail/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_git_repository,access_git_repository,model_git_repository,base.group_user,1,1,1,1
access_nostr_event,access_nostr_event,model_nostr_event,base.group_user,1,1,1,1
access_create_nostr_event_wizard,access_create_nostr_event_wizard,model_create_nostr_event_wizard,base.group_user,1,1,1,0
=== ./odoo_custom_addons/custom_thunderbird_mail/views/res_users_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_users_form_inherit_git_nostr" model="ir.ui.view">
        <field name="name">res.users.form.inherit.git.nostr</field>
        <field name="model">res.users</field>
        <field name="inherit_id" ref="base.view_users_form"/>
        <field name="arch" type="xml">
            <notebook position="inside">
                <page string="Nostr Settings" name="nostr_settings">
                    <group>
                        <field name="nostr_private_key" password="True"/>
                        <field name="nostr_public_key"/>
                    </group>
                </page>
            </notebook>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons/custom_thunderbird_mail/views/res_config_settings_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="res_config_settings_view_form" model="ir.ui.view">
        <field name="name">res.config.settings.view.form.inherit.git_nostr_bridge</field>
        <field name="model">res.config.settings</field>
        <field name="inherit_id" ref="base.res_config_settings_view_form"/>
        <field name="arch" type="xml">
            <xpath expr="//div[hasclass('settings')]" position="inside">
                <div class="app_settings_block" data-string="Git-Nostr Bridge" string="Git-Nostr Bridge" data-key="git_nostr_bridge">
                    <h2>Nostr Settings</h2>
                    <div class="row mt16 o_settings_container">
                        <div class="col-12 col-lg-6 o_setting_box">
                            <div class="o_setting_left_pane"/>
                            <div class="o_setting_right_pane">
                                <span class="o_form_label">Nostr Relay URLs</span>
                                <div class="text-muted">
                                    Comma-separated list of Nostr relay URLs
                                </div>
                                <div class="content-group">
                                    <div class="mt16">
                                        <field name="git_nostr_relay_urls"/>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </xpath>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons/custom_thunderbird_mail/views/nostr_event_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_nostr_event_form" model="ir.ui.view">
        <field name="name">nostr.event.form</field>
        <field name="model">nostr.event</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="action_publish" string="Publish" type="object" class="oe_highlight" attrs="{'invisible': [('published', '=', True)]}"/>
                </header>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="event_type"/>
                        <field name="content"/>
                        <field name="tags"/>
                        <field name="published"/>
                        <field name="event_id"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_nostr_event_form_git_nostr" model="ir.ui.view">
        <field name="name">nostr.event.form.git.nostr</field>
        <field name="model">nostr.event</field>
        <field name="inherit_id" ref="integrated_ivcs.view_nostr_event_form"/>
        <field name="arch" type="xml">
            <xpath expr="//field[@name='event_type']" position="after">
                <field name="repository_id" attrs="{'invisible': [('event_type', 'not in', ['repo_anchor', 'branch', 'commit', 'tree', 'blob'])]}"/>
            </xpath>
        </field>
    </record>

    <record id="action_nostr_event" model="ir.actions.act_window">
        <field name="name">Nostr Events</field>
        <field name="res_model">nostr.event</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_nostr_event_git" name="Git Nostr Events" parent="menu_git_nostr_bridge" action="integrated_ivcs.action_nostr_event" sequence="20"/>
</odoo>
=== ./odoo_custom_addons/custom_thunderbird_mail/views/git_repository_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_repository_form" model="ir.ui.view">
        <field name="name">git.repository.form</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="action_pull" string="Pull" type="object" class="oe_highlight"/>
                    <button name="action_push" string="Push" type="object" class="oe_highlight"/>
                    <button name="action_commit" string="Commit" type="object" class="oe_highlight"/>
                </header>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="path"/>
                        <field name="remote_url"/>
                        <field name="branch"/>
                        <field name="last_commit"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="action_git_repository" model="ir.actions.act_window">
        <field name="name">Git Repositories</field>
        <field name="res_model">git.repository</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_git_nostr_bridge" name="Git-Nostr Bridge" sequence="10"/>
    <menuitem id="menu_git_repository" name="Git Repositories" parent="menu_git_nostr_bridge" action="action_git_repository" sequence="10"/>
</odoo>
=== ./odoo_custom_addons/git_nostr_bridge/models/git_repository.py ===
# models/git_repository.py
import os
import git
from odoo import models, fields, api, _
from odoo.exceptions import UserError

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Name', required=True)
    path = fields.Char(string='Local Path', required=True)
    remote_url = fields.Char(string='Remote URL')
    branch = fields.Char(string='Current Branch', default='main')
    last_commit = fields.Char(string='Last Commit', readonly=True)

    @api.model
    def create(self, vals):
        repo = super(GitRepository, self).create(vals)
        repo._initialize_repository()
        return repo

    def _initialize_repository(self):
        if not os.path.exists(self.path):
            os.makedirs(self.path)
            repo = git.Repo.init(self.path)
            if self.remote_url:
                repo.create_remote('origin', self.remote_url)
            open(os.path.join(self.path, 'README.md'), 'w').close()
            repo.index.add(['README.md'])
            repo.index.commit('Initial commit')
            self.last_commit = repo.head.commit.hexsha

    def action_pull(self):
        repo = git.Repo(self.path)
        origin = repo.remotes.origin
        origin.pull()
        self.last_commit = repo.head.commit.hexsha

    def action_push(self):
        repo = git.Repo(self.path)
        origin = repo.remotes.origin
        origin.push()

    def action_commit(self):
        return {
            'name': _('Create Commit'),
            'type': 'ir.actions.act_window',
            'res_model': 'create.nostr.event.wizard',
            'view_mode': 'form',
            'target': 'new',
            'context': {'default_repository_id': self.id, 'default_event_type': 'commit'},
        }
=== ./odoo_custom_addons/git_nostr_bridge/models/__init__.py ===
from . import git_repository
from . import nostr_event
from . import res_config_settings
=== ./odoo_custom_addons/git_nostr_bridge/models/res_users.py ===
from odoo import models, fields, api
from nostr.key import PrivateKey

class ResUsers(models.Model):
    _inherit = 'res.users'

    nostr_public_key = fields.Char(string="Nostr Public Key")
    nostr_private_key = fields.Char(string="Nostr Private Key")
    nostr_relay_url = fields.Char(string="Nostr Relay URL")

    @api.depends('nostr_private_key')
    def _compute_public_key(self):
        for user in self:
            if user.nostr_private_key:
                try:
                    private_key = PrivateKey.from_nsec(user.nostr_private_key)
                    user.nostr_public_key = private_key.public_key.hex()
                except Exception:
                    user.nostr_public_key = False
            else:
                user.nostr_public_key = False

    @api.model
    def create(self, vals):
        if 'nostr_private_key' not in vals or not vals['nostr_private_key']:
            private_key = PrivateKey()
            vals['nostr_private_key'] = private_key.bech32()
        return super(ResUsers, self).create(vals)
=== ./odoo_custom_addons/git_nostr_bridge/models/nostr_event.py ===
# File: /opt/odoo/custom_addons/git_nostr_bridge/models/nostr_event.py

import asyncio
import json
import logging
import websockets
from urllib.parse import urlparse
import time
import traceback

from odoo import models, fields, api, _
from odoo.exceptions import UserError
from nostr.event import Event as NostrLibEvent
from nostr.key import PrivateKey

_logger = logging.getLogger(__name__)

class NostrEvent(models.Model):
    _name = 'nostr.event'
    _description = 'Nostr Event'
    _inherit = 'nostr.event'

    name = fields.Char(string='Name', required=True)
    event_type = fields.Selection([
        ('repo_anchor', 'Repository Anchor'),
        ('branch', 'Branch'),
        ('commit', 'Commit'),
        ('tree', 'Tree'),
        ('blob', 'Blob'),
    ], string='Event Type', required=True)
    content = fields.Text(string='Content')
    tags = fields.Text(string='Tags')
    published = fields.Boolean(string='Published', default=False)
    event_id = fields.Char(string='Event ID', readonly=True)
    kind = fields.Integer(string='Nostr Event Kind', default=1)
    repository_id = fields.Many2one('git.repository', string='Related Repository')
    signature = fields.Char(string='Signature', readonly=True)
    public_key = fields.Char(string='Public Key', readonly=True)
    created_at = fields.Integer(string='Created At', readonly=True)

    @api.model
    def create(self, vals):
        record = super(NostrEvent, self).create(vals)
        record.generate_event_details()
        return record

    def generate_event_details(self):
        if not self.event_id or not self.signature:
            try:
                private_key = PrivateKey()
                public_key = private_key.public_key.hex()
                
                event = NostrLibEvent(
                    kind=self.kind,
                    content=self.content or '',
                    tags=json.loads(self.tags) if self.tags else [],
                    public_key=public_key,
                    created_at=int(time.time())
                )
                
                private_key.sign_event(event)
                
                self.write({
                    'event_id': event.id,
                    'signature': event.signature,
                    'public_key': public_key,
                    'created_at': event.created_at
                })
            except Exception as e:
                _logger.error(f"Error generating Nostr event details: {str(e)}")
                # Not raising UserError here to avoid disrupting the creation process

    @api.model
    def action_publish(self, event_id):
        event = self.browse(event_id)
        _logger.info(f"Starting publish action for event: {event.name}")
        start_time = time.time()

        try:
            if not self.env.user.nostr_private_key:
                raise UserError(_("Nostr private key is not set for the current user."))

            _logger.info("Generating private key")
            try:
                private_key = PrivateKey.from_nsec(self.env.user.nostr_private_key)
                _logger.info("Private key generated successfully")
            except Exception as e:
                _logger.error(f"Failed to generate private key: {str(e)}")
                _logger.error(traceback.format_exc())
                raise UserError(_("Invalid Nostr private key: %s") % str(e))

            public_key = private_key.public_key.hex()
            _logger.info(f"Public key: {public_key}")

            _logger.info("Parsing tags")
            try:
                tags = json.loads(event.tags) if event.tags else []
                _logger.info(f"Parsed tags: {tags}")
                if not isinstance(tags, list):
                    raise ValueError("Tags must be a list of lists")
                for tag in tags:
                    if not isinstance(tag, list):
                        raise ValueError("Each tag must be a list")
            except json.JSONDecodeError as e:
                _logger.error(f"JSON decode error: {str(e)}")
                _logger.error(traceback.format_exc())
                raise UserError(_("Invalid tags format. Please ensure tags are in valid JSON format."))
            except ValueError as e:
                _logger.error(f"Value error: {str(e)}")
                _logger.error(traceback.format_exc())
                raise UserError(_("Invalid tags format: %s") % str(e))

            _logger.info("Creating Nostr event")
            nostr_event = NostrLibEvent(
                kind=1,  # Assuming TEXT_NOTE, adjust if needed
                content=str(event.content),
                tags=tags,
                public_key=public_key  # Ensure public_key is provided
            )
            private_key.sign_event(nostr_event)
            _logger.info(f"Event created: {nostr_event.to_message()}")

            _logger.info("Fetching relay URLs")
            relay_urls = self.env['ir.config_parameter'].sudo().get_param('git_nostr_bridge.relay_urls', '').split(',')
            relay_urls = [url.strip() for url in relay_urls if url.strip()][:5]  # Limit to 5 relays
            _logger.info(f"Relay URLs: {relay_urls}")

            if not relay_urls:
                raise UserError(_("No Nostr relay URLs configured. Please set them in the settings."))

            _logger.info("Validating relay URLs")
            for url in relay_urls:
                parsed = urlparse(url)
                if parsed.scheme not in ('ws', 'wss'):
                    _logger.error(f"Invalid relay URL: {url}")
                    raise UserError(_("Invalid relay URL: %s. Must start with ws:// or wss://") % url)

            async def publish_to_relay(relay_url, nostr_event, retries=3):
                for attempt in range(retries):
                    try:
                        _logger.info(f"Attempting to connect to {relay_url} (attempt {attempt + 1})")
                        connection_start = time.time()
                        async with websockets.connect(relay_url, timeout=30) as websocket:
                            connection_end = time.time()
                            _logger.info(f"Connected to {relay_url} in {connection_end - connection_start:.2f} seconds")
                            
                            message = nostr_event.to_message()
                            _logger.debug(f"Raw event message: {message}")
                            
                            _logger.info(f"Sending Nostr event to {relay_url}: {message}")
                            
                            send_start = time.time()
                            await websocket.send(message)
                            send_end = time.time()
                            _logger.info(f"Sent message to {relay_url} in {send_end - send_start:.2f} seconds")
                            
                            _logger.info(f"Waiting for response from {relay_url}")
                            response_start = time.time()
                            response = await asyncio.wait_for(websocket.recv(), timeout=10.0)
                            response_end = time.time()
                            _logger.info(f"Received response from {relay_url} in {response_end - response_start:.2f} seconds: {response}")
                            
                            try:
                                return json.loads(response)
                            except json.JSONDecodeError as e:
                                _logger.error(f"Failed to parse response from {relay_url}: {str(e)}")
                                return f"Invalid response from {relay_url}: {response}"
                    except (websockets.exceptions.WebSocketException, asyncio.TimeoutError) as e:
                        _logger.error(f"Error publishing to {relay_url} (attempt {attempt + 1}): {str(e)}")
                        _logger.error(traceback.format_exc())
                        await asyncio.sleep(5 * (attempt + 1))  # Increased delay between attempts
                return f"Failed to publish to {relay_url} after {retries} attempts"

            async def publish_with_timeout():
                tasks = [publish_to_relay(url, nostr_event) for url in relay_urls]
                return await asyncio.gather(*tasks, return_exceptions=True)

            async def run_publication():
                _logger.info("Starting publication process")
                try:
                    results = await asyncio.wait_for(publish_with_timeout(), timeout=120)  # Increased overall timeout
                    _logger.info(f"Publication results: {results}")
                    return results
                except asyncio.TimeoutError:
                    _logger.error("Publication process timed out after 120 seconds")
                    raise UserError(_("Publishing timed out after 120 seconds"))

            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            try:
                results = loop.run_until_complete(run_publication())
            finally:
                loop.close()

            success = any(isinstance(result, list) and result[0] == "OK" for result in results)
            if success:
                event.write({
                    'published': True,
                    'event_id': nostr_event.id
                })
                _logger.info(f"Successfully published Nostr event: {nostr_event.id}")
                
                # Verify event publication
                self.verify_event_publication(nostr_event.id, relay_urls)
                
                end_time = time.time()
                _logger.info(f"Total publish action time: {end_time - start_time:.2f} seconds")
                
                return {
                    'type': 'ir.actions.client',
                    'tag': 'display_notification',
                    'params': {
                        'message': _("Nostr event successfully published to at least one relay."),
                        'type': 'success',
                        'sticky': False,
                    }
                }
            else:
                error_messages = [str(result) for result in results if isinstance(result, str)]
                _logger.error(f"Failed to publish Nostr event: {'; '.join(error_messages)}")
                raise UserError(_("Failed to publish Nostr event: %s") % "; ".join(error_messages))

        except Exception as e:
            _logger.error(f"Unexpected error in action_publish: {str(e)}")
            _logger.error(traceback.format_exc())
            raise UserError(_("An unexpected error occurred: %s") % str(e))

    @api.model
    def verify_event_publication(self, event_id, relay_urls, max_attempts=5, delay=2):
        _logger.info(f"Starting verification for event: {event_id}")
        for attempt in range(max_attempts):
            _logger.info(f"Verification attempt {attempt + 1}")
            for url in relay_urls:
                try:
                    loop = asyncio.new_event_loop()
                    asyncio.set_event_loop(loop)
                    result = loop.run_until_complete(self.query_event(url, event_id))
                    if result:
                        _logger.info(f"Event {event_id} found on relay {url}")
                        return True
                except Exception as e:
                    _logger.error(f"Error querying event from {url}: {str(e)}")
                    _logger.error(traceback.format_exc())
                finally:
                    loop.close()
            _logger.info(f"Waiting {delay} seconds before next attempt")
            time.sleep(delay)
        _logger.warning(f"Event {event_id} not found on any relay after {max_attempts} attempts")
        return False

    async def query_event(self, relay_url, event_id):
        _logger.info(f"Querying event {event_id} from {relay_url}")
        start_time = time.time()
        try:
            async with websockets.connect(relay_url, timeout=10) as websocket:
                request = json.dumps(["REQ", "query", {"ids": [event_id]}])
                _logger.info(f"Sending query to {relay_url}: {request}")
                await websocket.send(request)
                response = await asyncio.wait_for(websocket.recv(), timeout=5.0)
                _logger.info(f"Response from {relay_url}: {response}")
                end_time = time.time()
                _logger.info(f"Query to {relay_url} took {end_time - start_time:.2f} seconds")
                return json.loads(response)
        except Exception as e:
            _logger.error(f"Error querying {relay_url}: {str(e)}")
            _logger.error(traceback.format_exc())
            end_time = time.time()
            _logger.info(f"Failed query to {relay_url} took {end_time - start_time:.2f} seconds")
            return None
=== ./odoo_custom_addons/git_nostr_bridge/models/res_config_settings.py ===
import requests
import json
from odoo import fields, models, api
import logging

_logger = logging.getLogger(__name__)

class ResConfigSettings(models.TransientModel):
    _inherit = 'res.config.settings'

    git_nostr_relay_urls = fields.Char(
        string="Nostr Relay URLs", 
        config_parameter='git_nostr_bridge.relay_urls',
        default=lambda self: self._default_nostr_relays()
    )

    def _default_nostr_relays(self):
        return self._get_top_nostr_relays()

    @api.model
    def _get_top_nostr_relays(self, limit=108):
        url = "https://api.nostr.watch/v1/online"
        try:
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
            }
            response = requests.get(url, headers=headers, timeout=10)
            response.raise_for_status()
            _logger.info(f"Response status code: {response.status_code}")
            
            data = response.json()
            _logger.info(f"API response (first 108 items): {data[:108]}")
            
            relays = data[:108]
            _logger.info(f"Number of relay links found: {len(relays)}")
            _logger.info(f"Extracted relays (first 5): {relays[:5]}")
            
            relay_urls = ",".join(relays)
            return relay_urls
        except requests.RequestException as e:
            _logger.error(f"Error fetching Nostr relays: {e}")
            return "wss://nostr-relay.app,wss://nos.lol,wss://relay.snort.social,wss://relay.nostr.net"

    nostr_relay_urls = fields.Char(
        string="Nostr Relay URLs", 
        config_parameter='nostr_bridge.relay_urls',
        default=_default_nostr_relays
    )

    @api.model
    def get_values(self):
        res = super(ResConfigSettings, self).get_values()
        ICPSudo = self.env['ir.config_parameter'].sudo()
        
        relay_urls = ICPSudo.get_param('git_nostr_bridge.relay_urls')
        if not relay_urls:
            relay_urls = self._default_nostr_relays()
            ICPSudo.set_param('git_nostr_bridge.relay_urls', relay_urls)
            _logger.info(f"Set new relay URLs: {relay_urls[:100]}...")
        else:
            _logger.info(f"Using existing relay URLs: {relay_urls[:100]}...")
        
        res.update(git_nostr_relay_urls=relay_urls)
        return res

    def set_values(self):
        super(ResConfigSettings, self).set_values()
        ICPSudo = self.env['ir.config_parameter'].sudo()
        if self.git_nostr_relay_urls:
            ICPSudo.set_param('git_nostr_bridge.relay_urls', self.git_nostr_relay_urls)
            _logger.info(f"Updated relay URLs: {self.git_nostr_relay_urls[:100]}...")
        else:
            default_urls = self._default_nostr_relays()
            ICPSudo.set_param('git_nostr_bridge.relay_urls', default_urls)
            _logger.info(f"Set default relay URLs: {default_urls[:100]}...")
=== ./odoo_custom_addons/git_nostr_bridge/models/git_repository ===
# models/git_repository.py
import os
import git
from odoo import models, fields, api, _
from odoo.exceptions import UserError

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Name', required=True)
    path = fields.Char(string='Local Path', required=True)
    remote_url = fields.Char(string='Remote URL')
    branch = fields.Char(string='Current Branch', default='main')
    last_commit = fields.Char(string='Last Commit', readonly=True)

    @api.model
    def create(self, vals):
        repo = super(GitRepository, self).create(vals)
        repo._initialize_repository()
        return repo

    def _initialize_repository(self):
        if not os.path.exists(self.path):
            os.makedirs(self.path)
            repo = git.Repo.init(self.path)
            if self.remote_url:
                repo.create_remote('origin', self.remote_url)
            open(os.path.join(self.path, 'README.md'), 'w').close()
            repo.index.add(['README.md'])
            repo.index.commit('Initial commit')
            self.last_commit = repo.head.commit.hexsha

    def action_pull(self):
        repo = git.Repo(self.path)
        origin = repo.remotes.origin
        origin.pull()
        self.last_commit = repo.head.commit.hexsha

    def action_push(self):
        repo = git.Repo(self.path)
        origin = repo.remotes.origin
        origin.push()

    def action_commit(self):
        return {
            'name': _('Create Commit'),
            'type': 'ir.actions.act_window',
            'res_model': 'create.nostr.event.wizard',
            'view_mode': 'form',
            'target': 'new',
            'context': {'default_repository_id': self.id, 'default_event_type': 'commit'},
        }
=== ./odoo_custom_addons/git_nostr_bridge/__init__.py ===
from . import models
from . import wizard
=== ./odoo_custom_addons/git_nostr_bridge/__manifest__.py ===
{
    'name': 'Git-Nostr Bridge',
    'version': '1.0',
    'category': 'Tools',
    'summary': 'Integrates Git repositories with Nostr network',
    'author': 'Your Name',
    'website': 'https://www.example.com',
    'depends': ['base', 'mail', 'nostr_auth', 'nostr_bridge', 'integrated_ivcs'],
    'data': [
        'security/ir.model.access.csv',
        'views/git_repository_views.xml',
        'views/nostr_event_views.xml',
        'views/res_config_settings_views.xml',
        'views/res_users_views.xml',
        'wizard/create_nostr_event_wizard_views.xml',
    ],
    'installable': True,
    'application': True,
    'auto_install': False,
    'external_dependencies': {
        'python': ['git', 'nostr', 'websockets'],
    },
}
=== ./odoo_custom_addons/git_nostr_bridge/wizard/create_nostr_event_wizard.py ===
# wizard/create_nostr_event_wizard.py
from odoo import models, fields, api
import git
import json

class CreateNostrEventWizard(models.TransientModel):
    _name = 'create.nostr.event.wizard'
    _description = 'Create Nostr Event Wizard'

    repository_id = fields.Many2one('git.repository', string='Repository', required=True)
    event_type = fields.Selection([
        ('repo_anchor', 'Repository Anchor'),
        ('branch', 'Branch'),
        ('commit', 'Commit'),
        ('tree', 'Tree'),
        ('blob', 'Blob'),
    ], string='Event Type', required=True)
    commit_message = fields.Text(string='Commit Message')
    branch_name = fields.Char(string='Branch Name')
    file_content = fields.Text(string='File Content')
    file_name = fields.Char(string='File Name')

    def action_create_event(self):
        repo = git.Repo(self.repository_id.path)
        
        if self.event_type == 'commit':
            # Stage all changes
            repo.git.add(A=True)
            # Commit changes
            commit = repo.index.commit(self.commit_message)
            self.repository_id.last_commit = commit.hexsha
            content = json.dumps({
                'type': 'commit',
                'repository': self.repository_id.name,
                'commit_hash': commit.hexsha,
                'message': self.commit_message,
            })
        elif self.event_type == 'branch':
            repo.git.checkout('-b', self.branch_name)
            self.repository_id.branch = self.branch_name
            content = json.dumps({
                'type': 'branch',
                'repository': self.repository_id.name,
                'branch_name': self.branch_name,
            })
        elif self.event_type == 'blob':
            with open(os.path.join(self.repository_id.path, self.file_name), 'w') as f:
                f.write(self.file_content)
            repo.index.add([self.file_name])
            commit = repo.index.commit(f"Add file: {self.file_name}")
            self.repository_id.last_commit = commit.hexsha
            content = json.dumps({
                'type': 'blob',
                'repository': self.repository_id.name,
                'file_name': self.file_name,
                'commit_hash': commit.hexsha,
            })
        
        self.env['nostr.event'].create({
            'name': f"{self.event_type.capitalize()} - {self.repository_id.name}",
            'event_type': self.event_type,
            'content': content,
            'tags': json.dumps([['r', self.repository_id.remote_url]]),
        })

        return {'type': 'ir.actions.act_window_close'}
=== ./odoo_custom_addons/git_nostr_bridge/wizard/__init__.py ===
# wizard/__init__.py
from . import create_nostr_event_wizard
=== ./odoo_custom_addons/git_nostr_bridge/wizard/create_nostr_event_wizard_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_create_nostr_event_wizard_form" model="ir.ui.view">
        <field name="name">create.nostr.event.wizard.form</field>
        <field name="model">create.nostr.event.wizard</field>
        <field name="arch" type="xml">
            <form string="Create Nostr Event">
                <group>
                    <field name="repository_id"/>
                    <field name="event_type"/>
                    <field name="commit_message" attrs="{'invisible': [('event_type', '!=', 'commit')], 'required': [('event_type', '=', 'commit')]}"/>
                    <field name="branch_name" attrs="{'invisible': [('event_type', '!=', 'branch')], 'required': [('event_type', '=', 'branch')]}"/>
                    <field name="file_name" attrs="{'invisible': [('event_type', '!=', 'blob')], 'required': [('event_type', '=', 'blob')]}"/>
                    <field name="file_content" attrs="{'invisible': [('event_type', '!=', 'blob')], 'required': [('event_type', '=', 'blob')]}" widget="ace" options="{'mode': 'xml'}"/>
                </group>
                <footer>
                    <button name="action_create_event" string="Create Event" type="object" class="btn-primary"/>
                    <button string="Cancel" class="btn-secondary" special="cancel"/>
                </footer>
            </form>
        </field>
    </record>

    <record id="action_create_nostr_event_wizard" model="ir.actions.act_window">
        <field name="name">Create Nostr Event</field>
        <field name="res_model">create.nostr.event.wizard</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
    </record>
</odoo>
=== ./odoo_custom_addons/git_nostr_bridge/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_git_repository,access_git_repository,model_git_repository,base.group_user,1,1,1,1
access_nostr_event,access_nostr_event,model_nostr_event,base.group_user,1,1,1,1
access_create_nostr_event_wizard,access_create_nostr_event_wizard,model_create_nostr_event_wizard,base.group_user,1,1,1,0
=== ./odoo_custom_addons/git_nostr_bridge/views/res_users_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_users_form_inherit_git_nostr" model="ir.ui.view">
        <field name="name">res.users.form.inherit.git.nostr</field>
        <field name="model">res.users</field>
        <field name="inherit_id" ref="base.view_users_form"/>
        <field name="arch" type="xml">
            <notebook position="inside">
                <page string="Nostr Settings" name="nostr_settings">
                    <group>
                        <field name="nostr_private_key" password="True"/>
                        <field name="nostr_public_key"/>
                    </group>
                </page>
            </notebook>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons/git_nostr_bridge/views/res_config_settings_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="res_config_settings_view_form" model="ir.ui.view">
        <field name="name">res.config.settings.view.form.inherit.git_nostr_bridge</field>
        <field name="model">res.config.settings</field>
        <field name="inherit_id" ref="base.res_config_settings_view_form"/>
        <field name="arch" type="xml">
            <xpath expr="//div[hasclass('settings')]" position="inside">
                <div class="app_settings_block" data-string="Git-Nostr Bridge" string="Git-Nostr Bridge" data-key="git_nostr_bridge">
                    <h2>Nostr Settings</h2>
                    <div class="row mt16 o_settings_container">
                        <div class="col-12 col-lg-6 o_setting_box">
                            <div class="o_setting_left_pane"/>
                            <div class="o_setting_right_pane">
                                <span class="o_form_label">Nostr Relay URLs</span>
                                <div class="text-muted">
                                    Comma-separated list of Nostr relay URLs
                                </div>
                                <div class="content-group">
                                    <div class="mt16">
                                        <field name="git_nostr_relay_urls"/>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </xpath>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons/git_nostr_bridge/views/nostr_event_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_nostr_event_form" model="ir.ui.view">
        <field name="name">nostr.event.form</field>
        <field name="model">nostr.event</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="action_publish" string="Publish" type="object" class="oe_highlight" attrs="{'invisible': [('published', '=', True)]}"/>
                </header>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="event_type"/>
                        <field name="content"/>
                        <field name="tags"/>
                        <field name="published"/>
                        <field name="event_id"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_nostr_event_form_git_nostr" model="ir.ui.view">
        <field name="name">nostr.event.form.git.nostr</field>
        <field name="model">nostr.event</field>
        <field name="inherit_id" ref="integrated_ivcs.view_nostr_event_form"/>
        <field name="arch" type="xml">
            <xpath expr="//field[@name='event_type']" position="after">
                <field name="repository_id" attrs="{'invisible': [('event_type', 'not in', ['repo_anchor', 'branch', 'commit', 'tree', 'blob'])]}"/>
            </xpath>
        </field>
    </record>

    <record id="action_nostr_event" model="ir.actions.act_window">
        <field name="name">Nostr Events</field>
        <field name="res_model">nostr.event</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_nostr_event_git" name="Git Nostr Events" parent="menu_git_nostr_bridge" action="integrated_ivcs.action_nostr_event" sequence="20"/>
</odoo>
=== ./odoo_custom_addons/git_nostr_bridge/views/git_repository_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_repository_form" model="ir.ui.view">
        <field name="name">git.repository.form</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="action_pull" string="Pull" type="object" class="oe_highlight"/>
                    <button name="action_push" string="Push" type="object" class="oe_highlight"/>
                    <button name="action_commit" string="Commit" type="object" class="oe_highlight"/>
                </header>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="path"/>
                        <field name="remote_url"/>
                        <field name="branch"/>
                        <field name="last_commit"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="action_git_repository" model="ir.actions.act_window">
        <field name="name">Git Repositories</field>
        <field name="res_model">git.repository</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_git_nostr_bridge" name="Git-Nostr Bridge" sequence="10"/>
    <menuitem id="menu_git_repository" name="Git Repositories" parent="menu_git_nostr_bridge" action="action_git_repository" sequence="10"/>
</odoo>
=== ./odoo_custom_addons/gitlab_nostr_bridge/models/gitlab_commit.py ===
from odoo import models, fields, api
from dateutil import parser
from datetime import datetime, timezone

class GitlabCommit(models.Model):
    _name = 'gitlab.commit'
    _description = 'GitLab Commit'

    name = fields.Char(string='Commit Hash', required=True)
    message = fields.Text(string='Commit Message')
    author = fields.Char(string='Author')
    date = fields.Datetime(string='Commit Date')
    repository_id = fields.Many2one('gitlab.repository', string='Repository', required=True)
    branch_ids = fields.Many2many('gitlab.branch', string='Branches')

    @api.model
    def create_or_update_from_gitlab(self, repository_id, gitlab_commit):
        existing_commit = self.search([('name', '=', gitlab_commit.id), ('repository_id', '=', repository_id)])
        commit_date = self._convert_to_naive_datetime(gitlab_commit.committed_date)
        if existing_commit:
            return existing_commit.write({
                'message': gitlab_commit.message,
                'author': gitlab_commit.author_name,
                'date': commit_date,
            })
        else:
            return self.create({
                'name': gitlab_commit.id,
                'message': gitlab_commit.message,
                'author': gitlab_commit.author_name,
                'date': commit_date,
                'repository_id': repository_id,
            })

    def _convert_to_naive_datetime(self, date_string):
        dt = parser.parse(date_string)
        return dt.replace(tzinfo=None)
=== ./odoo_custom_addons/gitlab_nostr_bridge/models/__init__.py ===
from . import gitlab_repository
from . import gitlab_branch
from . import gitlab_commit
from . import nostr_event
from . import res_config_settings
=== ./odoo_custom_addons/gitlab_nostr_bridge/models/nostr_event.py ===
# File: gitlab_nostr_bridge/models/nostr_event.py

from odoo import models, fields, api, _
from odoo.exceptions import UserError
from nostr.event import Event
from nostr.key import PrivateKey
from bech32 import bech32_decode, convertbits
import json
import logging
import time
import asyncio
import websockets

_logger = logging.getLogger(__name__)

class NostrEvent(models.Model):
    _name = 'nostr.event'
    _description = 'Nostr Event'

    event_id = fields.Char(string='Event ID', required=True)
    kind = fields.Integer(string='Event Kind', required=True)
    content = fields.Text(string='Content', required=True)
    tags = fields.Text(string='Tags')
    public_key = fields.Char(string='Public Key', required=True)
    created_at = fields.Integer(string='Created At', required=True)
    signature = fields.Char(string='Signature', required=True)
    published = fields.Boolean(string='Published', default=False)
    logs = fields.Text(string='Logs')

    @api.model
    def create_gitlab_event(self, event_type, data):
        content = json.dumps(data)
        event = Event(
            kind=self._get_event_kind(event_type),
            content=content,
            tags=self._get_event_tags(event_type, data),
            public_key=self.env.user.nostr_public_key,
            created_at=int(time.time())
        )
        private_key = self._get_private_key(self.env.user.nostr_private_key)
        private_key.sign_event(event)
        
        # Convert the event to a properly formatted JSON string
        event_data = {
            "id": event.id,
            "pubkey": event.public_key,
            "created_at": event.created_at,
            "kind": event.kind,
            "tags": event.tags,
            "content": event.content,
            "sig": event.signature
        }
        return self.create_and_publish(event_data)

    def _get_event_kind(self, event_type):
        event_kinds = {
            'commit': 3121,
            'branch': 31227,
            'merge_request': 31228,
        }
        return event_kinds.get(event_type, 1)

    def _get_event_tags(self, event_type, data):
        tags = []
        if event_type == 'commit':
            tags.extend([['p', data['project_id']], ['c', data['commit_id']]])
        elif event_type == 'branch':
            tags.extend([['p', data['project_id']], ['b', data['branch_name']]])
        elif event_type == 'merge_request':
            tags.extend([['p', data['project_id']], ['mr', data['merge_request_id']]])
        return tags

    def _get_private_key(self, key):
        _logger.info(f"Getting private key. Key starts with: {key[:8] if key else 'None'}")
        if not key:
            raise UserError(_("Nostr private key is not set for the current user."))
        
        if key.startswith('nsec'):
            hrp, data = bech32_decode(key)
            if data is None:
                raise ValueError("Invalid nsec key")
            hex_key = bytes(convertbits(data, 5, 8, False)).hex()
        elif len(key) == 64:  # It's already a hex key
            hex_key = key
        else:
            raise ValueError("Invalid private key format")
        return PrivateKey(bytes.fromhex(hex_key))


    def create_and_publish(self, event):
        try:
            vals = {
                'event_id': event.id,
                'kind': event.kind,
                'content': event.content,
                'tags': json.dumps(event.tags),
                'public_key': event.public_key,
                'created_at': event.created_at,
                'signature': event.signature,
            }
            nostr_event = self.create(vals)
            nostr_event.action_publish()
            return nostr_event
        except Exception as e:
            _logger.error(f"Error in create_and_publish: {str(e)}", exc_info=True)
            raise UserError(_("Failed to create and publish Nostr event: %s") % str(e))

    def action_publish(self):
        self.ensure_one()
        _logger.info(f"Starting publish action for event: {self.event_id}")
        start_time = time.time()
    
        try:
            relay_urls = self.env['ir.config_parameter'].sudo().get_param('nostr_bridge.relay_urls', '')
            _logger.info(f"Retrieved raw relay URLs: {relay_urls}")
            
            relay_urls = [url.strip() for url in relay_urls.split(',') if url.strip()][:5]  # Limit to 5 relays
            _logger.info(f"Processed relay URLs: {relay_urls}")
    
            if not relay_urls:
                raise UserError(_("No Nostr relay URLs configured. Please set them in the settings."))
    
            event_data = {
                'id': self.event_id,
                'kind': self.kind,
                'created_at': self.created_at,
                'tags': json.loads(self.tags) if self.tags else [],
                'content': self.content,
                'pubkey': self.public_key,
                'sig': self.signature,
            }
        
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            try:
                results = loop.run_until_complete(self._publish_to_relays(relay_urls, event_data))
                verification_results = loop.run_until_complete(self.verify_event_publication(self.event_id, relay_urls))
            finally:
                loop.close()
    
            success = any(result.get('success', False) for result in results)
            if success:
                self.write({
                    'published': True,
                    'logs': '\n'.join([str(result) for result in results])
                })
                _logger.info(f"Successfully published Nostr event: {self.event_id}")
                _logger.info(f"Verification results: {verification_results}")
                
                end_time = time.time()
                _logger.info(f"Total publish action time: {end_time - start_time:.2f} seconds")
                
                return True
            else:
                error_messages = [result.get('error', 'Unknown error') for result in results if not result.get('success', False)]
                raise UserError(_("Failed to publish Nostr event: %s") % "; ".join(error_messages))
    
        except Exception as e:
            _logger.error(f"Unexpected error in action_publish: {str(e)}", exc_info=True)
            raise UserError(_("An unexpected error occurred: %s") % str(e))
    
    async def _publish_to_relays(self, relay_urls, event_data):
        async def publish_to_relay(url, event_data):
            try:
                _logger.info(f"Attempting to connect to relay: {url}")
                async with websockets.connect(url, close_timeout=30) as websocket:
                    _logger.info(f"Connected to relay: {url}")
                    message = json.dumps(["EVENT", event_data])
                    _logger.info(f"Sending message to relay {url}: {message}")
                    await websocket.send(message)
                    _logger.info(f"Sent event to relay: {url}")
                    response = await asyncio.wait_for(websocket.recv(), timeout=10.0)
                    _logger.info(f"Received response from relay {url}: {response}")
                    return {'success': True, 'url': url, 'response': response}
            except Exception as e:
                _logger.error(f"Error publishing to relay {url}: {str(e)}")
                return {'success': False, 'url': url, 'error': str(e)}
    
        tasks = [publish_to_relay(url, event_data) for url in relay_urls]
        return await asyncio.gather(*tasks)
    
    @api.model
    def process_incoming_events(self):
        relay_urls = self.env['ir.config_parameter'].sudo().get_param('nostr_bridge.relay_urls', '').split(',')
        relay_urls = [url.strip() for url in relay_urls if url.strip()]

        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        try:
            loop.run_until_complete(self._listen_to_relays(relay_urls))
        finally:
            loop.close()

    async def _listen_to_relays(self, relay_urls):
        async def listen_to_relay(url):
            try:
                async with websockets.connect(url) as websocket:
                    subscription_id = "my_subscription"
                    await websocket.send(json.dumps(["REQ", subscription_id, {}]))
                    while True:
                        response = await websocket.recv()
                        event = json.loads(response)
                        if event[0] == "EVENT" and event[1] == subscription_id:
                            self._process_event(event[2])
            except Exception as e:
                _logger.error(f"Error listening to relay {url}: {str(e)}")

        await asyncio.gather(*[listen_to_relay(url) for url in relay_urls])

    async def verify_event_publication(self, event_id, relay_urls):
        async def check_relay(url):
            try:
                async with websockets.connect(url, timeout=30) as websocket:
                    request = json.dumps(["REQ", "verify", {"ids": [event_id]}])
                    await websocket.send(request)
                    response = await asyncio.wait_for(websocket.recv(), timeout=10.0)
                    return {'url': url, 'found': event_id in response}
            except Exception as e:
                return {'url': url, 'error': str(e)}
    
        tasks = [check_relay(url) for url in relay_urls]
        results = await asyncio.gather(*tasks)
        return results

    def _process_event(self, event_data):
        existing_event = self.search([('event_id', '=', event_data['id'])])
        if not existing_event:
            self.create({
                'event_id': event_data['id'],
                'kind': event_data['kind'],
                'content': event_data['content'],
                'tags': json.dumps(event_data['tags']),
                'public_key': event_data['pubkey'],
                'created_at': event_data['created_at'],
                'signature': event_data['sig'],
                'published': True,
            })
            _logger.info(f"Processed new Nostr event: {event_data['id']}")
=== ./odoo_custom_addons/gitlab_nostr_bridge/models/gitlab_branch.py ===
from odoo import models, fields, api
from dateutil import parser
from datetime import datetime, timezone

class GitlabBranch(models.Model):
    _name = 'gitlab.branch'
    _description = 'GitLab Branch'

    name = fields.Char(string='Branch Name', required=True)
    repository_id = fields.Many2one('gitlab.repository', string='Repository', required=True)
    last_commit_date = fields.Datetime(string='Last Commit Date')
    commit_ids = fields.Many2many('gitlab.commit', string='Commits')

    @api.model
    def create_or_update_from_gitlab(self, repository_id, gitlab_branch):
        existing_branch = self.search([('name', '=', gitlab_branch.name), ('repository_id', '=', repository_id)])
        last_commit_date = self._convert_to_naive_datetime(gitlab_branch.commit['committed_date']) if gitlab_branch.commit else False
        if existing_branch:
            return existing_branch.write({
                'last_commit_date': last_commit_date,
            })
        else:
            return self.create({
                'name': gitlab_branch.name,
                'repository_id': repository_id,
                'last_commit_date': last_commit_date,
            })

    def _convert_to_naive_datetime(self, date_string):
        dt = parser.parse(date_string)
        return dt.replace(tzinfo=None)
=== ./odoo_custom_addons/gitlab_nostr_bridge/models/res_config_settings.py ===
# models/res_config_settings.py
import logging
from odoo.exceptions import UserError
from odoo import _, api, fields, models
import gitlab

_logger = logging.getLogger(__name__)

class ResConfigSettings(models.TransientModel):
    _inherit = 'res.config.settings'

    gitlab_private_token = fields.Char(string="GitLab Private Token", config_parameter='gitlab_nostr_bridge.gitlab_private_token')
    gitlab_url = fields.Char(string="GitLab URL", config_parameter='gitlab_nostr_bridge.gitlab_url')

    def test_gitlab_connection(self):
        url = self.gitlab_url
        token = self.gitlab_private_token
        
        if not url or not token:
            raise UserError(_("GitLab URL and Private Token must be set."))

        try:
            response = requests.get(f"{url}/api/v4/user", headers={"Private-Token": token}, timeout=10)
            response.raise_for_status()
            return {
                'type': 'ir.actions.client',
                'tag': 'display_notification',
                'params': {
                    'title': _("Connection Successful"),
                    'message': _("Connected to GitLab successfully."),
                    'type': 'success',
                    'sticky': False,
                }
            }
        except requests.exceptions.RequestException as e:
            raise UserError(_("Failed to connect to GitLab: %s") % str(e))
=== ./odoo_custom_addons/gitlab_nostr_bridge/models/gitlab_repository.py ===
import logging
from odoo.exceptions import UserError
from odoo import _, api, fields, models
import gitlab
import requests

_logger = logging.getLogger(__name__)

class GitlabRepository(models.Model):
    _name = 'gitlab.repository'
    _description = 'GitLab Repository'

    name = fields.Char(string='Repository Name', required=True)
    gitlab_id = fields.Integer(string='GitLab Repository ID', required=True)
    url = fields.Char(string='GitLab URL', required=True)
    project_id = fields.Integer(string='GitLab Project ID', required=True)
    branch_ids = fields.One2many('gitlab.branch', 'repository_id', string='Branches')
    commit_ids = fields.One2many('gitlab.commit', 'repository_id', string='Commits')

    def action_create_commit(self):
        return {
            'name': 'Create Commit',
            'type': 'ir.actions.act_window',
            'res_model': 'gitlab_nostr_bridge.create.commit.wizard',
            'view_mode': 'form',
            'target': 'new',
        }

    def sync_with_gitlab(self):
        self.ensure_one()
        gitlab_url = self.env['ir.config_parameter'].sudo().get_param('gitlab_nostr_bridge.gitlab_url')
        gitlab_token = self.env['ir.config_parameter'].sudo().get_param('gitlab_nostr_bridge.gitlab_private_token')

        if not gitlab_url or not gitlab_token:
            raise UserError(_("GitLab URL or Private Token is not configured. Please check the settings."))

        try:
            gl = gitlab.Gitlab(gitlab_url, private_token=gitlab_token, timeout=30)
            gl.auth()
            project = gl.projects.get(self.project_id)
            
            # Sync branches
            for branch in project.branches.list():
                self.env['gitlab.branch'].create_or_update_from_gitlab(self.id, branch)
            
            # Sync commits
            for commit in project.commits.list():
                self.env['gitlab.commit'].create_or_update_from_gitlab(self.id, commit)

            return {
                'type': 'ir.actions.client',
                'tag': 'display_notification',
                'params': {
                    'title': _("Sync Successful"),
                    'message': _("Repository synced successfully with GitLab."),
                    'type': 'success',
                    'sticky': False,
                }
            }
        except Exception as e:
            _logger.error(f"Failed to sync with GitLab: {str(e)}")
            raise UserError(_("Failed to sync with GitLab: %s") % str(e))

    @api.model
    def create(self, vals):
        repo = super(GitlabRepository, self).create(vals)
        gitlab_url = self.env['ir.config_parameter'].sudo().get_param('gitlab_nostr_bridge.gitlab_url')
        gitlab_token = self.env['ir.config_parameter'].sudo().get_param('gitlab_nostr_bridge.gitlab_private_token')

        if not gitlab_url or not gitlab_token:
            raise UserError(_("GitLab URL or Private Token is not configured. Please check the settings."))

        _logger.info(f"Attempting to connect to GitLab at {gitlab_url}")

        try:
            gl = gitlab.Gitlab(gitlab_url, private_token=gitlab_token, timeout=10)
            gl.auth()
            _logger.info("Successfully authenticated with GitLab")
        except gitlab.exceptions.GitlabAuthenticationError:
            _logger.error("GitLab authentication failed")
            raise UserError(_("Failed to authenticate with GitLab. Please check your GitLab private token."))
        except requests.exceptions.RequestException as e:
            _logger.error(f"Failed to connect to GitLab: {str(e)}")
            raise UserError(_("Failed to connect to GitLab. Please check the GitLab URL and your network connection."))
        except Exception as e:
            _logger.error(f"Unexpected error when connecting to GitLab: {str(e)}")
            raise UserError(_("An unexpected error occurred: %s") % str(e))

        try:
            project = gl.projects.get(repo.project_id)
            _logger.info(f"Successfully retrieved GitLab project: {project.name}")
        except gitlab.exceptions.GitlabGetError:
            _logger.info(f"Project not found. Attempting to create new project: {repo.name}")
            try:
                project = gl.projects.create({'name': repo.name})
                repo.write({'project_id': project.id})
                _logger.info(f"Successfully created GitLab project: {project.name}")
            except gitlab.exceptions.GitlabCreateError as e:
                _logger.error(f"Failed to create GitLab project: {str(e)}")
                raise UserError(_("Failed to create GitLab project. Error: %s") % str(e))

        return repo
=== ./odoo_custom_addons/gitlab_nostr_bridge/__init__.py ===
from . import models
from . import wizards
=== ./odoo_custom_addons/gitlab_nostr_bridge/wizards/create_commit_wizard_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_create_commit_wizard_form" model="ir.ui.view">
        <field name="name">gitlab_nostr_bridge.create.commit.wizard.form</field>
        <field name="model">gitlab_nostr_bridge.create.commit.wizard</field>
        <field name="arch" type="xml">
            <form string="Create Commit">
                <group>
                    <field name="repository_id" readonly="1"/>
                    <field name="branch_name"/>
                    <field name="file_upload" widget="binary" filename="file_name"/>
                    <field name="file_name" invisible="1"/>
                    <field name="file_path" required="1" placeholder="/path/to/your/file.txt"/>
                    <field name="file_exists" invisible="1"/>
                    <field name="commit_message" required="1" placeholder="Enter your commit message here"/>
                    <field name="file_content" widget="ace" options="{'mode': 'text'}" placeholder="Enter or paste your file content here" attrs="{'readonly': [('file_exists', '=', True)]}"/>
                </group>
                <footer>
                    <button name="action_create_commit" string="Create Commit" type="object" class="btn-primary"/>
                    <button string="Cancel" class="btn-secondary" special="cancel"/>
                </footer>
            </form>
        </field>
    </record>

    <record id="action_create_commit_wizard" model="ir.actions.act_window">
        <field name="name">Create Commit</field>
        <field name="res_model">gitlab_nostr_bridge.create.commit.wizard</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
        <field name="view_id" ref="view_create_commit_wizard_form"/>
    </record>
</odoo>
=== ./odoo_custom_addons/gitlab_nostr_bridge/wizards/__init__.py ===
from . import create_branch_wizard
from . import create_commit_wizard
=== ./odoo_custom_addons/gitlab_nostr_bridge/wizards/create_commit_wizard.py ===
# wizards/create_commit_wizard.py

from odoo import models, fields, api, _
from odoo.exceptions import UserError
import gitlab
import base64
import logging
from bech32 import bech32_decode, convertbits

_logger = logging.getLogger(__name__)

class CreateCommitWizard(models.TransientModel):
    _name = 'gitlab_nostr_bridge.create.commit.wizard'
    _description = 'Create Commit Wizard'

    repository_id = fields.Many2one('gitlab.repository', string='Repository', required=True)
    branch_name = fields.Char(string='Branch Name', required=True, default='main')
    commit_message = fields.Text(string='Commit Message', required=True)
    file_path = fields.Char(string='File Path', required=True)
    file_content = fields.Text(string='File Content', required=True)
    file_upload = fields.Binary(string='Upload File')
    is_new_file = fields.Boolean(string='Is New File', default=True)
    file_exists = fields.Boolean(string='File Exists', compute='_compute_file_exists')
    file_name = fields.Char(string='File Name')

    @api.depends('repository_id', 'branch_name', 'file_path')
    def _compute_file_exists(self):
        for record in self:
            record.file_exists = False
            if record.repository_id and record.branch_name and record.file_path:
                try:
                    gl = record._get_gitlab_client()
                    project = gl.projects.get(record.repository_id.project_id)
                    project.files.get(file_path=record.file_path, ref=record.branch_name)
                    record.file_exists = True
                except gitlab.exceptions.GitlabHttpError:
                    record.file_exists = False


    @api.model
    def default_get(self, fields_list):
        defaults = super(CreateCommitWizard, self).default_get(fields_list)
        active_id = self._context.get('active_id')
        if active_id:
            repository = self.env['gitlab.repository'].browse(active_id)
            defaults['repository_id'] = repository.id
            defaults['branch_name'] = 'main'  # Set default branch to 'main'
        return defaults

    @api.depends('repository_id')
    def _get_branch_selection(self):
        _logger.info("_get_branch_selection called")
        branches = []
        repository_id = self._context.get('default_repository_id')
        if self:  # Check if self is not empty
            repository = self.env['gitlab.repository'].browse(repository_id)
            _logger.info(f"Repository: {repository}")
            if repository:
                try:
                    gl = self._get_gitlab_client()
                    project = gl.projects.get(repository.project_id)
                    branches = [(branch.name, branch.name) for branch in project.branches.list()]
                    _logger.info(f"Retrieved branches for repository {repository.name}: {branches}")
                except Exception as e:
                    _logger.error(f"Failed to fetch branches for repository {repository.name}: {str(e)}")
        if not branches:
            branches = [('main', 'main')]  # Provide a default option
        _logger.info(f"Returning branches: {branches}")
        return branches

    @api.onchange('repository_id', 'branch_name', 'file_path')
    def _onchange_file_details(self):
        if self.repository_id and self.branch_name and self.file_path:
            # Basic validation of file path
            if not self.file_path or '..' in self.file_path:
                return {'warning': {'title': _("Invalid File Path"), 'message': _("Please enter a valid file path.")}}
            
            gl = self._get_gitlab_client()
            project = gl.projects.get(self.repository_id.project_id)
            try:
                file_content = project.files.get(file_path=self.file_path, ref=self.branch_name)
                self.file_content = base64.b64decode(file_content.content).decode('utf-8')
                self.is_new_file = False
            except gitlab.exceptions.GitlabHttpError as e:
                if e.response_code == 404:
                    # File not found, treat as a new file
                    self.file_content = ''
                    self.is_new_file = True
                else:
                    # Other GitLab API errors
                    return {'warning': {'title': _("GitLab Error"), 'message': str(e)}}
            except Exception as e:
                # Handle other exceptions
                return {'warning': {'title': _("Error"), 'message': str(e)}}

    @api.onchange('file_upload')
    def _onchange_file_upload(self):
        if self.file_upload:
            self.file_content = base64.b64decode(self.file_upload).decode('utf-8')

    """@api.onchange('file_name')
    def _onchange_file_name(self):
        if self.file_name and not self.file_path:
            self.file_path = self.file_name"""

    @api.onchange('repository_id')
    def _onchange_repository_id(self):
        if self.repository_id:
            return {'domain': {'branch_name': []}, 'context': {'default_repository_id': self.repository_id.id}}

    def _get_gitlab_client(self):
        gitlab_url = self.env['ir.config_parameter'].sudo().get_param('gitlab_nostr_bridge.gitlab_url')
        gitlab_token = self.env['ir.config_parameter'].sudo().get_param('gitlab_nostr_bridge.gitlab_private_token')
        _logger.info(f"GitLab URL: {gitlab_url}")
        if not gitlab_url or not gitlab_token:
            raise UserError(_("GitLab URL or Private Token is not configured. Please check the settings."))
        try:
            return gitlab.Gitlab(gitlab_url, private_token=gitlab_token)
        except Exception as e:
            _logger.error(f"Failed to create GitLab client: {str(e)}")
            raise UserError(_("Failed to connect to GitLab. Please check your settings and network connection."))

    @api.constrains('file_path')
    def _check_file_path(self):
        for record in self:
            if not record.file_path or '..' in record.file_path:
                raise UserError(_("Invalid file path. Please provide a valid path without '..'"))

    def action_create_commit(self):
        self.ensure_one()
        gl = self._get_gitlab_client()
        project = gl.projects.get(self.repository_id.project_id)
        
        action = 'create' if self.is_new_file else 'update'
        
        commit_data = {
            'branch': self.branch_name,
            'commit_message': self.commit_message,
            'actions': [
                {
                    'action': action,
                    'file_path': self.file_path,
                    'content': self.file_content,
                }
            ]
        }
        
        try:
            commit = project.commits.create(commit_data)
        except gitlab.exceptions.GitlabCreateError as e:
            raise UserError(_("Failed to create commit: %s") % str(e))
        
        self.env['gitlab.commit'].create_or_update_from_gitlab(self.repository_id.id, commit)
        
        try:
            self.env['nostr.event'].create_gitlab_event('commit', {
                'project_id': self.repository_id.project_id,
                'commit_id': commit.id,
                'message': self.commit_message,
            })
        except Exception as e:
            _logger.error("Failed to create and publish Nostr event: %s", str(e))
            return {
                'type': 'ir.actions.client',
                'tag': 'display_notification',
                'params': {
                    'title': _("Warning"),
                    'message': _("Commit created, but failed to publish Nostr event: %s") % str(e),
                    'type': 'warning',
                }
            }
    
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _("Success"),
                'message': _("Commit created and Nostr event published successfully"),
                'type': 'success',
            }
        }
=== ./odoo_custom_addons/gitlab_nostr_bridge/wizards/create_branch_wizard.py ===
from odoo import models, fields, api

class CreateBranchWizard(models.TransientModel):
    _name = 'gitlab_nostr_bridge.create.branch.wizard'
    _description = 'Create Branch Wizard'

    repository_id = fields.Many2one('gitlab.repository', string='Repository', required=True)
    branch_name = fields.Char(string='Branch Name', required=True)
    branch_name = fields.Char(string='Branch Name', required=True)
    source_branch = fields.Char(string='Source Branch', default='master')

    def action_create_branch(self):
        self.ensure_one()
        gl = gitlab.Gitlab(self.repository_id.url, private_token=self.env['ir.config_parameter'].sudo().get_param('gitlab.private_token'))
        project = gl.projects.get(self.repository_id.project_id)
        branch = project.branches.create({'branch': self.branch_name, 'ref': self.source_branch})
        
        self.env['gitlab.branch'].create_or_update_from_gitlab(self.repository_id.id, branch)
        
        self.env['nostr.event'].create_gitlab_event('branch', {
            'project_id': self.repository_id.project_id,
            'branch_name': self.branch_name,
            'action': 'create',
        })
        
        return {'type': 'ir.actions.act_window_close'}
=== ./odoo_custom_addons/gitlab_nostr_bridge/wizards/create_branch_wizard_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_create_branch_wizard_form" model="ir.ui.view">
        <field name="name">gitlab_nostr_bridge.create.branch.wizard.form</field>
        <field name="model">gitlab_nostr_bridge.create.branch.wizard</field>
        <field name="arch" type="xml">
            <form string="Create Branch">
                <group>
                    <field name="repository_id"/>
                    <field name="branch_name"/>
                </group>
                <footer>
                    <button name="action_create_branch" string="Create Branch" type="object" class="btn-primary"/>
                    <button string="Cancel" class="btn-secondary" special="cancel"/>
                </footer>
            </form>
        </field>
    </record>

    <record id="action_create_branch_wizard" model="ir.actions.act_window">
        <field name="name">Create Branch</field>
        <field name="res_model">gitlab_nostr_bridge.create.branch.wizard</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
    </record>
</odoo>
=== ./odoo_custom_addons/gitlab_nostr_bridge/__manifest__.py ===
{
    'name': 'GitLab-Nostr Bridge',
    'version': '1.0',
    'category': 'Development',
    'summary': 'Integrate GitLab repositories with Nostr events',
    'author': 'Your Name',
    'website': 'https://www.example.com',
    'depends': ['base', 'mail'],
    'data': [
        'security/ir.model.access.csv',
        'views/gitlab_repository_views.xml',
        'views/gitlab_branch_views.xml',
        'views/gitlab_commit_views.xml',
        'views/nostr_event_views.xml',
        'views/res_config_settings_views.xml',
        'wizards/create_branch_wizard_views.xml',
        'wizards/create_commit_wizard_views.xml',
        'data/gitlab_nostr_bridge_data.xml',
    ],
    'external_dependencies': {
        'python': ['gitlab', 'nostr'],
    },
    'installable': True,
    'application': True,
    'auto_install': False,
}
=== ./odoo_custom_addons/gitlab_nostr_bridge/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_gitlab_repository_user,gitlab.repository user,model_gitlab_repository,base.group_user,1,1,1,1
access_gitlab_branch_user,gitlab.branch user,model_gitlab_branch,base.group_user,1,1,1,1
access_gitlab_commit_user,gitlab.commit user,model_gitlab_commit,base.group_user,1,1,1,1
access_nostr_event_user,nostr.event user,model_nostr_event,base.group_user,1,1,1,1
access_create_branch_wizard_user,create.branch.wizard user,model_gitlab_nostr_bridge_create_branch_wizard,base.group_user,1,1,1,0
access_create_commit_wizard_user,create.commit.wizard user,model_gitlab_nostr_bridge_create_commit_wizard,base.group_user,1,1,1,0
=== ./odoo_custom_addons/gitlab_nostr_bridge/data/gitlab_nostr_bridge_data.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <record id="gitlab_private_token" model="ir.config_parameter">
            <field name="key">gitlab.private_token</field>
            <field name="value">your_gitlab_private_token_here</field>
        </record>
    </data>
</odoo>
=== ./odoo_custom_addons/gitlab_nostr_bridge/views/gitlab_commit_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_gitlab_commit_form" model="ir.ui.view">
        <field name="name">gitlab.commit.form</field>
        <field name="model">gitlab.commit</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="message"/>
                        <field name="author"/>
                        <field name="date"/>
                        <field name="repository_id"/>
                    </group>
                    <notebook>
                        <page string="Branches">
                            <field name="branch_ids"/>
                        </page>
                    </notebook>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_gitlab_commit_tree" model="ir.ui.view">
        <field name="name">gitlab.commit.tree</field>
        <field name="model">gitlab.commit</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="message"/>
                <field name="author"/>
                <field name="date"/>
                <field name="repository_id"/>
            </tree>
        </field>
    </record>

    <record id="action_gitlab_commit" model="ir.actions.act_window">
        <field name="name">GitLab Commits</field>
        <field name="res_model">gitlab.commit</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_gitlab_commit" name="Commits" parent="menu_gitlab_nostr_bridge" action="action_gitlab_commit" sequence="30"/>
</odoo>
=== ./odoo_custom_addons/gitlab_nostr_bridge/views/gitlab_repository_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_gitlab_repository_form" model="ir.ui.view">
        <field name="name">gitlab.repository.form</field>
        <field name="model">gitlab.repository</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="sync_with_gitlab" string="Sync with GitLab" type="object" class="oe_highlight"/>
                    <button name="action_create_commit" string="Create Commit" type="object" class="oe_highlight"/>
                </header>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="gitlab_id"/>
                        <field name="url"/>
                        <field name="project_id"/>
                    </group>
                    <notebook>
                        <page string="Branches">
                            <field name="branch_ids"/>
                        </page>
                        <page string="Commits">
                            <field name="commit_ids"/>
                        </page>
                    </notebook>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_gitlab_repository_tree" model="ir.ui.view">
        <field name="name">gitlab.repository.tree</field>
        <field name="model">gitlab.repository</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="gitlab_id"/>
                <field name="url"/>
                <field name="project_id"/>
            </tree>
        </field>
    </record>

    <record id="action_gitlab_repository" model="ir.actions.act_window">
        <field name="name">GitLab Repositories</field>
        <field name="res_model">gitlab.repository</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_gitlab_nostr_bridge" name="GitLab-Nostr Bridge" sequence="10"/>
    <menuitem id="menu_gitlab_repository" name="Repositories" parent="menu_gitlab_nostr_bridge" action="action_gitlab_repository" sequence="10"/>
</odoo>
=== ./odoo_custom_addons/gitlab_nostr_bridge/views/res_config_settings_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="res_config_settings_view_form" model="ir.ui.view">
        <field name="name">res.config.settings.view.form.inherit.gitlab.nostr.bridge</field>
        <field name="model">res.config.settings</field>
        <field name="inherit_id" ref="base.res_config_settings_view_form"/>
        <field name="arch" type="xml">
            <xpath expr="//div[hasclass('settings')]" position="inside">
                <div class="app_settings_block" data-string="GitLab-Nostr Bridge" string="GitLab-Nostr Bridge" data-key="gitlab_nostr_bridge">
                    <h2>GitLab Settings</h2>
                    <div class="row mt16 o_settings_container">
                        <div class="col-12 col-lg-6 o_setting_box">
                            <div class="o_setting_left_pane"/>
                            <div class="o_setting_right_pane">
                                <span class="o_form_label">GitLab URL</span>
                                <div class="text-muted">
                                    Enter your GitLab server URL
                                </div>
                                <div class="content-group">
                                    <div class="mt16">
                                        <field name="gitlab_url"/>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="col-12 col-lg-6 o_setting_box">
                            <div class="o_setting_left_pane"/>
                            <div class="o_setting_right_pane">
                                <span class="o_form_label">GitLab Private Token</span>
                                <div class="text-muted">
                                    Enter your GitLab private token for API access
                                </div>
                                <div class="content-group">
                                    <div class="mt16">
                                        <field name="gitlab_private_token" password="True"/>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="row mt16">
                        <div class="col-12">
                            <button name="test_gitlab_connection" string="Test GitLab Connection" type="object" class="oe_highlight"/>
                        </div>
                    </div>
                </div>
            </xpath>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons/gitlab_nostr_bridge/views/nostr_event_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_nostr_event_form" model="ir.ui.view">
        <field name="name">nostr.event.form</field>
        <field name="model">nostr.event</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="event_id"/>
                        <field name="kind"/>
                        <field name="content"/>
                        <field name="tags"/>
                        <field name="public_key"/>
                        <field name="created_at"/>
                        <field name="signature"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_nostr_event_tree" model="ir.ui.view">
        <field name="name">nostr.event.tree</field>
        <field name="model">nostr.event</field>
        <field name="arch" type="xml">
            <tree>
                <field name="event_id"/>
                <field name="kind"/>
                <field name="public_key"/>
                <field name="created_at"/>
            </tree>
        </field>
    </record>

    <record id="action_nostr_event" model="ir.actions.act_window">
        <field name="name">Nostr Events</field>
        <field name="res_model">nostr.event</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_nostr_event" name="Nostr Events" parent="menu_gitlab_nostr_bridge" action="action_nostr_event" sequence="40"/>
</odoo>
=== ./odoo_custom_addons/gitlab_nostr_bridge/views/gitlab_branch_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_gitlab_branch_form" model="ir.ui.view">
        <field name="name">gitlab.branch.form</field>
        <field name="model">gitlab.branch</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="repository_id"/>
                        <field name="last_commit_date"/>
                    </group>
                    <notebook>
                        <page string="Commits">
                            <field name="commit_ids"/>
                        </page>
                    </notebook>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_gitlab_branch_tree" model="ir.ui.view">
        <field name="name">gitlab.branch.tree</field>
        <field name="model">gitlab.branch</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="repository_id"/>
                <field name="last_commit_date"/>
            </tree>
        </field>
    </record>

    <record id="action_gitlab_branch" model="ir.actions.act_window">
        <field name="name">GitLab Branches</field>
        <field name="res_model">gitlab.branch</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_gitlab_branch" name="Branches" parent="menu_gitlab_nostr_bridge" action="action_gitlab_branch" sequence="20"/>
</odoo>
=== ./odoo_custom_addons/custom_auth/models/res_users.py ===
from odoo import models, api
from odoo.exceptions import AccessDenied
import requests

class ResUsers(models.Model):
    _inherit = 'res.users'

    @classmethod
    def _login(cls, db, login, password):
        if not cls.validate_external_auth(login, password):
            raise AccessDenied()
        return super(ResUsers, cls)._login(db, login, password)

    @classmethod
    def validate_external_auth(cls, login, token):
        # Replace with your actual localhost API endpoint
        validation_url = 'http://localhost/validate_admin'
        response = requests.post(validation_url, json={'login': login, 'token': token})
        return response.status_code == 200 and response.json().get('is_admin', False)
=== ./odoo_custom_addons/custom_auth/__manifest__.py ===
{
    'name': 'Custom External Authentication',
    'version': '1.0',
    'category': 'Hidden',
    'summary': 'Custom authentication for external admin access',
    'depends': ['base'],
    'data': [],
    'installable': True,
}
=== ./odoo_custom_addons/opinion_reputation_nostr/models/__init__.py ===
from . import opinion_reputation
from . import nostr_event
=== ./odoo_custom_addons/opinion_reputation_nostr/models/nostr_event.py ===
from odoo import models, api, _
from odoo.exceptions import UserError
import json
import logging

_logger = logging.getLogger(__name__)

class NostrEvent(models.AbstractModel):
    _name = 'opinion.nostr.event'
    _description = 'Nostr Event for Opinion Reputation'

    @api.model
    def create_prediction_event(self, prediction):
        content = json.dumps({
            'question_id': prediction.question_id.id,
            'question_text': prediction.question_id.text,
            'answer': prediction.answer,
            'confidence': prediction.confidence
        })
        
        try:
            nostr_event = self.env['nostr.event']
            event = nostr_event.create_event(
                kind=1,  # You might want to use a custom event kind for predictions
                content=content,
                tags=[['p', prediction.user_id.nostr_public_key]],
                private_key=prediction.user_id.nostr_private_key
            )
            
            nostr_event.publish_event(event)
            _logger.info(f"Nostr event created and published for prediction {prediction.id}")
        except AttributeError:
            _logger.warning("Nostr bridge not available. Prediction event not published to Nostr.")
        except Exception as e:
            _logger.error(f"Error creating Nostr event: {str(e)}")
            raise UserError(_("Failed to create Nostr event: %s") % str(e))
=== ./odoo_custom_addons/opinion_reputation_nostr/models/opinion_reputation.py ===
from odoo import models, fields, api
from odoo.exceptions import UserError
import enum
import logging

_logger = logging.getLogger(__name__)

class AnswerChoice(enum.Enum):
    AGREE = "I Agree"
    DO_NOT_DISAGREE = "I do not disagree"
    DO_NOT_AGREE = "I do not agree"
    DISAGREE = "I Disagree"

class User(models.Model):
    _inherit = 'res.users'

    reputation = fields.Float(default=0)

class Question(models.Model):
    _name = 'opinion.question'
    _description = 'Opinion Question'

    text = fields.Text(required=True)
    explanation = fields.Text()
    created_by = fields.Many2one('res.users', string='Created By')
    created_at = fields.Datetime(default=fields.Datetime.now)
    is_settled = fields.Boolean(default=False)
    last_revisited = fields.Datetime()

class Prediction(models.Model):
    _name = 'opinion.prediction'
    _description = 'Opinion Prediction'

    user_id = fields.Many2one('res.users', required=True)
    question_id = fields.Many2one('opinion.question', required=True)
    answer = fields.Selection([
        ('AGREE', 'I Agree'),
        ('DO_NOT_DISAGREE', 'I do not disagree'),
        ('DO_NOT_AGREE', 'I do not agree'),
        ('DISAGREE', 'I Disagree')
    ], required=True)
    confidence = fields.Float(required=True)
    timestamp = fields.Datetime(default=fields.Datetime.now)
    is_correct = fields.Boolean()

    @api.model
    def create(self, vals):
        prediction = super(Prediction, self).create(vals)
        try:
            self.env['opinion.nostr.event'].create_prediction_event(prediction)
        except Exception as e:
            _logger.error(f"Failed to create Nostr event for prediction {prediction.id}: {str(e)}")
        self.update_reputation(prediction.user_id.id)
        return prediction

    def update_reputation(self, user_id):
        user = self.env['res.users'].browse(user_id)
        predictions = self.search([('user_id', '=', user_id)])
        correct_predictions = predictions.filtered(lambda p: p.is_correct)
        if predictions:
            user.reputation = (len(correct_predictions) / len(predictions)) * 100

class OpinionReputationSystem(models.AbstractModel):
    _name = 'opinion.reputation.system'
    _description = 'Opinion Reputation System'

    @api.model
    def revisit_question(self, question_id):
        question = self.env['opinion.question'].browse(question_id)
        if (fields.Datetime.now() - question.created_at).days >= 4*365:
            predictions = self.env['opinion.prediction'].search([('question_id', '=', question_id)])
            total_votes = len(predictions)
            if total_votes > 0:
                agreement_ratio = len(predictions.filtered(lambda p: p.answer in ['AGREE', 'DO_NOT_DISAGREE'])) / total_votes
                question.write({
                    'is_settled': agreement_ratio >= 0.8333334,
                    'last_revisited': fields.Datetime.now()
                })

    @api.model
    def explain_answer_choices(self):
        return """
        Answer choices explanation:
        1. I Agree: You fully support and believe in the statement.
        2. I do not disagree: You somewhat agree or have no strong objection to the statement.
        3. I do not agree: You somewhat disagree or have some reservations about the statement.
        4. I Disagree: You fully oppose or do not believe in the statement.
        """
=== ./odoo_custom_addons/opinion_reputation_nostr/__init__.py ===
from . import models
=== ./odoo_custom_addons/opinion_reputation_nostr/__manifest__.py ===
{
    'name': 'Opinion Reputation with Nostr',
    'version': '1.0',
    'category': 'Tools',
    'summary': 'Opinion Reputation System with optional Nostr integration',
    'depends': ['base'],
    'data': [
        'security/ir.model.access.csv',
        'views/opinion_reputation_views.xml',
        'data/default_questions.xml',
    ],
    'installable': True,
    'application': True,
}
=== ./odoo_custom_addons/opinion_reputation_nostr/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_opinion_question,access_opinion_question,model_opinion_question,base.group_user,1,1,1,1
access_opinion_prediction,access_opinion_prediction,model_opinion_prediction,base.group_user,1,1,1,1
access_opinion_nostr_event,access_opinion_nostr_event,model_opinion_nostr_event,base.group_user,1,1,1,1
=== ./odoo_custom_addons/opinion_reputation_nostr/data/default_questions.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <!-- Add your default questions here -->
        <record id="question_1" model="opinion.question">
            <field name="text">Do life's challenges sometimes lead to self-doubt?</field>
            <field name="explanation">Sometimes when things get tough, we might wonder if we're good enough or if we can handle it.</field>
        </record>
        <!-- Add more questions as needed -->
    </data>
</odoo>
=== ./odoo_custom_addons/opinion_reputation_nostr/views/opinion_reputation_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_question_form" model="ir.ui.view">
        <field name="name">opinion.question.form</field>
        <field name="model">opinion.question</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="text"/>
                        <field name="explanation"/>
                        <field name="created_by"/>
                        <field name="created_at"/>
                        <field name="is_settled"/>
                        <field name="last_revisited"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_prediction_form" model="ir.ui.view">
        <field name="name">opinion.prediction.form</field>
        <field name="model">opinion.prediction</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="user_id"/>
                        <field name="question_id"/>
                        <field name="answer"/>
                        <field name="confidence"/>
                        <field name="timestamp"/>
                        <field name="is_correct"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="action_questions" model="ir.actions.act_window">
        <field name="name">Questions</field>
        <field name="res_model">opinion.question</field>
        <field name="view_mode">tree,form</field>
    </record>

    <record id="action_predictions" model="ir.actions.act_window">
        <field name="name">Predictions</field>
        <field name="res_model">opinion.prediction</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_opinion_reputation" name="Opinion Reputation"/>
    <menuitem id="menu_questions" parent="menu_opinion_reputation" action="action_questions"/>
    <menuitem id="menu_predictions" parent="menu_opinion_reputation" action="action_predictions"/>
</odoo>
=== ./odoo_custom_addons/integrated_ivcs/models/git_repository.py ===
from odoo import models, fields, api
import git
import os

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Repository Name', required=True)
    path = fields.Char(string='Repository Path', required=True)
    
    @api.model
    def create(self, vals):
        repo = super(GitRepository, self).create(vals)
        if not os.path.exists(repo.path):
            os.makedirs(repo.path)
            git.Repo.init(repo.path)
        return repo

    def commit_changes(self, message):
        repo = git.Repo(self.path)
        repo.git.add(A=True)
        commit = repo.index.commit(message)
        
        self.env['nostr.event'].create_git_event(self.path, commit.hexsha)
        
        return commit.hexsha
=== ./odoo_custom_addons/integrated_ivcs/models/__init__.py ===
from . import ivcs_item
from . import ivcs_version
from . import ivcs_commit
from . import git_repository
from . import nostr_event
from . import branch_manager
from . import res_config_settings
from . import nostr_event
=== ./odoo_custom_addons/integrated_ivcs/models/nostr_events.py ===
# integrated_ivcs/models/nostr_events.py

import json
from odoo import models, fields, api
from odoo.exceptions import ValidationError
from datetime import datetime

class NostrEvent(models.AbstractModel):
    _name = 'nostr.event'
    _description = 'Base Nostr Event'

    id = fields.Char(string='Event ID', required=True, readonly=True)
    pubkey = fields.Char(string='Public Key', required=True)
    created_at = fields.Integer(string='Created At', required=True)
    kind = fields.Integer(string='Kind', required=True)
    tags = fields.Text(string='Tags')
    content = fields.Text(string='Content')
    sig = fields.Char(string='Signature', required=True)

    @api.model
    def create(self, vals):
        if 'created_at' not in vals:
            vals['created_at'] = int(datetime.now().timestamp())
        return super(NostrEvent, self).create(vals)

    def to_json(self):
        return json.dumps({
            "id": self.id,
            "pubkey": self.pubkey,
            "created_at": self.created_at,
            "kind": self.kind,
            "tags": json.loads(self.tags) if self.tags else [],
            "content": self.content,
            "sig": self.sig
        })

    @classmethod
    def from_json(cls, json_str):
        data = json.loads(json_str)
        return cls.create({
            "id": data["id"],
            "pubkey": data["pubkey"],
            "created_at": data["created_at"],
            "kind": data["kind"],
            "tags": json.dumps(data["tags"]),
            "content": data["content"],
            "sig": data["sig"]
        })

    @api.constrains('kind')
    def _check_kind(self):
        for record in self:
            if record.kind not in [31228, 31227, 3121, 3122, 3123]:
                raise ValidationError("Invalid event kind")

class NostrRepositoryAnchor(models.Model):
    _name = 'nostr.event.repository.anchor'
    _description = 'Nostr Repository Anchor Event'
    _inherit = 'nostr.event'

    kind = fields.Integer(default=31228, readonly=True)
    repo_name = fields.Char(string='Repository Name', required=True)
    description = fields.Text(string='Description')
    maintainers = fields.Many2many('res.users', string='Maintainers')

    @api.constrains('content')
    def _check_content(self):
        for record in self:
            try:
                content = json.loads(record.content)
                if 'action' not in content or content['action'] != 'create_repository':
                    raise ValidationError("Invalid content for Repository Anchor event")
            except json.JSONDecodeError:
                raise ValidationError("Invalid JSON in content field")

    def to_json(self):
        json_data = super(NostrRepositoryAnchor, self).to_json()
        data = json.loads(json_data)
        data['content'] = json.dumps({
            "action": "create_repository",
            "repo_name": self.repo_name,
            "description": self.description,
            "maintainers": self.maintainers.mapped('nostr_public_key')
        })
        return json.dumps(data)

    @classmethod
    def from_json(cls, json_str):
        data = json.loads(json_str)
        content = json.loads(data['content'])
        maintainer_ids = cls.env['res.users'].search([('nostr_public_key', 'in', content['maintainers'])]).ids
        return cls.create({
            "id": data["id"],
            "pubkey": data["pubkey"],
            "created_at": data["created_at"],
            "kind": data["kind"],
            "tags": json.dumps(data["tags"]),
            "content": data["content"],
            "sig": data["sig"],
            "repo_name": content["repo_name"],
            "description": content["description"],
            "maintainers": [(6, 0, maintainer_ids)]
        })

class NostrBranchEvent(models.Model):
    _name = 'nostr.event.branch'
    _description = 'Nostr Branch Event'
    _inherit = 'nostr.event'

    kind = fields.Integer(default=31227, readonly=True)
    branch_name = fields.Char(string='Branch Name', required=True)
    action = fields.Selection([('create', 'Create'), ('update', 'Update'), ('delete', 'Delete')], string='Action', required=True)

    @api.constrains('content')
    def _check_content(self):
        for record in self:
            try:
                content = json.loads(record.content)
                if 'action' not in content or content['action'] not in ['create_branch', 'update_branch', 'delete_branch']:
                    raise ValidationError("Invalid content for Branch event")
            except json.JSONDecodeError:
                raise ValidationError("Invalid JSON in content field")

    def to_json(self):
        json_data = super(NostrBranchEvent, self).to_json()
        data = json.loads(json_data)
        data['content'] = json.dumps({
            "action": f"{self.action}_branch",
            "branch_name": self.branch_name
        })
        return json.dumps(data)

    @classmethod
    def from_json(cls, json_str):
        data = json.loads(json_str)
        content = json.loads(data['content'])
        return cls.create({
            "id": data["id"],
            "pubkey": data["pubkey"],
            "created_at": data["created_at"],
            "kind": data["kind"],
            "tags": json.dumps(data["tags"]),
            "content": data["content"],
            "sig": data["sig"],
            "branch_name": content["branch_name"],
            "action": content["action"].replace("_branch", "")
        })

class NostrCommitEvent(models.Model):
    _name = 'nostr.event.commit'
    _description = 'Nostr Commit Event'
    _inherit = 'nostr.event'

    kind = fields.Integer(default=3121, readonly=True)
    commit_hash = fields.Char(string='Commit Hash', required=True)
    message = fields.Text(string='Commit Message', required=True)
    author = fields.Char(string='Author', required=True)
    timestamp = fields.Datetime(string='Timestamp', required=True)

    @api.constrains('content')
    def _check_content(self):
        for record in self:
            try:
                content = json.loads(record.content)
                required_fields = ['hash', 'message', 'author', 'date']
                if not all(field in content for field in required_fields):
                    raise ValidationError("Missing required fields in Commit event content")
            except json.JSONDecodeError:
                raise ValidationError("Invalid JSON in content field")

    def to_json(self):
        json_data = super(NostrCommitEvent, self).to_json()
        data = json.loads(json_data)
        data['content'] = json.dumps({
            "hash": self.commit_hash,
            "message": self.message,
            "author": self.author,
            "date": self.timestamp.isoformat()
        })
        return json.dumps(data)

    @classmethod
    def from_json(cls, json_str):
        data = json.loads(json_str)
        content = json.loads(data['content'])
        return cls.create({
            "id": data["id"],
            "pubkey": data["pubkey"],
            "created_at": data["created_at"],
            "kind": data["kind"],
            "tags": json.dumps(data["tags"]),
            "content": data["content"],
            "sig": data["sig"],
            "commit_hash": content["hash"],
            "message": content["message"],
            "author": content["author"],
            "timestamp": datetime.fromisoformat(content["date"])
        })

class NostrTreeEvent(models.Model):
    _name = 'nostr.event.tree'
    _description = 'Nostr Tree Event'
    _inherit = 'nostr.event'

    kind = fields.Integer(default=3122, readonly=True)
    tree_hash = fields.Char(string='Tree Hash', required=True)
    items = fields.Text(string='Tree Items', required=True)

    @api.constrains('content')
    def _check_content(self):
        for record in self:
            try:
                content = json.loads(record.content)
                if 'hash' not in content or 'items' not in content:
                    raise ValidationError("Missing required fields in Tree event content")
            except json.JSONDecodeError:
                raise ValidationError("Invalid JSON in content field")

    def to_json(self):
        json_data = super(NostrTreeEvent, self).to_json()
        data = json.loads(json_data)
        data['content'] = json.dumps({
            "hash": self.tree_hash,
            "items": json.loads(self.items)
        })
        return json.dumps(data)

    @classmethod
    def from_json(cls, json_str):
        data = json.loads(json_str)
        content = json.loads(data['content'])
        return cls.create({
            "id": data["id"],
            "pubkey": data["pubkey"],
            "created_at": data["created_at"],
            "kind": data["kind"],
            "tags": json.dumps(data["tags"]),
            "content": data["content"],
            "sig": data["sig"],
            "tree_hash": content["hash"],
            "items": json.dumps(content["items"])
        })

class NostrBlobEvent(models.Model):
    _name = 'nostr.event.blob'
    _description = 'Nostr Blob Event'
    _inherit = 'nostr.event'

    kind = fields.Integer(default=3123, readonly=True)
    blob_hash = fields.Char(string='Blob Hash', required=True)
    size = fields.Integer(string='Blob Size', required=True)
    data = fields.Text(string='Blob Data', required=True)

    @api.constrains('content')
    def _check_content(self):
        for record in self:
            try:
                content = json.loads(record.content)
                if 'hash' not in content or 'size' not in content or 'data' not in content:
                    raise ValidationError("Missing required fields in Blob event content")
            except json.JSONDecodeError:
                raise ValidationError("Invalid JSON in content field")

    def to_json(self):
        json_data = super(NostrBlobEvent, self).to_json()
        data = json.loads(json_data)
        data['content'] = json.dumps({
            "hash": self.blob_hash,
            "size": self.size,
            "data": self.data
        })
        return json.dumps(data)

    @classmethod
    def from_json(cls, json_str):
        data = json.loads(json_str)
        content = json.loads(data['content'])
        return cls.create({
            "id": data["id"],
            "pubkey": data["pubkey"],
            "created_at": data["created_at"],
            "kind": data["kind"],
            "tags": json.dumps(data["tags"]),
            "content": data["content"],
            "sig": data["sig"],
            "blob_hash": content["hash"],
            "size": content["size"],
            "data": content["data"]
        })
=== ./odoo_custom_addons/integrated_ivcs/models/ivcs_version.py ===
from odoo import models, fields, api

class IVCSVersion(models.Model):
    _name = 'ivcs.version'
    _description = 'IVCS Version'

    name = fields.Char(string='Version Name', required=True)
    description = fields.Text(string='Description')
    item_id = fields.Many2one('ivcs.item', string='IVCS Item', required=True, ondelete='cascade')
    commit_id = fields.Many2one('ivcs.commit', string='Associated Commit')
    create_date = fields.Datetime(string='Created On', readonly=True, default=fields.Datetime.now)

    @api.model
    def create(self, vals):
        version = super(IVCSVersion, self).create(vals)
        if not version.item_id.current_version_id:
            version.item_id.current_version_id = version.id
        return version

    def name_get(self):
        result = []
        for version in self:
            name = f"{version.item_id.name} - {version.name}"
            result.append((version.id, name))
        return result
=== ./odoo_custom_addons/integrated_ivcs/models/nostr_event.py ===
from odoo import models, fields, api, _
from odoo.exceptions import UserError
from nostr.event import Event
from nostr.key import PrivateKey
import json
import logging
import time
import git

_logger = logging.getLogger(__name__)

class NostrEvent(models.Model):
    _name = 'nostr.event'
    _description = 'Nostr Event'

    event_id = fields.Char(string='Event ID', required=True)
    kind = fields.Integer(string='Event Kind', required=True)
    content = fields.Text(string='Content', required=True)
    tags = fields.Text(string='Tags')
    public_key = fields.Char(string='Public Key')
    created_at = fields.Integer(string='Created At', required=True)
    signature = fields.Char(string='Signature', required=True)
    published = fields.Boolean(string='Published', default=False)
    name = fields.Char(string='Name')
    event_type = fields.Selection([
        ('repo_anchor', 'Repository Anchor'),
        ('branch', 'Branch'),
        ('commit', 'Commit'),
        ('tree', 'Tree'),
        ('blob', 'Blob'),
    ], string='Event Type')

    def create_and_publish(self, event):
        event_model = self._get_event_model(event.kind)
        if event_model:
            nostr_event = event_model.from_json(event.to_json())
            nostr_event.publish_event()
            return nostr_event
        else:
            return super(NostrEvent, self).create_and_publish(event)

    def _get_event_model(self, kind):
        if kind == 31228:
            return self.env['nostr.event.repository.anchor']
        elif kind == 31227:
            return self.env['nostr.event.branch']
        elif kind == 3121:
            return self.env['nostr.event.commit']
        elif kind == 3122:
            return self.env['nostr.event.tree']
        elif kind == 3123:
            return self.env['nostr.event.blob']
        else:
            return None

    def publish_event(self):
        self.ensure_one()
        relay_urls = self.env['ir.config_parameter'].sudo().get_param('integrated_ivcs.relay_urls', '').split(',')
        
        event_data = {
            'id': self.event_id,
            'kind': self.kind,
            'created_at': self.created_at,
            'tags': json.loads(self.tags),
            'content': self.content,
            'pubkey': self.public_key,
            'sig': self.signature,
        }

        for url in relay_urls:
            try:
                # Here you would typically use a Nostr client library to publish the event
                # For simplicity, we'll just log the action
                _logger.info(f"Publishing event {self.event_id} to relay: {url}")
                # Example: nostr_client.publish_event(url, event_data)
                self.published = True
            except Exception as e:
                _logger.error(f"Failed to publish event to {url}: {str(e)}")

    @api.model
    def create_git_event(self, repo_path, commit_hash):
        repo = git.Repo(repo_path)
        commit = repo.commit(commit_hash)
        
        commit_event = self.env['nostr.event.commit'].create({
            'id': commit_hash,  # Using commit hash as event ID
            'pubkey': self.env.user.nostr_public_key,
            'sig': 'placeholder',  # This should be properly signed
            'commit_hash': commit_hash,
            'message': commit.message,
            'author': f"{commit.author.name} <{commit.author.email}>",
            'timestamp': commit.committed_datetime.isoformat(),
            'content': json.dumps({
                'hash': commit_hash,
                'message': commit.message,
                'author': f"{commit.author.name} <{commit.author.email}>",
                'date': commit.committed_datetime.isoformat(),
            })
        })
        
        return commit_event

    @api.model
    def create_tree_event(self, repo_path, tree_hash):
        repo = git.Repo(repo_path)
        tree = repo.tree(tree_hash)
        
        content = json.dumps({
            "action": "tree",
            "hash": tree_hash,
            "items": [{"mode": item.mode, "type": item.type, "hash": item.hexsha, "path": item.path} for item in tree.traverse()],
        })
        
        event = Event(
            kind=3122,
            content=content,
            tags=[
                ["r", repo_path],
                ["h", tree_hash],
            ],
            public_key=self.env.user.nostr_public_key,
        )
        
        private_key = PrivateKey(bytes.fromhex(self.env.user.nostr_private_key))
        private_key.sign_event(event)
        
        return self.create_and_publish(event)

    @api.model
    def create_blob_event(self, repo_path, blob_hash):
        repo = git.Repo(repo_path)
        blob = repo.blob(blob_hash)
        
        content = json.dumps({
            "action": "blob",
            "hash": blob_hash,
            "size": blob.size,
            "data": blob.data_stream.read().decode('utf-8', errors='replace'),
        })
        
        event = Event(
            kind=3123,
            content=content,
            tags=[
                ["r", repo_path],
                ["h", blob_hash],
            ],
            public_key=self.env.user.nostr_public_key,
        )
        
        private_key = PrivateKey(bytes.fromhex(self.env.user.nostr_private_key))
        private_key.sign_event(event)
        
        return self.create_and_publish(event)

    @api.model
    def reconstruct_git_objects(self, repo_path):
        repo = git.Repo(repo_path)
        events = self.search([('tags', 'ilike', repo_path)])
        
        for event in events:
            content = json.loads(event.content)
            if event.kind == 3121:  # Commit
                self._reconstruct_commit(repo, content)
            elif event.kind == 3122:  # Tree
                self._reconstruct_tree(repo, content)
            elif event.kind == 3123:  # Blob
                self._reconstruct_blob(repo, content)

    def _reconstruct_commit(self, repo, content):
        commit_hash = content['hash']
        if commit_hash not in repo.objects:
            repo.create_commit(
                tree=repo.tree(content['tree_hash']),
                message=content['message'],
                author=git.Actor(content['author'], content['email']),
                committer=git.Actor(content['author'], content['email']),
                parent_commits=[repo.commit(p) for p in content['parent_hashes']],
                commit_timestamp=int(content['date']),
                ref=f'refs/heads/{content["branch"]}' if 'branch' in content else None
            )

    def _reconstruct_tree(self, repo, content):
        tree_hash = content['hash']
        if tree_hash not in repo.objects:
            tree_items = []
            for item in content['items']:
                if item['type'] == 'blob':
                    tree_items.append((item['mode'], 'blob', item['hash'], item['path']))
                elif item['type'] == 'tree':
                    tree_items.append((item['mode'], 'tree', item['hash'], item['path']))
            repo.create_tree(tree_items)

    def _reconstruct_blob(self, repo, content):
        blob_hash = content['hash']
        if blob_hash not in repo.objects:
            repo.create_blob(content['data'].encode('utf-8'))

    def sync_git_nostr(self, repo_path):
        repo = git.Repo(repo_path)
        for obj in repo.objects:
            if isinstance(obj, git.Commit):
                self.create_git_event(repo_path, obj.hexsha)
            elif isinstance(obj, git.Tree):
                self.create_tree_event(repo_path, obj.hexsha)
            elif isinstance(obj, git.Blob):
                self.create_blob_event(repo_path, obj.hexsha)

        self.reconstruct_git_objects(repo_path)
=== ./odoo_custom_addons/integrated_ivcs/models/res_config_settings.py ===
from odoo import fields, models

class ResConfigSettings(models.TransientModel):
    _inherit = 'res.config.settings'

    integrated_ivcs_relay_urls = fields.Char(string="Nostr Relay URLs", config_parameter='integrated_ivcs.relay_urls')
=== ./odoo_custom_addons/integrated_ivcs/models/ivcs_commit.py ===
from odoo import models, fields, api
import json
from nostr.event import Event
from nostr.key import PrivateKey
import logging

_logger = logging.getLogger(__name__)

class IVCSCommit(models.Model):
    _name = 'ivcs.commit'
    _description = 'IVCS Commit'

    hash = fields.Char(string='Commit Hash', required=True)
    message = fields.Text(string='Commit Message', required=True)
    author = fields.Char(string='Author', required=True, default=lambda self: self.env.user.name)
    date = fields.Datetime(string='Commit Date', required=True, default=fields.Datetime.now)
    item_id = fields.Many2one('ivcs.item', string='IVCS Item', required=True, ondelete='cascade')
    version_id = fields.Many2one('ivcs.version', string='Associated Version')

    @api.model
    def create(self, vals):
        commit = super(IVCSCommit, self).create(vals)
        try:
            commit._create_nostr_commit_event()
        except Exception as e:
            _logger.error(f"Failed to create Nostr commit event: {str(e)}")
        return commit

    def _create_nostr_commit_event(self):
        if not self.item_id.nostr_private_key:
            _logger.warning(f"No Nostr private key set for IVCS Item {self.item_id.name}")
            return

        try:
            private_key = PrivateKey.from_nsec(self.item_id.nostr_private_key)
        except Exception as e:
            _logger.error(f"Invalid Nostr private key for IVCS Item {self.item_id.name}: {str(e)}")
            return

        event = Event(
            kind=3121,
            content=json.dumps({
                "hash": self.hash,
                "message": self.message,
                "author": self.author,
                "date": self.date.isoformat(),
            }),
            tags=[['r', self.item_id.repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)
        
        try:
            self.env['nostr.event'].create_and_publish(event)
            _logger.info(f"Nostr commit event created and published for commit {self.hash}")
        except Exception as e:
            _logger.error(f"Failed to create and publish Nostr event for commit {self.hash}: {str(e)}")
=== ./odoo_custom_addons/integrated_ivcs/models/ivcs_item.py ===
from odoo import models, fields, api, _
from odoo.exceptions import UserError
import git
import json
from nostr.event import Event
from nostr.key import PrivateKey
import os
import logging

_logger = logging.getLogger(__name__)

class IVCSItem(models.Model):
    _name = 'ivcs.item'
    _description = 'IVCS Item'

    name = fields.Char(string='Name', required=True)
    description = fields.Text('Description')
    current_version_id = fields.Many2one('ivcs.version', string='Current Version', compute='_compute_current_version', store=True)
    version_ids = fields.One2many('ivcs.version', 'item_id', string='Versions')
    repo_path = fields.Char('Repository Path', compute='_compute_repo_path', store=True)
    current_branch = fields.Char('Current Branch', default='main')
    commit_ids = fields.One2many('ivcs.commit', 'item_id', string='Commits')
    nostr_private_key = fields.Char(string="Nostr Private Key")
    branch_manager_id = fields.Many2one('ivcs.branch.manager', string='Branch Manager')

    @api.depends('name')
    def _compute_repo_path(self):
        for item in self:
            item.repo_path = f"/opt/ivcs_repos/item_{item.id}"

    @api.depends('version_ids')
    def _compute_current_version(self):
        for item in self:
            if item.version_ids:
                item.current_version_id = item.version_ids.sorted(lambda v: v.create_date, reverse=True)[0]
            else:
                item.current_version_id = False

    @api.model
    def create(self, vals):
        if 'nostr_private_key' in vals and vals['nostr_private_key']:
            try:
                # Validate and format the private key
                private_key = PrivateKey.from_nsec(vals['nostr_private_key'])
                vals['nostr_private_key'] = private_key.hex()  # Store the private key as a hex string
            except Exception as e:
                raise UserError(_("Invalid Nostr private key: %s") % str(e))
        return super(IVCSItem, self).create(vals)

    def write(self, vals):
        if 'nostr_private_key' in vals and vals['nostr_private_key']:
            try:
                # Validate and format the private key
                private_key = PrivateKey.from_nsec(vals['nostr_private_key'])
                vals['nostr_private_key'] = private_key.hex()  # Store the private key as a hex string
            except Exception as e:
                raise UserError(_("Invalid Nostr private key: %s") % str(e))
        return super(IVCSItem, self).write(vals)

    def _initialize_repository(self):
        self.ensure_one()
        if not os.path.exists(self.repo_path):
            os.makedirs(self.repo_path)
            repo = git.Repo.init(self.repo_path)
            readme_path = os.path.join(self.repo_path, 'README.md')
            with open(readme_path, 'w') as f:
                f.write(f"# {self.name}\n\n{self.description}")
            repo.index.add(['README.md'])
            commit = repo.index.commit("Initial commit")
            self._create_initial_version(commit.hexsha)
            self._create_nostr_repo_event()

    def _create_initial_version(self, commit_hash):
        version = self.env['ivcs.version'].create({
            'name': 'v1.0',
            'description': 'Initial version',
            'item_id': self.id,
        })
        self.env['ivcs.commit'].create({
            'hash': commit_hash,
            'message': "Initial commit",
            'item_id': self.id,
            'version_id': version.id,
        })

    def _create_nostr_repo_event(self):
        if not self.nostr_private_key:
            raise UserError(_("Nostr private key is not set for this item."))
    
        private_key = PrivateKey(bytes.fromhex(self.nostr_private_key))
        event = Event(
            kind=31228,
            content=json.dumps({
                "action": "create_repository",
                "repo_name": self.name,
                "description": self.description
            }),
            tags=[['r', self.repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)
        
        self.env['nostr.event'].create_and_publish(event)

    def create_branch(self, branch_name):
        self.ensure_one()
        repo = git.Repo(self.repo_path)
        if not self.branch_manager_id:
            self.branch_manager_id = self.env['ivcs.branch.manager'].create({
                'name': f"Branch Manager for {self.name}",
                'item_id': self.id,
            })
        if branch_name not in repo.heads:
            repo.create_head(branch_name)
            self.current_branch = branch_name
            self._create_nostr_branch_event(branch_name)
            if self.branch_manager_id:
                self.branch_manager_id.create_branch(branch_name)
            return self._return_success('Branch Created', f'Branch {branch_name} has been created.')
        else:
            return self._return_warning('Branch Exists', f'Branch {branch_name} already exists.')

    def _create_nostr_branch_event(self, branch_name):
        if not self.nostr_private_key:
            raise UserError(_("Nostr private key is not set for this item."))
        
        private_key = PrivateKey(bytes.fromhex(self.nostr_private_key))
        event = Event(
            kind=31227,
            content=json.dumps({
                "action": "create_branch",
                "branch_name": branch_name,
                "repo_name": self.name
            }),
            tags=[['r', self.repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)
        
        self.env['nostr.event'].create_and_publish(event)

    def _return_success(self, title, message):
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _(title),
                'message': _(message),
                'type': 'success',
            }
        }

    def _return_warning(self, title, message):
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _(title),
                'message': _(message),
                'type': 'warning',
            }
        }

    def delete_branch(self, branch_name):
        self.ensure_one()
        if self.branch_manager_id.delete_branch(branch_name):
            return self._return_success('Branch Deleted', f'Branch {branch_name} has been deleted.')
        else:
            return self._return_warning('Branch Not Found', f'Branch {branch_name} does not exist.')

    def merge_branches(self, source_branch, target_branch):
        self.ensure_one()
        if self.branch_manager_id.merge_branches(source_branch, target_branch):
            return self._return_success('Branches Merged', f'Branch {source_branch} has been merged into {target_branch}.')
        else:
            return self._return_warning('Merge Failed', f'Failed to merge {source_branch} into {target_branch}.')

    def reconstruct_branches(self):
        self.ensure_one()
        branches = self.branch_manager_id.reconstruct_branches_from_events()
        return self._return_success('Branches Reconstructed', f'Reconstructed {len(branches)} branches from Nostr events.')

    # Add other methods as needed (e.g., commit, push, pull, etc.)
=== ./odoo_custom_addons/integrated_ivcs/models/branch_manager.py ===
from odoo import models, fields, api
from git import Repo, GitCommandError
import json
from nostr.event import Event
from nostr.key import PrivateKey
import logging

_logger = logging.getLogger(__name__)

class BranchManager(models.Model):
    _name = 'ivcs.branch.manager'
    _description = 'IVCS Branch Manager'

    name = fields.Char(string='Name', required=True)
    item_id = fields.Many2one('ivcs.item', string='IVCS Item', required=True)

    def create_branch(self, branch_name):
        self.ensure_one()
        repo = Repo(self.item_id.repo_path)
        if branch_name not in repo.heads:
            repo.create_head(branch_name)
            self._create_branch_event(branch_name, 'create')
            return True
        return False

    def delete_branch(self, branch_name):
        self.ensure_one()
        repo = Repo(self.item_id.repo_path)
        if branch_name in repo.heads:
            repo.delete_head(branch_name, force=True)
            self._create_branch_event(branch_name, 'delete')
            return True
        return False

    def update_branch(self, branch_name, new_commit):
        self.ensure_one()
        repo = Repo(self.item_id.repo_path)
        if branch_name in repo.heads:
            branch = repo.heads[branch_name]
            branch.set_commit(new_commit)
            self._create_branch_event(branch_name, 'update', new_commit)
            return True
        return False

    def merge_branches(self, source_branch, target_branch):
        self.ensure_one()
        repo = Repo(self.item_id.repo_path)
        if source_branch in repo.heads and target_branch in repo.heads:
            try:
                repo.git.checkout(target_branch)
                repo.git.merge(source_branch)
                self._create_branch_event(target_branch, 'merge', source_branch)
                return True
            except GitCommandError as e:
                _logger.error(f"Merge conflict: {str(e)}")
                repo.git.merge('--abort')
                return False
        return False

    def _create_branch_event(self, branch_name, action, additional_info=None):
        if not self.item_id.nostr_private_key:
            _logger.warning(f"No Nostr private key for item {self.item_id.name}")
            return

        private_key = PrivateKey(bytes.fromhex(self.item_id.nostr_private_key))
        content = {
            "action": action,
            "branch_name": branch_name,
            "repo_name": self.item_id.name
        }
        if additional_info:
            content["additional_info"] = additional_info

        event = Event(
            kind=31227,
            content=json.dumps(content),
            tags=[['r', self.item_id.repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)
        
        self.env['nostr.event'].create_and_publish(event)

    def list_branches(self):
        self.ensure_one()
        repo = Repo(self.item_id.repo_path)
        return [head.name for head in repo.heads]

    def reconstruct_branches_from_events(self):
        self.ensure_one()
        events = self.env['nostr.event'].search([
            ('kind', '=', 31227),
            ('tags', 'ilike', self.item_id.repo_path)
        ], order='created_at asc')

        branches = {}
        for event in events:
            content = json.loads(event.content)
            action = content.get('action')
            branch_name = content.get('branch_name')

            if action == 'create':
                branches[branch_name] = {'created_at': event.created_at}
            elif action == 'delete':
                branches.pop(branch_name, None)
            elif action == 'update':
                if branch_name in branches:
                    branches[branch_name]['last_updated'] = event.created_at
            elif action == 'merge':
                if branch_name in branches:
                    branches[branch_name]['last_merged'] = event.created_at
                    branches[branch_name]['merged_from'] = content.get('additional_info')

        return branches
=== ./odoo_custom_addons/integrated_ivcs/__init__.py ===
from . import models
from . import wizards
=== ./odoo_custom_addons/integrated_ivcs/wizards/create_commit_wizard_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_create_commit_wizard_form" model="ir.ui.view">
        <field name="name">create.commit.wizard.form</field>
        <field name="model">create.commit.wizard</field>
        <field name="arch" type="xml">
            <form string="Create Commit">
                <group>
                    <field name="item_id"/>
                    <field name="message"/>
                </group>
                <footer>
                    <button name="action_create_commit" string="Create Commit" type="object" class="btn-primary"/>
                    <button string="Cancel" class="btn-secondary" special="cancel"/>
                </footer>
            </form>
        </field>
    </record>

    <record id="action_create_commit_wizard" model="ir.actions.act_window">
        <field name="name">Create Commit</field>
        <field name="res_model">create.commit.wizard</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
    </record>
</odoo>
=== ./odoo_custom_addons/integrated_ivcs/wizards/__init__.py ===
from . import create_branch_wizard
from . import create_commit_wizard
=== ./odoo_custom_addons/integrated_ivcs/wizards/create_commit_wizard.py ===
from odoo import models, fields, api

class CreateCommitWizard(models.TransientModel):
    _name = 'create.commit.wizard'
    _description = 'Create Commit Wizard'

    item_id = fields.Many2one('ivcs.item', string='IVCS Item', required=True)
    message = fields.Text(string='Commit Message', required=True)

    def action_create_commit(self):
        self.ensure_one()
        repo = self.env['git.repository'].search([('path', '=', self.item_id.repo_path)])
        commit_hash = repo.commit_changes(self.message)
        self.env['ivcs.commit'].create({
            'hash': commit_hash,
            'message': self.message,
            'author': self.env.user.name,
            'date': fields.Datetime.now(),
            'item_id': self.item_id.id,
        })
        return {'type': 'ir.actions.act_window_close'}
=== ./odoo_custom_addons/integrated_ivcs/wizards/create_branch_wizard.py ===
from odoo import models, fields, api

class CreateBranchWizard(models.TransientModel):
    _name = 'create.branch.wizard'
    _description = 'Create Branch Wizard'

    item_id = fields.Many2one('ivcs.item', string='IVCS Item', required=True)
    branch_name = fields.Char(string='Branch Name', required=True)

    def action_create_branch(self):
        self.ensure_one()
        return self.item_id.create_branch(self.branch_name)
=== ./odoo_custom_addons/integrated_ivcs/wizards/create_branch_wizard_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_create_branch_wizard_form" model="ir.ui.view">
        <field name="name">create.branch.wizard.form</field>
        <field name="model">create.branch.wizard</field>
        <field name="arch" type="xml">
            <form string="Create Branch">
                <group>
                    <field name="item_id"/>
                    <field name="branch_name"/>
                </group>
                <footer>
                    <button name="action_create_branch" string="Create Branch" type="object" class="btn-primary"/>
                    <button string="Cancel" class="btn-secondary" special="cancel"/>
                </footer>
            </form>
        </field>
    </record>

    <record id="action_create_branch_wizard" model="ir.actions.act_window">
        <field name="name">Create Branch</field>
        <field name="res_model">create.branch.wizard</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
    </record>
</odoo>
=== ./odoo_custom_addons/integrated_ivcs/cli.py ===
import argparse
import os
import git
from nostr.event import Event
from nostr.key import PrivateKey
import json
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class GitNostrCLI:
    def __init__(self, repo_path):
        self.repo_path = repo_path
        self.repo = git.Repo(repo_path)
        self.private_key = PrivateKey()

    def create_branch(self, branch_name):
        logger.info(f"Creating branch: {branch_name}")
        self.repo.create_head(branch_name)
        self._create_branch_event(branch_name, 'create')
        logger.info(f"Branch {branch_name} created successfully")

    def delete_branch(self, branch_name):
        logger.info(f"Deleting branch: {branch_name}")
        self.repo.delete_head(branch_name, force=True)
        self._create_branch_event(branch_name, 'delete')
        logger.info(f"Branch {branch_name} deleted successfully")

    def merge_branches(self, source_branch, target_branch):
        logger.info(f"Merging {source_branch} into {target_branch}")
        self.repo.git.checkout(target_branch)
        try:
            self.repo.git.merge(source_branch)
            self._create_branch_event(target_branch, 'merge', source_branch)
            logger.info(f"Merged {source_branch} into {target_branch} successfully")
        except git.GitCommandError as e:
            logger.error(f"Merge conflict: {str(e)}")
            self.repo.git.merge('--abort')
            logger.info("Merge aborted due to conflicts")

    def commit_changes(self, message):
        logger.info(f"Committing changes with message: {message}")
        self.repo.git.add(A=True)
        commit = self.repo.index.commit(message)
        self._create_commit_event(commit)
        logger.info(f"Changes committed successfully. Commit hash: {commit.hexsha}")

    def _create_branch_event(self, branch_name, action, additional_info=None):
        logger.info(f"Creating Nostr event for branch action: {action}")
        content = {
            "action": action,
            "branch_name": branch_name,
            "repo_name": os.path.basename(self.repo_path)
        }
        if additional_info:
            content["additional_info"] = additional_info

        event = Event(
            kind=31227,
            content=json.dumps(content),
            tags=[['r', self.repo_path]],
            public_key=self.private_key.public_key.hex()
        )
        self.private_key.sign_event(event)
        logger.info(f"Nostr event created: {event.id}")
        # Here you would typically publish the event to Nostr relays

    def _create_commit_event(self, commit):
        logger.info(f"Creating Nostr event for commit: {commit.hexsha}")
        content = json.dumps({
            "action": "commit",
            "message": commit.message,
            "author": commit.author.name,
            "email": commit.author.email,
            "date": commit.authored_datetime.isoformat(),
            "hash": commit.hexsha,
            "parent_hashes": [c.hexsha for c in commit.parents],
            "tree_hash": commit.tree.hexsha,
        })
        
        event = Event(
            kind=3121,
            content=content,
            tags=[
                ["r", self.repo_path],
                ["h", commit.hexsha],
            ],
            public_key=self.private_key.public_key.hex()
        )
        self.private_key.sign_event(event)
        logger.info(f"Nostr event created: {event.id}")
        # Here you would typically publish the event to Nostr relays

def main():
    parser = argparse.ArgumentParser(description="Git-Nostr CLI")
    parser.add_argument('repo_path', help="Path to the Git repository")
    parser.add_argument('action', choices=['create-branch', 'delete-branch', 'merge-branches', 'commit'])
    parser.add_argument('--branch-name', help="Name of the branch (for create-branch and delete-branch)")
    parser.add_argument('--source-branch', help="Source branch for merge")
    parser.add_argument('--target-branch', help="Target branch for merge")
    parser.add_argument('--commit-message', help="Commit message")

    args = parser.parse_args()

    cli = GitNostrCLI(args.repo_path)

    if args.action == 'create-branch':
        cli.create_branch(args.branch_name)
    elif args.action == 'delete-branch':
        cli.delete_branch(args.branch_name)
    elif args.action == 'merge-branches':
        cli.merge_branches(args.source_branch, args.target_branch)
    elif args.action == 'commit':
        cli.commit_changes(args.commit_message)

if __name__ == "__main__":
    main()
=== ./odoo_custom_addons/integrated_ivcs/__manifest__.py ===
{
    'name': 'Integrated IVCS',
    'version': '1.0',
    'category': 'Development',
    'summary': 'Integrated Version Control System with Git and Nostr',
    'author': 'Your Name',
    'website': 'https://www.example.com',
    'depends': ['base', 'mail'],
    'data': [
        'security/ir.model.access.csv',
        'views/ivcs_item_views.xml',
        'views/ivcs_version_views.xml',
        'views/ivcs_commit_views.xml',
        'views/git_repository_views.xml',
        'views/nostr_event_views.xml',
        'views/res_config_settings_views.xml',
        'wizards/create_branch_wizard_views.xml',
        'wizards/create_commit_wizard_views.xml',
        'models/nostr_events.py',
    ],
    'demo': [],
    'external_dependencies': {
        'python': ['git', 'nostr'],
    },
    'installable': True,
    'application': True,
    'auto_install': False,
    'post_init_hook': 'post_init_hook',
    'uninstall_hook': 'uninstall_hook',
}
=== ./odoo_custom_addons/integrated_ivcs/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_nostr_event_user,nostr.event user,model_nostr_event,base.group_user,1,1,1,1
access_nostr_event_branch_user,nostr.event.branch user,model_nostr_event_branch,base.group_user,1,1,1,1
access_nostr_event_commit_user,nostr.event.commit user,model_nostr_event_commit,base.group_user,1,1,1,1
access_nostr_event_tree_user,nostr.event.tree user,model_nostr_event_tree,base.group_user,1,1,1,1
access_nostr_event_blob_user,nostr.event.blob user,model_nostr_event_blob,base.group_user,1,1,1,1
access_nostr_event_repository_anchor_user,nostr.event.repository.anchor user,model_nostr_event_repository_anchor,base.group_user,1,1,1,1
=== ./odoo_custom_addons/integrated_ivcs/tests/test_nostr_events.py ===
# integrated_ivcs/tests/test_nostr_events.py

from odoo.tests.common import TransactionCase
from odoo.exceptions import ValidationError
import json

class TestNostrEvents(TransactionCase):

    def setUp(self):
        super(TestNostrEvents, self).setUp()
        self.RepositoryAnchor = self.env['nostr.event.repository.anchor']
        self.BranchEvent = self.env['nostr.event.branch']
        self.CommitEvent = self.env['nostr.event.commit']
        self.TreeEvent = self.env['nostr.event.tree']
        self.BlobEvent = self.env['nostr.event.blob']

    def test_repository_anchor_event(self):
        event = self.RepositoryAnchor.create({
            'id': 'test_id',
            'pubkey': 'test_pubkey',
            'sig': 'test_sig',
            'repo_name': 'test_repo',
            'description': 'Test repository',
            'content': json.dumps({
                'action': 'create_repository',
                'repo_name': 'test_repo',
                'description': 'Test repository'
            })
        })
        self.assertEqual(event.kind, 31228)
        
        json_str = event.to_json()
        new_event = self.RepositoryAnchor.from_json(json_str)
        self.assertEqual(new_event.repo_name, 'test_repo')
        
        with self.assertRaises(ValidationError):
            self.RepositoryAnchor.create({
                'id': 'test_id',
                'pubkey': 'test_pubkey',
                'sig': 'test_sig',
                'repo_name': 'test_repo',
                'description': 'Test repository',
                'content': json.dumps({
                    'action': 'invalid_action',
                    'repo_name': 'test_repo',
                    'description': 'Test repository'
                })
            })

    def test_branch_event(self):
        event = self.BranchEvent.create({
            'id': 'test_id',
            'pubkey': 'test_pubkey',
            'sig': 'test_sig',
            'branch_name': 'test_branch',
            'action': 'create',
            'content': json.dumps({
                'action': 'create_branch',
                'branch_name': 'test_branch'
            })
        })
        self.assertEqual(event.kind, 31227)
        
        json_str = event.to_json()
        new_event = self.BranchEvent.from_json(json_str)
        self.assertEqual(new_event.branch_name, 'test_branch')
        self.assertEqual(new_event.action, 'create')
        
        with self.assertRaises(ValidationError):
            self.BranchEvent.create({
                'id': 'test_id',
                'pubkey': 'test_pubkey',
                'sig': 'test_sig',
                'branch_name': 'test_branch',
                'action': 'create',
                'content': json.dumps({
                    'action': 'invalid_action',
                    'branch_name': 'test_branch'
                })
            })

    def test_commit_event(self):
        event = self.CommitEvent.create({
            'id': 'test_id',
            'pubkey': 'test_pubkey',
            'sig': 'test_sig',
            'commit_hash': 'test_hash',
            'message': 'Test commit',
            'author': 'Test Author',
            'timestamp': '2023-06-01 12:00:00',
            'content': json.dumps({
                'hash': 'test_hash',
                'message': 'Test commit',
                'author': 'Test Author',
                'date': '2023-06-01T12:00:00'
            })
        })
        self.assertEqual(event.kind, 3121)
        
        json_str = event.to_json()
        new_event = self.CommitEvent.from_json(json_str)
        self.assertEqual(new_event.commit_hash, 'test_hash')
        self.assertEqual(new_event.message, 'Test commit')
        
        with self.assertRaises(ValidationError):
            self.CommitEvent.create({
                'id': 'test_id',
                'pubkey': 'test_pubkey',
                'sig': 'test_sig',
                'commit_hash': 'test_hash',
                'message': 'Test commit',
                'author': 'Test Author',
                'timestamp': '2023-06-01 12:00:00',
                'content': json.dumps({
                    'hash': 'test_hash',
                    'message': 'Test commit'
                    # Missing 'author' and 'date' fields
                })
            })

    def test_tree_event(self):
        event = self.TreeEvent.create({
            'id': 'test_id',
            'pubkey': 'test_pubkey',
            'sig': 'test_sig',
            'tree_hash': 'test_hash',
            'items': json.dumps([{'path': 'file1', 'mode': '100644', 'type': 'blob', 'sha': 'file1_hash'}]),
            'content': json.dumps({
                'hash': 'test_hash',
                'items': [{'path': 'file1', 'mode': '100644', 'type': 'blob', 'sha': 'file1_hash'}]
            })
        })
        self.assertEqual(event.kind, 3122)
        
        json_str = event.to_json()
        new_event = self.TreeEvent.from_json(json_str)
        self.assertEqual(new_event.tree_hash, 'test_hash')
        self.assertIn('file1', new_event.items)
        
        with self.assertRaises(ValidationError):
            self.TreeEvent.create({
                'id': 'test_id',
                'pubkey': 'test_pubkey',
                'sig': 'test_sig',
                'tree_hash': 'test_hash',
                'items': json.dumps([{'path': 'file1', 'mode': '100644', 'type': 'blob', 'sha': 'file1_hash'}]),
                'content': json.dumps({
                    'hash': 'test_hash'
                    # Missing 'items' field
                })
            })

    def test_blob_event(self):
        event = self.BlobEvent.create({
            'id': 'test_id',
            'pubkey': 'test_pubkey',
            'sig': 'test_sig',
            'blob_hash': 'test_hash',
            'size': 100,
            'data': 'Test blob data',
            'content': json.dumps({
                'hash': 'test_hash',
                'size': 100,
                'data': 'Test blob data'
            })
        })
        self.assertEqual(event.kind, 3123)
        
        json_str = event.to_json()
        new_event = self.BlobEvent.from_json(json_str)
        self.assertEqual(new_event.blob_hash, 'test_hash')
        self.assertEqual(new_event.size, 100)
        self.assertEqual(new_event.data, 'Test blob data')
        
        with self.assertRaises(ValidationError):
            self.BlobEvent.create({
                'id': 'test_id',
                'pubkey': 'test_pubkey',
                'sig': 'test_sig',
                'blob_hash': 'test_hash',
                'size': 100,
                'data': 'Test blob data',
                'content': json.dumps({
                    'hash': 'test_hash',
                    'size': 100
                    # Missing 'data' field
                })
            })
=== ./odoo_custom_addons/integrated_ivcs/tests/test_git_nostr_integration.py ===
import unittest
import tempfile
import os
import git
import json
from nostr.event import Event
from nostr.key import PrivateKey
from odoo.tests.common import TransactionCase
from odoo.exceptions import UserError

class TestGitNostrIntegration(TransactionCase):

    def setUp(self):
        super(TestGitNostrIntegration, self).setUp()
        self.IVCSItem = self.env['ivcs.item']
        self.NostrEvent = self.env['nostr.event']
        self.temp_dir = tempfile.mkdtemp()
        self.repo_path = os.path.join(self.temp_dir, 'test_repo')

    def tearDown(self):
        super(TestGitNostrIntegration, self).tearDown()
        if os.path.exists(self.temp_dir):
            import shutil
            shutil.rmtree(self.temp_dir)

    def test_create_repository(self):
        item = self.IVCSItem.create({
            'name': 'Test Repo',
            'description': 'Test repository',
            'repo_path': self.repo_path,
        })
        self.assertTrue(os.path.exists(self.repo_path))
        self.assertTrue(os.path.exists(os.path.join(self.repo_path, '.git')))
        self.assertTrue(os.path.exists(os.path.join(self.repo_path, 'README.md')))

    def test_create_branch(self):
        item = self.IVCSItem.create({
            'name': 'Test Repo',
            'description': 'Test repository',
            'repo_path': self.repo_path,
        })
        result = item.create_branch('test-branch')
        self.assertEqual(result['type'], 'ir.actions.client')
        self.assertEqual(result['params']['type'], 'success')
        repo = git.Repo(self.repo_path)
        self.assertIn('test-branch', repo.heads)

    def test_merge_branches(self):
        item = self.IVCSItem.create({
            'name': 'Test Repo',
            'description': 'Test repository',
            'repo_path': self.repo_path,
        })
        item.create_branch('branch1')
        item.create_branch('branch2')
        repo = git.Repo(self.repo_path)
        repo.heads.branch1.checkout()
        with open(os.path.join(self.repo_path, 'file1.txt'), 'w') as f:
            f.write('Content in branch1')
        repo.index.add(['file1.txt'])
        repo.index.commit('Commit in branch1')
        
        result = item.merge_branches('branch1', 'branch2')
        self.assertEqual(result['type'], 'ir.actions.client')
        self.assertEqual(result['params']['type'], 'success')
        
        repo.heads.branch2.checkout()
        self.assertTrue(os.path.exists(os.path.join(self.repo_path, 'file1.txt')))

    def test_create_nostr_events(self):
        item = self.IVCSItem.create({
            'name': 'Test Repo',
            'description': 'Test repository',
            'repo_path': self.repo_path,
        })
        repo = git.Repo(self.repo_path)
        with open(os.path.join(self.repo_path, 'test.txt'), 'w') as f:
            f.write('Test content')
        repo.index.add(['test.txt'])
        commit = repo.index.commit('Test commit')
        
        event = self.NostrEvent.create_git_event(self.repo_path, commit.hexsha)
        self.assertEqual(event.kind, 3121)
        self.assertIn(commit.hexsha, event.content)

    def test_reconstruct_git_objects(self):
        item = self.IVCSItem.create({
            'name': 'Test Repo',
            'description': 'Test repository',
            'repo_path': self.repo_path,
        })
        repo = git.Repo(self.repo_path)
        with open(os.path.join(self.repo_path, 'test.txt'), 'w') as f:
            f.write('Test content')
        repo.index.add(['test.txt'])
        commit = repo.index.commit('Test commit')
        
        self.NostrEvent.create_git_event(self.repo_path, commit.hexsha)
        
        # Delete the .git directory to simulate a fresh repository
        import shutil
        shutil.rmtree(os.path.join(self.repo_path, '.git'))
        
        # Reconstruct the repository from Nostr events
        self.NostrEvent.reconstruct_git_objects(self.repo_path)
        
        reconstructed_repo = git.Repo(self.repo_path)
        self.assertIn(commit.hexsha, reconstructed_repo.heads.master.commit.hexsha)
        self.assertTrue(os.path.exists(os.path.join(self.repo_path, 'test.txt')))

if __name__ == '__main__':
    unittest.main()
=== ./odoo_custom_addons/integrated_ivcs/views/res_config_settings_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="res_config_settings_view_form" model="ir.ui.view">
        <field name="name">res.config.settings.view.form.inherit.integrated_ivcs</field>
        <field name="model">res.config.settings</field>
        <field name="inherit_id" ref="base.res_config_settings_view_form"/>
        <field name="arch" type="xml">
            <xpath expr="//div[hasclass('settings')]" position="inside">
                <div class="app_settings_block" data-string="Integrated IVCS" string="Integrated IVCS" data-key="integrated_ivcs">
                    <h2>Nostr Settings</h2>
                    <div class="row mt16 o_settings_container">
                        <div class="col-12 col-lg-6 o_setting_box">
                            <div class="o_setting_left_pane"/>
                            <div class="o_setting_right_pane">
                                <span class="o_form_label">Nostr Relay URLs</span>
                                <div class="text-muted">
                                    Comma-separated list of Nostr relay URLs
                                </div>
                                <div class="content-group">
                                    <field name="integrated_ivcs_relay_urls"/>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </xpath>
        </field>
    </record>
</odoo>
=== ./odoo_custom_addons/integrated_ivcs/views/ivcs_version_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_ivcs_version_form" model="ir.ui.view">
        <field name="name">ivcs.version.form</field>
        <field name="model">ivcs.version</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="description"/>
                        <field name="item_id"/>
                        <field name="commit_id"/>
                        <field name="create_date"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_ivcs_version_tree" model="ir.ui.view">
        <field name="name">ivcs.version.tree</field>
        <field name="model">ivcs.version</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="item_id"/>
                <field name="create_date"/>
            </tree>
        </field>
    </record>

    <record id="action_ivcs_version" model="ir.actions.act_window">
        <field name="name">IVCS Versions</field>
        <field name="res_model">ivcs.version</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_ivcs_version" name="Versions" parent="menu_ivcs_root" action="action_ivcs_version"/>
</odoo>
=== ./odoo_custom_addons/integrated_ivcs/views/nostr_event_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_nostr_event_form" model="ir.ui.view">
        <field name="name">nostr.event.form</field>
        <field name="model">nostr.event</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="event_id"/>
                        <field name="kind"/>
                        <field name="event_type"/>
                        <field name="content"/>
                        <field name="tags"/>
                        <field name="public_key"/>
                        <field name="created_at"/>
                        <field name="signature"/>
                        <field name="published"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_nostr_event_tree" model="ir.ui.view">
        <field name="name">nostr.event.tree</field>
        <field name="model">nostr.event</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="event_id"/>
                <field name="kind"/>
                <field name="event_type"/>
                <field name="public_key"/>
                <field name="created_at"/>
                <field name="published"/>
            </tree>
        </field>
    </record>

    <record id="action_nostr_event" model="ir.actions.act_window">
        <field name="name">Nostr Events</field>
        <field name="res_model">nostr.event</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_nostr_event" name="Nostr Events" parent="menu_ivcs_root" action="action_nostr_event"/>
</odoo>
=== ./odoo_custom_addons/integrated_ivcs/views/ivcs_item_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_ivcs_item_form" model="ir.ui.view">
        <field name="name">ivcs.item.form</field>
        <field name="model">ivcs.item</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="description"/>
                        <field name="repo_path"/>
                        <field name="current_branch"/>
                        <field name="current_version_id"/>
                        <field name="nostr_private_key" password="True"/>
                    </group>
                    <notebook>
                        <page string="Versions">
                            <field name="version_ids"/>
                        </page>
                        <page string="Commits">
                            <field name="commit_ids"/>
                        </page>
                    </notebook>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_ivcs_item_tree" model="ir.ui.view">
        <field name="name">ivcs.item.tree</field>
        <field name="model">ivcs.item</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="repo_path"/>
                <field name="current_branch"/>
                <field name="current_version_id"/>
            </tree>
        </field>
    </record>

    <record id="action_ivcs_item" model="ir.actions.act_window">
        <field name="name">IVCS Items</field>
        <field name="res_model">ivcs.item</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_ivcs_root" name="Integrated IVCS"/>
    <menuitem id="menu_ivcs_item" name="IVCS Items" parent="menu_ivcs_root" action="action_ivcs_item"/>
</odoo>
=== ./odoo_custom_addons/integrated_ivcs/views/git_repository_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_repository_form" model="ir.ui.view">
        <field name="name">git.repository.form</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="path"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_git_repository_tree" model="ir.ui.view">
        <field name="name">git.repository.tree</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="path"/>
            </tree>
        </field>
    </record>

    <record id="action_git_repository" model="ir.actions.act_window">
        <field name="name">Git Repositories</field>
        <field name="res_model">git.repository</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_git_repository" name="Git Repositories" parent="menu_ivcs_root" action="action_git_repository"/>
</odoo>
=== ./odoo_custom_addons/integrated_ivcs/views/ivcs_commit_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_ivcs_commit_form" model="ir.ui.view">
        <field name="name">ivcs.commit.form</field>
        <field name="model">ivcs.commit</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="hash"/>
                        <field name="message"/>
                        <field name="author"/>
                        <field name="date"/>
                        <field name="item_id"/>
                        <field name="version_id"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_ivcs_commit_tree" model="ir.ui.view">
        <field name="name">ivcs.commit.tree</field>
        <field name="model">ivcs.commit</field>
        <field name="arch" type="xml">
            <tree>
                <field name="hash"/>
                <field name="message"/>
                <field name="author"/>
                <field name="date"/>
                <field name="item_id"/>
            </tree>
        </field>
    </record>

    <record id="action_ivcs_commit" model="ir.actions.act_window">
        <field name="name">IVCS Commits</field>
        <field name="res_model">ivcs.commit</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_ivcs_commit" name="Commits" parent="menu_ivcs_root" action="action_ivcs_commit"/>
</odoo>
=== ./odoo_custom_addons/opinion_reputation_system/models/__init__.py ===
from . import user
from . import question
from . import prediction
from . import relationship
from . import relative
=== ./odoo_custom_addons/opinion_reputation_system/models/prediction.py ===
from odoo import models, fields, api

class Prediction(models.Model):
    _name = 'opinion.prediction'
    _description = 'Prediction Model'
    
    user_id = fields.Many2one('opinion.user', required=True)
    question_id = fields.Many2one('opinion.question', required=True)
    answer = fields.Selection([
        ('agree', 'I Agree'),
        ('do_not_disagree', 'I do not disagree'),
        ('do_not_agree', 'I do not agree'),
        ('disagree', 'I Disagree')
    ], required=True)
    confidence = fields.Float(required=True)
    timestamp = fields.Datetime(default=fields.Datetime.now)
    is_correct = fields.Boolean()

    @api.model
    def get_answer_options(self):
        return [
            ('agree', 'I Agree'),
            ('do_not_disagree', 'I do not disagree'),
            ('do_not_agree', 'I do not agree'),
            ('disagree', 'I Disagree')
        ]
=== ./odoo_custom_addons/opinion_reputation_system/models/user.py ===
from odoo import models, fields, api

class User(models.Model):
    _name = 'opinion.user'
    _description = 'User Model'
    
    name = fields.Char(required=True)
    reputation = fields.Float(compute='_compute_reputation', store=True)
    predictions = fields.One2many('opinion.prediction', 'user_id')

    @api.depends('predictions.is_correct')
    def _compute_reputation(self):
        for user in self:
            predictions = user.predictions
            correct_predictions = sum(1 for p in predictions if p.is_correct)
            total_predictions = len(predictions)
            user.reputation = (correct_predictions / total_predictions) * 100 if total_predictions else 0
=== ./odoo_custom_addons/opinion_reputation_system/models/relationship.py ===
from odoo import models, fields

class Relationship(models.Model):
    _name = 'opinion.relationship'
    _description = 'Family Relationship'

    name = fields.Char(string='Relationship Name', required=True)
    description = fields.Text(string='Description')
=== ./odoo_custom_addons/opinion_reputation_system/models/question.py ===
from odoo import models, fields, api
from datetime import datetime, timedelta
import json
import os

class Question(models.Model):
    _name = 'opinion.question'
    _description = 'Question Model'
    
    text = fields.Text(required=True)
    explanation = fields.Text()
    created_by = fields.Many2one('opinion.user')
    created_at = fields.Datetime(default=fields.Datetime.now)
    is_settled = fields.Boolean(default=False)
    last_revisited = fields.Datetime()
    predictions = fields.One2many('opinion.prediction', 'question_id')

    @api.model
    def revisit_questions(self):
        four_years_ago = datetime.now() - timedelta(days=4*365)
        questions = self.search([
            ('created_at', '<=', four_years_ago),
            ('is_settled', '=', False)
        ])
        for question in questions:
            predictions = question.predictions
            total_votes = len(predictions)
            if total_votes > 0:
                agreement_ratio = sum(1 for p in predictions if p.answer in ['agree', 'do_not_disagree']) / total_votes
                question.is_settled = agreement_ratio >= 0.8333334
                question.last_revisited = fields.Datetime.now()

    @api.model
    def load_default_questions(self):
        file_path = os.path.join(os.path.dirname(__file__), '..', 'data', 'default_questions.json')
        with open(file_path, 'r') as file:
            data = json.load(file)
            default_questions = data['default_questions']
        
        for q in default_questions:
            existing_question = self.search([('text', '=', q['question'])], limit=1)
            if not existing_question:
                self.create({
                    'text': q['question'],
                    'explanation': q['explanation'],
                })

    @api.model
    def get_answer_options(self):
        return self.env['opinion.prediction'].get_answer_options()
=== ./odoo_custom_addons/opinion_reputation_system/models/relative.py ===
from odoo import models, fields, api
from datetime import datetime

class Relative(models.Model):
    _name = 'opinion.relative'
    _description = 'Family Relative'

    name = fields.Char(string='Name', required=True)
    relationship_id = fields.Many2one('opinion.relationship', string='Relationship', required=True)
    address = fields.Text(string='Address')
    birth_date = fields.Date(string='Birth Date')
    user_id = fields.Many2one('res.users', string='Related User', default=lambda self: self.env.user)

    @api.model
    def create(self, vals):
        if 'birth_date' in vals and isinstance(vals['birth_date'], str):
            vals['birth_date'] = datetime.strptime(vals['birth_date'], "%Y-%m-%d").date()
        return super(Relative, self).create(vals)

    def write(self, vals):
        if 'birth_date' in vals and isinstance(vals['birth_date'], str):
            vals['birth_date'] = datetime.strptime(vals['birth_date'], "%Y-%m-%d").date()
        return super(Relative, self).write(vals)
=== ./odoo_custom_addons/opinion_reputation_system/__init__.py ===
from . import models
from . import controllers
from . import wizards
=== ./odoo_custom_addons/opinion_reputation_system/wizards/__init__.py ===
from . import load_questions_wizard
from . import update_relative_wizard
=== ./odoo_custom_addons/opinion_reputation_system/wizards/load_questions_wizard.py ===
from odoo import models, fields, api

class LoadQuestionsWizard(models.TransientModel):
    _name = 'load.questions.wizard'
    _description = 'Load Default Questions Wizard'

    @api.model
    def default_get(self, fields):
        res = super(LoadQuestionsWizard, self).default_get(fields)
        current_questions = self.env['opinion.question'].search_count([])
        res['current_question_count'] = current_questions
        return res

    current_question_count = fields.Integer(string="Current Number of Questions", readonly=True)

    def action_load_questions(self):
        self.env['opinion.question'].load_default_questions()
        new_question_count = self.env['opinion.question'].search_count([])
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': 'Success',
                'message': f'Loaded {new_question_count - self.current_question_count} new questions.',
                'type': 'success',
                'sticky': False,
            }
        }
=== ./odoo_custom_addons/opinion_reputation_system/wizards/update_relative_wizard_view.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_update_relative_wizard_form" model="ir.ui.view">
        <field name="name">update.relative.wizard.form</field>
        <field name="model">update.relative.wizard</field>
        <field name="arch" type="xml">
            <form string="Update Relative">
                <group>
                    <field name="relative_id"/>
                    <field name="name"/>
                    <field name="relationship_id"/>
                    <field name="address"/>
                    <field name="birth_date"/>
                </group>
                <footer>
                    <button name="action_update_relative" string="Update" type="object" class="btn-primary"/>
                    <button string="Cancel" class="btn-secondary" special="cancel"/>
                </footer>
            </form>
        </field>
    </record>

    <record id="action_update_relative_wizard" model="ir.actions.act_window">
        <field name="name">Update Relative</field>
        <field name="res_model">update.relative.wizard</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
    </record>

    <menuitem id="menu_update_relative_wizard"
              name="Update Relative"
              parent="menu_opinion_root"
              action="action_update_relative_wizard"
              sequence="52"/>
</odoo>
=== ./odoo_custom_addons/opinion_reputation_system/wizards/update_relative_wizard.py ===
from odoo import models, fields, api

class UpdateRelativeWizard(models.TransientModel):
    _name = 'update.relative.wizard'
    _description = 'Update Relative Wizard'

    relative_id = fields.Many2one('opinion.relative', string='Relative', required=True)
    name = fields.Char(string='Name', required=True)
    relationship_id = fields.Many2one('opinion.relationship', string='Relationship', required=True)
    address = fields.Text(string='Address')
    birth_date = fields.Date(string='Birth Date')

    @api.onchange('relative_id')
    def _onchange_relative_id(self):
        if self.relative_id:
            self.name = self.relative_id.name
            self.relationship_id = self.relative_id.relationship_id
            self.address = self.relative_id.address
            self.birth_date = self.relative_id.birth_date

    def action_update_relative(self):
        self.ensure_one()
        self.relative_id.write({
            'name': self.name,
            'relationship_id': self.relationship_id.id,
            'address': self.address,
            'birth_date': self.birth_date,
        })
        return {'type': 'ir.actions.act_window_close'}
=== ./odoo_custom_addons/opinion_reputation_system/wizards/load_questions_wizard_view.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_load_questions_wizard_form" model="ir.ui.view">
        <field name="name">load.questions.wizard.form</field>
        <field name="model">load.questions.wizard</field>
        <field name="arch" type="xml">
            <form string="Load Default Questions">
                <group>
                    <field name="current_question_count"/>
                </group>
                <footer>
                    <button name="action_load_questions" string="Load Questions" type="object" class="btn-primary"/>
                    <button string="Cancel" class="btn-secondary" special="cancel"/>
                </footer>
            </form>
        </field>
    </record>

    <record id="action_load_questions_wizard" model="ir.actions.act_window">
        <field name="name">Load Default Questions</field>
        <field name="res_model">load.questions.wizard</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
    </record>

    <menuitem id="menu_load_questions_wizard"
              name="Load Default Questions"
              parent="menu_opinion_root"
              action="action_load_questions_wizard"
              sequence="50"/>
</odoo>
=== ./odoo_custom_addons/opinion_reputation_system/__manifest__.py ===
{
    'name': 'Opinion Reputation System and Relationship Management',
    'version': '1.0',
    'category': 'Social',
    'summary': 'Prevent scams in a decentralized environment and manage family relationships',
    'author': 'Your Name',
    'website': 'https://www.example.com',
    'depends': ['base'],
    'data': [
        'security/ir.model.access.csv',
        'views/user_views.xml',
        'views/question_views.xml',
        'views/prediction_views.xml',
        'views/relationship_views.xml',
        'views/relative_views.xml',
        'data/default_relationships.xml',
        'wizards/load_questions_wizard_view.xml',
        'wizards/update_relative_wizard_view.xml',
    ],
    'demo': [],
    'installable': True,
    'application': True,
    'auto_install': False,
}
=== ./odoo_custom_addons/opinion_reputation_system/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_opinion_user,opinion.user,model_opinion_user,base.group_user,1,1,1,1
access_opinion_question,opinion.question,model_opinion_question,base.group_user,1,1,1,1
access_opinion_prediction,opinion.prediction,model_opinion_prediction,base.group_user,1,1,1,1
access_opinion_relationship,opinion.relationship,model_opinion_relationship,base.group_user,1,1,1,1
access_opinion_relative,opinion.relative,model_opinion_relative,base.group_user,1,1,1,1
access_load_questions_wizard,load.questions.wizard,model_load_questions_wizard,base.group_user,1,1,1,1
access_update_relative_wizard,update.relative.wizard,model_update_relative_wizard,base.group_user,1,1,1,1
=== ./odoo_custom_addons/opinion_reputation_system/data/default_questions.json ===
{
  "default_questions": [
    {
      "question": "Do life's challenges sometimes lead to self-doubt?",
      "explanation": "Sometimes when things get tough, we might wonder if we're good enough or if we can handle it."
    },
    {
      "question": "Can self-doubt create a desire for approval from others?",
      "explanation": "When we're not sure about ourselves, we might want other people to tell us we're doing okay."
    },
    {
      "question": "Does the desire for approval make one more susceptible to peer pressure?",
      "explanation": "If we really want others to like us, we might be more likely to do what they want, even if we're not sure it's right."
    },
    {
      "question": "Can peer pressure lead to compromising one's values in small ways?",
      "explanation": "Sometimes, to fit in with friends, we might do little things we usually wouldn't do."
    },
    {
      "question": "Do small compromises sometimes evolve into larger ethical dilemmas?",
      "explanation": "If we start making small bad choices, it might become easier to make bigger bad choices later."
    },
    {
      "question": "Can ethical dilemmas create internal conflict and stress?",
      "explanation": "When we're not sure if something is right or wrong, it can make us feel worried and upset inside."
    },
    {
      "question": "Does prolonged stress potentially lead to poor decision-making?",
      "explanation": "If we feel stressed for a long time, it might be harder to make good choices."
    },
    {
      "question": "Can poor decisions result in actions that harm others unintentionally?",
      "explanation": "Sometimes when we make bad choices, we might accidentally hurt someone's feelings or cause problems we didn't mean to."
    },
    {
      "question": "Do harmful actions, even if unintentional, sometimes lead to guilt?",
      "explanation": "If we do something that hurts someone, even by accident, we might feel really sorry about it afterwards."
    },
    {
      "question": "Can guilt, if unaddressed, manifest as more severe behavioral issues?",
      "explanation": "If we keep feeling bad about something we did and don't talk about it, we might start acting out in other ways."
    },
    {
      "question": "Do severe behavioral issues increase the likelihood of intentional wrongdoing?",
      "explanation": "If someone is already doing a lot of bad things, they might start doing even worse things on purpose."
    },
    {
      "question": "Can intentional wrongdoing lead to legal consequences and societal rejection?",
      "explanation": "If someone chooses to do something really wrong, they might get in trouble with the law or other people might not want to be around them anymore."
    },
    {
      "question": "Do life's challenges sometimes lead to self-doubt about one's self-concept?",
      "explanation": "When things are hard, we might start to wonder if we really know who we are."
    },
    {
      "question": "Can self-doubt in one's self-concept create a desire for approval from others?",
      "explanation": "If we're not sure about who we are, we might really want other people to tell us we're okay."
    },
    {
      "question": "Does the desire for approval make one's self-concept more susceptible to peer pressure?",
      "explanation": "If we really want people to like us, we might change who we are to fit in with our friends."
    },
    {
      "question": "Can peer pressure lead to compromising one's self-concept in small ways?",
      "explanation": "To make friends happy, we might act a little different from who we really are."
    },
    {
      "question": "Do small compromises in self-concept sometimes evolve into larger identity dilemmas?",
      "explanation": "If we keep pretending to be someone we're not, we might start to forget who we really are."
    },
    {
      "question": "Can identity dilemmas create internal conflict and stress about one's self-concept?",
      "explanation": "Not being sure about who we are can make us feel really confused and worried inside."
    },
    {
      "question": "Does prolonged stress potentially lead to poor decision-making regarding self-concept?",
      "explanation": "If we feel stressed for a long time about who we are, we might make choices that don't fit with our true selves."
    },
    {
      "question": "Can poor decisions about self-concept result in actions that harm others unintentionally?",
      "explanation": "If we're confused about who we are, we might accidentally do things that hurt other people's feelings."
    },
    {
      "question": "Do harmful actions stemming from self-concept issues sometimes lead to guilt?",
      "explanation": "If we hurt someone because we're not sure about who we are, we might feel really bad about it afterwards."
    },
    {
      "question": "Can guilt about one's self-concept, if unaddressed, manifest as more severe behavioral issues?",
      "explanation": "If we keep feeling bad about who we are and don't talk about it, we might start acting out in other ways."
    },
    {
      "question": "Do severe behavioral issues related to self-concept increase the likelihood of intentional wrongdoing?",
      "explanation": "If someone is really confused about who they are, they might start doing bad things on purpose."
    },
    {
      "question": "Can intentional wrongdoing due to distorted self-concept lead to legal consequences and societal rejection?",
      "explanation": "If someone does something really wrong because they're confused about who they are, they might get in trouble with the law or lose friends."
    },
    {
      "question": "Do life's challenges sometimes lead to self-doubt in one's values system?",
      "explanation": "When things are tough, we might start to wonder if what we believe is right is actually right."
    },
    {
      "question": "Can self-doubt in one's values create a desire for approval from others?",
      "explanation": "If we're not sure about what we believe, we might want other people to tell us our ideas are good."
    },
    {
      "question": "Does the desire for approval make one's values more susceptible to peer pressure?",
      "explanation": "If we really want people to like us, we might change what we believe to match what our friends believe."
    },
    {
      "question": "Can peer pressure lead to compromising one's values in small ways?",
      "explanation": "To fit in with friends, we might do little things that we usually think are wrong."
    },
    {
      "question": "Do small compromises in values sometimes evolve into larger ethical dilemmas?",
      "explanation": "If we keep doing small things we think are wrong, we might start doing bigger wrong things."
    },
    {
      "question": "Can ethical dilemmas create internal conflict and stress about one's values?",
      "explanation": "When we're not sure if something is right or wrong, it can make us feel really worried and confused inside."
    },
    {
      "question": "Does prolonged stress potentially lead to poor decision-making regarding values?",
      "explanation": "If we feel stressed for a long time about what's right and wrong, we might make bad choices."
    },
    {
      "question": "Can poor decisions about values result in actions that harm others unintentionally?",
      "explanation": "If we're confused about what's right and wrong, we might accidentally do things that hurt other people."
    },
    {
      "question": "Do harmful actions stemming from compromised values sometimes lead to guilt?",
      "explanation": "If we do something we think is wrong and it hurts someone, we might feel really bad about it afterwards."
    },
    {
      "question": "Can guilt about compromised values, if unaddressed, manifest as more severe behavioral issues?",
      "explanation": "If we keep feeling bad about doing things we think are wrong and don't talk about it, we might start acting out in other ways."
    },
    {
      "question": "Do severe behavioral issues related to conflicted values increase the likelihood of intentional wrongdoing?",
      "explanation": "If someone is really confused about what's right and wrong, they might start doing bad things on purpose."
    },
    {
      "question": "Can intentional wrongdoing due to compromised values lead to legal consequences and societal rejection?",
      "explanation": "If someone does something really wrong because they're confused about what's right and wrong, they might get in trouble with the law or lose friends."
    },
    {
      "question": "Do life's challenges sometimes lead to self-doubt in one's sense of purpose?",
      "explanation": "When things are hard, we might start to wonder why we're here and what we're supposed to do with our lives."
    },
    {
      "question": "Can self-doubt in one's purpose create a desire for approval from others?",
      "explanation": "If we're not sure about what we're meant to do in life, we might want other people to tell us we're doing the right things."
    },
    {
      "question": "Does the desire for approval make one's sense of purpose more susceptible to peer pressure?",
      "explanation": "If we really want people to like us, we might change what we think we should do in life to match what our friends think."
    },
    {
      "question": "Can peer pressure lead to compromising one's purpose in small ways?",
      "explanation": "To make friends happy, we might do things that don't really fit with what we think we should do in life."
    },
    {
      "question": "Do small compromises in purpose sometimes evolve into larger existential dilemmas?",
      "explanation": "If we keep doing things that don't fit with what we think we should do in life, we might start to feel really lost and confused."
    },
    {
      "question": "Can existential dilemmas create internal conflict and stress about one's purpose?",
      "explanation": "When we're not sure why we're here or what we should do with our lives, it can make us feel really worried and upset inside."
    },
    {
      "question": "Does prolonged stress potentially lead to poor decision-making regarding life purpose?",
      "explanation": "If we feel stressed for a long time about what we should do with our lives, we might make choices that don't really make us happy."
    },
    {
      "question": "Can poor decisions about purpose result in actions that harm others unintentionally?",
      "explanation": "If we're confused about what we should do in life, we might accidentally do things that cause problems for other people."
    },
    {
      "question": "Do harmful actions stemming from a confused sense of purpose sometimes lead to guilt?",
      "explanation": "If we hurt someone because we're not sure what we should be doing with our lives, we might feel really bad about it afterwards."
    },
    {
      "question": "Can guilt about one's purpose, if unaddressed, manifest as more severe behavioral issues?",
      "explanation": "If we keep feeling bad about not knowing what to do with our lives and don't talk about it, we might start acting out in other ways."
    },
    {
      "question": "Do severe behavioral issues related to lack of purpose increase the likelihood of intentional wrongdoing?",
      "explanation": "If someone is really confused about what they should do in life, they might start doing bad things on purpose."
    },
    {
      "question": "Can intentional wrongdoing due to a distorted sense of purpose lead to legal consequences and societal rejection?",
      "explanation": "If someone does something really wrong because they're confused about what they should do in life, they might get in trouble with the law or lose friends."
    },
    {
      "question": "Do life's challenges sometimes lead to self-doubt in one's communication abilities?",
      "explanation": "When things are tough, we might start to wonder if we're good at talking to other people or explaining our ideas."
    },
    {
      "question": "Can self-doubt in communication create a desire for approval from others?",
      "explanation": "If we're not sure if we're good at talking to people, we might really want others to tell us we're doing a good job."
    },
    {
      "question": "Does the desire for approval make one's communication more susceptible to peer pressure?",
      "explanation": "If we really want people to like us, we might change how we talk or what we say to match our friends."
    },
    {
      "question": "Can peer pressure lead to compromising one's authentic communication in small ways?",
      "explanation": "To fit in with friends, we might say things we don't really mean or not say things we do mean."
    },
    {
      "question": "Do small compromises in communication sometimes evolve into larger interpersonal dilemmas?",
      "explanation": "If we keep not being honest in how we talk to people, it might cause big problems in our friendships."
    },
    {
      "question": "Can interpersonal dilemmas create internal conflict and stress about one's communication?",
      "explanation": "When we're not sure how to talk to people or what to say, it can make us feel really worried and upset inside."
    },
    {
      "question": "Does prolonged stress potentially lead to poor decision-making in communication?",
      "explanation": "If we feel stressed for a long time about talking to people, we might say things we don't mean or that hurt others."
    },
    {
      "question": "Can poor communication decisions result in actions that harm others unintentionally?",
      "explanation": "If we're not good at explaining our ideas or feelings, we might accidentally hurt someone's feelings or cause misunderstandings."
    },
    {
      "question": "Do harmful actions stemming from poor communication sometimes lead to guilt?",
      "explanation": "If we hurt someone because we didn't communicate well, we might feel really bad about it afterwards."
    },
    {
      "question": "Can guilt about one's communication, if unaddressed, manifest as more severe behavioral issues?",
      "explanation": "If we keep feeling bad about how we talk to people and don't try to get better, we might start acting out in other ways."
    },
    {
      "question": "Do severe behavioral issues related to communication increase the likelihood of intentional wrongdoing?",
      "explanation": "If someone has a lot of trouble talking to people, they might start doing bad things on purpose to express themselves."
    },
    {
      "question": "Can intentional wrongdoing due to communication issues lead to legal consequences and societal rejection?",
      "explanation": "If someone does something really wrong because they can't communicate well, they might get in trouble with the law or lose friends."
    },
    {
      "question": "Do life's challenges sometimes lead to self-doubt in one's ability to connect with others?",
      "explanation": "When things are tough, we might start to wonder if we're good at making friends or getting along with people."
    },
    {
      "question": "Can self-doubt in connection create a desire for approval from others?",
      "explanation": "If we're not sure if we're good at making friends, we might really want people to show us they like us."
    },
    {
      "question": "Does the desire for approval make one's connections more susceptible to peer pressure?",
      "explanation": "If we really want people to like us, we might change how we act with different friends to make them happy."
    },
    {
      "question": "Can peer pressure lead to compromising one's authentic connections in small ways?",
      "explanation": "To keep our friends happy, we might pretend to like things we don't really like or not spend time with people we do like."
    },
    {
      "question": "Do small compromises in connections sometimes evolve into larger relationship dilemmas?",
      "explanation": "If we keep pretending in our friendships, it might cause big problems in how we get along with people."
    },
    {
      "question": "Can relationship dilemmas create internal conflict and stress about one's connections?",
      "explanation": "When we're not sure how to be a good friend or who to be friends with, it can make us feel really worried and upset inside."
    },
    {
      "question": "Does prolonged stress potentially lead to poor decision-making in relationships?",
      "explanation": "If we feel stressed for a long time about our friendships, we might make choices that hurt our relationships."
    },
    {
      "question": "Can poor decisions about connections result in actions that harm others unintentionally?",
      "explanation": "If we're not good at being a friend, we might accidentally hurt someone's feelings or make them feel left out."
    },
    {
      "question": "Do harmful actions stemming from compromised connections sometimes lead to guilt?",
      "explanation": "If we hurt someone because we didn't know how to be a good friend, we might feel really bad about it afterwards."
    },
    {
      "question": "Can guilt about one's connections, if unaddressed, manifest as more severe behavioral issues?",
      "explanation": "If we keep feeling bad about our friendships and don't try to fix them, we might start acting out in other ways."
    },
    {
      "question": "Do severe behavioral issues related to connections increase the likelihood of intentional wrongdoing?",
      "explanation": "If someone has a lot of trouble making friends, they might start doing bad things on purpose to get attention."
    },
    {
      "question": "Can intentional wrongdoing due to problematic connections lead to legal consequences and societal rejection?",
      "explanation": "If someone does something really wrong because they can't make friends, they might get in trouble with the law or lose even more friends."
    },
    {
      "question": "Do life's challenges sometimes lead to self-doubt in one's social awareness?",
      "explanation": "When things are tough, we might start to wonder if we're good at understanding how other people feel or what they need."
    },
    {
      "question": "Can self-doubt in social awareness create a desire for approval from others?",
      "explanation": "If we're not sure if we're good at understanding people, we might really want others to tell us we're doing okay in social situations."
    },
    {
      "question": "Does the desire for approval make one's social awareness more susceptible to peer pressure?",
      "explanation": "If we really want people to like us, we might ignore our own feelings about a situation to go along with what everyone else thinks."
    },
    {
      "question": "Can peer pressure lead to compromising one's social awareness in small ways?",
      "explanation": "To fit in with friends, we might pretend not to notice when someone is upset or ignore things that we think are wrong."
    },
    {
      "question": "Do small compromises in social awareness sometimes evolve into larger social dilemmas?",
      "explanation": "If we keep ignoring our feelings about social situations, we might end up in really uncomfortable or unfair situations."
    },
    {
      "question": "Can social dilemmas create internal conflict and stress about one's place in society?",
      "explanation": "When we're not sure how to act in social situations, it can make us feel really worried and upset about where we fit in with others."
    },
    {
      "question": "Does prolonged stress potentially lead to poor decision-making in social situations?",
      "explanation": "If we feel stressed for a long time about social stuff, we might make choices that make it hard to get along with others."
    },
    {
      "question": "Can poor decisions due to lack of social awareness result in actions that harm others unintentionally?",
      "explanation": "If we're not good at understanding how others feel, we might accidentally say or do things that hurt people's feelings."
    },
    {
      "question": "Do harmful actions stemming from poor social awareness sometimes lead to guilt?",
      "explanation": "If we hurt someone because we didn't understand how they were feeling, we might feel really bad about it afterwards."
    },
    {
      "question": "Can guilt about one's social missteps, if unaddressed, manifest as more severe behavioral issues?",
      "explanation": "If we keep feeling bad about not understanding social situations and don't try to get better, we might start acting out in other ways."
    },
    {
      "question": "Do severe behavioral issues related to social awareness increase the likelihood of intentional wrongdoing?",
      "explanation": "If someone has a lot of trouble understanding social situations, they might start doing bad things on purpose because they don't know how else to act."
    },
    {
      "question": "Can intentional wrongdoing due to lack of social awareness lead to legal consequences and societal rejection?",
      "explanation": "If someone does something really wrong because they don't understand social rules, they might get in trouble with the law or have trouble making friends."
    },
    {
      "question": "Do life's challenges sometimes lead to self-doubt in one's ability to maintain physical health?",
      "explanation": "When things are tough, we might start to wonder if we're taking good care of our body or if we can stay healthy."
    },
    {
      "question": "Can self-doubt about physical health create a desire for approval from others?",
      "explanation": "If we're not sure if we're healthy, we might really want other people to tell us we look good or that we're doing a good job staying healthy."
    },
    {
      "question": "Does the desire for approval make one's health choices more susceptible to peer pressure?",
      "explanation": "If we really want people to like us, we might eat things we shouldn't or do unsafe things just because our friends are doing it."
    },
    {
      "question": "Can peer pressure lead to compromising one's physical health in small ways?",
      "explanation": "To fit in with friends, we might stay up too late or eat too much junk food, even though we know it's not good for us."
    },
    {
      "question": "Do small compromises in health sometimes evolve into larger health dilemmas?",
      "explanation": "If we keep doing little things that aren't healthy, it might lead to bigger health problems over time."
    },
    {
      "question": "Can health dilemmas create internal conflict and stress about one's physical well-being?",
      "explanation": "When we're not sure if we're healthy or how to take care of ourselves, it can make us feel really worried and upset."
    },
    {
      "question": "Does prolonged stress potentially lead to poor decision-making regarding physical health?",
      "explanation": "If we feel stressed for a long time about our health, we might make choices that actually make us less healthy."
    },
    {
      "question": "Can poor health decisions result in actions that harm others unintentionally?",
      "explanation": "If we don't take care of our health, we might accidentally get other people sick or not be able to help when others need us."
    },
    {
      "question": "Do harmful actions stemming from poor health sometimes lead to guilt?",
      "explanation": "If we hurt someone because we didn't take care of our health, we might feel really bad about it afterwards."
    },
    {
      "question": "Can guilt about one's health choices, if unaddressed, manifest as more severe behavioral issues?",
      "explanation": "If we keep feeling bad about not taking care of our health and don't try to get better, we might start acting out in other ways."
    },
    {
      "question": "Do severe behavioral issues related to physical health increase the likelihood of intentional wrongdoing?",
      "explanation": "If someone has a lot of trouble taking care of their health, they might start doing bad things on purpose because they feel frustrated or upset."
    },
    {
      "question": "Can intentional wrongdoing due to health issues lead to legal consequences and societal rejection?",
      "explanation": "If someone does something really wrong because of health problems, they might get in trouble with the law or have trouble keeping friends."
    }
  ]
}
=== ./odoo_custom_addons/opinion_reputation_system/data/load_default_questions.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data>
        <function model="opinion.question" name="load_default_questions"/>
    </data>
</odoo>
=== ./odoo_custom_addons/opinion_reputation_system/data/default_relationships.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <record id="relationship_father" model="opinion.relationship">
            <field name="name">Father</field>
        </record>
        <record id="relationship_mother" model="opinion.relationship">
            <field name="name">Mother</field>
        </record>
        <record id="relationship_son" model="opinion.relationship">
            <field name="name">Son</field>
        </record>
        <record id="relationship_daughter" model="opinion.relationship">
            <field name="name">Daughter</field>
        </record>
        <record id="relationship_stepfather" model="opinion.relationship">
            <field name="name">Stepfather</field>
        </record>
        <record id="relationship_stepmother" model="opinion.relationship">
            <field name="name">Stepmother</field>
        </record>
        <record id="relationship_brother" model="opinion.relationship">
            <field name="name">Brother</field>
        </record>
        <record id="relationship_sister" model="opinion.relationship">
            <field name="name">Sister</field>
        </record>
        <!-- Add more relationships as needed -->
    </data>
</odoo>
=== ./odoo_custom_addons/opinion_reputation_system/views/relationship_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_relationship_tree" model="ir.ui.view">
        <field name="name">opinion.relationship.tree</field>
        <field name="model">opinion.relationship</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="description"/>
            </tree>
        </field>
    </record>

    <record id="view_relationship_form" model="ir.ui.view">
        <field name="name">opinion.relationship.form</field>
        <field name="model">opinion.relationship</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="description"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="action_relationship" model="ir.actions.act_window">
        <field name="name">Relationships</field>
        <field name="res_model">opinion.relationship</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_relationship" name="Relationships" parent="menu_opinion_root" action="action_relationship"/>
</odoo>
=== ./odoo_custom_addons/opinion_reputation_system/views/question_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_opinion_question_form" model="ir.ui.view">
        <field name="name">opinion.question.form</field>
        <field name="model">opinion.question</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="text"/>
                        <field name="explanation"/>
                        <field name="created_by"/>
                        <field name="created_at"/>
                        <field name="is_settled"/>
                        <field name="last_revisited"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_opinion_question_tree" model="ir.ui.view">
        <field name="name">opinion.question.tree</field>
        <field name="model">opinion.question</field>
        <field name="arch" type="xml">
            <tree>
                <field name="text"/>
                <field name="created_by"/>
                <field name="created_at"/>
                <field name="is_settled"/>
            </tree>
        </field>
    </record>

    <record id="action_opinion_question" model="ir.actions.act_window">
        <field name="name">Questions</field>
        <field name="res_model">opinion.question</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_opinion_question" parent="menu_opinion_root" action="action_opinion_question"/>
</odoo>
=== ./odoo_custom_addons/opinion_reputation_system/views/prediction_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_opinion_prediction_form" model="ir.ui.view">
        <field name="name">opinion.prediction.form</field>
        <field name="model">opinion.prediction</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="user_id"/>
                        <field name="question_id"/>
                        <field name="answer"/>
                        <field name="confidence"/>
                        <field name="timestamp"/>
                        <field name="is_correct"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_opinion_prediction_tree" model="ir.ui.view">
        <field name="name">opinion.prediction.tree</field>
        <field name="model">opinion.prediction</field>
        <field name="arch" type="xml">
            <tree>
                <field name="user_id"/>
                <field name="question_id"/>
                <field name="answer"/>
                <field name="confidence"/>
                <field name="timestamp"/>
                <field name="is_correct"/>
            </tree>
        </field>
    </record>

    <record id="action_opinion_prediction" model="ir.actions.act_window">
        <field name="name">Predictions</field>
        <field name="res_model">opinion.prediction</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_opinion_prediction" parent="menu_opinion_root" action="action_opinion_prediction"/>
</odoo>
=== ./odoo_custom_addons/opinion_reputation_system/views/relative_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_relative_tree" model="ir.ui.view">
        <field name="name">opinion.relative.tree</field>
        <field name="model">opinion.relative</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="relationship_id"/>
                <field name="birth_date"/>
            </tree>
        </field>
    </record>

    <record id="view_relative_form" model="ir.ui.view">
        <field name="name">opinion.relative.form</field>
        <field name="model">opinion.relative</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="relationship_id"/>
                        <field name="address"/>
                        <field name="birth_date"/>
                        <field name="user_id" invisible="1"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="action_relative" model="ir.actions.act_window">
        <field name="name">Relatives</field>
        <field name="res_model">opinion.relative</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_relative" name="Relatives" parent="menu_opinion_root" action="action_relative"/>
</odoo>
=== ./odoo_custom_addons/opinion_reputation_system/views/user_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_opinion_user_form" model="ir.ui.view">
        <field name="name">opinion.user.form</field>
        <field name="model">opinion.user</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="reputation"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_opinion_user_tree" model="ir.ui.view">
        <field name="name">opinion.user.tree</field>
        <field name="model">opinion.user</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="reputation"/>
            </tree>
        </field>
    </record>

    <record id="action_opinion_user" model="ir.actions.act_window">
        <field name="name">Users</field>
        <field name="res_model">opinion.user</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_opinion_root" name="Opinion Reputation System"/>
    <menuitem id="menu_opinion_user" parent="menu_opinion_root" action="action_opinion_user"/>
</odoo>
=== ./odoo_custom_addons/opinion_reputation_system/controllers/__init__.py ===
from . import main
=== ./odoo_custom_addons/opinion_reputation_system/controllers/main.py ===
from odoo import http
from odoo.http import request

class OpinionController(http.Controller):

    @http.route('/api/register', type='json', auth='public')
    def register(self, name):
        user = request.env['opinion.user'].sudo().create({'name': name})
        return {'id': user.id, 'name': user.name}

    @http.route('/api/questions', type='json', auth='public')
    def get_questions(self):
        questions = request.env['opinion.question'].sudo().search([])
        return [{
            'id': q.id,
            'text': q.text,
            'explanation': q.explanation,
            'is_settled': q.is_settled
        } for q in questions]

    @http.route('/api/predict', type='json', auth='public')
    def predict(self, user_id, question_id, answer, confidence):
        prediction = request.env['opinion.prediction'].sudo().create({
            'user_id': user_id,
            'question_id': question_id,
            'answer': answer,
            'confidence': confidence
        })
        return {
            'id': prediction.id,
            'user_id': prediction.user_id.id,
            'question_id': prediction.question_id.id
        }

    @http.route('/api/user_reputation', type='json', auth='public')
    def get_user_reputation(self, user_id):
        user = request.env['opinion.user'].sudo().browse(user_id)
        return {'reputation': user.reputation}
